!SESSION 2017-05-27 19:54:17.091 -----------------------------------------------
eclipse.buildId=4.6.3.M20170301-0400
java.version=1.8.0_131
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_ES
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

This is a continuation of log file C:\Users\Alvaro\Desktop\workspace\.metadata\.bak_3.log
Created Time: 2017-05-27 20:05:29.218

!ENTRY org.eclipse.jdt.ui 4 2 2017-05-27 20:05:29.218
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.recommenders.rcp.utils.JdtUtils.findAstNodeFromEditorSelection(JdtUtils.java:669)
	at org.eclipse.recommenders.internal.rcp.JavaElementSelectionService.handleSelectionInEditor(JavaElementSelectionService.java:110)
	at org.eclipse.recommenders.internal.rcp.JavaElementSelectionService.access$1(JavaElementSelectionService.java:105)
	at org.eclipse.recommenders.internal.rcp.JavaElementSelectionService$1.run(JavaElementSelectionService.java:82)
	at java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source)
	at java.util.concurrent.FutureTask.run(Unknown Source)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(Unknown Source)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(Unknown Source)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source)
	at java.lang.Thread.run(Unknown Source)

!ENTRY org.eclipse.jdt.ui 4 0 2017-05-27 20:05:29.219
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.recommenders.rcp.utils.JdtUtils.findAstNodeFromEditorSelection(JdtUtils.java:669)
	at org.eclipse.recommenders.internal.rcp.JavaElementSelectionService.handleSelectionInEditor(JavaElementSelectionService.java:110)
	at org.eclipse.recommenders.internal.rcp.JavaElementSelectionService.access$1(JavaElementSelectionService.java:105)
	at org.eclipse.recommenders.internal.rcp.JavaElementSelectionService$1.run(JavaElementSelectionService.java:82)
	at java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source)
	at java.util.concurrent.FutureTask.run(Unknown Source)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(Unknown Source)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(Unknown Source)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source)
	at java.lang.Thread.run(Unknown Source)

!ENTRY org.eclipse.jdt.core 4 4 2017-05-27 20:05:33.748
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
public class OperationsManaged
{
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, double second, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            firstInfo, new UnitInfo(second), operation
        );
    }

    public static UnitInfo PerformManagedOperationUnits(double first, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            new UnitInfo(first), secondInfo, operation
        );
    }

    //This method should always be used when dealing with random UnitInfo variables because it accounts for all the
    //possible scenarios. On the other hand, with simple operations (e.g., random UnitInfo & numeric type) it might
    //be better to use PerformManagedOperationValues. 
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        ErrorTypes errorType = InternalMethods.GetOperationError
        (
            firstInfo, secondInfo, operation
        );
        if (errorType != ErrorTypes.None)
        {
            return new UnitInfo(firstInfo) 
            {{
                Error = new ErrorInfo(errorType); 
            }};
        }

        return
        (
            operation == Operations.Addition || operation == Operations.Subtraction ?
            PerformManagedOperationAddition(firstInfo, secondInfo, operation) :
            PerformManagedOperationMultiplication(firstInfo, secondInfo, operation)
        );
    }

    static UnitInfo PerformManagedOperationAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {   
        //After being normalised, the operands might require further modifications.
        UnitInfo[] normalised = GetOperandsAddition(firstInfo, secondInfo, operation);

        return PerformManagedOperationNormalisedValues
        (
            firstInfo, normalised, operation
        );
    }

    static UnitInfo[] GetOperandsAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        UnitInfo[] operands2 = new UnitInfo[] 
        {
            new UnitInfo(firstInfo), new UnitInfo(secondInfo)
        };

        if (operands2[0].BaseTenExponent != operands2[1].BaseTenExponent || operands2[0].Prefix.Factor != operands2[1].Prefix.Factor)
        {
            //The addition/subtraction might not be performed right away even with normalised values.
            //For example: 5 and 6 from 5*10^2 and 6*10^7 cannot be added right away.
            operands2 = AdaptNormalisedValuesForAddition
            (
                new UnitInfo[] 
                { 
                    NormaliseUnitInfo(operands2[0]), 
                    NormaliseUnitInfo(operands2[1])
                },
                operation
            );
        }

        return operands2;
    }
    
    static UnitInfo[] AdaptNormalisedValuesForAddition(UnitInfo[] unitInfos2, Operations operation)
    {
        if (unitInfos2[0].BaseTenExponent == unitInfos2[1].BaseTenExponent)
        {
            //Having the same BaseTenExponent values means that the given operation can be performed right away.
            return unitInfos2;
        }

        int[] bigSmallI = 
        (
            unitInfos2[0].BaseTenExponent > unitInfos2[1].BaseTenExponent ?
            new int[] { 0, 1 } : new int[] { 1, 0 }
        );

        //Only the variable with the bigger value is modified. For example: 5*10^5 & 3*10^3 is converted
        //into 500*10^3 & 3*10^3 in order to allow the addition 500 + 3. 
        UnitInfo big2 = AdaptBiggerAdditionOperand(unitInfos2, bigSmallI, operation);
        if (big2.Error.Type != ErrorTypes.None)
        {
            return TooBigGapAddition(unitInfos2, bigSmallI, operation);
        }

        unitInfos2[bigSmallI[0]].Value = big2.Value;
        unitInfos2[bigSmallI[0]].BaseTenExponent = unitInfos2[bigSmallI[1]].BaseTenExponent;

        return unitInfos2;
    }

    //When adding/subtracting two numbers whose gap is bigger than the maximum double range, there
    //is no need to perform any operation (i.e., no change will be observed because of being outside
    //the maximum supported precision). This method takes care of these cases and returns the expected
    //output (i.e., biggest value).
    static UnitInfo[] TooBigGapAddition(UnitInfo[] unitInfos2, int[] bigSmallI, Operations operation)
    {
        UnitInfo[] outInfos = new UnitInfo[] 
        {
            //First operand (i.e., one whose information defines the operation) together with the
            //numeric information (i.e., just Value and BaseTenExponent because both are normalised)
            //which is associated with the biggest one.
            new UnitInfo(unitInfos2[0])
            {{
                Value = unitInfos2[bigSmallI[0]].Value;
                BaseTenExponent = unitInfos2[bigSmallI[0]].BaseTenExponent;
            }}
        };

        if (operation == Operations.Subtraction && bigSmallI[0] == 1)
        {
            outInfos[0].Value = -1.0 * outInfos[0].Value;
        }

        if (outInfos[0].Unit == Units.Unitless)
        {
            outInfos[0].Unit = unitInfos2[bigSmallI[1]].Unit;
        }

        return outInfos;
    }

    static UnitInfo AdaptBiggerAdditionOperand(UnitInfo[] unitInfos2, Integer[] bigSmallI, Operations operation)
    {
        int gapExponent = unitInfos2[bigSmallI[0]].BaseTenExponent - unitInfos2[bigSmallI[1]].BaseTenExponent;
        if (gapExponent >= 27)
        {
            //The difference between both inputs is bigger than (or, at least, very close to) the maximum double value/precision;
            //what makes this situation calculation unworthy and the first operand to be returned as the result.
            //Note that the error below these lines is just an easy way to tell the calling function about this eventuality.
            return new UnitInfo(unitInfos2[0]) 
            {{ 
                Error = new ErrorInfo(ErrorTypes.InvalidOperation); 
            }};
        }

        //PerformManagedOperationValues is used to make sure that the resulting numeric information is stored
        //in Value (if possible).
        UnitInfo big2 = PerformManagedOperationValues
        (
            RaiseToIntegerExponent(10.0, gapExponent), unitInfos2[bigSmallI[0]].Value, 
            Operations.Multiplication                
        );

        boolean isWrong = 
        (
            big2.Error.Type != ErrorTypes.None || big2.BaseTenExponent != 0 ?
            
            //The value of the bigger input times 10^(gap between BaseTenExponent of inputs) is too big. 
            isWrong = true :
            
            //Overflow-check very unlikely to trigger an error. In fact, with properly normalised variables,
            //triggering an error would be plainly impossible.               
            AreAdditionFinalValuesWrong
            (
                unitInfos2[0].Value, unitInfos2[1].Value, operation
            )
        );

        UnitInfo temp = null;
        if (isWrong)
        {
        	temp = new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }};
            
            temp.Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            
        }
        
        
        return temp;
        
        
        return
        (
            isWrong ?
            //This error is just an easy way to let the calling function know about the fact that no
            //calculation has been performed (too big gap). This isn't a properly-speaking error and
            //that's why it will not be notified to the user.
            new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }} :
            //Returning the new big value. For example: with 5*10^4 & 3*10^2, 500 would be returned.
            new UnitInfo(unitInfos2[bigSmallI[0]])
            {{
                Value = big2.Value;
            }}
        )
    }

    static boolean AreAdditionFinalValuesWrong(double val1, double val2, Operations operation)
    {
        boolean isWrong = false;

        try
        {
            val1 = val1 + val2 *
            (
                operation == Operations.Addition ? 1 : -1
            );
        }
        catch { isWrong = true; }

        return isWrong;
    }

    static UnitInfo PerformManagedOperationMultiplication(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationNormalisedValues
        (
            firstInfo, new UnitInfo[] 
            { 
                NormaliseUnitInfo(firstInfo),
                NormaliseUnitInfo(secondInfo) 
            },
            operation
        );
    }

    public static UnitInfo RaiseToIntegerExponent(double baseValue, int exponent)
    {
        return RaiseToIntegerExponent(new UnitInfo(baseValue), exponent);
    }

    static UnitInfo RaiseToIntegerExponent(UnitInfo baseInfo, int exponent)
    {
        if (exponent <= 1 && exponent >= 0)
        {
            baseInfo.Value = (exponent == 0 ? 1.0 : baseInfo.Value);
            return baseInfo;
        }

        UnitInfo outInfo = new UnitInfo(baseInfo);

        for (int i = 1; i < Math.Abs(exponent); i++)
        {
            outInfo = PerformManagedOperationValues
            (
                outInfo, baseInfo, Operations.Multiplication
            );
            if (outInfo.Error.Type != ErrorTypes.None) return outInfo;
        }

        return
        (
            exponent < 0 ?
            PerformManagedOperationValues(new UnitInfo(1.0), outInfo, Operations.Division) :
            outInfo
        );
    }

    static UnitInfo PerformManagedOperationNormalisedValues(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        outInfo =
        (
            normalisedInfos.Length == 1 ?
            //There is just one operand when the difference between both of them is too big.
            outInfo = normalisedInfos[0] :
            PerformManagedOperationTwoOperands(outInfo, normalisedInfos, operation)
        );

        return outInfo;
    }

    static UnitInfo PerformManagedOperationTwoOperands(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        UnitInfo outInfoNormalised = PerformManagedOperationValues
        (
            normalisedInfos[0], normalisedInfos[1], operation
        );

        if (outInfo.Error.Type != ErrorTypes.None)
        {
            return new UnitInfo(outInfo)
            {
                Error = new ErrorInfo(ErrorTypes.NumericError)
            };
        }

        outInfo.BaseTenExponent = outInfoNormalised.BaseTenExponent;
        outInfo.Value = outInfoNormalised.Value;
        //Normalised means no prefixes.
        outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage); 

        return outInfo;
    }

    static UnitInfo PerformManagedOperationValues(double firstValue, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            new UnitInfo(firstValue), new UnitInfo(secondValue), operation
        );
    }

    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            firstInfo, new UnitInfo(secondValue), operation
        );
    }

    //This method might be used to perform full operations (not just being the last calculation step) instead
    //of the default one (PerformManagedOperationUnits) for simple cases. That is: ones not dealing with the
    //complex numeric reality (Value, Prefix and BaseTenExponent) which makes a pre-analysis required.
    //Note that, unlikely what happens with PerformMangedOperationUnits, the outputs of this method aren't
    //normalised (= primarily stored under Value), what is useful in certain contexts.
    //NOTE: this function assumes that both inputs are normalised, what means that no prefix information is expected.
    //It might also be used with non-normalised inputs, but their prefix information would be plainly ignored.
    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        if (firstInfo.Value == 0.0 || secondInfo.Value == 0.0)
        {
            if (operation == Operations.Multiplication || operation == Operations.Division)
            {
                //Dividing by zero scenarios are taken into account somewhere else.
                return new UnitInfo(firstInfo) { Value = 0.0 };
            }
        }

        UnitInfo outInfo = new UnitInfo(firstInfo);
        UnitInfo firstInfo0 = new UnitInfo(firstInfo);
        UnitInfo secondInfo0 = new UnitInfo(secondInfo);

        boolean isWrong = false;
        try
        {
            if (operation == Operations.Addition)
            {
                outInfo.Value += secondInfo0.Value;
            }
            else if (operation == Operations.Subtraction)
            {
                outInfo.Value -= secondInfo.Value;
            }
            else
            {
                //The reason for checking whether BaseTenExponent is inside/outside the int range before performing 
                //the operation (rather than going ahead and eventually catching the resulting exception) isn't just
                //being quicker, but also the only option in many situations. Note that an addition/subtraction between
                //two int variables whose result is outside the int range might not trigger an exception (+ random 
                //negative value as output).
                if (VaryBaseTenExponent(outInfo, secondInfo0.BaseTenExponent, operation == Operations.Division).Error.Type != ErrorTypes.None)
                {
                    return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
                }

                if (operation == Operations.Multiplication)
                {
                    outInfo.Value *= secondInfo.Value;
                    outInfo.BaseTenExponent += secondInfo.BaseTenExponent;
                }
                else if (operation == Operations.Division)
                {
                    if (secondInfo.Value == 0.0)
                    {
                        return
                        (
                            new UnitInfo(outInfo) 
                            { 
                                Error = new ErrorInfo(ErrorTypes.NumericError) 
                            }
                        );
                    }
                    outInfo.Value /= secondInfo.Value;
                    outInfo.BaseTenExponent -= secondInfo.BaseTenExponent;
                }
            }
        }
        catch { isWrong = true; }

        return
        (
            //An error might not be triggered despite of dealing with numbers outside double precision.
            //For example: 0.00000000000000000001m * 0.0000000000000000000001m can output 0.0 without triggering an error. 
            isWrong || ((operation == Operations.Multiplication || operation == Operations.Division) && outInfo.Value == 0.0.0) ?
            OperationValuesManageError(firstInfo0, secondInfo0, operation) : outInfo
        );
    }

    static UnitInfo OperationValuesManageError(UnitInfo outInfo, UnitInfo secondInfo, Operations operation)
    {
        if (operation != Operations.Multiplication && operation != Operations.Division)
        {
            //This condition should never be true on account of the fact that the pre-modifications performed before
            //adding/subtracting should avoid erroneous situations.
            return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
        }

        UnitInfo secondInfo2 = ConvertValueToBaseTen(secondInfo.Value);
        outInfo = VaryBaseTenExponent(outInfo, secondInfo2.BaseTenExponent, operation == Operations.Division);
        if (Math.Abs(secondInfo2.Value) == 1.0 || outInfo.Error.Type != ErrorTypes.None) return outInfo;
        
        try
        {
            outInfo = PerformManagedOperationUnits
            (
                outInfo, secondInfo2.Value, operation
            );
        }
        catch
        {
            //Very unlikely scenario on account of the fact that Math.Abs(secondInfo2.Value)
            //lies within the 0.1-10.0 range.
            outInfo = OperationValuesManageError
            (
                new UnitInfo(outInfo)
                {
                    Value = secondInfo2.Value,
                    BaseTenExponent = 0
                },
                new UnitInfo()
                {
                    Value = outInfo.Value,
                    BaseTenExponent = outInfo.BaseTenExponent
                },
                operation
            );
        }

        return outInfo;
    }

    static UnitInfo ConvertValueToBaseTen(double value)
    {
        value = Math.Abs(value);
        return FromValueToBaseTenExponent
        (
             new UnitInfo(value), Math.Abs(value), false
        );
    }

    static UnitInfo ConvertBaseTenToValue(UnitInfo unitInfo)
    {
        if (unitInfo.BaseTenExponent == 0) return unitInfo;

        UnitInfo outInfo = new UnitInfo(unitInfo);
        boolean decrease = unitInfo.BaseTenExponent > 0;
        int sign = Math.Sign(outInfo.Value);
        double absValue = Math.Abs(outInfo.Value);

        while (outInfo.BaseTenExponent != 0.0)
        {
            if (decrease)
            {
                if (absValue >= MaxValueDec / 10.0) break;
                absValue *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }
            else
            {
                if (absValue <= MinValueDec * 10.0) break;
                absValue /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
        }

        outInfo.Value = sign * absValue;

        return outInfo;
    }

    static UnitInfo NormaliseUnitInfo(UnitInfo unitInfo)
    {
        if (unitInfo.Value == 0 && unitInfo.Prefix.Factor == 1.0)
        {
            return unitInfo;
        }
        UnitInfo outInfo = new UnitInfo(unitInfo);

        if (outInfo.Prefix.Factor != 1)
        {
            outInfo = FromValueToBaseTenExponent
            (
                outInfo, outInfo.Prefix.Factor, true
            );
            outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage);
        }
        if (outInfo.Value == 0.0) return outInfo;

        outInfo = FromValueToBaseTenExponent
        (
            outInfo, outInfo.Value, false
        );

        return outInfo;
    }

    static UnitInfo FromValueToBaseTenExponent(UnitInfo outInfo, double value, boolean isPrefix)
    {
        if (value == 0.0) return outInfo;

        double valueAbs = Math.Abs(value);
        boolean decrease = (valueAbs > 1.0);
        if (!isPrefix)
        {
            outInfo.Value = outInfo.Value / valueAbs;
        }

        while (valueAbs != 1.0)
        {
            if ((valueAbs < 10.0 && valueAbs > 1.0) || (valueAbs > 0.1.0 && valueAbs < 1.0))
            {
                if (!isPrefix) outInfo.Value = value;
                else
                {
                    outInfo = PerformManagedOperationValues
                    (
                        outInfo, value, Operations.Multiplication
                    );
                }

                return outInfo;
            }

            if (decrease)
            {
                value /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
            else
            {
                value *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }

            valueAbs = Math.Abs(value);
        }

        return outInfo;
    }

    //Method used to vary BaseTenExponent without provoking unhandled exceptions (i.e., bigger than Integer.MAX_VALUE).
    static UnitInfo VaryBaseTenExponent(UnitInfo info, int baseTenIncrease, boolean isDivision = false)
    {
        long val1 = info.BaseTenExponent;
        long val2 = baseTenIncrease;

        if (isDivision)
        {
            //Converting a negative value into positive might provoke an overflow error for the int type
            //(e.g., Math.Abs(Integer.MAIN_VALUE)). Converting both variables to long is a quick and effective
            //way to avoid this problem.
            val2 *= -1;
        }

        return
        (
             ((val2 > 0 && val1 > Integer.MAX_VALUE - val2) || (val2 < 0 && val1 < Integer.MAIN_VALUE - val2)) ?
            new UnitInfo(info, ErrorTypes.NumericError) : new UnitInfo(info){{ BaseTenExponent = (int)(val1 + val2); }}
        );
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 2 2017-05-27 20:05:33.749
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 0 2017-05-27 20:05:33.750
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.core 4 4 2017-05-27 20:05:36.198
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
public class OperationsManaged
{
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, double second, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            firstInfo, new UnitInfo(second), operation
        );
    }

    public static UnitInfo PerformManagedOperationUnits(double first, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            new UnitInfo(first), secondInfo, operation
        );
    }

    //This method should always be used when dealing with random UnitInfo variables because it accounts for all the
    //possible scenarios. On the other hand, with simple operations (e.g., random UnitInfo & numeric type) it might
    //be better to use PerformManagedOperationValues. 
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        ErrorTypes errorType = InternalMethods.GetOperationError
        (
            firstInfo, secondInfo, operation
        );
        if (errorType != ErrorTypes.None)
        {
            return new UnitInfo(firstInfo) 
            {{
                Error = new ErrorInfo(errorType); 
            }};
        }

        return
        (
            operation == Operations.Addition || operation == Operations.Subtraction ?
            PerformManagedOperationAddition(firstInfo, secondInfo, operation) :
            PerformManagedOperationMultiplication(firstInfo, secondInfo, operation)
        );
    }

    static UnitInfo PerformManagedOperationAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {   
        //After being normalised, the operands might require further modifications.
        UnitInfo[] normalised = GetOperandsAddition(firstInfo, secondInfo, operation);

        return PerformManagedOperationNormalisedValues
        (
            firstInfo, normalised, operation
        );
    }

    static UnitInfo[] GetOperandsAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        UnitInfo[] operands2 = new UnitInfo[] 
        {
            new UnitInfo(firstInfo), new UnitInfo(secondInfo)
        };

        if (operands2[0].BaseTenExponent != operands2[1].BaseTenExponent || operands2[0].Prefix.Factor != operands2[1].Prefix.Factor)
        {
            //The addition/subtraction might not be performed right away even with normalised values.
            //For example: 5 and 6 from 5*10^2 and 6*10^7 cannot be added right away.
            operands2 = AdaptNormalisedValuesForAddition
            (
                new UnitInfo[] 
                { 
                    NormaliseUnitInfo(operands2[0]), 
                    NormaliseUnitInfo(operands2[1])
                },
                operation
            );
        }

        return operands2;
    }
    
    static UnitInfo[] AdaptNormalisedValuesForAddition(UnitInfo[] unitInfos2, Operations operation)
    {
        if (unitInfos2[0].BaseTenExponent == unitInfos2[1].BaseTenExponent)
        {
            //Having the same BaseTenExponent values means that the given operation can be performed right away.
            return unitInfos2;
        }

        int[] bigSmallI = 
        (
            unitInfos2[0].BaseTenExponent > unitInfos2[1].BaseTenExponent ?
            new int[] { 0, 1 } : new int[] { 1, 0 }
        );

        //Only the variable with the bigger value is modified. For example: 5*10^5 & 3*10^3 is converted
        //into 500*10^3 & 3*10^3 in order to allow the addition 500 + 3. 
        UnitInfo big2 = AdaptBiggerAdditionOperand(unitInfos2, bigSmallI, operation);
        if (big2.Error.Type != ErrorTypes.None)
        {
            return TooBigGapAddition(unitInfos2, bigSmallI, operation);
        }

        unitInfos2[bigSmallI[0]].Value = big2.Value;
        unitInfos2[bigSmallI[0]].BaseTenExponent = unitInfos2[bigSmallI[1]].BaseTenExponent;

        return unitInfos2;
    }

    //When adding/subtracting two numbers whose gap is bigger than the maximum double range, there
    //is no need to perform any operation (i.e., no change will be observed because of being outside
    //the maximum supported precision). This method takes care of these cases and returns the expected
    //output (i.e., biggest value).
    static UnitInfo[] TooBigGapAddition(UnitInfo[] unitInfos2, int[] bigSmallI, Operations operation)
    {
        UnitInfo[] outInfos = new UnitInfo[] 
        {
            //First operand (i.e., one whose information defines the operation) together with the
            //numeric information (i.e., just Value and BaseTenExponent because both are normalised)
            //which is associated with the biggest one.
            new UnitInfo(unitInfos2[0])
            {{
                Value = unitInfos2[bigSmallI[0]].Value;
                BaseTenExponent = unitInfos2[bigSmallI[0]].BaseTenExponent;
            }}
        };

        if (operation == Operations.Subtraction && bigSmallI[0] == 1)
        {
            outInfos[0].Value = -1.0 * outInfos[0].Value;
        }

        if (outInfos[0].Unit == Units.Unitless)
        {
            outInfos[0].Unit = unitInfos2[bigSmallI[1]].Unit;
        }

        return outInfos;
    }

    static UnitInfo AdaptBiggerAdditionOperand(UnitInfo[] unitInfos2, Integer[] bigSmallI, Operations operation)
    {
        int gapExponent = unitInfos2[bigSmallI[0]].BaseTenExponent - unitInfos2[bigSmallI[1]].BaseTenExponent;
        if (gapExponent >= 27)
        {
            //The difference between both inputs is bigger than (or, at least, very close to) the maximum double value/precision;
            //what makes this situation calculation unworthy and the first operand to be returned as the result.
            //Note that the error below these lines is just an easy way to tell the calling function about this eventuality.
            return new UnitInfo(unitInfos2[0]) 
            {{ 
                Error = new ErrorInfo(ErrorTypes.InvalidOperation); 
            }};
        }

        //PerformManagedOperationValues is used to make sure that the resulting numeric information is stored
        //in Value (if possible).
        UnitInfo big2 = PerformManagedOperationValues
        (
            RaiseToIntegerExponent(10.0, gapExponent), unitInfos2[bigSmallI[0]].Value, 
            Operations.Multiplication                
        );

        boolean isWrong = 
        (
            big2.Error.Type != ErrorTypes.None || big2.BaseTenExponent != 0 ?
            
            //The value of the bigger input times 10^(gap between BaseTenExponent of inputs) is too big. 
            isWrong = true :
            
            //Overflow-check very unlikely to trigger an error. In fact, with properly normalised variables,
            //triggering an error would be plainly impossible.               
            AreAdditionFinalValuesWrong
            (
                unitInfos2[0].Value, unitInfos2[1].Value, operation
            )
        );

        UnitInfo temp = null;
        if (isWrong)
        {
        	temp = new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }};
            
            temp.Error = new ErrorInfo(ErrorTypes.InvalidOperation);
        }
        
        
        return temp;
        
        
        return
        (
            isWrong ?
            //This error is just an easy way to let the calling function know about the fact that no
            //calculation has been performed (too big gap). This isn't a properly-speaking error and
            //that's why it will not be notified to the user.
            new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }} :
            //Returning the new big value. For example: with 5*10^4 & 3*10^2, 500 would be returned.
            new UnitInfo(unitInfos2[bigSmallI[0]])
            {{
                Value = big2.Value;
            }}
        )
    }

    static boolean AreAdditionFinalValuesWrong(double val1, double val2, Operations operation)
    {
        boolean isWrong = false;

        try
        {
            val1 = val1 + val2 *
            (
                operation == Operations.Addition ? 1 : -1
            );
        }
        catch { isWrong = true; }

        return isWrong;
    }

    static UnitInfo PerformManagedOperationMultiplication(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationNormalisedValues
        (
            firstInfo, new UnitInfo[] 
            { 
                NormaliseUnitInfo(firstInfo),
                NormaliseUnitInfo(secondInfo) 
            },
            operation
        );
    }

    public static UnitInfo RaiseToIntegerExponent(double baseValue, int exponent)
    {
        return RaiseToIntegerExponent(new UnitInfo(baseValue), exponent);
    }

    static UnitInfo RaiseToIntegerExponent(UnitInfo baseInfo, int exponent)
    {
        if (exponent <= 1 && exponent >= 0)
        {
            baseInfo.Value = (exponent == 0 ? 1.0 : baseInfo.Value);
            return baseInfo;
        }

        UnitInfo outInfo = new UnitInfo(baseInfo);

        for (int i = 1; i < Math.Abs(exponent); i++)
        {
            outInfo = PerformManagedOperationValues
            (
                outInfo, baseInfo, Operations.Multiplication
            );
            if (outInfo.Error.Type != ErrorTypes.None) return outInfo;
        }

        return
        (
            exponent < 0 ?
            PerformManagedOperationValues(new UnitInfo(1.0), outInfo, Operations.Division) :
            outInfo
        );
    }

    static UnitInfo PerformManagedOperationNormalisedValues(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        outInfo =
        (
            normalisedInfos.Length == 1 ?
            //There is just one operand when the difference between both of them is too big.
            outInfo = normalisedInfos[0] :
            PerformManagedOperationTwoOperands(outInfo, normalisedInfos, operation)
        );

        return outInfo;
    }

    static UnitInfo PerformManagedOperationTwoOperands(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        UnitInfo outInfoNormalised = PerformManagedOperationValues
        (
            normalisedInfos[0], normalisedInfos[1], operation
        );

        if (outInfo.Error.Type != ErrorTypes.None)
        {
            return new UnitInfo(outInfo)
            {
                Error = new ErrorInfo(ErrorTypes.NumericError)
            };
        }

        outInfo.BaseTenExponent = outInfoNormalised.BaseTenExponent;
        outInfo.Value = outInfoNormalised.Value;
        //Normalised means no prefixes.
        outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage); 

        return outInfo;
    }

    static UnitInfo PerformManagedOperationValues(double firstValue, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            new UnitInfo(firstValue), new UnitInfo(secondValue), operation
        );
    }

    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            firstInfo, new UnitInfo(secondValue), operation
        );
    }

    //This method might be used to perform full operations (not just being the last calculation step) instead
    //of the default one (PerformManagedOperationUnits) for simple cases. That is: ones not dealing with the
    //complex numeric reality (Value, Prefix and BaseTenExponent) which makes a pre-analysis required.
    //Note that, unlikely what happens with PerformMangedOperationUnits, the outputs of this method aren't
    //normalised (= primarily stored under Value), what is useful in certain contexts.
    //NOTE: this function assumes that both inputs are normalised, what means that no prefix information is expected.
    //It might also be used with non-normalised inputs, but their prefix information would be plainly ignored.
    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        if (firstInfo.Value == 0.0 || secondInfo.Value == 0.0)
        {
            if (operation == Operations.Multiplication || operation == Operations.Division)
            {
                //Dividing by zero scenarios are taken into account somewhere else.
                return new UnitInfo(firstInfo) { Value = 0.0 };
            }
        }

        UnitInfo outInfo = new UnitInfo(firstInfo);
        UnitInfo firstInfo0 = new UnitInfo(firstInfo);
        UnitInfo secondInfo0 = new UnitInfo(secondInfo);

        boolean isWrong = false;
        try
        {
            if (operation == Operations.Addition)
            {
                outInfo.Value += secondInfo0.Value;
            }
            else if (operation == Operations.Subtraction)
            {
                outInfo.Value -= secondInfo.Value;
            }
            else
            {
                //The reason for checking whether BaseTenExponent is inside/outside the int range before performing 
                //the operation (rather than going ahead and eventually catching the resulting exception) isn't just
                //being quicker, but also the only option in many situations. Note that an addition/subtraction between
                //two int variables whose result is outside the int range might not trigger an exception (+ random 
                //negative value as output).
                if (VaryBaseTenExponent(outInfo, secondInfo0.BaseTenExponent, operation == Operations.Division).Error.Type != ErrorTypes.None)
                {
                    return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
                }

                if (operation == Operations.Multiplication)
                {
                    outInfo.Value *= secondInfo.Value;
                    outInfo.BaseTenExponent += secondInfo.BaseTenExponent;
                }
                else if (operation == Operations.Division)
                {
                    if (secondInfo.Value == 0.0)
                    {
                        return
                        (
                            new UnitInfo(outInfo) 
                            { 
                                Error = new ErrorInfo(ErrorTypes.NumericError) 
                            }
                        );
                    }
                    outInfo.Value /= secondInfo.Value;
                    outInfo.BaseTenExponent -= secondInfo.BaseTenExponent;
                }
            }
        }
        catch { isWrong = true; }

        return
        (
            //An error might not be triggered despite of dealing with numbers outside double precision.
            //For example: 0.00000000000000000001m * 0.0000000000000000000001m can output 0.0 without triggering an error. 
            isWrong || ((operation == Operations.Multiplication || operation == Operations.Division) && outInfo.Value == 0.0.0) ?
            OperationValuesManageError(firstInfo0, secondInfo0, operation) : outInfo
        );
    }

    static UnitInfo OperationValuesManageError(UnitInfo outInfo, UnitInfo secondInfo, Operations operation)
    {
        if (operation != Operations.Multiplication && operation != Operations.Division)
        {
            //This condition should never be true on account of the fact that the pre-modifications performed before
            //adding/subtracting should avoid erroneous situations.
            return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
        }

        UnitInfo secondInfo2 = ConvertValueToBaseTen(secondInfo.Value);
        outInfo = VaryBaseTenExponent(outInfo, secondInfo2.BaseTenExponent, operation == Operations.Division);
        if (Math.Abs(secondInfo2.Value) == 1.0 || outInfo.Error.Type != ErrorTypes.None) return outInfo;
        
        try
        {
            outInfo = PerformManagedOperationUnits
            (
                outInfo, secondInfo2.Value, operation
            );
        }
        catch
        {
            //Very unlikely scenario on account of the fact that Math.Abs(secondInfo2.Value)
            //lies within the 0.1-10.0 range.
            outInfo = OperationValuesManageError
            (
                new UnitInfo(outInfo)
                {
                    Value = secondInfo2.Value,
                    BaseTenExponent = 0
                },
                new UnitInfo()
                {
                    Value = outInfo.Value,
                    BaseTenExponent = outInfo.BaseTenExponent
                },
                operation
            );
        }

        return outInfo;
    }

    static UnitInfo ConvertValueToBaseTen(double value)
    {
        value = Math.Abs(value);
        return FromValueToBaseTenExponent
        (
             new UnitInfo(value), Math.Abs(value), false
        );
    }

    static UnitInfo ConvertBaseTenToValue(UnitInfo unitInfo)
    {
        if (unitInfo.BaseTenExponent == 0) return unitInfo;

        UnitInfo outInfo = new UnitInfo(unitInfo);
        boolean decrease = unitInfo.BaseTenExponent > 0;
        int sign = Math.Sign(outInfo.Value);
        double absValue = Math.Abs(outInfo.Value);

        while (outInfo.BaseTenExponent != 0.0)
        {
            if (decrease)
            {
                if (absValue >= MaxValueDec / 10.0) break;
                absValue *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }
            else
            {
                if (absValue <= MinValueDec * 10.0) break;
                absValue /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
        }

        outInfo.Value = sign * absValue;

        return outInfo;
    }

    static UnitInfo NormaliseUnitInfo(UnitInfo unitInfo)
    {
        if (unitInfo.Value == 0 && unitInfo.Prefix.Factor == 1.0)
        {
            return unitInfo;
        }
        UnitInfo outInfo = new UnitInfo(unitInfo);

        if (outInfo.Prefix.Factor != 1)
        {
            outInfo = FromValueToBaseTenExponent
            (
                outInfo, outInfo.Prefix.Factor, true
            );
            outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage);
        }
        if (outInfo.Value == 0.0) return outInfo;

        outInfo = FromValueToBaseTenExponent
        (
            outInfo, outInfo.Value, false
        );

        return outInfo;
    }

    static UnitInfo FromValueToBaseTenExponent(UnitInfo outInfo, double value, boolean isPrefix)
    {
        if (value == 0.0) return outInfo;

        double valueAbs = Math.Abs(value);
        boolean decrease = (valueAbs > 1.0);
        if (!isPrefix)
        {
            outInfo.Value = outInfo.Value / valueAbs;
        }

        while (valueAbs != 1.0)
        {
            if ((valueAbs < 10.0 && valueAbs > 1.0) || (valueAbs > 0.1.0 && valueAbs < 1.0))
            {
                if (!isPrefix) outInfo.Value = value;
                else
                {
                    outInfo = PerformManagedOperationValues
                    (
                        outInfo, value, Operations.Multiplication
                    );
                }

                return outInfo;
            }

            if (decrease)
            {
                value /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
            else
            {
                value *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }

            valueAbs = Math.Abs(value);
        }

        return outInfo;
    }

    //Method used to vary BaseTenExponent without provoking unhandled exceptions (i.e., bigger than Integer.MAX_VALUE).
    static UnitInfo VaryBaseTenExponent(UnitInfo info, int baseTenIncrease, boolean isDivision = false)
    {
        long val1 = info.BaseTenExponent;
        long val2 = baseTenIncrease;

        if (isDivision)
        {
            //Converting a negative value into positive might provoke an overflow error for the int type
            //(e.g., Math.Abs(Integer.MAIN_VALUE)). Converting both variables to long is a quick and effective
            //way to avoid this problem.
            val2 *= -1;
        }

        return
        (
             ((val2 > 0 && val1 > Integer.MAX_VALUE - val2) || (val2 < 0 && val1 < Integer.MAIN_VALUE - val2)) ?
            new UnitInfo(info, ErrorTypes.NumericError) : new UnitInfo(info){{ BaseTenExponent = (int)(val1 + val2); }}
        );
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2017-05-27 20:05:36.198
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2017-05-27 20:05:36.199
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2017-05-27 20:05:36.218
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
public class OperationsManaged
{
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, double second, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            firstInfo, new UnitInfo(second), operation
        );
    }

    public static UnitInfo PerformManagedOperationUnits(double first, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            new UnitInfo(first), secondInfo, operation
        );
    }

    //This method should always be used when dealing with random UnitInfo variables because it accounts for all the
    //possible scenarios. On the other hand, with simple operations (e.g., random UnitInfo & numeric type) it might
    //be better to use PerformManagedOperationValues. 
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        ErrorTypes errorType = InternalMethods.GetOperationError
        (
            firstInfo, secondInfo, operation
        );
        if (errorType != ErrorTypes.None)
        {
            return new UnitInfo(firstInfo) 
            {{
                Error = new ErrorInfo(errorType); 
            }};
        }

        return
        (
            operation == Operations.Addition || operation == Operations.Subtraction ?
            PerformManagedOperationAddition(firstInfo, secondInfo, operation) :
            PerformManagedOperationMultiplication(firstInfo, secondInfo, operation)
        );
    }

    static UnitInfo PerformManagedOperationAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {   
        //After being normalised, the operands might require further modifications.
        UnitInfo[] normalised = GetOperandsAddition(firstInfo, secondInfo, operation);

        return PerformManagedOperationNormalisedValues
        (
            firstInfo, normalised, operation
        );
    }

    static UnitInfo[] GetOperandsAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        UnitInfo[] operands2 = new UnitInfo[] 
        {
            new UnitInfo(firstInfo), new UnitInfo(secondInfo)
        };

        if (operands2[0].BaseTenExponent != operands2[1].BaseTenExponent || operands2[0].Prefix.Factor != operands2[1].Prefix.Factor)
        {
            //The addition/subtraction might not be performed right away even with normalised values.
            //For example: 5 and 6 from 5*10^2 and 6*10^7 cannot be added right away.
            operands2 = AdaptNormalisedValuesForAddition
            (
                new UnitInfo[] 
                { 
                    NormaliseUnitInfo(operands2[0]), 
                    NormaliseUnitInfo(operands2[1])
                },
                operation
            );
        }

        return operands2;
    }
    
    static UnitInfo[] AdaptNormalisedValuesForAddition(UnitInfo[] unitInfos2, Operations operation)
    {
        if (unitInfos2[0].BaseTenExponent == unitInfos2[1].BaseTenExponent)
        {
            //Having the same BaseTenExponent values means that the given operation can be performed right away.
            return unitInfos2;
        }

        int[] bigSmallI = 
        (
            unitInfos2[0].BaseTenExponent > unitInfos2[1].BaseTenExponent ?
            new int[] { 0, 1 } : new int[] { 1, 0 }
        );

        //Only the variable with the bigger value is modified. For example: 5*10^5 & 3*10^3 is converted
        //into 500*10^3 & 3*10^3 in order to allow the addition 500 + 3. 
        UnitInfo big2 = AdaptBiggerAdditionOperand(unitInfos2, bigSmallI, operation);
        if (big2.Error.Type != ErrorTypes.None)
        {
            return TooBigGapAddition(unitInfos2, bigSmallI, operation);
        }

        unitInfos2[bigSmallI[0]].Value = big2.Value;
        unitInfos2[bigSmallI[0]].BaseTenExponent = unitInfos2[bigSmallI[1]].BaseTenExponent;

        return unitInfos2;
    }

    //When adding/subtracting two numbers whose gap is bigger than the maximum double range, there
    //is no need to perform any operation (i.e., no change will be observed because of being outside
    //the maximum supported precision). This method takes care of these cases and returns the expected
    //output (i.e., biggest value).
    static UnitInfo[] TooBigGapAddition(UnitInfo[] unitInfos2, int[] bigSmallI, Operations operation)
    {
        UnitInfo[] outInfos = new UnitInfo[] 
        {
            //First operand (i.e., one whose information defines the operation) together with the
            //numeric information (i.e., just Value and BaseTenExponent because both are normalised)
            //which is associated with the biggest one.
            new UnitInfo(unitInfos2[0])
            {{
                Value = unitInfos2[bigSmallI[0]].Value;
                BaseTenExponent = unitInfos2[bigSmallI[0]].BaseTenExponent;
            }}
        };

        if (operation == Operations.Subtraction && bigSmallI[0] == 1)
        {
            outInfos[0].Value = -1.0 * outInfos[0].Value;
        }

        if (outInfos[0].Unit == Units.Unitless)
        {
            outInfos[0].Unit = unitInfos2[bigSmallI[1]].Unit;
        }

        return outInfos;
    }

    static UnitInfo AdaptBiggerAdditionOperand(UnitInfo[] unitInfos2, Integer[] bigSmallI, Operations operation)
    {
        int gapExponent = unitInfos2[bigSmallI[0]].BaseTenExponent - unitInfos2[bigSmallI[1]].BaseTenExponent;
        if (gapExponent >= 27)
        {
            //The difference between both inputs is bigger than (or, at least, very close to) the maximum double value/precision;
            //what makes this situation calculation unworthy and the first operand to be returned as the result.
            //Note that the error below these lines is just an easy way to tell the calling function about this eventuality.
            return new UnitInfo(unitInfos2[0]) 
            {{ 
                Error = new ErrorInfo(ErrorTypes.InvalidOperation); 
            }};
        }

        //PerformManagedOperationValues is used to make sure that the resulting numeric information is stored
        //in Value (if possible).
        UnitInfo big2 = PerformManagedOperationValues
        (
            RaiseToIntegerExponent(10.0, gapExponent), unitInfos2[bigSmallI[0]].Value, 
            Operations.Multiplication                
        );

        boolean isWrong = 
        (
            big2.Error.Type != ErrorTypes.None || big2.BaseTenExponent != 0 ?
            
            //The value of the bigger input times 10^(gap between BaseTenExponent of inputs) is too big. 
            isWrong = true :
            
            //Overflow-check very unlikely to trigger an error. In fact, with properly normalised variables,
            //triggering an error would be plainly impossible.               
            AreAdditionFinalValuesWrong
            (
                unitInfos2[0].Value, unitInfos2[1].Value, operation
            )
        );

        UnitInfo temp = null;
        if (isWrong)
        {
        	temp = new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }};
            
            temp.Error = new ErrorInfo(ErrorTypes.InvalidOperation);
        }
        
        
        return temp;
        
        
        return
        (
            isWrong ?
            //This error is just an easy way to let the calling function know about the fact that no
            //calculation has been performed (too big gap). This isn't a properly-speaking error and
            //that's why it will not be notified to the user.
            new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }} :
            //Returning the new big value. For example: with 5*10^4 & 3*10^2, 500 would be returned.
            new UnitInfo(unitInfos2[bigSmallI[0]])
            {{
                Value = big2.Value;
            }}
        )
    }

    static boolean AreAdditionFinalValuesWrong(double val1, double val2, Operations operation)
    {
        boolean isWrong = false;

        try
        {
            val1 = val1 + val2 *
            (
                operation == Operations.Addition ? 1 : -1
            );
        }
        catch { isWrong = true; }

        return isWrong;
    }

    static UnitInfo PerformManagedOperationMultiplication(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationNormalisedValues
        (
            firstInfo, new UnitInfo[] 
            { 
                NormaliseUnitInfo(firstInfo),
                NormaliseUnitInfo(secondInfo) 
            },
            operation
        );
    }

    public static UnitInfo RaiseToIntegerExponent(double baseValue, int exponent)
    {
        return RaiseToIntegerExponent(new UnitInfo(baseValue), exponent);
    }

    static UnitInfo RaiseToIntegerExponent(UnitInfo baseInfo, int exponent)
    {
        if (exponent <= 1 && exponent >= 0)
        {
            baseInfo.Value = (exponent == 0 ? 1.0 : baseInfo.Value);
            return baseInfo;
        }

        UnitInfo outInfo = new UnitInfo(baseInfo);

        for (int i = 1; i < Math.Abs(exponent); i++)
        {
            outInfo = PerformManagedOperationValues
            (
                outInfo, baseInfo, Operations.Multiplication
            );
            if (outInfo.Error.Type != ErrorTypes.None) return outInfo;
        }

        return
        (
            exponent < 0 ?
            PerformManagedOperationValues(new UnitInfo(1.0), outInfo, Operations.Division) :
            outInfo
        );
    }

    static UnitInfo PerformManagedOperationNormalisedValues(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        outInfo =
        (
            normalisedInfos.Length == 1 ?
            //There is just one operand when the difference between both of them is too big.
            outInfo = normalisedInfos[0] :
            PerformManagedOperationTwoOperands(outInfo, normalisedInfos, operation)
        );

        return outInfo;
    }

    static UnitInfo PerformManagedOperationTwoOperands(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        UnitInfo outInfoNormalised = PerformManagedOperationValues
        (
            normalisedInfos[0], normalisedInfos[1], operation
        );

        if (outInfo.Error.Type != ErrorTypes.None)
        {
            return new UnitInfo(outInfo)
            {
                Error = new ErrorInfo(ErrorTypes.NumericError)
            };
        }

        outInfo.BaseTenExponent = outInfoNormalised.BaseTenExponent;
        outInfo.Value = outInfoNormalised.Value;
        //Normalised means no prefixes.
        outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage); 

        return outInfo;
    }

    static UnitInfo PerformManagedOperationValues(double firstValue, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            new UnitInfo(firstValue), new UnitInfo(secondValue), operation
        );
    }

    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            firstInfo, new UnitInfo(secondValue), operation
        );
    }

    //This method might be used to perform full operations (not just being the last calculation step) instead
    //of the default one (PerformManagedOperationUnits) for simple cases. That is: ones not dealing with the
    //complex numeric reality (Value, Prefix and BaseTenExponent) which makes a pre-analysis required.
    //Note that, unlikely what happens with PerformMangedOperationUnits, the outputs of this method aren't
    //normalised (= primarily stored under Value), what is useful in certain contexts.
    //NOTE: this function assumes that both inputs are normalised, what means that no prefix information is expected.
    //It might also be used with non-normalised inputs, but their prefix information would be plainly ignored.
    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        if (firstInfo.Value == 0.0 || secondInfo.Value == 0.0)
        {
            if (operation == Operations.Multiplication || operation == Operations.Division)
            {
                //Dividing by zero scenarios are taken into account somewhere else.
                return new UnitInfo(firstInfo) { Value = 0.0 };
            }
        }

        UnitInfo outInfo = new UnitInfo(firstInfo);
        UnitInfo firstInfo0 = new UnitInfo(firstInfo);
        UnitInfo secondInfo0 = new UnitInfo(secondInfo);

        boolean isWrong = false;
        try
        {
            if (operation == Operations.Addition)
            {
                outInfo.Value += secondInfo0.Value;
            }
            else if (operation == Operations.Subtraction)
            {
                outInfo.Value -= secondInfo.Value;
            }
            else
            {
                //The reason for checking whether BaseTenExponent is inside/outside the int range before performing 
                //the operation (rather than going ahead and eventually catching the resulting exception) isn't just
                //being quicker, but also the only option in many situations. Note that an addition/subtraction between
                //two int variables whose result is outside the int range might not trigger an exception (+ random 
                //negative value as output).
                if (VaryBaseTenExponent(outInfo, secondInfo0.BaseTenExponent, operation == Operations.Division).Error.Type != ErrorTypes.None)
                {
                    return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
                }

                if (operation == Operations.Multiplication)
                {
                    outInfo.Value *= secondInfo.Value;
                    outInfo.BaseTenExponent += secondInfo.BaseTenExponent;
                }
                else if (operation == Operations.Division)
                {
                    if (secondInfo.Value == 0.0)
                    {
                        return
                        (
                            new UnitInfo(outInfo) 
                            { 
                                Error = new ErrorInfo(ErrorTypes.NumericError) 
                            }
                        );
                    }
                    outInfo.Value /= secondInfo.Value;
                    outInfo.BaseTenExponent -= secondInfo.BaseTenExponent;
                }
            }
        }
        catch { isWrong = true; }

        return
        (
            //An error might not be triggered despite of dealing with numbers outside double precision.
            //For example: 0.00000000000000000001m * 0.0000000000000000000001m can output 0.0 without triggering an error. 
            isWrong || ((operation == Operations.Multiplication || operation == Operations.Division) && outInfo.Value == 0.0.0) ?
            OperationValuesManageError(firstInfo0, secondInfo0, operation) : outInfo
        );
    }

    static UnitInfo OperationValuesManageError(UnitInfo outInfo, UnitInfo secondInfo, Operations operation)
    {
        if (operation != Operations.Multiplication && operation != Operations.Division)
        {
            //This condition should never be true on account of the fact that the pre-modifications performed before
            //adding/subtracting should avoid erroneous situations.
            return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
        }

        UnitInfo secondInfo2 = ConvertValueToBaseTen(secondInfo.Value);
        outInfo = VaryBaseTenExponent(outInfo, secondInfo2.BaseTenExponent, operation == Operations.Division);
        if (Math.Abs(secondInfo2.Value) == 1.0 || outInfo.Error.Type != ErrorTypes.None) return outInfo;
        
        try
        {
            outInfo = PerformManagedOperationUnits
            (
                outInfo, secondInfo2.Value, operation
            );
        }
        catch
        {
            //Very unlikely scenario on account of the fact that Math.Abs(secondInfo2.Value)
            //lies within the 0.1-10.0 range.
            outInfo = OperationValuesManageError
            (
                new UnitInfo(outInfo)
                {
                    Value = secondInfo2.Value,
                    BaseTenExponent = 0
                },
                new UnitInfo()
                {
                    Value = outInfo.Value,
                    BaseTenExponent = outInfo.BaseTenExponent
                },
                operation
            );
        }

        return outInfo;
    }

    static UnitInfo ConvertValueToBaseTen(double value)
    {
        value = Math.Abs(value);
        return FromValueToBaseTenExponent
        (
             new UnitInfo(value), Math.Abs(value), false
        );
    }

    static UnitInfo ConvertBaseTenToValue(UnitInfo unitInfo)
    {
        if (unitInfo.BaseTenExponent == 0) return unitInfo;

        UnitInfo outInfo = new UnitInfo(unitInfo);
        boolean decrease = unitInfo.BaseTenExponent > 0;
        int sign = Math.Sign(outInfo.Value);
        double absValue = Math.Abs(outInfo.Value);

        while (outInfo.BaseTenExponent != 0.0)
        {
            if (decrease)
            {
                if (absValue >= MaxValueDec / 10.0) break;
                absValue *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }
            else
            {
                if (absValue <= MinValueDec * 10.0) break;
                absValue /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
        }

        outInfo.Value = sign * absValue;

        return outInfo;
    }

    static UnitInfo NormaliseUnitInfo(UnitInfo unitInfo)
    {
        if (unitInfo.Value == 0 && unitInfo.Prefix.Factor == 1.0)
        {
            return unitInfo;
        }
        UnitInfo outInfo = new UnitInfo(unitInfo);

        if (outInfo.Prefix.Factor != 1)
        {
            outInfo = FromValueToBaseTenExponent
            (
                outInfo, outInfo.Prefix.Factor, true
            );
            outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage);
        }
        if (outInfo.Value == 0.0) return outInfo;

        outInfo = FromValueToBaseTenExponent
        (
            outInfo, outInfo.Value, false
        );

        return outInfo;
    }

    static UnitInfo FromValueToBaseTenExponent(UnitInfo outInfo, double value, boolean isPrefix)
    {
        if (value == 0.0) return outInfo;

        double valueAbs = Math.Abs(value);
        boolean decrease = (valueAbs > 1.0);
        if (!isPrefix)
        {
            outInfo.Value = outInfo.Value / valueAbs;
        }

        while (valueAbs != 1.0)
        {
            if ((valueAbs < 10.0 && valueAbs > 1.0) || (valueAbs > 0.1.0 && valueAbs < 1.0))
            {
                if (!isPrefix) outInfo.Value = value;
                else
                {
                    outInfo = PerformManagedOperationValues
                    (
                        outInfo, value, Operations.Multiplication
                    );
                }

                return outInfo;
            }

            if (decrease)
            {
                value /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
            else
            {
                value *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }

            valueAbs = Math.Abs(value);
        }

        return outInfo;
    }

    //Method used to vary BaseTenExponent without provoking unhandled exceptions (i.e., bigger than Integer.MAX_VALUE).
    static UnitInfo VaryBaseTenExponent(UnitInfo info, int baseTenIncrease, boolean isDivision = false)
    {
        long val1 = info.BaseTenExponent;
        long val2 = baseTenIncrease;

        if (isDivision)
        {
            //Converting a negative value into positive might provoke an overflow error for the int type
            //(e.g., Math.Abs(Integer.MAIN_VALUE)). Converting both variables to long is a quick and effective
            //way to avoid this problem.
            val2 *= -1;
        }

        return
        (
             ((val2 > 0 && val1 > Integer.MAX_VALUE - val2) || (val2 < 0 && val1 < Integer.MAIN_VALUE - val2)) ?
            new UnitInfo(info, ErrorTypes.NumericError) : new UnitInfo(info){{ BaseTenExponent = (int)(val1 + val2); }}
        );
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:476)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 2 2017-05-27 20:05:36.219
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:476)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 0 2017-05-27 20:05:36.219
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:476)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.core 4 4 2017-05-27 20:05:39.209
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
public class OperationsManaged
{
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, double second, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            firstInfo, new UnitInfo(second), operation
        );
    }

    public static UnitInfo PerformManagedOperationUnits(double first, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            new UnitInfo(first), secondInfo, operation
        );
    }

    //This method should always be used when dealing with random UnitInfo variables because it accounts for all the
    //possible scenarios. On the other hand, with simple operations (e.g., random UnitInfo & numeric type) it might
    //be better to use PerformManagedOperationValues. 
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        ErrorTypes errorType = InternalMethods.GetOperationError
        (
            firstInfo, secondInfo, operation
        );
        if (errorType != ErrorTypes.None)
        {
            return new UnitInfo(firstInfo) 
            {{
                Error = new ErrorInfo(errorType); 
            }};
        }

        return
        (
            operation == Operations.Addition || operation == Operations.Subtraction ?
            PerformManagedOperationAddition(firstInfo, secondInfo, operation) :
            PerformManagedOperationMultiplication(firstInfo, secondInfo, operation)
        );
    }

    static UnitInfo PerformManagedOperationAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {   
        //After being normalised, the operands might require further modifications.
        UnitInfo[] normalised = GetOperandsAddition(firstInfo, secondInfo, operation);

        return PerformManagedOperationNormalisedValues
        (
            firstInfo, normalised, operation
        );
    }

    static UnitInfo[] GetOperandsAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        UnitInfo[] operands2 = new UnitInfo[] 
        {
            new UnitInfo(firstInfo), new UnitInfo(secondInfo)
        };

        if (operands2[0].BaseTenExponent != operands2[1].BaseTenExponent || operands2[0].Prefix.Factor != operands2[1].Prefix.Factor)
        {
            //The addition/subtraction might not be performed right away even with normalised values.
            //For example: 5 and 6 from 5*10^2 and 6*10^7 cannot be added right away.
            operands2 = AdaptNormalisedValuesForAddition
            (
                new UnitInfo[] 
                { 
                    NormaliseUnitInfo(operands2[0]), 
                    NormaliseUnitInfo(operands2[1])
                },
                operation
            );
        }

        return operands2;
    }
    
    static UnitInfo[] AdaptNormalisedValuesForAddition(UnitInfo[] unitInfos2, Operations operation)
    {
        if (unitInfos2[0].BaseTenExponent == unitInfos2[1].BaseTenExponent)
        {
            //Having the same BaseTenExponent values means that the given operation can be performed right away.
            return unitInfos2;
        }

        int[] bigSmallI = 
        (
            unitInfos2[0].BaseTenExponent > unitInfos2[1].BaseTenExponent ?
            new int[] { 0, 1 } : new int[] { 1, 0 }
        );

        //Only the variable with the bigger value is modified. For example: 5*10^5 & 3*10^3 is converted
        //into 500*10^3 & 3*10^3 in order to allow the addition 500 + 3. 
        UnitInfo big2 = AdaptBiggerAdditionOperand(unitInfos2, bigSmallI, operation);
        if (big2.Error.Type != ErrorTypes.None)
        {
            return TooBigGapAddition(unitInfos2, bigSmallI, operation);
        }

        unitInfos2[bigSmallI[0]].Value = big2.Value;
        unitInfos2[bigSmallI[0]].BaseTenExponent = unitInfos2[bigSmallI[1]].BaseTenExponent;

        return unitInfos2;
    }

    //When adding/subtracting two numbers whose gap is bigger than the maximum double range, there
    //is no need to perform any operation (i.e., no change will be observed because of being outside
    //the maximum supported precision). This method takes care of these cases and returns the expected
    //output (i.e., biggest value).
    static UnitInfo[] TooBigGapAddition(UnitInfo[] unitInfos2, int[] bigSmallI, Operations operation)
    {
        UnitInfo[] outInfos = new UnitInfo[] 
        {
            //First operand (i.e., one whose information defines the operation) together with the
            //numeric information (i.e., just Value and BaseTenExponent because both are normalised)
            //which is associated with the biggest one.
            new UnitInfo(unitInfos2[0])
            {{
                Value = unitInfos2[bigSmallI[0]].Value;
                BaseTenExponent = unitInfos2[bigSmallI[0]].BaseTenExponent;
            }}
        };

        if (operation == Operations.Subtraction && bigSmallI[0] == 1)
        {
            outInfos[0].Value = -1.0 * outInfos[0].Value;
        }

        if (outInfos[0].Unit == Units.Unitless)
        {
            outInfos[0].Unit = unitInfos2[bigSmallI[1]].Unit;
        }

        return outInfos;
    }

    static UnitInfo AdaptBiggerAdditionOperand(UnitInfo[] unitInfos2, Integer[] bigSmallI, Operations operation)
    {
        int gapExponent = unitInfos2[bigSmallI[0]].BaseTenExponent - unitInfos2[bigSmallI[1]].BaseTenExponent;
        if (gapExponent >= 27)
        {
            //The difference between both inputs is bigger than (or, at least, very close to) the maximum double value/precision;
            //what makes this situation calculation unworthy and the first operand to be returned as the result.
            //Note that the error below these lines is just an easy way to tell the calling function about this eventuality.
            return new UnitInfo(unitInfos2[0]) 
            {{ 
                Error = new ErrorInfo(ErrorTypes.InvalidOperation); 
            }};
        }

        //PerformManagedOperationValues is used to make sure that the resulting numeric information is stored
        //in Value (if possible).
        UnitInfo big2 = PerformManagedOperationValues
        (
            RaiseToIntegerExponent(10.0, gapExponent), unitInfos2[bigSmallI[0]].Value, 
            Operations.Multiplication                
        );

        boolean isWrong = 
        (
            big2.Error.Type != ErrorTypes.None || big2.BaseTenExponent != 0 ?
            
            //The value of the bigger input times 10^(gap between BaseTenExponent of inputs) is too big. 
            isWrong = true :
            
            //Overflow-check very unlikely to trigger an error. In fact, with properly normalised variables,
            //triggering an error would be plainly impossible.               
            AreAdditionFinalValuesWrong
            (
                unitInfos2[0].Value, unitInfos2[1].Value, operation
            )
        );

        UnitInfo temp = null;
        if (isWrong)
        {
        	temp = new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }};
            
            temp.Error = new ErrorInfo(ErrorTypes.InvalidOperation);
        }
        
        
        return temp;
        
        
        return
        (
            isWrong ?
            //This error is just an easy way to let the calling function know about the fact that no
            //calculation has been performed (too big gap). This isn't a properly-speaking error and
            //that's why it will not be notified to the user.
            new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }} :
            //Returning the new big value. For example: with 5*10^4 & 3*10^2, 500 would be returned.
            new UnitInfo(unitInfos2[bigSmallI[0]])
            {{
                Value = big2.Value;
            }}
        )
    }

    static boolean AreAdditionFinalValuesWrong(double val1, double val2, Operations operation)
    {
        boolean isWrong = false;

        try
        {
            val1 = val1 + val2 *
            (
                operation == Operations.Addition ? 1 : -1
            );
        }
        catch { isWrong = true; }

        return isWrong;
    }

    static UnitInfo PerformManagedOperationMultiplication(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationNormalisedValues
        (
            firstInfo, new UnitInfo[] 
            { 
                NormaliseUnitInfo(firstInfo),
                NormaliseUnitInfo(secondInfo) 
            },
            operation
        );
    }

    public static UnitInfo RaiseToIntegerExponent(double baseValue, int exponent)
    {
        return RaiseToIntegerExponent(new UnitInfo(baseValue), exponent);
    }

    static UnitInfo RaiseToIntegerExponent(UnitInfo baseInfo, int exponent)
    {
        if (exponent <= 1 && exponent >= 0)
        {
            baseInfo.Value = (exponent == 0 ? 1.0 : baseInfo.Value);
            return baseInfo;
        }

        UnitInfo outInfo = new UnitInfo(baseInfo);

        for (int i = 1; i < Math.Abs(exponent); i++)
        {
            outInfo = PerformManagedOperationValues
            (
                outInfo, baseInfo, Operations.Multiplication
            );
            if (outInfo.Error.Type != ErrorTypes.None) return outInfo;
        }

        return
        (
            exponent < 0 ?
            PerformManagedOperationValues(new UnitInfo(1.0), outInfo, Operations.Division) :
            outInfo
        );
    }

    static UnitInfo PerformManagedOperationNormalisedValues(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        outInfo =
        (
            normalisedInfos.Length == 1 ?
            //There is just one operand when the difference between both of them is too big.
            outInfo = normalisedInfos[0] :
            PerformManagedOperationTwoOperands(outInfo, normalisedInfos, operation)
        );

        return outInfo;
    }

    static UnitInfo PerformManagedOperationTwoOperands(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        UnitInfo outInfoNormalised = PerformManagedOperationValues
        (
            normalisedInfos[0], normalisedInfos[1], operation
        );

        if (outInfo.Error.Type != ErrorTypes.None)
        {
            return new UnitInfo(outInfo)
            {
                Error = new ErrorInfo(ErrorTypes.NumericError)
            };
        }

        outInfo.BaseTenExponent = outInfoNormalised.BaseTenExponent;
        outInfo.Value = outInfoNormalised.Value;
        //Normalised means no prefixes.
        outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage); 

        return outInfo;
    }

    static UnitInfo PerformManagedOperationValues(double firstValue, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            new UnitInfo(firstValue), new UnitInfo(secondValue), operation
        );
    }

    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            firstInfo, new UnitInfo(secondValue), operation
        );
    }

    //This method might be used to perform full operations (not just being the last calculation step) instead
    //of the default one (PerformManagedOperationUnits) for simple cases. That is: ones not dealing with the
    //complex numeric reality (Value, Prefix and BaseTenExponent) which makes a pre-analysis required.
    //Note that, unlikely what happens with PerformMangedOperationUnits, the outputs of this method aren't
    //normalised (= primarily stored under Value), what is useful in certain contexts.
    //NOTE: this function assumes that both inputs are normalised, what means that no prefix information is expected.
    //It might also be used with non-normalised inputs, but their prefix information would be plainly ignored.
    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        if (firstInfo.Value == 0.0 || secondInfo.Value == 0.0)
        {
            if (operation == Operations.Multiplication || operation == Operations.Division)
            {
                //Dividing by zero scenarios are taken into account somewhere else.
                return new UnitInfo(firstInfo) { Value = 0.0 };
            }
        }

        UnitInfo outInfo = new UnitInfo(firstInfo);
        UnitInfo firstInfo0 = new UnitInfo(firstInfo);
        UnitInfo secondInfo0 = new UnitInfo(secondInfo);

        boolean isWrong = false;
        try
        {
            if (operation == Operations.Addition)
            {
                outInfo.Value += secondInfo0.Value;
            }
            else if (operation == Operations.Subtraction)
            {
                outInfo.Value -= secondInfo.Value;
            }
            else
            {
                //The reason for checking whether BaseTenExponent is inside/outside the int range before performing 
                //the operation (rather than going ahead and eventually catching the resulting exception) isn't just
                //being quicker, but also the only option in many situations. Note that an addition/subtraction between
                //two int variables whose result is outside the int range might not trigger an exception (+ random 
                //negative value as output).
                if (VaryBaseTenExponent(outInfo, secondInfo0.BaseTenExponent, operation == Operations.Division).Error.Type != ErrorTypes.None)
                {
                    return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
                }

                if (operation == Operations.Multiplication)
                {
                    outInfo.Value *= secondInfo.Value;
                    outInfo.BaseTenExponent += secondInfo.BaseTenExponent;
                }
                else if (operation == Operations.Division)
                {
                    if (secondInfo.Value == 0.0)
                    {
                        return
                        (
                            new UnitInfo(outInfo) 
                            { 
                                Error = new ErrorInfo(ErrorTypes.NumericError) 
                            }
                        );
                    }
                    outInfo.Value /= secondInfo.Value;
                    outInfo.BaseTenExponent -= secondInfo.BaseTenExponent;
                }
            }
        }
        catch { isWrong = true; }

        return
        (
            //An error might not be triggered despite of dealing with numbers outside double precision.
            //For example: 0.00000000000000000001m * 0.0000000000000000000001m can output 0.0 without triggering an error. 
            isWrong || ((operation == Operations.Multiplication || operation == Operations.Division) && outInfo.Value == 0.0.0) ?
            OperationValuesManageError(firstInfo0, secondInfo0, operation) : outInfo
        );
    }

    static UnitInfo OperationValuesManageError(UnitInfo outInfo, UnitInfo secondInfo, Operations operation)
    {
        if (operation != Operations.Multiplication && operation != Operations.Division)
        {
            //This condition should never be true on account of the fact that the pre-modifications performed before
            //adding/subtracting should avoid erroneous situations.
            return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
        }

        UnitInfo secondInfo2 = ConvertValueToBaseTen(secondInfo.Value);
        outInfo = VaryBaseTenExponent(outInfo, secondInfo2.BaseTenExponent, operation == Operations.Division);
        if (Math.Abs(secondInfo2.Value) == 1.0 || outInfo.Error.Type != ErrorTypes.None) return outInfo;
        
        try
        {
            outInfo = PerformManagedOperationUnits
            (
                outInfo, secondInfo2.Value, operation
            );
        }
        catch
        {
            //Very unlikely scenario on account of the fact that Math.Abs(secondInfo2.Value)
            //lies within the 0.1-10.0 range.
            outInfo = OperationValuesManageError
            (
                new UnitInfo(outInfo)
                {
                    Value = secondInfo2.Value,
                    BaseTenExponent = 0
                },
                new UnitInfo()
                {
                    Value = outInfo.Value,
                    BaseTenExponent = outInfo.BaseTenExponent
                },
                operation
            );
        }

        return outInfo;
    }

    static UnitInfo ConvertValueToBaseTen(double value)
    {
        value = Math.Abs(value);
        return FromValueToBaseTenExponent
        (
             new UnitInfo(value), Math.Abs(value), false
        );
    }

    static UnitInfo ConvertBaseTenToValue(UnitInfo unitInfo)
    {
        if (unitInfo.BaseTenExponent == 0) return unitInfo;

        UnitInfo outInfo = new UnitInfo(unitInfo);
        boolean decrease = unitInfo.BaseTenExponent > 0;
        int sign = Math.Sign(outInfo.Value);
        double absValue = Math.Abs(outInfo.Value);

        while (outInfo.BaseTenExponent != 0.0)
        {
            if (decrease)
            {
                if (absValue >= MaxValueDec / 10.0) break;
                absValue *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }
            else
            {
                if (absValue <= MinValueDec * 10.0) break;
                absValue /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
        }

        outInfo.Value = sign * absValue;

        return outInfo;
    }

    static UnitInfo NormaliseUnitInfo(UnitInfo unitInfo)
    {
        if (unitInfo.Value == 0 && unitInfo.Prefix.Factor == 1.0)
        {
            return unitInfo;
        }
        UnitInfo outInfo = new UnitInfo(unitInfo);

        if (outInfo.Prefix.Factor != 1)
        {
            outInfo = FromValueToBaseTenExponent
            (
                outInfo, outInfo.Prefix.Factor, true
            );
            outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage);
        }
        if (outInfo.Value == 0.0) return outInfo;

        outInfo = FromValueToBaseTenExponent
        (
            outInfo, outInfo.Value, false
        );

        return outInfo;
    }

    static UnitInfo FromValueToBaseTenExponent(UnitInfo outInfo, double value, boolean isPrefix)
    {
        if (value == 0.0) return outInfo;

        double valueAbs = Math.Abs(value);
        boolean decrease = (valueAbs > 1.0);
        if (!isPrefix)
        {
            outInfo.Value = outInfo.Value / valueAbs;
        }

        while (valueAbs != 1.0)
        {
            if ((valueAbs < 10.0 && valueAbs > 1.0) || (valueAbs > 0.1.0 && valueAbs < 1.0))
            {
                if (!isPrefix) outInfo.Value = value;
                else
                {
                    outInfo = PerformManagedOperationValues
                    (
                        outInfo, value, Operations.Multiplication
                    );
                }

                return outInfo;
            }

            if (decrease)
            {
                value /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
            else
            {
                value *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }

            valueAbs = Math.Abs(value);
        }

        return outInfo;
    }

    //Method used to vary BaseTenExponent without provoking unhandled exceptions (i.e., bigger than Integer.MAX_VALUE).
    static UnitInfo VaryBaseTenExponent(UnitInfo info, int baseTenIncrease, boolean isDivision = false)
    {
        long val1 = info.BaseTenExponent;
        long val2 = baseTenIncrease;

        if (isDivision)
        {
            //Converting a negative value into positive might provoke an overflow error for the int type
            //(e.g., Math.Abs(Integer.MAIN_VALUE)). Converting both variables to long is a quick and effective
            //way to avoid this problem.
            val2 *= -1;
        }

        return
        (
             ((val2 > 0 && val1 > Integer.MAX_VALUE - val2) || (val2 < 0 && val1 < Integer.MAIN_VALUE - val2)) ?
            new UnitInfo(info, ErrorTypes.NumericError) : new UnitInfo(info){{ BaseTenExponent = (int)(val1 + val2); }}
        );
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 2 2017-05-27 20:05:39.210
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 0 2017-05-27 20:05:39.211
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.core 4 4 2017-05-27 20:05:39.863
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
public class OperationsManaged
{
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, double second, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            firstInfo, new UnitInfo(second), operation
        );
    }

    public static UnitInfo PerformManagedOperationUnits(double first, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            new UnitInfo(first), secondInfo, operation
        );
    }

    //This method should always be used when dealing with random UnitInfo variables because it accounts for all the
    //possible scenarios. On the other hand, with simple operations (e.g., random UnitInfo & numeric type) it might
    //be better to use PerformManagedOperationValues. 
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        ErrorTypes errorType = InternalMethods.GetOperationError
        (
            firstInfo, secondInfo, operation
        );
        if (errorType != ErrorTypes.None)
        {
            return new UnitInfo(firstInfo) 
            {{
                Error = new ErrorInfo(errorType); 
            }};
        }

        return
        (
            operation == Operations.Addition || operation == Operations.Subtraction ?
            PerformManagedOperationAddition(firstInfo, secondInfo, operation) :
            PerformManagedOperationMultiplication(firstInfo, secondInfo, operation)
        );
    }

    static UnitInfo PerformManagedOperationAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {   
        //After being normalised, the operands might require further modifications.
        UnitInfo[] normalised = GetOperandsAddition(firstInfo, secondInfo, operation);

        return PerformManagedOperationNormalisedValues
        (
            firstInfo, normalised, operation
        );
    }

    static UnitInfo[] GetOperandsAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        UnitInfo[] operands2 = new UnitInfo[] 
        {
            new UnitInfo(firstInfo), new UnitInfo(secondInfo)
        };

        if (operands2[0].BaseTenExponent != operands2[1].BaseTenExponent || operands2[0].Prefix.Factor != operands2[1].Prefix.Factor)
        {
            //The addition/subtraction might not be performed right away even with normalised values.
            //For example: 5 and 6 from 5*10^2 and 6*10^7 cannot be added right away.
            operands2 = AdaptNormalisedValuesForAddition
            (
                new UnitInfo[] 
                { 
                    NormaliseUnitInfo(operands2[0]), 
                    NormaliseUnitInfo(operands2[1])
                },
                operation
            );
        }

        return operands2;
    }
    
    static UnitInfo[] AdaptNormalisedValuesForAddition(UnitInfo[] unitInfos2, Operations operation)
    {
        if (unitInfos2[0].BaseTenExponent == unitInfos2[1].BaseTenExponent)
        {
            //Having the same BaseTenExponent values means that the given operation can be performed right away.
            return unitInfos2;
        }

        int[] bigSmallI = 
        (
            unitInfos2[0].BaseTenExponent > unitInfos2[1].BaseTenExponent ?
            new int[] { 0, 1 } : new int[] { 1, 0 }
        );

        //Only the variable with the bigger value is modified. For example: 5*10^5 & 3*10^3 is converted
        //into 500*10^3 & 3*10^3 in order to allow the addition 500 + 3. 
        UnitInfo big2 = AdaptBiggerAdditionOperand(unitInfos2, bigSmallI, operation);
        if (big2.Error.Type != ErrorTypes.None)
        {
            return TooBigGapAddition(unitInfos2, bigSmallI, operation);
        }

        unitInfos2[bigSmallI[0]].Value = big2.Value;
        unitInfos2[bigSmallI[0]].BaseTenExponent = unitInfos2[bigSmallI[1]].BaseTenExponent;

        return unitInfos2;
    }

    //When adding/subtracting two numbers whose gap is bigger than the maximum double range, there
    //is no need to perform any operation (i.e., no change will be observed because of being outside
    //the maximum supported precision). This method takes care of these cases and returns the expected
    //output (i.e., biggest value).
    static UnitInfo[] TooBigGapAddition(UnitInfo[] unitInfos2, int[] bigSmallI, Operations operation)
    {
        UnitInfo[] outInfos = new UnitInfo[] 
        {
            //First operand (i.e., one whose information defines the operation) together with the
            //numeric information (i.e., just Value and BaseTenExponent because both are normalised)
            //which is associated with the biggest one.
            new UnitInfo(unitInfos2[0])
            {{
                Value = unitInfos2[bigSmallI[0]].Value;
                BaseTenExponent = unitInfos2[bigSmallI[0]].BaseTenExponent;
            }}
        };

        if (operation == Operations.Subtraction && bigSmallI[0] == 1)
        {
            outInfos[0].Value = -1.0 * outInfos[0].Value;
        }

        if (outInfos[0].Unit == Units.Unitless)
        {
            outInfos[0].Unit = unitInfos2[bigSmallI[1]].Unit;
        }

        return outInfos;
    }

    static UnitInfo AdaptBiggerAdditionOperand(UnitInfo[] unitInfos2, Integer[] bigSmallI, Operations operation)
    {
        int gapExponent = unitInfos2[bigSmallI[0]].BaseTenExponent - unitInfos2[bigSmallI[1]].BaseTenExponent;
        if (gapExponent >= 27)
        {
            //The difference between both inputs is bigger than (or, at least, very close to) the maximum double value/precision;
            //what makes this situation calculation unworthy and the first operand to be returned as the result.
            //Note that the error below these lines is just an easy way to tell the calling function about this eventuality.
            return new UnitInfo(unitInfos2[0]) 
            {{ 
                Error = new ErrorInfo(ErrorTypes.InvalidOperation); 
            }};
        }

        //PerformManagedOperationValues is used to make sure that the resulting numeric information is stored
        //in Value (if possible).
        UnitInfo big2 = PerformManagedOperationValues
        (
            RaiseToIntegerExponent(10.0, gapExponent), unitInfos2[bigSmallI[0]].Value, 
            Operations.Multiplication                
        );

        boolean isWrong = 
        (
            big2.Error.Type != ErrorTypes.None || big2.BaseTenExponent != 0 ?
            
            //The value of the bigger input times 10^(gap between BaseTenExponent of inputs) is too big. 
            isWrong = true :
            
            //Overflow-check very unlikely to trigger an error. In fact, with properly normalised variables,
            //triggering an error would be plainly impossible.               
            AreAdditionFinalValuesWrong
            (
                unitInfos2[0].Value, unitInfos2[1].Value, operation
            )
        );

        UnitInfo temp = null;
        if (isWrong)
        {
        	temp = new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }};
            
            temp.Error = new ErrorInfo(ErrorTypes.InvalidOperation);
        }
        
        
        return temp;
        
        
        return
        (
            isWrong ?
            //This error is just an easy way to let the calling function know about the fact that no
            //calculation has been performed (too big gap). This isn't a properly-speaking error and
            //that's why it will not be notified to the user.
            new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }} :
            //Returning the new big value. For example: with 5*10^4 & 3*10^2, 500 would be returned.
            new UnitInfo(unitInfos2[bigSmallI[0]])
            {{
                Value = big2.Value;
            }}
        )
    }

    static boolean AreAdditionFinalValuesWrong(double val1, double val2, Operations operation)
    {
        boolean isWrong = false;

        try
        {
            val1 = val1 + val2 *
            (
                operation == Operations.Addition ? 1 : -1
            );
        }
        catch { isWrong = true; }

        return isWrong;
    }

    static UnitInfo PerformManagedOperationMultiplication(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationNormalisedValues
        (
            firstInfo, new UnitInfo[] 
            { 
                NormaliseUnitInfo(firstInfo),
                NormaliseUnitInfo(secondInfo) 
            },
            operation
        );
    }

    public static UnitInfo RaiseToIntegerExponent(double baseValue, int exponent)
    {
        return RaiseToIntegerExponent(new UnitInfo(baseValue), exponent);
    }

    static UnitInfo RaiseToIntegerExponent(UnitInfo baseInfo, int exponent)
    {
        if (exponent <= 1 && exponent >= 0)
        {
            baseInfo.Value = (exponent == 0 ? 1.0 : baseInfo.Value);
            return baseInfo;
        }

        UnitInfo outInfo = new UnitInfo(baseInfo);

        for (int i = 1; i < Math.Abs(exponent); i++)
        {
            outInfo = PerformManagedOperationValues
            (
                outInfo, baseInfo, Operations.Multiplication
            );
            if (outInfo.Error.Type != ErrorTypes.None) return outInfo;
        }

        return
        (
            exponent < 0 ?
            PerformManagedOperationValues(new UnitInfo(1.0), outInfo, Operations.Division) :
            outInfo
        );
    }

    static UnitInfo PerformManagedOperationNormalisedValues(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        outInfo =
        (
            normalisedInfos.Length == 1 ?
            //There is just one operand when the difference between both of them is too big.
            outInfo = normalisedInfos[0] :
            PerformManagedOperationTwoOperands(outInfo, normalisedInfos, operation)
        );

        return outInfo;
    }

    static UnitInfo PerformManagedOperationTwoOperands(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        UnitInfo outInfoNormalised = PerformManagedOperationValues
        (
            normalisedInfos[0], normalisedInfos[1], operation
        );

        if (outInfo.Error.Type != ErrorTypes.None)
        {
            return new UnitInfo(outInfo)
            {
                Error = new ErrorInfo(ErrorTypes.NumericError)
            };
        }

        outInfo.BaseTenExponent = outInfoNormalised.BaseTenExponent;
        outInfo.Value = outInfoNormalised.Value;
        //Normalised means no prefixes.
        outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage); 

        return outInfo;
    }

    static UnitInfo PerformManagedOperationValues(double firstValue, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            new UnitInfo(firstValue), new UnitInfo(secondValue), operation
        );
    }

    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            firstInfo, new UnitInfo(secondValue), operation
        );
    }

    //This method might be used to perform full operations (not just being the last calculation step) instead
    //of the default one (PerformManagedOperationUnits) for simple cases. That is: ones not dealing with the
    //complex numeric reality (Value, Prefix and BaseTenExponent) which makes a pre-analysis required.
    //Note that, unlikely what happens with PerformMangedOperationUnits, the outputs of this method aren't
    //normalised (= primarily stored under Value), what is useful in certain contexts.
    //NOTE: this function assumes that both inputs are normalised, what means that no prefix information is expected.
    //It might also be used with non-normalised inputs, but their prefix information would be plainly ignored.
    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        if (firstInfo.Value == 0.0 || secondInfo.Value == 0.0)
        {
            if (operation == Operations.Multiplication || operation == Operations.Division)
            {
                //Dividing by zero scenarios are taken into account somewhere else.
                return new UnitInfo(firstInfo) { Value = 0.0 };
            }
        }

        UnitInfo outInfo = new UnitInfo(firstInfo);
        UnitInfo firstInfo0 = new UnitInfo(firstInfo);
        UnitInfo secondInfo0 = new UnitInfo(secondInfo);

        boolean isWrong = false;
        try
        {
            if (operation == Operations.Addition)
            {
                outInfo.Value += secondInfo0.Value;
            }
            else if (operation == Operations.Subtraction)
            {
                outInfo.Value -= secondInfo.Value;
            }
            else
            {
                //The reason for checking whether BaseTenExponent is inside/outside the int range before performing 
                //the operation (rather than going ahead and eventually catching the resulting exception) isn't just
                //being quicker, but also the only option in many situations. Note that an addition/subtraction between
                //two int variables whose result is outside the int range might not trigger an exception (+ random 
                //negative value as output).
                if (VaryBaseTenExponent(outInfo, secondInfo0.BaseTenExponent, operation == Operations.Division).Error.Type != ErrorTypes.None)
                {
                    return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
                }

                if (operation == Operations.Multiplication)
                {
                    outInfo.Value *= secondInfo.Value;
                    outInfo.BaseTenExponent += secondInfo.BaseTenExponent;
                }
                else if (operation == Operations.Division)
                {
                    if (secondInfo.Value == 0.0)
                    {
                        return
                        (
                            new UnitInfo(outInfo) 
                            { 
                                Error = new ErrorInfo(ErrorTypes.NumericError) 
                            }
                        );
                    }
                    outInfo.Value /= secondInfo.Value;
                    outInfo.BaseTenExponent -= secondInfo.BaseTenExponent;
                }
            }
        }
        catch { isWrong = true; }

        return
        (
            //An error might not be triggered despite of dealing with numbers outside double precision.
            //For example: 0.00000000000000000001m * 0.0000000000000000000001m can output 0.0 without triggering an error. 
            isWrong || ((operation == Operations.Multiplication || operation == Operations.Division) && outInfo.Value == 0.0.0) ?
            OperationValuesManageError(firstInfo0, secondInfo0, operation) : outInfo
        );
    }

    static UnitInfo OperationValuesManageError(UnitInfo outInfo, UnitInfo secondInfo, Operations operation)
    {
        if (operation != Operations.Multiplication && operation != Operations.Division)
        {
            //This condition should never be true on account of the fact that the pre-modifications performed before
            //adding/subtracting should avoid erroneous situations.
            return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
        }

        UnitInfo secondInfo2 = ConvertValueToBaseTen(secondInfo.Value);
        outInfo = VaryBaseTenExponent(outInfo, secondInfo2.BaseTenExponent, operation == Operations.Division);
        if (Math.Abs(secondInfo2.Value) == 1.0 || outInfo.Error.Type != ErrorTypes.None) return outInfo;
        
        try
        {
            outInfo = PerformManagedOperationUnits
            (
                outInfo, secondInfo2.Value, operation
            );
        }
        catch
        {
            //Very unlikely scenario on account of the fact that Math.Abs(secondInfo2.Value)
            //lies within the 0.1-10.0 range.
            outInfo = OperationValuesManageError
            (
                new UnitInfo(outInfo)
                {
                    Value = secondInfo2.Value,
                    BaseTenExponent = 0
                },
                new UnitInfo()
                {
                    Value = outInfo.Value,
                    BaseTenExponent = outInfo.BaseTenExponent
                },
                operation
            );
        }

        return outInfo;
    }

    static UnitInfo ConvertValueToBaseTen(double value)
    {
        value = Math.Abs(value);
        return FromValueToBaseTenExponent
        (
             new UnitInfo(value), Math.Abs(value), false
        );
    }

    static UnitInfo ConvertBaseTenToValue(UnitInfo unitInfo)
    {
        if (unitInfo.BaseTenExponent == 0) return unitInfo;

        UnitInfo outInfo = new UnitInfo(unitInfo);
        boolean decrease = unitInfo.BaseTenExponent > 0;
        int sign = Math.Sign(outInfo.Value);
        double absValue = Math.Abs(outInfo.Value);

        while (outInfo.BaseTenExponent != 0.0)
        {
            if (decrease)
            {
                if (absValue >= MaxValueDec / 10.0) break;
                absValue *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }
            else
            {
                if (absValue <= MinValueDec * 10.0) break;
                absValue /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
        }

        outInfo.Value = sign * absValue;

        return outInfo;
    }

    static UnitInfo NormaliseUnitInfo(UnitInfo unitInfo)
    {
        if (unitInfo.Value == 0 && unitInfo.Prefix.Factor == 1.0)
        {
            return unitInfo;
        }
        UnitInfo outInfo = new UnitInfo(unitInfo);

        if (outInfo.Prefix.Factor != 1)
        {
            outInfo = FromValueToBaseTenExponent
            (
                outInfo, outInfo.Prefix.Factor, true
            );
            outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage);
        }
        if (outInfo.Value == 0.0) return outInfo;

        outInfo = FromValueToBaseTenExponent
        (
            outInfo, outInfo.Value, false
        );

        return outInfo;
    }

    static UnitInfo FromValueToBaseTenExponent(UnitInfo outInfo, double value, boolean isPrefix)
    {
        if (value == 0.0) return outInfo;

        double valueAbs = Math.Abs(value);
        boolean decrease = (valueAbs > 1.0);
        if (!isPrefix)
        {
            outInfo.Value = outInfo.Value / valueAbs;
        }

        while (valueAbs != 1.0)
        {
            if ((valueAbs < 10.0 && valueAbs > 1.0) || (valueAbs > 0.1.0 && valueAbs < 1.0))
            {
                if (!isPrefix) outInfo.Value = value;
                else
                {
                    outInfo = PerformManagedOperationValues
                    (
                        outInfo, value, Operations.Multiplication
                    );
                }

                return outInfo;
            }

            if (decrease)
            {
                value /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
            else
            {
                value *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }

            valueAbs = Math.Abs(value);
        }

        return outInfo;
    }

    //Method used to vary BaseTenExponent without provoking unhandled exceptions (i.e., bigger than Integer.MAX_VALUE).
    static UnitInfo VaryBaseTenExponent(UnitInfo info, int baseTenIncrease, boolean isDivision = false)
    {
        long val1 = info.BaseTenExponent;
        long val2 = baseTenIncrease;

        if (isDivision)
        {
            //Converting a negative value into positive might provoke an overflow error for the int type
            //(e.g., Math.Abs(Integer.MAIN_VALUE)). Converting both variables to long is a quick and effective
            //way to avoid this problem.
            val2 *= -1;
        }

        return
        (
             ((val2 > 0 && val1 > Integer.MAX_VALUE - val2) || (val2 < 0 && val1 < Integer.MAIN_VALUE - val2)) ?
            new UnitInfo(info, ErrorTypes.NumericError) : new UnitInfo(info){{ BaseTenExponent = (int)(val1 + val2); }}
        );
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData(ClipboardOperationAction.java:430)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImportsOperation(ClipboardOperationAction.java:357)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperation(ClipboardOperationAction.java:317)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction$1.run(ClipboardOperationAction.java:265)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:70)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run(ClipboardOperationAction.java:262)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:473)
	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:118)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:90)
	at sun.reflect.GeneratedMethodAccessor44.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:55)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:282)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:264)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:132)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:152)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:494)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:488)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:210)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:286)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:507)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:558)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:378)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.access$0(KeyBindingDispatcher.java:324)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:86)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1270)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1078)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1103)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1088)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1130)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1126)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1547)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4918)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:364)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4799)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:359)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5110)
	at org.eclipse.swt.internal.win32.OS.DispatchMessageW(Native Method)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(OS.java:2552)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3822)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:1121)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1022)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:150)
	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:693)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:610)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:148)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:138)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:388)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:243)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:673)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:610)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1519)

!ENTRY org.eclipse.jdt.ui 4 2 2017-05-27 20:05:39.864
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData(ClipboardOperationAction.java:430)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImportsOperation(ClipboardOperationAction.java:357)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperation(ClipboardOperationAction.java:317)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction$1.run(ClipboardOperationAction.java:265)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:70)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run(ClipboardOperationAction.java:262)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:473)
	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:118)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:90)
	at sun.reflect.GeneratedMethodAccessor44.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:55)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:282)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:264)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:132)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:152)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:494)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:488)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:210)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:286)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:507)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:558)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:378)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.access$0(KeyBindingDispatcher.java:324)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:86)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1270)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1078)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1103)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1088)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1130)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1126)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1547)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4918)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:364)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4799)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:359)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5110)
	at org.eclipse.swt.internal.win32.OS.DispatchMessageW(Native Method)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(OS.java:2552)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3822)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:1121)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1022)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:150)
	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:693)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:610)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:148)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:138)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:388)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:243)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:673)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:610)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1519)

!ENTRY org.eclipse.jdt.ui 4 0 2017-05-27 20:05:39.865
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData(ClipboardOperationAction.java:430)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImportsOperation(ClipboardOperationAction.java:357)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperation(ClipboardOperationAction.java:317)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction$1.run(ClipboardOperationAction.java:265)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:70)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run(ClipboardOperationAction.java:262)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:473)
	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:118)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:90)
	at sun.reflect.GeneratedMethodAccessor44.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:55)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:282)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:264)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:132)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:152)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:494)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:488)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:210)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:286)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:507)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:558)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:378)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.access$0(KeyBindingDispatcher.java:324)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:86)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1270)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1078)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1103)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1088)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1130)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1126)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1547)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4918)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:364)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4799)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:359)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5110)
	at org.eclipse.swt.internal.win32.OS.DispatchMessageW(Native Method)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(OS.java:2552)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3822)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:1121)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1022)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:150)
	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:693)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:610)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:148)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:138)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:388)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:243)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:673)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:610)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1519)

!ENTRY org.eclipse.jdt.core 4 4 2017-05-27 20:05:41.893
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
public class OperationsManaged
{
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, double second, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            firstInfo, new UnitInfo(second), operation
        );
    }

    public static UnitInfo PerformManagedOperationUnits(double first, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            new UnitInfo(first), secondInfo, operation
        );
    }

    //This method should always be used when dealing with random UnitInfo variables because it accounts for all the
    //possible scenarios. On the other hand, with simple operations (e.g., random UnitInfo & numeric type) it might
    //be better to use PerformManagedOperationValues. 
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        ErrorTypes errorType = InternalMethods.GetOperationError
        (
            firstInfo, secondInfo, operation
        );
        if (errorType != ErrorTypes.None)
        {
            return new UnitInfo(firstInfo) 
            {{
                Error = new ErrorInfo(errorType); 
            }};
        }

        return
        (
            operation == Operations.Addition || operation == Operations.Subtraction ?
            PerformManagedOperationAddition(firstInfo, secondInfo, operation) :
            PerformManagedOperationMultiplication(firstInfo, secondInfo, operation)
        );
    }

    static UnitInfo PerformManagedOperationAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {   
        //After being normalised, the operands might require further modifications.
        UnitInfo[] normalised = GetOperandsAddition(firstInfo, secondInfo, operation);

        return PerformManagedOperationNormalisedValues
        (
            firstInfo, normalised, operation
        );
    }

    static UnitInfo[] GetOperandsAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        UnitInfo[] operands2 = new UnitInfo[] 
        {
            new UnitInfo(firstInfo), new UnitInfo(secondInfo)
        };

        if (operands2[0].BaseTenExponent != operands2[1].BaseTenExponent || operands2[0].Prefix.Factor != operands2[1].Prefix.Factor)
        {
            //The addition/subtraction might not be performed right away even with normalised values.
            //For example: 5 and 6 from 5*10^2 and 6*10^7 cannot be added right away.
            operands2 = AdaptNormalisedValuesForAddition
            (
                new UnitInfo[] 
                { 
                    NormaliseUnitInfo(operands2[0]), 
                    NormaliseUnitInfo(operands2[1])
                },
                operation
            );
        }

        return operands2;
    }
    
    static UnitInfo[] AdaptNormalisedValuesForAddition(UnitInfo[] unitInfos2, Operations operation)
    {
        if (unitInfos2[0].BaseTenExponent == unitInfos2[1].BaseTenExponent)
        {
            //Having the same BaseTenExponent values means that the given operation can be performed right away.
            return unitInfos2;
        }

        int[] bigSmallI = 
        (
            unitInfos2[0].BaseTenExponent > unitInfos2[1].BaseTenExponent ?
            new int[] { 0, 1 } : new int[] { 1, 0 }
        );

        //Only the variable with the bigger value is modified. For example: 5*10^5 & 3*10^3 is converted
        //into 500*10^3 & 3*10^3 in order to allow the addition 500 + 3. 
        UnitInfo big2 = AdaptBiggerAdditionOperand(unitInfos2, bigSmallI, operation);
        if (big2.Error.Type != ErrorTypes.None)
        {
            return TooBigGapAddition(unitInfos2, bigSmallI, operation);
        }

        unitInfos2[bigSmallI[0]].Value = big2.Value;
        unitInfos2[bigSmallI[0]].BaseTenExponent = unitInfos2[bigSmallI[1]].BaseTenExponent;

        return unitInfos2;
    }

    //When adding/subtracting two numbers whose gap is bigger than the maximum double range, there
    //is no need to perform any operation (i.e., no change will be observed because of being outside
    //the maximum supported precision). This method takes care of these cases and returns the expected
    //output (i.e., biggest value).
    static UnitInfo[] TooBigGapAddition(UnitInfo[] unitInfos2, int[] bigSmallI, Operations operation)
    {
        UnitInfo[] outInfos = new UnitInfo[] 
        {
            //First operand (i.e., one whose information defines the operation) together with the
            //numeric information (i.e., just Value and BaseTenExponent because both are normalised)
            //which is associated with the biggest one.
            new UnitInfo(unitInfos2[0])
            {{
                Value = unitInfos2[bigSmallI[0]].Value;
                BaseTenExponent = unitInfos2[bigSmallI[0]].BaseTenExponent;
            }}
        };

        if (operation == Operations.Subtraction && bigSmallI[0] == 1)
        {
            outInfos[0].Value = -1.0 * outInfos[0].Value;
        }

        if (outInfos[0].Unit == Units.Unitless)
        {
            outInfos[0].Unit = unitInfos2[bigSmallI[1]].Unit;
        }

        return outInfos;
    }

    static UnitInfo AdaptBiggerAdditionOperand(UnitInfo[] unitInfos2, Integer[] bigSmallI, Operations operation)
    {
        int gapExponent = unitInfos2[bigSmallI[0]].BaseTenExponent - unitInfos2[bigSmallI[1]].BaseTenExponent;
        if (gapExponent >= 27)
        {
            //The difference between both inputs is bigger than (or, at least, very close to) the maximum double value/precision;
            //what makes this situation calculation unworthy and the first operand to be returned as the result.
            //Note that the error below these lines is just an easy way to tell the calling function about this eventuality.
            return new UnitInfo(unitInfos2[0]) 
            {{ 
                Error = new ErrorInfo(ErrorTypes.InvalidOperation); 
            }};
        }

        //PerformManagedOperationValues is used to make sure that the resulting numeric information is stored
        //in Value (if possible).
        UnitInfo big2 = PerformManagedOperationValues
        (
            RaiseToIntegerExponent(10.0, gapExponent), unitInfos2[bigSmallI[0]].Value, 
            Operations.Multiplication                
        );

        boolean isWrong = 
        (
            big2.Error.Type != ErrorTypes.None || big2.BaseTenExponent != 0 ?
            
            //The value of the bigger input times 10^(gap between BaseTenExponent of inputs) is too big. 
            isWrong = true :
            
            //Overflow-check very unlikely to trigger an error. In fact, with properly normalised variables,
            //triggering an error would be plainly impossible.               
            AreAdditionFinalValuesWrong
            (
                unitInfos2[0].Value, unitInfos2[1].Value, operation
            )
        );

        UnitInfo temp = null;
        if (isWrong)
        {
        	temp = new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }};
            
            temp.Error = new ErrorInfo(ErrorTypes.InvalidOperation);
        }
        
        
        return temp;
        
        
        return
        (
            isWrong ?
            //This error is just an easy way to let the calling function know about the fact that no
            //calculation has been performed (too big gap). This isn't a properly-speaking error and
            //that's why it will not be notified to the user.
            new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }} :
            //Returning the new big value. For example: with 5*10^4 & 3*10^2, 500 would be returned.
            new UnitInfo(unitInfos2[bigSmallI[0]])
            {{
                Value = big2.Value;
            }}
        )
    }

    static boolean AreAdditionFinalValuesWrong(double val1, double val2, Operations operation)
    {
        boolean isWrong = false;

        try
        {
            val1 = val1 + val2 *
            (
                operation == Operations.Addition ? 1 : -1
            );
        }
        catch { isWrong = true; }

        return isWrong;
    }

    static UnitInfo PerformManagedOperationMultiplication(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationNormalisedValues
        (
            firstInfo, new UnitInfo[] 
            { 
                NormaliseUnitInfo(firstInfo),
                NormaliseUnitInfo(secondInfo) 
            },
            operation
        );
    }

    public static UnitInfo RaiseToIntegerExponent(double baseValue, int exponent)
    {
        return RaiseToIntegerExponent(new UnitInfo(baseValue), exponent);
    }

    static UnitInfo RaiseToIntegerExponent(UnitInfo baseInfo, int exponent)
    {
        if (exponent <= 1 && exponent >= 0)
        {
            baseInfo.Value = (exponent == 0 ? 1.0 : baseInfo.Value);
            return baseInfo;
        }

        UnitInfo outInfo = new UnitInfo(baseInfo);

        for (int i = 1; i < Math.Abs(exponent); i++)
        {
            outInfo = PerformManagedOperationValues
            (
                outInfo, baseInfo, Operations.Multiplication
            );
            if (outInfo.Error.Type != ErrorTypes.None) return outInfo;
        }

        return
        (
            exponent < 0 ?
            PerformManagedOperationValues(new UnitInfo(1.0), outInfo, Operations.Division) :
            outInfo
        );
    }

    static UnitInfo PerformManagedOperationNormalisedValues(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        outInfo =
        (
            normalisedInfos.Length == 1 ?
            //There is just one operand when the difference between both of them is too big.
            outInfo = normalisedInfos[0] :
            PerformManagedOperationTwoOperands(outInfo, normalisedInfos, operation)
        );

        return outInfo;
    }

    static UnitInfo PerformManagedOperationTwoOperands(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        UnitInfo outInfoNormalised = PerformManagedOperationValues
        (
            normalisedInfos[0], normalisedInfos[1], operation
        );

        if (outInfo.Error.Type != ErrorTypes.None)
        {
            return new UnitInfo(outInfo)
            {
                Error = new ErrorInfo(ErrorTypes.NumericError)
            };
        }

        outInfo.BaseTenExponent = outInfoNormalised.BaseTenExponent;
        outInfo.Value = outInfoNormalised.Value;
        //Normalised means no prefixes.
        outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage); 

        return outInfo;
    }

    static UnitInfo PerformManagedOperationValues(double firstValue, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            new UnitInfo(firstValue), new UnitInfo(secondValue), operation
        );
    }

    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            firstInfo, new UnitInfo(secondValue), operation
        );
    }

    //This method might be used to perform full operations (not just being the last calculation step) instead
    //of the default one (PerformManagedOperationUnits) for simple cases. That is: ones not dealing with the
    //complex numeric reality (Value, Prefix and BaseTenExponent) which makes a pre-analysis required.
    //Note that, unlikely what happens with PerformMangedOperationUnits, the outputs of this method aren't
    //normalised (= primarily stored under Value), what is useful in certain contexts.
    //NOTE: this function assumes that both inputs are normalised, what means that no prefix information is expected.
    //It might also be used with non-normalised inputs, but their prefix information would be plainly ignored.
    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        if (firstInfo.Value == 0.0 || secondInfo.Value == 0.0)
        {
            if (operation == Operations.Multiplication || operation == Operations.Division)
            {
                //Dividing by zero scenarios are taken into account somewhere else.
                return new UnitInfo(firstInfo) { Value = 0.0 };
            }
        }

        UnitInfo outInfo = new UnitInfo(firstInfo);
        UnitInfo firstInfo0 = new UnitInfo(firstInfo);
        UnitInfo secondInfo0 = new UnitInfo(secondInfo);

        boolean isWrong = false;
        try
        {
            if (operation == Operations.Addition)
            {
                outInfo.Value += secondInfo0.Value;
            }
            else if (operation == Operations.Subtraction)
            {
                outInfo.Value -= secondInfo.Value;
            }
            else
            {
                //The reason for checking whether BaseTenExponent is inside/outside the int range before performing 
                //the operation (rather than going ahead and eventually catching the resulting exception) isn't just
                //being quicker, but also the only option in many situations. Note that an addition/subtraction between
                //two int variables whose result is outside the int range might not trigger an exception (+ random 
                //negative value as output).
                if (VaryBaseTenExponent(outInfo, secondInfo0.BaseTenExponent, operation == Operations.Division).Error.Type != ErrorTypes.None)
                {
                    return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
                }

                if (operation == Operations.Multiplication)
                {
                    outInfo.Value *= secondInfo.Value;
                    outInfo.BaseTenExponent += secondInfo.BaseTenExponent;
                }
                else if (operation == Operations.Division)
                {
                    if (secondInfo.Value == 0.0)
                    {
                        return
                        (
                            new UnitInfo(outInfo) 
                            { 
                                Error = new ErrorInfo(ErrorTypes.NumericError) 
                            }
                        );
                    }
                    outInfo.Value /= secondInfo.Value;
                    outInfo.BaseTenExponent -= secondInfo.BaseTenExponent;
                }
            }
        }
        catch { isWrong = true; }

        return
        (
            //An error might not be triggered despite of dealing with numbers outside double precision.
            //For example: 0.00000000000000000001m * 0.0000000000000000000001m can output 0.0 without triggering an error. 
            isWrong || ((operation == Operations.Multiplication || operation == Operations.Division) && outInfo.Value == 0.0.0) ?
            OperationValuesManageError(firstInfo0, secondInfo0, operation) : outInfo
        );
    }

    static UnitInfo OperationValuesManageError(UnitInfo outInfo, UnitInfo secondInfo, Operations operation)
    {
        if (operation != Operations.Multiplication && operation != Operations.Division)
        {
            //This condition should never be true on account of the fact that the pre-modifications performed before
            //adding/subtracting should avoid erroneous situations.
            return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
        }

        UnitInfo secondInfo2 = ConvertValueToBaseTen(secondInfo.Value);
        outInfo = VaryBaseTenExponent(outInfo, secondInfo2.BaseTenExponent, operation == Operations.Division);
        if (Math.Abs(secondInfo2.Value) == 1.0 || outInfo.Error.Type != ErrorTypes.None) return outInfo;
        
        try
        {
            outInfo = PerformManagedOperationUnits
            (
                outInfo, secondInfo2.Value, operation
            );
        }
        catch
        {
            //Very unlikely scenario on account of the fact that Math.Abs(secondInfo2.Value)
            //lies within the 0.1-10.0 range.
            outInfo = OperationValuesManageError
            (
                new UnitInfo(outInfo)
                {
                    Value = secondInfo2.Value,
                    BaseTenExponent = 0
                },
                new UnitInfo()
                {
                    Value = outInfo.Value,
                    BaseTenExponent = outInfo.BaseTenExponent
                },
                operation
            );
        }

        return outInfo;
    }

    static UnitInfo ConvertValueToBaseTen(double value)
    {
        value = Math.Abs(value);
        return FromValueToBaseTenExponent
        (
             new UnitInfo(value), Math.Abs(value), false
        );
    }

    static UnitInfo ConvertBaseTenToValue(UnitInfo unitInfo)
    {
        if (unitInfo.BaseTenExponent == 0) return unitInfo;

        UnitInfo outInfo = new UnitInfo(unitInfo);
        boolean decrease = unitInfo.BaseTenExponent > 0;
        int sign = Math.Sign(outInfo.Value);
        double absValue = Math.Abs(outInfo.Value);

        while (outInfo.BaseTenExponent != 0.0)
        {
            if (decrease)
            {
                if (absValue >= MaxValueDec / 10.0) break;
                absValue *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }
            else
            {
                if (absValue <= MinValueDec * 10.0) break;
                absValue /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
        }

        outInfo.Value = sign * absValue;

        return outInfo;
    }

    static UnitInfo NormaliseUnitInfo(UnitInfo unitInfo)
    {
        if (unitInfo.Value == 0 && unitInfo.Prefix.Factor == 1.0)
        {
            return unitInfo;
        }
        UnitInfo outInfo = new UnitInfo(unitInfo);

        if (outInfo.Prefix.Factor != 1)
        {
            outInfo = FromValueToBaseTenExponent
            (
                outInfo, outInfo.Prefix.Factor, true
            );
            outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage);
        }
        if (outInfo.Value == 0.0) return outInfo;

        outInfo = FromValueToBaseTenExponent
        (
            outInfo, outInfo.Value, false
        );

        return outInfo;
    }

    static UnitInfo FromValueToBaseTenExponent(UnitInfo outInfo, double value, boolean isPrefix)
    {
        if (value == 0.0) return outInfo;

        double valueAbs = Math.Abs(value);
        boolean decrease = (valueAbs > 1.0);
        if (!isPrefix)
        {
            outInfo.Value = outInfo.Value / valueAbs;
        }

        while (valueAbs != 1.0)
        {
            if ((valueAbs < 10.0 && valueAbs > 1.0) || (valueAbs > 0.1.0 && valueAbs < 1.0))
            {
                if (!isPrefix) outInfo.Value = value;
                else
                {
                    outInfo = PerformManagedOperationValues
                    (
                        outInfo, value, Operations.Multiplication
                    );
                }

                return outInfo;
            }

            if (decrease)
            {
                value /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
            else
            {
                value *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }

            valueAbs = Math.Abs(value);
        }

        return outInfo;
    }

    //Method used to vary BaseTenExponent without provoking unhandled exceptions (i.e., bigger than Integer.MAX_VALUE).
    static UnitInfo VaryBaseTenExponent(UnitInfo info, int baseTenIncrease, boolean isDivision = false)
    {
        long val1 = info.BaseTenExponent;
        long val2 = baseTenIncrease;

        if (isDivision)
        {
            //Converting a negative value into positive might provoke an overflow error for the int type
            //(e.g., Math.Abs(Integer.MAIN_VALUE)). Converting both variables to long is a quick and effective
            //way to avoid this problem.
            val2 *= -1;
        }

        return
        (
             ((val2 > 0 && val1 > Integer.MAX_VALUE - val2) || (val2 < 0 && val1 < Integer.MAIN_VALUE - val2)) ?
            new UnitInfo(info, ErrorTypes.NumericError) : new UnitInfo(info){{ BaseTenExponent = (int)(val1 + val2); }}
        );
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 2 2017-05-27 20:05:41.894
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 0 2017-05-27 20:05:41.894
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.core 4 4 2017-05-27 20:05:43.728
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
public class OperationsManaged
{
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, double second, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            firstInfo, new UnitInfo(second), operation
        );
    }

    public static UnitInfo PerformManagedOperationUnits(double first, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            new UnitInfo(first), secondInfo, operation
        );
    }

    //This method should always be used when dealing with random UnitInfo variables because it accounts for all the
    //possible scenarios. On the other hand, with simple operations (e.g., random UnitInfo & numeric type) it might
    //be better to use PerformManagedOperationValues. 
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        ErrorTypes errorType = InternalMethods.GetOperationError
        (
            firstInfo, secondInfo, operation
        );
        if (errorType != ErrorTypes.None)
        {
            return new UnitInfo(firstInfo) 
            {{
                Error = new ErrorInfo(errorType); 
            }};
        }

        return
        (
            operation == Operations.Addition || operation == Operations.Subtraction ?
            PerformManagedOperationAddition(firstInfo, secondInfo, operation) :
            PerformManagedOperationMultiplication(firstInfo, secondInfo, operation)
        );
    }

    static UnitInfo PerformManagedOperationAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {   
        //After being normalised, the operands might require further modifications.
        UnitInfo[] normalised = GetOperandsAddition(firstInfo, secondInfo, operation);

        return PerformManagedOperationNormalisedValues
        (
            firstInfo, normalised, operation
        );
    }

    static UnitInfo[] GetOperandsAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        UnitInfo[] operands2 = new UnitInfo[] 
        {
            new UnitInfo(firstInfo), new UnitInfo(secondInfo)
        };

        if (operands2[0].BaseTenExponent != operands2[1].BaseTenExponent || operands2[0].Prefix.Factor != operands2[1].Prefix.Factor)
        {
            //The addition/subtraction might not be performed right away even with normalised values.
            //For example: 5 and 6 from 5*10^2 and 6*10^7 cannot be added right away.
            operands2 = AdaptNormalisedValuesForAddition
            (
                new UnitInfo[] 
                { 
                    NormaliseUnitInfo(operands2[0]), 
                    NormaliseUnitInfo(operands2[1])
                },
                operation
            );
        }

        return operands2;
    }
    
    static UnitInfo[] AdaptNormalisedValuesForAddition(UnitInfo[] unitInfos2, Operations operation)
    {
        if (unitInfos2[0].BaseTenExponent == unitInfos2[1].BaseTenExponent)
        {
            //Having the same BaseTenExponent values means that the given operation can be performed right away.
            return unitInfos2;
        }

        int[] bigSmallI = 
        (
            unitInfos2[0].BaseTenExponent > unitInfos2[1].BaseTenExponent ?
            new int[] { 0, 1 } : new int[] { 1, 0 }
        );

        //Only the variable with the bigger value is modified. For example: 5*10^5 & 3*10^3 is converted
        //into 500*10^3 & 3*10^3 in order to allow the addition 500 + 3. 
        UnitInfo big2 = AdaptBiggerAdditionOperand(unitInfos2, bigSmallI, operation);
        if (big2.Error.Type != ErrorTypes.None)
        {
            return TooBigGapAddition(unitInfos2, bigSmallI, operation);
        }

        unitInfos2[bigSmallI[0]].Value = big2.Value;
        unitInfos2[bigSmallI[0]].BaseTenExponent = unitInfos2[bigSmallI[1]].BaseTenExponent;

        return unitInfos2;
    }

    //When adding/subtracting two numbers whose gap is bigger than the maximum double range, there
    //is no need to perform any operation (i.e., no change will be observed because of being outside
    //the maximum supported precision). This method takes care of these cases and returns the expected
    //output (i.e., biggest value).
    static UnitInfo[] TooBigGapAddition(UnitInfo[] unitInfos2, int[] bigSmallI, Operations operation)
    {
        UnitInfo[] outInfos = new UnitInfo[] 
        {
            //First operand (i.e., one whose information defines the operation) together with the
            //numeric information (i.e., just Value and BaseTenExponent because both are normalised)
            //which is associated with the biggest one.
            new UnitInfo(unitInfos2[0])
            {{
                Value = unitInfos2[bigSmallI[0]].Value;
                BaseTenExponent = unitInfos2[bigSmallI[0]].BaseTenExponent;
            }}
        };

        if (operation == Operations.Subtraction && bigSmallI[0] == 1)
        {
            outInfos[0].Value = -1.0 * outInfos[0].Value;
        }

        if (outInfos[0].Unit == Units.Unitless)
        {
            outInfos[0].Unit = unitInfos2[bigSmallI[1]].Unit;
        }

        return outInfos;
    }

    static UnitInfo AdaptBiggerAdditionOperand(UnitInfo[] unitInfos2, Integer[] bigSmallI, Operations operation)
    {
        int gapExponent = unitInfos2[bigSmallI[0]].BaseTenExponent - unitInfos2[bigSmallI[1]].BaseTenExponent;
        if (gapExponent >= 27)
        {
            //The difference between both inputs is bigger than (or, at least, very close to) the maximum double value/precision;
            //what makes this situation calculation unworthy and the first operand to be returned as the result.
            //Note that the error below these lines is just an easy way to tell the calling function about this eventuality.
            return new UnitInfo(unitInfos2[0]) 
            {{ 
                Error = new ErrorInfo(ErrorTypes.InvalidOperation); 
            }};
        }

        //PerformManagedOperationValues is used to make sure that the resulting numeric information is stored
        //in Value (if possible).
        UnitInfo big2 = PerformManagedOperationValues
        (
            RaiseToIntegerExponent(10.0, gapExponent), unitInfos2[bigSmallI[0]].Value, 
            Operations.Multiplication                
        );

        boolean isWrong = 
        (
            big2.Error.Type != ErrorTypes.None || big2.BaseTenExponent != 0 ?
            
            //The value of the bigger input times 10^(gap between BaseTenExponent of inputs) is too big. 
            isWrong = true :
            
            //Overflow-check very unlikely to trigger an error. In fact, with properly normalised variables,
            //triggering an error would be plainly impossible.               
            AreAdditionFinalValuesWrong
            (
                unitInfos2[0].Value, unitInfos2[1].Value, operation
            )
        );

        UnitInfo temp = null;
        if (isWrong)
        {
        	temp = new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }};
            
            temp.Error = new ErrorInfo(ErrorTypes.InvalidOperation);
        }
        else
        	
        
        
        return temp;
        
        
        return
        (
            isWrong ?
            //This error is just an easy way to let the calling function know about the fact that no
            //calculation has been performed (too big gap). This isn't a properly-speaking error and
            //that's why it will not be notified to the user.
            new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }} :
            //Returning the new big value. For example: with 5*10^4 & 3*10^2, 500 would be returned.
            new UnitInfo(unitInfos2[bigSmallI[0]])
            {{
                Value = big2.Value;
            }}
        )
    }

    static boolean AreAdditionFinalValuesWrong(double val1, double val2, Operations operation)
    {
        boolean isWrong = false;

        try
        {
            val1 = val1 + val2 *
            (
                operation == Operations.Addition ? 1 : -1
            );
        }
        catch { isWrong = true; }

        return isWrong;
    }

    static UnitInfo PerformManagedOperationMultiplication(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationNormalisedValues
        (
            firstInfo, new UnitInfo[] 
            { 
                NormaliseUnitInfo(firstInfo),
                NormaliseUnitInfo(secondInfo) 
            },
            operation
        );
    }

    public static UnitInfo RaiseToIntegerExponent(double baseValue, int exponent)
    {
        return RaiseToIntegerExponent(new UnitInfo(baseValue), exponent);
    }

    static UnitInfo RaiseToIntegerExponent(UnitInfo baseInfo, int exponent)
    {
        if (exponent <= 1 && exponent >= 0)
        {
            baseInfo.Value = (exponent == 0 ? 1.0 : baseInfo.Value);
            return baseInfo;
        }

        UnitInfo outInfo = new UnitInfo(baseInfo);

        for (int i = 1; i < Math.Abs(exponent); i++)
        {
            outInfo = PerformManagedOperationValues
            (
                outInfo, baseInfo, Operations.Multiplication
            );
            if (outInfo.Error.Type != ErrorTypes.None) return outInfo;
        }

        return
        (
            exponent < 0 ?
            PerformManagedOperationValues(new UnitInfo(1.0), outInfo, Operations.Division) :
            outInfo
        );
    }

    static UnitInfo PerformManagedOperationNormalisedValues(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        outInfo =
        (
            normalisedInfos.Length == 1 ?
            //There is just one operand when the difference between both of them is too big.
            outInfo = normalisedInfos[0] :
            PerformManagedOperationTwoOperands(outInfo, normalisedInfos, operation)
        );

        return outInfo;
    }

    static UnitInfo PerformManagedOperationTwoOperands(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        UnitInfo outInfoNormalised = PerformManagedOperationValues
        (
            normalisedInfos[0], normalisedInfos[1], operation
        );

        if (outInfo.Error.Type != ErrorTypes.None)
        {
            return new UnitInfo(outInfo)
            {
                Error = new ErrorInfo(ErrorTypes.NumericError)
            };
        }

        outInfo.BaseTenExponent = outInfoNormalised.BaseTenExponent;
        outInfo.Value = outInfoNormalised.Value;
        //Normalised means no prefixes.
        outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage); 

        return outInfo;
    }

    static UnitInfo PerformManagedOperationValues(double firstValue, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            new UnitInfo(firstValue), new UnitInfo(secondValue), operation
        );
    }

    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            firstInfo, new UnitInfo(secondValue), operation
        );
    }

    //This method might be used to perform full operations (not just being the last calculation step) instead
    //of the default one (PerformManagedOperationUnits) for simple cases. That is: ones not dealing with the
    //complex numeric reality (Value, Prefix and BaseTenExponent) which makes a pre-analysis required.
    //Note that, unlikely what happens with PerformMangedOperationUnits, the outputs of this method aren't
    //normalised (= primarily stored under Value), what is useful in certain contexts.
    //NOTE: this function assumes that both inputs are normalised, what means that no prefix information is expected.
    //It might also be used with non-normalised inputs, but their prefix information would be plainly ignored.
    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        if (firstInfo.Value == 0.0 || secondInfo.Value == 0.0)
        {
            if (operation == Operations.Multiplication || operation == Operations.Division)
            {
                //Dividing by zero scenarios are taken into account somewhere else.
                return new UnitInfo(firstInfo) { Value = 0.0 };
            }
        }

        UnitInfo outInfo = new UnitInfo(firstInfo);
        UnitInfo firstInfo0 = new UnitInfo(firstInfo);
        UnitInfo secondInfo0 = new UnitInfo(secondInfo);

        boolean isWrong = false;
        try
        {
            if (operation == Operations.Addition)
            {
                outInfo.Value += secondInfo0.Value;
            }
            else if (operation == Operations.Subtraction)
            {
                outInfo.Value -= secondInfo.Value;
            }
            else
            {
                //The reason for checking whether BaseTenExponent is inside/outside the int range before performing 
                //the operation (rather than going ahead and eventually catching the resulting exception) isn't just
                //being quicker, but also the only option in many situations. Note that an addition/subtraction between
                //two int variables whose result is outside the int range might not trigger an exception (+ random 
                //negative value as output).
                if (VaryBaseTenExponent(outInfo, secondInfo0.BaseTenExponent, operation == Operations.Division).Error.Type != ErrorTypes.None)
                {
                    return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
                }

                if (operation == Operations.Multiplication)
                {
                    outInfo.Value *= secondInfo.Value;
                    outInfo.BaseTenExponent += secondInfo.BaseTenExponent;
                }
                else if (operation == Operations.Division)
                {
                    if (secondInfo.Value == 0.0)
                    {
                        return
                        (
                            new UnitInfo(outInfo) 
                            { 
                                Error = new ErrorInfo(ErrorTypes.NumericError) 
                            }
                        );
                    }
                    outInfo.Value /= secondInfo.Value;
                    outInfo.BaseTenExponent -= secondInfo.BaseTenExponent;
                }
            }
        }
        catch { isWrong = true; }

        return
        (
            //An error might not be triggered despite of dealing with numbers outside double precision.
            //For example: 0.00000000000000000001m * 0.0000000000000000000001m can output 0.0 without triggering an error. 
            isWrong || ((operation == Operations.Multiplication || operation == Operations.Division) && outInfo.Value == 0.0.0) ?
            OperationValuesManageError(firstInfo0, secondInfo0, operation) : outInfo
        );
    }

    static UnitInfo OperationValuesManageError(UnitInfo outInfo, UnitInfo secondInfo, Operations operation)
    {
        if (operation != Operations.Multiplication && operation != Operations.Division)
        {
            //This condition should never be true on account of the fact that the pre-modifications performed before
            //adding/subtracting should avoid erroneous situations.
            return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
        }

        UnitInfo secondInfo2 = ConvertValueToBaseTen(secondInfo.Value);
        outInfo = VaryBaseTenExponent(outInfo, secondInfo2.BaseTenExponent, operation == Operations.Division);
        if (Math.Abs(secondInfo2.Value) == 1.0 || outInfo.Error.Type != ErrorTypes.None) return outInfo;
        
        try
        {
            outInfo = PerformManagedOperationUnits
            (
                outInfo, secondInfo2.Value, operation
            );
        }
        catch
        {
            //Very unlikely scenario on account of the fact that Math.Abs(secondInfo2.Value)
            //lies within the 0.1-10.0 range.
            outInfo = OperationValuesManageError
            (
                new UnitInfo(outInfo)
                {
                    Value = secondInfo2.Value,
                    BaseTenExponent = 0
                },
                new UnitInfo()
                {
                    Value = outInfo.Value,
                    BaseTenExponent = outInfo.BaseTenExponent
                },
                operation
            );
        }

        return outInfo;
    }

    static UnitInfo ConvertValueToBaseTen(double value)
    {
        value = Math.Abs(value);
        return FromValueToBaseTenExponent
        (
             new UnitInfo(value), Math.Abs(value), false
        );
    }

    static UnitInfo ConvertBaseTenToValue(UnitInfo unitInfo)
    {
        if (unitInfo.BaseTenExponent == 0) return unitInfo;

        UnitInfo outInfo = new UnitInfo(unitInfo);
        boolean decrease = unitInfo.BaseTenExponent > 0;
        int sign = Math.Sign(outInfo.Value);
        double absValue = Math.Abs(outInfo.Value);

        while (outInfo.BaseTenExponent != 0.0)
        {
            if (decrease)
            {
                if (absValue >= MaxValueDec / 10.0) break;
                absValue *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }
            else
            {
                if (absValue <= MinValueDec * 10.0) break;
                absValue /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
        }

        outInfo.Value = sign * absValue;

        return outInfo;
    }

    static UnitInfo NormaliseUnitInfo(UnitInfo unitInfo)
    {
        if (unitInfo.Value == 0 && unitInfo.Prefix.Factor == 1.0)
        {
            return unitInfo;
        }
        UnitInfo outInfo = new UnitInfo(unitInfo);

        if (outInfo.Prefix.Factor != 1)
        {
            outInfo = FromValueToBaseTenExponent
            (
                outInfo, outInfo.Prefix.Factor, true
            );
            outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage);
        }
        if (outInfo.Value == 0.0) return outInfo;

        outInfo = FromValueToBaseTenExponent
        (
            outInfo, outInfo.Value, false
        );

        return outInfo;
    }

    static UnitInfo FromValueToBaseTenExponent(UnitInfo outInfo, double value, boolean isPrefix)
    {
        if (value == 0.0) return outInfo;

        double valueAbs = Math.Abs(value);
        boolean decrease = (valueAbs > 1.0);
        if (!isPrefix)
        {
            outInfo.Value = outInfo.Value / valueAbs;
        }

        while (valueAbs != 1.0)
        {
            if ((valueAbs < 10.0 && valueAbs > 1.0) || (valueAbs > 0.1.0 && valueAbs < 1.0))
            {
                if (!isPrefix) outInfo.Value = value;
                else
                {
                    outInfo = PerformManagedOperationValues
                    (
                        outInfo, value, Operations.Multiplication
                    );
                }

                return outInfo;
            }

            if (decrease)
            {
                value /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
            else
            {
                value *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }

            valueAbs = Math.Abs(value);
        }

        return outInfo;
    }

    //Method used to vary BaseTenExponent without provoking unhandled exceptions (i.e., bigger than Integer.MAX_VALUE).
    static UnitInfo VaryBaseTenExponent(UnitInfo info, int baseTenIncrease, boolean isDivision = false)
    {
        long val1 = info.BaseTenExponent;
        long val2 = baseTenIncrease;

        if (isDivision)
        {
            //Converting a negative value into positive might provoke an overflow error for the int type
            //(e.g., Math.Abs(Integer.MAIN_VALUE)). Converting both variables to long is a quick and effective
            //way to avoid this problem.
            val2 *= -1;
        }

        return
        (
             ((val2 > 0 && val1 > Integer.MAX_VALUE - val2) || (val2 < 0 && val1 < Integer.MAIN_VALUE - val2)) ?
            new UnitInfo(info, ErrorTypes.NumericError) : new UnitInfo(info){{ BaseTenExponent = (int)(val1 + val2); }}
        );
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2017-05-27 20:05:43.729
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2017-05-27 20:05:43.729
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2017-05-27 20:05:43.753
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
public class OperationsManaged
{
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, double second, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            firstInfo, new UnitInfo(second), operation
        );
    }

    public static UnitInfo PerformManagedOperationUnits(double first, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            new UnitInfo(first), secondInfo, operation
        );
    }

    //This method should always be used when dealing with random UnitInfo variables because it accounts for all the
    //possible scenarios. On the other hand, with simple operations (e.g., random UnitInfo & numeric type) it might
    //be better to use PerformManagedOperationValues. 
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        ErrorTypes errorType = InternalMethods.GetOperationError
        (
            firstInfo, secondInfo, operation
        );
        if (errorType != ErrorTypes.None)
        {
            return new UnitInfo(firstInfo) 
            {{
                Error = new ErrorInfo(errorType); 
            }};
        }

        return
        (
            operation == Operations.Addition || operation == Operations.Subtraction ?
            PerformManagedOperationAddition(firstInfo, secondInfo, operation) :
            PerformManagedOperationMultiplication(firstInfo, secondInfo, operation)
        );
    }

    static UnitInfo PerformManagedOperationAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {   
        //After being normalised, the operands might require further modifications.
        UnitInfo[] normalised = GetOperandsAddition(firstInfo, secondInfo, operation);

        return PerformManagedOperationNormalisedValues
        (
            firstInfo, normalised, operation
        );
    }

    static UnitInfo[] GetOperandsAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        UnitInfo[] operands2 = new UnitInfo[] 
        {
            new UnitInfo(firstInfo), new UnitInfo(secondInfo)
        };

        if (operands2[0].BaseTenExponent != operands2[1].BaseTenExponent || operands2[0].Prefix.Factor != operands2[1].Prefix.Factor)
        {
            //The addition/subtraction might not be performed right away even with normalised values.
            //For example: 5 and 6 from 5*10^2 and 6*10^7 cannot be added right away.
            operands2 = AdaptNormalisedValuesForAddition
            (
                new UnitInfo[] 
                { 
                    NormaliseUnitInfo(operands2[0]), 
                    NormaliseUnitInfo(operands2[1])
                },
                operation
            );
        }

        return operands2;
    }
    
    static UnitInfo[] AdaptNormalisedValuesForAddition(UnitInfo[] unitInfos2, Operations operation)
    {
        if (unitInfos2[0].BaseTenExponent == unitInfos2[1].BaseTenExponent)
        {
            //Having the same BaseTenExponent values means that the given operation can be performed right away.
            return unitInfos2;
        }

        int[] bigSmallI = 
        (
            unitInfos2[0].BaseTenExponent > unitInfos2[1].BaseTenExponent ?
            new int[] { 0, 1 } : new int[] { 1, 0 }
        );

        //Only the variable with the bigger value is modified. For example: 5*10^5 & 3*10^3 is converted
        //into 500*10^3 & 3*10^3 in order to allow the addition 500 + 3. 
        UnitInfo big2 = AdaptBiggerAdditionOperand(unitInfos2, bigSmallI, operation);
        if (big2.Error.Type != ErrorTypes.None)
        {
            return TooBigGapAddition(unitInfos2, bigSmallI, operation);
        }

        unitInfos2[bigSmallI[0]].Value = big2.Value;
        unitInfos2[bigSmallI[0]].BaseTenExponent = unitInfos2[bigSmallI[1]].BaseTenExponent;

        return unitInfos2;
    }

    //When adding/subtracting two numbers whose gap is bigger than the maximum double range, there
    //is no need to perform any operation (i.e., no change will be observed because of being outside
    //the maximum supported precision). This method takes care of these cases and returns the expected
    //output (i.e., biggest value).
    static UnitInfo[] TooBigGapAddition(UnitInfo[] unitInfos2, int[] bigSmallI, Operations operation)
    {
        UnitInfo[] outInfos = new UnitInfo[] 
        {
            //First operand (i.e., one whose information defines the operation) together with the
            //numeric information (i.e., just Value and BaseTenExponent because both are normalised)
            //which is associated with the biggest one.
            new UnitInfo(unitInfos2[0])
            {{
                Value = unitInfos2[bigSmallI[0]].Value;
                BaseTenExponent = unitInfos2[bigSmallI[0]].BaseTenExponent;
            }}
        };

        if (operation == Operations.Subtraction && bigSmallI[0] == 1)
        {
            outInfos[0].Value = -1.0 * outInfos[0].Value;
        }

        if (outInfos[0].Unit == Units.Unitless)
        {
            outInfos[0].Unit = unitInfos2[bigSmallI[1]].Unit;
        }

        return outInfos;
    }

    static UnitInfo AdaptBiggerAdditionOperand(UnitInfo[] unitInfos2, Integer[] bigSmallI, Operations operation)
    {
        int gapExponent = unitInfos2[bigSmallI[0]].BaseTenExponent - unitInfos2[bigSmallI[1]].BaseTenExponent;
        if (gapExponent >= 27)
        {
            //The difference between both inputs is bigger than (or, at least, very close to) the maximum double value/precision;
            //what makes this situation calculation unworthy and the first operand to be returned as the result.
            //Note that the error below these lines is just an easy way to tell the calling function about this eventuality.
            return new UnitInfo(unitInfos2[0]) 
            {{ 
                Error = new ErrorInfo(ErrorTypes.InvalidOperation); 
            }};
        }

        //PerformManagedOperationValues is used to make sure that the resulting numeric information is stored
        //in Value (if possible).
        UnitInfo big2 = PerformManagedOperationValues
        (
            RaiseToIntegerExponent(10.0, gapExponent), unitInfos2[bigSmallI[0]].Value, 
            Operations.Multiplication                
        );

        boolean isWrong = 
        (
            big2.Error.Type != ErrorTypes.None || big2.BaseTenExponent != 0 ?
            
            //The value of the bigger input times 10^(gap between BaseTenExponent of inputs) is too big. 
            isWrong = true :
            
            //Overflow-check very unlikely to trigger an error. In fact, with properly normalised variables,
            //triggering an error would be plainly impossible.               
            AreAdditionFinalValuesWrong
            (
                unitInfos2[0].Value, unitInfos2[1].Value, operation
            )
        );

        UnitInfo temp = null;
        if (isWrong)
        {
        	temp = new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }};
            
            temp.Error = new ErrorInfo(ErrorTypes.InvalidOperation);
        }
        else
        	
        
        
        return temp;
        
        
        return
        (
            isWrong ?
            //This error is just an easy way to let the calling function know about the fact that no
            //calculation has been performed (too big gap). This isn't a properly-speaking error and
            //that's why it will not be notified to the user.
            new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }} :
            //Returning the new big value. For example: with 5*10^4 & 3*10^2, 500 would be returned.
            new UnitInfo(unitInfos2[bigSmallI[0]])
            {{
                Value = big2.Value;
            }}
        )
    }

    static boolean AreAdditionFinalValuesWrong(double val1, double val2, Operations operation)
    {
        boolean isWrong = false;

        try
        {
            val1 = val1 + val2 *
            (
                operation == Operations.Addition ? 1 : -1
            );
        }
        catch { isWrong = true; }

        return isWrong;
    }

    static UnitInfo PerformManagedOperationMultiplication(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationNormalisedValues
        (
            firstInfo, new UnitInfo[] 
            { 
                NormaliseUnitInfo(firstInfo),
                NormaliseUnitInfo(secondInfo) 
            },
            operation
        );
    }

    public static UnitInfo RaiseToIntegerExponent(double baseValue, int exponent)
    {
        return RaiseToIntegerExponent(new UnitInfo(baseValue), exponent);
    }

    static UnitInfo RaiseToIntegerExponent(UnitInfo baseInfo, int exponent)
    {
        if (exponent <= 1 && exponent >= 0)
        {
            baseInfo.Value = (exponent == 0 ? 1.0 : baseInfo.Value);
            return baseInfo;
        }

        UnitInfo outInfo = new UnitInfo(baseInfo);

        for (int i = 1; i < Math.Abs(exponent); i++)
        {
            outInfo = PerformManagedOperationValues
            (
                outInfo, baseInfo, Operations.Multiplication
            );
            if (outInfo.Error.Type != ErrorTypes.None) return outInfo;
        }

        return
        (
            exponent < 0 ?
            PerformManagedOperationValues(new UnitInfo(1.0), outInfo, Operations.Division) :
            outInfo
        );
    }

    static UnitInfo PerformManagedOperationNormalisedValues(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        outInfo =
        (
            normalisedInfos.Length == 1 ?
            //There is just one operand when the difference between both of them is too big.
            outInfo = normalisedInfos[0] :
            PerformManagedOperationTwoOperands(outInfo, normalisedInfos, operation)
        );

        return outInfo;
    }

    static UnitInfo PerformManagedOperationTwoOperands(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        UnitInfo outInfoNormalised = PerformManagedOperationValues
        (
            normalisedInfos[0], normalisedInfos[1], operation
        );

        if (outInfo.Error.Type != ErrorTypes.None)
        {
            return new UnitInfo(outInfo)
            {
                Error = new ErrorInfo(ErrorTypes.NumericError)
            };
        }

        outInfo.BaseTenExponent = outInfoNormalised.BaseTenExponent;
        outInfo.Value = outInfoNormalised.Value;
        //Normalised means no prefixes.
        outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage); 

        return outInfo;
    }

    static UnitInfo PerformManagedOperationValues(double firstValue, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            new UnitInfo(firstValue), new UnitInfo(secondValue), operation
        );
    }

    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            firstInfo, new UnitInfo(secondValue), operation
        );
    }

    //This method might be used to perform full operations (not just being the last calculation step) instead
    //of the default one (PerformManagedOperationUnits) for simple cases. That is: ones not dealing with the
    //complex numeric reality (Value, Prefix and BaseTenExponent) which makes a pre-analysis required.
    //Note that, unlikely what happens with PerformMangedOperationUnits, the outputs of this method aren't
    //normalised (= primarily stored under Value), what is useful in certain contexts.
    //NOTE: this function assumes that both inputs are normalised, what means that no prefix information is expected.
    //It might also be used with non-normalised inputs, but their prefix information would be plainly ignored.
    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        if (firstInfo.Value == 0.0 || secondInfo.Value == 0.0)
        {
            if (operation == Operations.Multiplication || operation == Operations.Division)
            {
                //Dividing by zero scenarios are taken into account somewhere else.
                return new UnitInfo(firstInfo) { Value = 0.0 };
            }
        }

        UnitInfo outInfo = new UnitInfo(firstInfo);
        UnitInfo firstInfo0 = new UnitInfo(firstInfo);
        UnitInfo secondInfo0 = new UnitInfo(secondInfo);

        boolean isWrong = false;
        try
        {
            if (operation == Operations.Addition)
            {
                outInfo.Value += secondInfo0.Value;
            }
            else if (operation == Operations.Subtraction)
            {
                outInfo.Value -= secondInfo.Value;
            }
            else
            {
                //The reason for checking whether BaseTenExponent is inside/outside the int range before performing 
                //the operation (rather than going ahead and eventually catching the resulting exception) isn't just
                //being quicker, but also the only option in many situations. Note that an addition/subtraction between
                //two int variables whose result is outside the int range might not trigger an exception (+ random 
                //negative value as output).
                if (VaryBaseTenExponent(outInfo, secondInfo0.BaseTenExponent, operation == Operations.Division).Error.Type != ErrorTypes.None)
                {
                    return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
                }

                if (operation == Operations.Multiplication)
                {
                    outInfo.Value *= secondInfo.Value;
                    outInfo.BaseTenExponent += secondInfo.BaseTenExponent;
                }
                else if (operation == Operations.Division)
                {
                    if (secondInfo.Value == 0.0)
                    {
                        return
                        (
                            new UnitInfo(outInfo) 
                            { 
                                Error = new ErrorInfo(ErrorTypes.NumericError) 
                            }
                        );
                    }
                    outInfo.Value /= secondInfo.Value;
                    outInfo.BaseTenExponent -= secondInfo.BaseTenExponent;
                }
            }
        }
        catch { isWrong = true; }

        return
        (
            //An error might not be triggered despite of dealing with numbers outside double precision.
            //For example: 0.00000000000000000001m * 0.0000000000000000000001m can output 0.0 without triggering an error. 
            isWrong || ((operation == Operations.Multiplication || operation == Operations.Division) && outInfo.Value == 0.0.0) ?
            OperationValuesManageError(firstInfo0, secondInfo0, operation) : outInfo
        );
    }

    static UnitInfo OperationValuesManageError(UnitInfo outInfo, UnitInfo secondInfo, Operations operation)
    {
        if (operation != Operations.Multiplication && operation != Operations.Division)
        {
            //This condition should never be true on account of the fact that the pre-modifications performed before
            //adding/subtracting should avoid erroneous situations.
            return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
        }

        UnitInfo secondInfo2 = ConvertValueToBaseTen(secondInfo.Value);
        outInfo = VaryBaseTenExponent(outInfo, secondInfo2.BaseTenExponent, operation == Operations.Division);
        if (Math.Abs(secondInfo2.Value) == 1.0 || outInfo.Error.Type != ErrorTypes.None) return outInfo;
        
        try
        {
            outInfo = PerformManagedOperationUnits
            (
                outInfo, secondInfo2.Value, operation
            );
        }
        catch
        {
            //Very unlikely scenario on account of the fact that Math.Abs(secondInfo2.Value)
            //lies within the 0.1-10.0 range.
            outInfo = OperationValuesManageError
            (
                new UnitInfo(outInfo)
                {
                    Value = secondInfo2.Value,
                    BaseTenExponent = 0
                },
                new UnitInfo()
                {
                    Value = outInfo.Value,
                    BaseTenExponent = outInfo.BaseTenExponent
                },
                operation
            );
        }

        return outInfo;
    }

    static UnitInfo ConvertValueToBaseTen(double value)
    {
        value = Math.Abs(value);
        return FromValueToBaseTenExponent
        (
             new UnitInfo(value), Math.Abs(value), false
        );
    }

    static UnitInfo ConvertBaseTenToValue(UnitInfo unitInfo)
    {
        if (unitInfo.BaseTenExponent == 0) return unitInfo;

        UnitInfo outInfo = new UnitInfo(unitInfo);
        boolean decrease = unitInfo.BaseTenExponent > 0;
        int sign = Math.Sign(outInfo.Value);
        double absValue = Math.Abs(outInfo.Value);

        while (outInfo.BaseTenExponent != 0.0)
        {
            if (decrease)
            {
                if (absValue >= MaxValueDec / 10.0) break;
                absValue *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }
            else
            {
                if (absValue <= MinValueDec * 10.0) break;
                absValue /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
        }

        outInfo.Value = sign * absValue;

        return outInfo;
    }

    static UnitInfo NormaliseUnitInfo(UnitInfo unitInfo)
    {
        if (unitInfo.Value == 0 && unitInfo.Prefix.Factor == 1.0)
        {
            return unitInfo;
        }
        UnitInfo outInfo = new UnitInfo(unitInfo);

        if (outInfo.Prefix.Factor != 1)
        {
            outInfo = FromValueToBaseTenExponent
            (
                outInfo, outInfo.Prefix.Factor, true
            );
            outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage);
        }
        if (outInfo.Value == 0.0) return outInfo;

        outInfo = FromValueToBaseTenExponent
        (
            outInfo, outInfo.Value, false
        );

        return outInfo;
    }

    static UnitInfo FromValueToBaseTenExponent(UnitInfo outInfo, double value, boolean isPrefix)
    {
        if (value == 0.0) return outInfo;

        double valueAbs = Math.Abs(value);
        boolean decrease = (valueAbs > 1.0);
        if (!isPrefix)
        {
            outInfo.Value = outInfo.Value / valueAbs;
        }

        while (valueAbs != 1.0)
        {
            if ((valueAbs < 10.0 && valueAbs > 1.0) || (valueAbs > 0.1.0 && valueAbs < 1.0))
            {
                if (!isPrefix) outInfo.Value = value;
                else
                {
                    outInfo = PerformManagedOperationValues
                    (
                        outInfo, value, Operations.Multiplication
                    );
                }

                return outInfo;
            }

            if (decrease)
            {
                value /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
            else
            {
                value *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }

            valueAbs = Math.Abs(value);
        }

        return outInfo;
    }

    //Method used to vary BaseTenExponent without provoking unhandled exceptions (i.e., bigger than Integer.MAX_VALUE).
    static UnitInfo VaryBaseTenExponent(UnitInfo info, int baseTenIncrease, boolean isDivision = false)
    {
        long val1 = info.BaseTenExponent;
        long val2 = baseTenIncrease;

        if (isDivision)
        {
            //Converting a negative value into positive might provoke an overflow error for the int type
            //(e.g., Math.Abs(Integer.MAIN_VALUE)). Converting both variables to long is a quick and effective
            //way to avoid this problem.
            val2 *= -1;
        }

        return
        (
             ((val2 > 0 && val1 > Integer.MAX_VALUE - val2) || (val2 < 0 && val1 < Integer.MAIN_VALUE - val2)) ?
            new UnitInfo(info, ErrorTypes.NumericError) : new UnitInfo(info){{ BaseTenExponent = (int)(val1 + val2); }}
        );
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:476)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 2 2017-05-27 20:05:43.753
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:476)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 0 2017-05-27 20:05:43.754
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:476)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.core 4 4 2017-05-27 20:05:44.760
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
public class OperationsManaged
{
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, double second, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            firstInfo, new UnitInfo(second), operation
        );
    }

    public static UnitInfo PerformManagedOperationUnits(double first, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            new UnitInfo(first), secondInfo, operation
        );
    }

    //This method should always be used when dealing with random UnitInfo variables because it accounts for all the
    //possible scenarios. On the other hand, with simple operations (e.g., random UnitInfo & numeric type) it might
    //be better to use PerformManagedOperationValues. 
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        ErrorTypes errorType = InternalMethods.GetOperationError
        (
            firstInfo, secondInfo, operation
        );
        if (errorType != ErrorTypes.None)
        {
            return new UnitInfo(firstInfo) 
            {{
                Error = new ErrorInfo(errorType); 
            }};
        }

        return
        (
            operation == Operations.Addition || operation == Operations.Subtraction ?
            PerformManagedOperationAddition(firstInfo, secondInfo, operation) :
            PerformManagedOperationMultiplication(firstInfo, secondInfo, operation)
        );
    }

    static UnitInfo PerformManagedOperationAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {   
        //After being normalised, the operands might require further modifications.
        UnitInfo[] normalised = GetOperandsAddition(firstInfo, secondInfo, operation);

        return PerformManagedOperationNormalisedValues
        (
            firstInfo, normalised, operation
        );
    }

    static UnitInfo[] GetOperandsAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        UnitInfo[] operands2 = new UnitInfo[] 
        {
            new UnitInfo(firstInfo), new UnitInfo(secondInfo)
        };

        if (operands2[0].BaseTenExponent != operands2[1].BaseTenExponent || operands2[0].Prefix.Factor != operands2[1].Prefix.Factor)
        {
            //The addition/subtraction might not be performed right away even with normalised values.
            //For example: 5 and 6 from 5*10^2 and 6*10^7 cannot be added right away.
            operands2 = AdaptNormalisedValuesForAddition
            (
                new UnitInfo[] 
                { 
                    NormaliseUnitInfo(operands2[0]), 
                    NormaliseUnitInfo(operands2[1])
                },
                operation
            );
        }

        return operands2;
    }
    
    static UnitInfo[] AdaptNormalisedValuesForAddition(UnitInfo[] unitInfos2, Operations operation)
    {
        if (unitInfos2[0].BaseTenExponent == unitInfos2[1].BaseTenExponent)
        {
            //Having the same BaseTenExponent values means that the given operation can be performed right away.
            return unitInfos2;
        }

        int[] bigSmallI = 
        (
            unitInfos2[0].BaseTenExponent > unitInfos2[1].BaseTenExponent ?
            new int[] { 0, 1 } : new int[] { 1, 0 }
        );

        //Only the variable with the bigger value is modified. For example: 5*10^5 & 3*10^3 is converted
        //into 500*10^3 & 3*10^3 in order to allow the addition 500 + 3. 
        UnitInfo big2 = AdaptBiggerAdditionOperand(unitInfos2, bigSmallI, operation);
        if (big2.Error.Type != ErrorTypes.None)
        {
            return TooBigGapAddition(unitInfos2, bigSmallI, operation);
        }

        unitInfos2[bigSmallI[0]].Value = big2.Value;
        unitInfos2[bigSmallI[0]].BaseTenExponent = unitInfos2[bigSmallI[1]].BaseTenExponent;

        return unitInfos2;
    }

    //When adding/subtracting two numbers whose gap is bigger than the maximum double range, there
    //is no need to perform any operation (i.e., no change will be observed because of being outside
    //the maximum supported precision). This method takes care of these cases and returns the expected
    //output (i.e., biggest value).
    static UnitInfo[] TooBigGapAddition(UnitInfo[] unitInfos2, int[] bigSmallI, Operations operation)
    {
        UnitInfo[] outInfos = new UnitInfo[] 
        {
            //First operand (i.e., one whose information defines the operation) together with the
            //numeric information (i.e., just Value and BaseTenExponent because both are normalised)
            //which is associated with the biggest one.
            new UnitInfo(unitInfos2[0])
            {{
                Value = unitInfos2[bigSmallI[0]].Value;
                BaseTenExponent = unitInfos2[bigSmallI[0]].BaseTenExponent;
            }}
        };

        if (operation == Operations.Subtraction && bigSmallI[0] == 1)
        {
            outInfos[0].Value = -1.0 * outInfos[0].Value;
        }

        if (outInfos[0].Unit == Units.Unitless)
        {
            outInfos[0].Unit = unitInfos2[bigSmallI[1]].Unit;
        }

        return outInfos;
    }

    static UnitInfo AdaptBiggerAdditionOperand(UnitInfo[] unitInfos2, Integer[] bigSmallI, Operations operation)
    {
        int gapExponent = unitInfos2[bigSmallI[0]].BaseTenExponent - unitInfos2[bigSmallI[1]].BaseTenExponent;
        if (gapExponent >= 27)
        {
            //The difference between both inputs is bigger than (or, at least, very close to) the maximum double value/precision;
            //what makes this situation calculation unworthy and the first operand to be returned as the result.
            //Note that the error below these lines is just an easy way to tell the calling function about this eventuality.
            return new UnitInfo(unitInfos2[0]) 
            {{ 
                Error = new ErrorInfo(ErrorTypes.InvalidOperation); 
            }};
        }

        //PerformManagedOperationValues is used to make sure that the resulting numeric information is stored
        //in Value (if possible).
        UnitInfo big2 = PerformManagedOperationValues
        (
            RaiseToIntegerExponent(10.0, gapExponent), unitInfos2[bigSmallI[0]].Value, 
            Operations.Multiplication                
        );

        boolean isWrong = 
        (
            big2.Error.Type != ErrorTypes.None || big2.BaseTenExponent != 0 ?
            
            //The value of the bigger input times 10^(gap between BaseTenExponent of inputs) is too big. 
            isWrong = true :
            
            //Overflow-check very unlikely to trigger an error. In fact, with properly normalised variables,
            //triggering an error would be plainly impossible.               
            AreAdditionFinalValuesWrong
            (
                unitInfos2[0].Value, unitInfos2[1].Value, operation
            )
        );

        UnitInfo temp = null;
        if (isWrong)
        {
        	temp = new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }};
            
            temp.Error = new ErrorInfo(ErrorTypes.InvalidOperation);
        }
        else
        {
        	
        }
        
        
        return temp;
        
        
        return
        (
            isWrong ?
            //This error is just an easy way to let the calling function know about the fact that no
            //calculation has been performed (too big gap). This isn't a properly-speaking error and
            //that's why it will not be notified to the user.
            new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }} :
            //Returning the new big value. For example: with 5*10^4 & 3*10^2, 500 would be returned.
            new UnitInfo(unitInfos2[bigSmallI[0]])
            {{
                Value = big2.Value;
            }}
        )
    }

    static boolean AreAdditionFinalValuesWrong(double val1, double val2, Operations operation)
    {
        boolean isWrong = false;

        try
        {
            val1 = val1 + val2 *
            (
                operation == Operations.Addition ? 1 : -1
            );
        }
        catch { isWrong = true; }

        return isWrong;
    }

    static UnitInfo PerformManagedOperationMultiplication(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationNormalisedValues
        (
            firstInfo, new UnitInfo[] 
            { 
                NormaliseUnitInfo(firstInfo),
                NormaliseUnitInfo(secondInfo) 
            },
            operation
        );
    }

    public static UnitInfo RaiseToIntegerExponent(double baseValue, int exponent)
    {
        return RaiseToIntegerExponent(new UnitInfo(baseValue), exponent);
    }

    static UnitInfo RaiseToIntegerExponent(UnitInfo baseInfo, int exponent)
    {
        if (exponent <= 1 && exponent >= 0)
        {
            baseInfo.Value = (exponent == 0 ? 1.0 : baseInfo.Value);
            return baseInfo;
        }

        UnitInfo outInfo = new UnitInfo(baseInfo);

        for (int i = 1; i < Math.Abs(exponent); i++)
        {
            outInfo = PerformManagedOperationValues
            (
                outInfo, baseInfo, Operations.Multiplication
            );
            if (outInfo.Error.Type != ErrorTypes.None) return outInfo;
        }

        return
        (
            exponent < 0 ?
            PerformManagedOperationValues(new UnitInfo(1.0), outInfo, Operations.Division) :
            outInfo
        );
    }

    static UnitInfo PerformManagedOperationNormalisedValues(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        outInfo =
        (
            normalisedInfos.Length == 1 ?
            //There is just one operand when the difference between both of them is too big.
            outInfo = normalisedInfos[0] :
            PerformManagedOperationTwoOperands(outInfo, normalisedInfos, operation)
        );

        return outInfo;
    }

    static UnitInfo PerformManagedOperationTwoOperands(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        UnitInfo outInfoNormalised = PerformManagedOperationValues
        (
            normalisedInfos[0], normalisedInfos[1], operation
        );

        if (outInfo.Error.Type != ErrorTypes.None)
        {
            return new UnitInfo(outInfo)
            {
                Error = new ErrorInfo(ErrorTypes.NumericError)
            };
        }

        outInfo.BaseTenExponent = outInfoNormalised.BaseTenExponent;
        outInfo.Value = outInfoNormalised.Value;
        //Normalised means no prefixes.
        outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage); 

        return outInfo;
    }

    static UnitInfo PerformManagedOperationValues(double firstValue, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            new UnitInfo(firstValue), new UnitInfo(secondValue), operation
        );
    }

    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            firstInfo, new UnitInfo(secondValue), operation
        );
    }

    //This method might be used to perform full operations (not just being the last calculation step) instead
    //of the default one (PerformManagedOperationUnits) for simple cases. That is: ones not dealing with the
    //complex numeric reality (Value, Prefix and BaseTenExponent) which makes a pre-analysis required.
    //Note that, unlikely what happens with PerformMangedOperationUnits, the outputs of this method aren't
    //normalised (= primarily stored under Value), what is useful in certain contexts.
    //NOTE: this function assumes that both inputs are normalised, what means that no prefix information is expected.
    //It might also be used with non-normalised inputs, but their prefix information would be plainly ignored.
    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        if (firstInfo.Value == 0.0 || secondInfo.Value == 0.0)
        {
            if (operation == Operations.Multiplication || operation == Operations.Division)
            {
                //Dividing by zero scenarios are taken into account somewhere else.
                return new UnitInfo(firstInfo) { Value = 0.0 };
            }
        }

        UnitInfo outInfo = new UnitInfo(firstInfo);
        UnitInfo firstInfo0 = new UnitInfo(firstInfo);
        UnitInfo secondInfo0 = new UnitInfo(secondInfo);

        boolean isWrong = false;
        try
        {
            if (operation == Operations.Addition)
            {
                outInfo.Value += secondInfo0.Value;
            }
            else if (operation == Operations.Subtraction)
            {
                outInfo.Value -= secondInfo.Value;
            }
            else
            {
                //The reason for checking whether BaseTenExponent is inside/outside the int range before performing 
                //the operation (rather than going ahead and eventually catching the resulting exception) isn't just
                //being quicker, but also the only option in many situations. Note that an addition/subtraction between
                //two int variables whose result is outside the int range might not trigger an exception (+ random 
                //negative value as output).
                if (VaryBaseTenExponent(outInfo, secondInfo0.BaseTenExponent, operation == Operations.Division).Error.Type != ErrorTypes.None)
                {
                    return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
                }

                if (operation == Operations.Multiplication)
                {
                    outInfo.Value *= secondInfo.Value;
                    outInfo.BaseTenExponent += secondInfo.BaseTenExponent;
                }
                else if (operation == Operations.Division)
                {
                    if (secondInfo.Value == 0.0)
                    {
                        return
                        (
                            new UnitInfo(outInfo) 
                            { 
                                Error = new ErrorInfo(ErrorTypes.NumericError) 
                            }
                        );
                    }
                    outInfo.Value /= secondInfo.Value;
                    outInfo.BaseTenExponent -= secondInfo.BaseTenExponent;
                }
            }
        }
        catch { isWrong = true; }

        return
        (
            //An error might not be triggered despite of dealing with numbers outside double precision.
            //For example: 0.00000000000000000001m * 0.0000000000000000000001m can output 0.0 without triggering an error. 
            isWrong || ((operation == Operations.Multiplication || operation == Operations.Division) && outInfo.Value == 0.0.0) ?
            OperationValuesManageError(firstInfo0, secondInfo0, operation) : outInfo
        );
    }

    static UnitInfo OperationValuesManageError(UnitInfo outInfo, UnitInfo secondInfo, Operations operation)
    {
        if (operation != Operations.Multiplication && operation != Operations.Division)
        {
            //This condition should never be true on account of the fact that the pre-modifications performed before
            //adding/subtracting should avoid erroneous situations.
            return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
        }

        UnitInfo secondInfo2 = ConvertValueToBaseTen(secondInfo.Value);
        outInfo = VaryBaseTenExponent(outInfo, secondInfo2.BaseTenExponent, operation == Operations.Division);
        if (Math.Abs(secondInfo2.Value) == 1.0 || outInfo.Error.Type != ErrorTypes.None) return outInfo;
        
        try
        {
            outInfo = PerformManagedOperationUnits
            (
                outInfo, secondInfo2.Value, operation
            );
        }
        catch
        {
            //Very unlikely scenario on account of the fact that Math.Abs(secondInfo2.Value)
            //lies within the 0.1-10.0 range.
            outInfo = OperationValuesManageError
            (
                new UnitInfo(outInfo)
                {
                    Value = secondInfo2.Value,
                    BaseTenExponent = 0
                },
                new UnitInfo()
                {
                    Value = outInfo.Value,
                    BaseTenExponent = outInfo.BaseTenExponent
                },
                operation
            );
        }

        return outInfo;
    }

    static UnitInfo ConvertValueToBaseTen(double value)
    {
        value = Math.Abs(value);
        return FromValueToBaseTenExponent
        (
             new UnitInfo(value), Math.Abs(value), false
        );
    }

    static UnitInfo ConvertBaseTenToValue(UnitInfo unitInfo)
    {
        if (unitInfo.BaseTenExponent == 0) return unitInfo;

        UnitInfo outInfo = new UnitInfo(unitInfo);
        boolean decrease = unitInfo.BaseTenExponent > 0;
        int sign = Math.Sign(outInfo.Value);
        double absValue = Math.Abs(outInfo.Value);

        while (outInfo.BaseTenExponent != 0.0)
        {
            if (decrease)
            {
                if (absValue >= MaxValueDec / 10.0) break;
                absValue *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }
            else
            {
                if (absValue <= MinValueDec * 10.0) break;
                absValue /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
        }

        outInfo.Value = sign * absValue;

        return outInfo;
    }

    static UnitInfo NormaliseUnitInfo(UnitInfo unitInfo)
    {
        if (unitInfo.Value == 0 && unitInfo.Prefix.Factor == 1.0)
        {
            return unitInfo;
        }
        UnitInfo outInfo = new UnitInfo(unitInfo);

        if (outInfo.Prefix.Factor != 1)
        {
            outInfo = FromValueToBaseTenExponent
            (
                outInfo, outInfo.Prefix.Factor, true
            );
            outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage);
        }
        if (outInfo.Value == 0.0) return outInfo;

        outInfo = FromValueToBaseTenExponent
        (
            outInfo, outInfo.Value, false
        );

        return outInfo;
    }

    static UnitInfo FromValueToBaseTenExponent(UnitInfo outInfo, double value, boolean isPrefix)
    {
        if (value == 0.0) return outInfo;

        double valueAbs = Math.Abs(value);
        boolean decrease = (valueAbs > 1.0);
        if (!isPrefix)
        {
            outInfo.Value = outInfo.Value / valueAbs;
        }

        while (valueAbs != 1.0)
        {
            if ((valueAbs < 10.0 && valueAbs > 1.0) || (valueAbs > 0.1.0 && valueAbs < 1.0))
            {
                if (!isPrefix) outInfo.Value = value;
                else
                {
                    outInfo = PerformManagedOperationValues
                    (
                        outInfo, value, Operations.Multiplication
                    );
                }

                return outInfo;
            }

            if (decrease)
            {
                value /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
            else
            {
                value *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }

            valueAbs = Math.Abs(value);
        }

        return outInfo;
    }

    //Method used to vary BaseTenExponent without provoking unhandled exceptions (i.e., bigger than Integer.MAX_VALUE).
    static UnitInfo VaryBaseTenExponent(UnitInfo info, int baseTenIncrease, boolean isDivision = false)
    {
        long val1 = info.BaseTenExponent;
        long val2 = baseTenIncrease;

        if (isDivision)
        {
            //Converting a negative value into positive might provoke an overflow error for the int type
            //(e.g., Math.Abs(Integer.MAIN_VALUE)). Converting both variables to long is a quick and effective
            //way to avoid this problem.
            val2 *= -1;
        }

        return
        (
             ((val2 > 0 && val1 > Integer.MAX_VALUE - val2) || (val2 < 0 && val1 < Integer.MAIN_VALUE - val2)) ?
            new UnitInfo(info, ErrorTypes.NumericError) : new UnitInfo(info){{ BaseTenExponent = (int)(val1 + val2); }}
        );
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2017-05-27 20:05:44.761
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2017-05-27 20:05:44.762
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2017-05-27 20:05:44.900
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
public class OperationsManaged
{
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, double second, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            firstInfo, new UnitInfo(second), operation
        );
    }

    public static UnitInfo PerformManagedOperationUnits(double first, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            new UnitInfo(first), secondInfo, operation
        );
    }

    //This method should always be used when dealing with random UnitInfo variables because it accounts for all the
    //possible scenarios. On the other hand, with simple operations (e.g., random UnitInfo & numeric type) it might
    //be better to use PerformManagedOperationValues. 
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        ErrorTypes errorType = InternalMethods.GetOperationError
        (
            firstInfo, secondInfo, operation
        );
        if (errorType != ErrorTypes.None)
        {
            return new UnitInfo(firstInfo) 
            {{
                Error = new ErrorInfo(errorType); 
            }};
        }

        return
        (
            operation == Operations.Addition || operation == Operations.Subtraction ?
            PerformManagedOperationAddition(firstInfo, secondInfo, operation) :
            PerformManagedOperationMultiplication(firstInfo, secondInfo, operation)
        );
    }

    static UnitInfo PerformManagedOperationAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {   
        //After being normalised, the operands might require further modifications.
        UnitInfo[] normalised = GetOperandsAddition(firstInfo, secondInfo, operation);

        return PerformManagedOperationNormalisedValues
        (
            firstInfo, normalised, operation
        );
    }

    static UnitInfo[] GetOperandsAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        UnitInfo[] operands2 = new UnitInfo[] 
        {
            new UnitInfo(firstInfo), new UnitInfo(secondInfo)
        };

        if (operands2[0].BaseTenExponent != operands2[1].BaseTenExponent || operands2[0].Prefix.Factor != operands2[1].Prefix.Factor)
        {
            //The addition/subtraction might not be performed right away even with normalised values.
            //For example: 5 and 6 from 5*10^2 and 6*10^7 cannot be added right away.
            operands2 = AdaptNormalisedValuesForAddition
            (
                new UnitInfo[] 
                { 
                    NormaliseUnitInfo(operands2[0]), 
                    NormaliseUnitInfo(operands2[1])
                },
                operation
            );
        }

        return operands2;
    }
    
    static UnitInfo[] AdaptNormalisedValuesForAddition(UnitInfo[] unitInfos2, Operations operation)
    {
        if (unitInfos2[0].BaseTenExponent == unitInfos2[1].BaseTenExponent)
        {
            //Having the same BaseTenExponent values means that the given operation can be performed right away.
            return unitInfos2;
        }

        int[] bigSmallI = 
        (
            unitInfos2[0].BaseTenExponent > unitInfos2[1].BaseTenExponent ?
            new int[] { 0, 1 } : new int[] { 1, 0 }
        );

        //Only the variable with the bigger value is modified. For example: 5*10^5 & 3*10^3 is converted
        //into 500*10^3 & 3*10^3 in order to allow the addition 500 + 3. 
        UnitInfo big2 = AdaptBiggerAdditionOperand(unitInfos2, bigSmallI, operation);
        if (big2.Error.Type != ErrorTypes.None)
        {
            return TooBigGapAddition(unitInfos2, bigSmallI, operation);
        }

        unitInfos2[bigSmallI[0]].Value = big2.Value;
        unitInfos2[bigSmallI[0]].BaseTenExponent = unitInfos2[bigSmallI[1]].BaseTenExponent;

        return unitInfos2;
    }

    //When adding/subtracting two numbers whose gap is bigger than the maximum double range, there
    //is no need to perform any operation (i.e., no change will be observed because of being outside
    //the maximum supported precision). This method takes care of these cases and returns the expected
    //output (i.e., biggest value).
    static UnitInfo[] TooBigGapAddition(UnitInfo[] unitInfos2, int[] bigSmallI, Operations operation)
    {
        UnitInfo[] outInfos = new UnitInfo[] 
        {
            //First operand (i.e., one whose information defines the operation) together with the
            //numeric information (i.e., just Value and BaseTenExponent because both are normalised)
            //which is associated with the biggest one.
            new UnitInfo(unitInfos2[0])
            {{
                Value = unitInfos2[bigSmallI[0]].Value;
                BaseTenExponent = unitInfos2[bigSmallI[0]].BaseTenExponent;
            }}
        };

        if (operation == Operations.Subtraction && bigSmallI[0] == 1)
        {
            outInfos[0].Value = -1.0 * outInfos[0].Value;
        }

        if (outInfos[0].Unit == Units.Unitless)
        {
            outInfos[0].Unit = unitInfos2[bigSmallI[1]].Unit;
        }

        return outInfos;
    }

    static UnitInfo AdaptBiggerAdditionOperand(UnitInfo[] unitInfos2, Integer[] bigSmallI, Operations operation)
    {
        int gapExponent = unitInfos2[bigSmallI[0]].BaseTenExponent - unitInfos2[bigSmallI[1]].BaseTenExponent;
        if (gapExponent >= 27)
        {
            //The difference between both inputs is bigger than (or, at least, very close to) the maximum double value/precision;
            //what makes this situation calculation unworthy and the first operand to be returned as the result.
            //Note that the error below these lines is just an easy way to tell the calling function about this eventuality.
            return new UnitInfo(unitInfos2[0]) 
            {{ 
                Error = new ErrorInfo(ErrorTypes.InvalidOperation); 
            }};
        }

        //PerformManagedOperationValues is used to make sure that the resulting numeric information is stored
        //in Value (if possible).
        UnitInfo big2 = PerformManagedOperationValues
        (
            RaiseToIntegerExponent(10.0, gapExponent), unitInfos2[bigSmallI[0]].Value, 
            Operations.Multiplication                
        );

        boolean isWrong = 
        (
            big2.Error.Type != ErrorTypes.None || big2.BaseTenExponent != 0 ?
            
            //The value of the bigger input times 10^(gap between BaseTenExponent of inputs) is too big. 
            isWrong = true :
            
            //Overflow-check very unlikely to trigger an error. In fact, with properly normalised variables,
            //triggering an error would be plainly impossible.               
            AreAdditionFinalValuesWrong
            (
                unitInfos2[0].Value, unitInfos2[1].Value, operation
            )
        );

        UnitInfo temp = null;
        if (isWrong)
        {
        	temp = new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }};
            
            temp.Error = new ErrorInfo(ErrorTypes.InvalidOperation);
        }
        else
        {
        	
        }
        
        
        return temp;
        
        
        return
        (
            isWrong ?
            //This error is just an easy way to let the calling function know about the fact that no
            //calculation has been performed (too big gap). This isn't a properly-speaking error and
            //that's why it will not be notified to the user.
            new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }} :
            //Returning the new big value. For example: with 5*10^4 & 3*10^2, 500 would be returned.
            new UnitInfo(unitInfos2[bigSmallI[0]])
            {{
                Value = big2.Value;
            }}
        )
    }

    static boolean AreAdditionFinalValuesWrong(double val1, double val2, Operations operation)
    {
        boolean isWrong = false;

        try
        {
            val1 = val1 + val2 *
            (
                operation == Operations.Addition ? 1 : -1
            );
        }
        catch { isWrong = true; }

        return isWrong;
    }

    static UnitInfo PerformManagedOperationMultiplication(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationNormalisedValues
        (
            firstInfo, new UnitInfo[] 
            { 
                NormaliseUnitInfo(firstInfo),
                NormaliseUnitInfo(secondInfo) 
            },
            operation
        );
    }

    public static UnitInfo RaiseToIntegerExponent(double baseValue, int exponent)
    {
        return RaiseToIntegerExponent(new UnitInfo(baseValue), exponent);
    }

    static UnitInfo RaiseToIntegerExponent(UnitInfo baseInfo, int exponent)
    {
        if (exponent <= 1 && exponent >= 0)
        {
            baseInfo.Value = (exponent == 0 ? 1.0 : baseInfo.Value);
            return baseInfo;
        }

        UnitInfo outInfo = new UnitInfo(baseInfo);

        for (int i = 1; i < Math.Abs(exponent); i++)
        {
            outInfo = PerformManagedOperationValues
            (
                outInfo, baseInfo, Operations.Multiplication
            );
            if (outInfo.Error.Type != ErrorTypes.None) return outInfo;
        }

        return
        (
            exponent < 0 ?
            PerformManagedOperationValues(new UnitInfo(1.0), outInfo, Operations.Division) :
            outInfo
        );
    }

    static UnitInfo PerformManagedOperationNormalisedValues(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        outInfo =
        (
            normalisedInfos.Length == 1 ?
            //There is just one operand when the difference between both of them is too big.
            outInfo = normalisedInfos[0] :
            PerformManagedOperationTwoOperands(outInfo, normalisedInfos, operation)
        );

        return outInfo;
    }

    static UnitInfo PerformManagedOperationTwoOperands(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        UnitInfo outInfoNormalised = PerformManagedOperationValues
        (
            normalisedInfos[0], normalisedInfos[1], operation
        );

        if (outInfo.Error.Type != ErrorTypes.None)
        {
            return new UnitInfo(outInfo)
            {
                Error = new ErrorInfo(ErrorTypes.NumericError)
            };
        }

        outInfo.BaseTenExponent = outInfoNormalised.BaseTenExponent;
        outInfo.Value = outInfoNormalised.Value;
        //Normalised means no prefixes.
        outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage); 

        return outInfo;
    }

    static UnitInfo PerformManagedOperationValues(double firstValue, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            new UnitInfo(firstValue), new UnitInfo(secondValue), operation
        );
    }

    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            firstInfo, new UnitInfo(secondValue), operation
        );
    }

    //This method might be used to perform full operations (not just being the last calculation step) instead
    //of the default one (PerformManagedOperationUnits) for simple cases. That is: ones not dealing with the
    //complex numeric reality (Value, Prefix and BaseTenExponent) which makes a pre-analysis required.
    //Note that, unlikely what happens with PerformMangedOperationUnits, the outputs of this method aren't
    //normalised (= primarily stored under Value), what is useful in certain contexts.
    //NOTE: this function assumes that both inputs are normalised, what means that no prefix information is expected.
    //It might also be used with non-normalised inputs, but their prefix information would be plainly ignored.
    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        if (firstInfo.Value == 0.0 || secondInfo.Value == 0.0)
        {
            if (operation == Operations.Multiplication || operation == Operations.Division)
            {
                //Dividing by zero scenarios are taken into account somewhere else.
                return new UnitInfo(firstInfo) { Value = 0.0 };
            }
        }

        UnitInfo outInfo = new UnitInfo(firstInfo);
        UnitInfo firstInfo0 = new UnitInfo(firstInfo);
        UnitInfo secondInfo0 = new UnitInfo(secondInfo);

        boolean isWrong = false;
        try
        {
            if (operation == Operations.Addition)
            {
                outInfo.Value += secondInfo0.Value;
            }
            else if (operation == Operations.Subtraction)
            {
                outInfo.Value -= secondInfo.Value;
            }
            else
            {
                //The reason for checking whether BaseTenExponent is inside/outside the int range before performing 
                //the operation (rather than going ahead and eventually catching the resulting exception) isn't just
                //being quicker, but also the only option in many situations. Note that an addition/subtraction between
                //two int variables whose result is outside the int range might not trigger an exception (+ random 
                //negative value as output).
                if (VaryBaseTenExponent(outInfo, secondInfo0.BaseTenExponent, operation == Operations.Division).Error.Type != ErrorTypes.None)
                {
                    return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
                }

                if (operation == Operations.Multiplication)
                {
                    outInfo.Value *= secondInfo.Value;
                    outInfo.BaseTenExponent += secondInfo.BaseTenExponent;
                }
                else if (operation == Operations.Division)
                {
                    if (secondInfo.Value == 0.0)
                    {
                        return
                        (
                            new UnitInfo(outInfo) 
                            { 
                                Error = new ErrorInfo(ErrorTypes.NumericError) 
                            }
                        );
                    }
                    outInfo.Value /= secondInfo.Value;
                    outInfo.BaseTenExponent -= secondInfo.BaseTenExponent;
                }
            }
        }
        catch { isWrong = true; }

        return
        (
            //An error might not be triggered despite of dealing with numbers outside double precision.
            //For example: 0.00000000000000000001m * 0.0000000000000000000001m can output 0.0 without triggering an error. 
            isWrong || ((operation == Operations.Multiplication || operation == Operations.Division) && outInfo.Value == 0.0.0) ?
            OperationValuesManageError(firstInfo0, secondInfo0, operation) : outInfo
        );
    }

    static UnitInfo OperationValuesManageError(UnitInfo outInfo, UnitInfo secondInfo, Operations operation)
    {
        if (operation != Operations.Multiplication && operation != Operations.Division)
        {
            //This condition should never be true on account of the fact that the pre-modifications performed before
            //adding/subtracting should avoid erroneous situations.
            return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
        }

        UnitInfo secondInfo2 = ConvertValueToBaseTen(secondInfo.Value);
        outInfo = VaryBaseTenExponent(outInfo, secondInfo2.BaseTenExponent, operation == Operations.Division);
        if (Math.Abs(secondInfo2.Value) == 1.0 || outInfo.Error.Type != ErrorTypes.None) return outInfo;
        
        try
        {
            outInfo = PerformManagedOperationUnits
            (
                outInfo, secondInfo2.Value, operation
            );
        }
        catch
        {
            //Very unlikely scenario on account of the fact that Math.Abs(secondInfo2.Value)
            //lies within the 0.1-10.0 range.
            outInfo = OperationValuesManageError
            (
                new UnitInfo(outInfo)
                {
                    Value = secondInfo2.Value,
                    BaseTenExponent = 0
                },
                new UnitInfo()
                {
                    Value = outInfo.Value,
                    BaseTenExponent = outInfo.BaseTenExponent
                },
                operation
            );
        }

        return outInfo;
    }

    static UnitInfo ConvertValueToBaseTen(double value)
    {
        value = Math.Abs(value);
        return FromValueToBaseTenExponent
        (
             new UnitInfo(value), Math.Abs(value), false
        );
    }

    static UnitInfo ConvertBaseTenToValue(UnitInfo unitInfo)
    {
        if (unitInfo.BaseTenExponent == 0) return unitInfo;

        UnitInfo outInfo = new UnitInfo(unitInfo);
        boolean decrease = unitInfo.BaseTenExponent > 0;
        int sign = Math.Sign(outInfo.Value);
        double absValue = Math.Abs(outInfo.Value);

        while (outInfo.BaseTenExponent != 0.0)
        {
            if (decrease)
            {
                if (absValue >= MaxValueDec / 10.0) break;
                absValue *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }
            else
            {
                if (absValue <= MinValueDec * 10.0) break;
                absValue /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
        }

        outInfo.Value = sign * absValue;

        return outInfo;
    }

    static UnitInfo NormaliseUnitInfo(UnitInfo unitInfo)
    {
        if (unitInfo.Value == 0 && unitInfo.Prefix.Factor == 1.0)
        {
            return unitInfo;
        }
        UnitInfo outInfo = new UnitInfo(unitInfo);

        if (outInfo.Prefix.Factor != 1)
        {
            outInfo = FromValueToBaseTenExponent
            (
                outInfo, outInfo.Prefix.Factor, true
            );
            outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage);
        }
        if (outInfo.Value == 0.0) return outInfo;

        outInfo = FromValueToBaseTenExponent
        (
            outInfo, outInfo.Value, false
        );

        return outInfo;
    }

    static UnitInfo FromValueToBaseTenExponent(UnitInfo outInfo, double value, boolean isPrefix)
    {
        if (value == 0.0) return outInfo;

        double valueAbs = Math.Abs(value);
        boolean decrease = (valueAbs > 1.0);
        if (!isPrefix)
        {
            outInfo.Value = outInfo.Value / valueAbs;
        }

        while (valueAbs != 1.0)
        {
            if ((valueAbs < 10.0 && valueAbs > 1.0) || (valueAbs > 0.1.0 && valueAbs < 1.0))
            {
                if (!isPrefix) outInfo.Value = value;
                else
                {
                    outInfo = PerformManagedOperationValues
                    (
                        outInfo, value, Operations.Multiplication
                    );
                }

                return outInfo;
            }

            if (decrease)
            {
                value /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
            else
            {
                value *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }

            valueAbs = Math.Abs(value);
        }

        return outInfo;
    }

    //Method used to vary BaseTenExponent without provoking unhandled exceptions (i.e., bigger than Integer.MAX_VALUE).
    static UnitInfo VaryBaseTenExponent(UnitInfo info, int baseTenIncrease, boolean isDivision = false)
    {
        long val1 = info.BaseTenExponent;
        long val2 = baseTenIncrease;

        if (isDivision)
        {
            //Converting a negative value into positive might provoke an overflow error for the int type
            //(e.g., Math.Abs(Integer.MAIN_VALUE)). Converting both variables to long is a quick and effective
            //way to avoid this problem.
            val2 *= -1;
        }

        return
        (
             ((val2 > 0 && val1 > Integer.MAX_VALUE - val2) || (val2 < 0 && val1 < Integer.MAIN_VALUE - val2)) ?
            new UnitInfo(info, ErrorTypes.NumericError) : new UnitInfo(info){{ BaseTenExponent = (int)(val1 + val2); }}
        );
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 2 2017-05-27 20:05:44.901
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 0 2017-05-27 20:05:44.901
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.core 4 4 2017-05-27 20:05:45.794
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
public class OperationsManaged
{
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, double second, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            firstInfo, new UnitInfo(second), operation
        );
    }

    public static UnitInfo PerformManagedOperationUnits(double first, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            new UnitInfo(first), secondInfo, operation
        );
    }

    //This method should always be used when dealing with random UnitInfo variables because it accounts for all the
    //possible scenarios. On the other hand, with simple operations (e.g., random UnitInfo & numeric type) it might
    //be better to use PerformManagedOperationValues. 
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        ErrorTypes errorType = InternalMethods.GetOperationError
        (
            firstInfo, secondInfo, operation
        );
        if (errorType != ErrorTypes.None)
        {
            return new UnitInfo(firstInfo) 
            {{
                Error = new ErrorInfo(errorType); 
            }};
        }

        return
        (
            operation == Operations.Addition || operation == Operations.Subtraction ?
            PerformManagedOperationAddition(firstInfo, secondInfo, operation) :
            PerformManagedOperationMultiplication(firstInfo, secondInfo, operation)
        );
    }

    static UnitInfo PerformManagedOperationAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {   
        //After being normalised, the operands might require further modifications.
        UnitInfo[] normalised = GetOperandsAddition(firstInfo, secondInfo, operation);

        return PerformManagedOperationNormalisedValues
        (
            firstInfo, normalised, operation
        );
    }

    static UnitInfo[] GetOperandsAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        UnitInfo[] operands2 = new UnitInfo[] 
        {
            new UnitInfo(firstInfo), new UnitInfo(secondInfo)
        };

        if (operands2[0].BaseTenExponent != operands2[1].BaseTenExponent || operands2[0].Prefix.Factor != operands2[1].Prefix.Factor)
        {
            //The addition/subtraction might not be performed right away even with normalised values.
            //For example: 5 and 6 from 5*10^2 and 6*10^7 cannot be added right away.
            operands2 = AdaptNormalisedValuesForAddition
            (
                new UnitInfo[] 
                { 
                    NormaliseUnitInfo(operands2[0]), 
                    NormaliseUnitInfo(operands2[1])
                },
                operation
            );
        }

        return operands2;
    }
    
    static UnitInfo[] AdaptNormalisedValuesForAddition(UnitInfo[] unitInfos2, Operations operation)
    {
        if (unitInfos2[0].BaseTenExponent == unitInfos2[1].BaseTenExponent)
        {
            //Having the same BaseTenExponent values means that the given operation can be performed right away.
            return unitInfos2;
        }

        int[] bigSmallI = 
        (
            unitInfos2[0].BaseTenExponent > unitInfos2[1].BaseTenExponent ?
            new int[] { 0, 1 } : new int[] { 1, 0 }
        );

        //Only the variable with the bigger value is modified. For example: 5*10^5 & 3*10^3 is converted
        //into 500*10^3 & 3*10^3 in order to allow the addition 500 + 3. 
        UnitInfo big2 = AdaptBiggerAdditionOperand(unitInfos2, bigSmallI, operation);
        if (big2.Error.Type != ErrorTypes.None)
        {
            return TooBigGapAddition(unitInfos2, bigSmallI, operation);
        }

        unitInfos2[bigSmallI[0]].Value = big2.Value;
        unitInfos2[bigSmallI[0]].BaseTenExponent = unitInfos2[bigSmallI[1]].BaseTenExponent;

        return unitInfos2;
    }

    //When adding/subtracting two numbers whose gap is bigger than the maximum double range, there
    //is no need to perform any operation (i.e., no change will be observed because of being outside
    //the maximum supported precision). This method takes care of these cases and returns the expected
    //output (i.e., biggest value).
    static UnitInfo[] TooBigGapAddition(UnitInfo[] unitInfos2, int[] bigSmallI, Operations operation)
    {
        UnitInfo[] outInfos = new UnitInfo[] 
        {
            //First operand (i.e., one whose information defines the operation) together with the
            //numeric information (i.e., just Value and BaseTenExponent because both are normalised)
            //which is associated with the biggest one.
            new UnitInfo(unitInfos2[0])
            {{
                Value = unitInfos2[bigSmallI[0]].Value;
                BaseTenExponent = unitInfos2[bigSmallI[0]].BaseTenExponent;
            }}
        };

        if (operation == Operations.Subtraction && bigSmallI[0] == 1)
        {
            outInfos[0].Value = -1.0 * outInfos[0].Value;
        }

        if (outInfos[0].Unit == Units.Unitless)
        {
            outInfos[0].Unit = unitInfos2[bigSmallI[1]].Unit;
        }

        return outInfos;
    }

    static UnitInfo AdaptBiggerAdditionOperand(UnitInfo[] unitInfos2, Integer[] bigSmallI, Operations operation)
    {
        int gapExponent = unitInfos2[bigSmallI[0]].BaseTenExponent - unitInfos2[bigSmallI[1]].BaseTenExponent;
        if (gapExponent >= 27)
        {
            //The difference between both inputs is bigger than (or, at least, very close to) the maximum double value/precision;
            //what makes this situation calculation unworthy and the first operand to be returned as the result.
            //Note that the error below these lines is just an easy way to tell the calling function about this eventuality.
            return new UnitInfo(unitInfos2[0]) 
            {{ 
                Error = new ErrorInfo(ErrorTypes.InvalidOperation); 
            }};
        }

        //PerformManagedOperationValues is used to make sure that the resulting numeric information is stored
        //in Value (if possible).
        UnitInfo big2 = PerformManagedOperationValues
        (
            RaiseToIntegerExponent(10.0, gapExponent), unitInfos2[bigSmallI[0]].Value, 
            Operations.Multiplication                
        );

        boolean isWrong = 
        (
            big2.Error.Type != ErrorTypes.None || big2.BaseTenExponent != 0 ?
            
            //The value of the bigger input times 10^(gap between BaseTenExponent of inputs) is too big. 
            isWrong = true :
            
            //Overflow-check very unlikely to trigger an error. In fact, with properly normalised variables,
            //triggering an error would be plainly impossible.               
            AreAdditionFinalValuesWrong
            (
                unitInfos2[0].Value, unitInfos2[1].Value, operation
            )
        );

        UnitInfo temp = null;
        if (isWrong)
        {
        	temp = new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }};
            
            temp.Error = new ErrorInfo(ErrorTypes.InvalidOperation);
        }
        else
        {
        	new UnitInfo(unitInfos2[bigSmallI[0]])
            {{
                Value = big2.Value;
            }}
        }
        
        
        return temp;
        
        
        return
        (
            isWrong ?
            //This error is just an easy way to let the calling function know about the fact that no
            //calculation has been performed (too big gap). This isn't a properly-speaking error and
            //that's why it will not be notified to the user.
            new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }} :
            //Returning the new big value. For example: with 5*10^4 & 3*10^2, 500 would be returned.
            new UnitInfo(unitInfos2[bigSmallI[0]])
            {{
                Value = big2.Value;
            }}
        )
    }

    static boolean AreAdditionFinalValuesWrong(double val1, double val2, Operations operation)
    {
        boolean isWrong = false;

        try
        {
            val1 = val1 + val2 *
            (
                operation == Operations.Addition ? 1 : -1
            );
        }
        catch { isWrong = true; }

        return isWrong;
    }

    static UnitInfo PerformManagedOperationMultiplication(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationNormalisedValues
        (
            firstInfo, new UnitInfo[] 
            { 
                NormaliseUnitInfo(firstInfo),
                NormaliseUnitInfo(secondInfo) 
            },
            operation
        );
    }

    public static UnitInfo RaiseToIntegerExponent(double baseValue, int exponent)
    {
        return RaiseToIntegerExponent(new UnitInfo(baseValue), exponent);
    }

    static UnitInfo RaiseToIntegerExponent(UnitInfo baseInfo, int exponent)
    {
        if (exponent <= 1 && exponent >= 0)
        {
            baseInfo.Value = (exponent == 0 ? 1.0 : baseInfo.Value);
            return baseInfo;
        }

        UnitInfo outInfo = new UnitInfo(baseInfo);

        for (int i = 1; i < Math.Abs(exponent); i++)
        {
            outInfo = PerformManagedOperationValues
            (
                outInfo, baseInfo, Operations.Multiplication
            );
            if (outInfo.Error.Type != ErrorTypes.None) return outInfo;
        }

        return
        (
            exponent < 0 ?
            PerformManagedOperationValues(new UnitInfo(1.0), outInfo, Operations.Division) :
            outInfo
        );
    }

    static UnitInfo PerformManagedOperationNormalisedValues(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        outInfo =
        (
            normalisedInfos.Length == 1 ?
            //There is just one operand when the difference between both of them is too big.
            outInfo = normalisedInfos[0] :
            PerformManagedOperationTwoOperands(outInfo, normalisedInfos, operation)
        );

        return outInfo;
    }

    static UnitInfo PerformManagedOperationTwoOperands(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        UnitInfo outInfoNormalised = PerformManagedOperationValues
        (
            normalisedInfos[0], normalisedInfos[1], operation
        );

        if (outInfo.Error.Type != ErrorTypes.None)
        {
            return new UnitInfo(outInfo)
            {
                Error = new ErrorInfo(ErrorTypes.NumericError)
            };
        }

        outInfo.BaseTenExponent = outInfoNormalised.BaseTenExponent;
        outInfo.Value = outInfoNormalised.Value;
        //Normalised means no prefixes.
        outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage); 

        return outInfo;
    }

    static UnitInfo PerformManagedOperationValues(double firstValue, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            new UnitInfo(firstValue), new UnitInfo(secondValue), operation
        );
    }

    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            firstInfo, new UnitInfo(secondValue), operation
        );
    }

    //This method might be used to perform full operations (not just being the last calculation step) instead
    //of the default one (PerformManagedOperationUnits) for simple cases. That is: ones not dealing with the
    //complex numeric reality (Value, Prefix and BaseTenExponent) which makes a pre-analysis required.
    //Note that, unlikely what happens with PerformMangedOperationUnits, the outputs of this method aren't
    //normalised (= primarily stored under Value), what is useful in certain contexts.
    //NOTE: this function assumes that both inputs are normalised, what means that no prefix information is expected.
    //It might also be used with non-normalised inputs, but their prefix information would be plainly ignored.
    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        if (firstInfo.Value == 0.0 || secondInfo.Value == 0.0)
        {
            if (operation == Operations.Multiplication || operation == Operations.Division)
            {
                //Dividing by zero scenarios are taken into account somewhere else.
                return new UnitInfo(firstInfo) { Value = 0.0 };
            }
        }

        UnitInfo outInfo = new UnitInfo(firstInfo);
        UnitInfo firstInfo0 = new UnitInfo(firstInfo);
        UnitInfo secondInfo0 = new UnitInfo(secondInfo);

        boolean isWrong = false;
        try
        {
            if (operation == Operations.Addition)
            {
                outInfo.Value += secondInfo0.Value;
            }
            else if (operation == Operations.Subtraction)
            {
                outInfo.Value -= secondInfo.Value;
            }
            else
            {
                //The reason for checking whether BaseTenExponent is inside/outside the int range before performing 
                //the operation (rather than going ahead and eventually catching the resulting exception) isn't just
                //being quicker, but also the only option in many situations. Note that an addition/subtraction between
                //two int variables whose result is outside the int range might not trigger an exception (+ random 
                //negative value as output).
                if (VaryBaseTenExponent(outInfo, secondInfo0.BaseTenExponent, operation == Operations.Division).Error.Type != ErrorTypes.None)
                {
                    return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
                }

                if (operation == Operations.Multiplication)
                {
                    outInfo.Value *= secondInfo.Value;
                    outInfo.BaseTenExponent += secondInfo.BaseTenExponent;
                }
                else if (operation == Operations.Division)
                {
                    if (secondInfo.Value == 0.0)
                    {
                        return
                        (
                            new UnitInfo(outInfo) 
                            { 
                                Error = new ErrorInfo(ErrorTypes.NumericError) 
                            }
                        );
                    }
                    outInfo.Value /= secondInfo.Value;
                    outInfo.BaseTenExponent -= secondInfo.BaseTenExponent;
                }
            }
        }
        catch { isWrong = true; }

        return
        (
            //An error might not be triggered despite of dealing with numbers outside double precision.
            //For example: 0.00000000000000000001m * 0.0000000000000000000001m can output 0.0 without triggering an error. 
            isWrong || ((operation == Operations.Multiplication || operation == Operations.Division) && outInfo.Value == 0.0.0) ?
            OperationValuesManageError(firstInfo0, secondInfo0, operation) : outInfo
        );
    }

    static UnitInfo OperationValuesManageError(UnitInfo outInfo, UnitInfo secondInfo, Operations operation)
    {
        if (operation != Operations.Multiplication && operation != Operations.Division)
        {
            //This condition should never be true on account of the fact that the pre-modifications performed before
            //adding/subtracting should avoid erroneous situations.
            return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
        }

        UnitInfo secondInfo2 = ConvertValueToBaseTen(secondInfo.Value);
        outInfo = VaryBaseTenExponent(outInfo, secondInfo2.BaseTenExponent, operation == Operations.Division);
        if (Math.Abs(secondInfo2.Value) == 1.0 || outInfo.Error.Type != ErrorTypes.None) return outInfo;
        
        try
        {
            outInfo = PerformManagedOperationUnits
            (
                outInfo, secondInfo2.Value, operation
            );
        }
        catch
        {
            //Very unlikely scenario on account of the fact that Math.Abs(secondInfo2.Value)
            //lies within the 0.1-10.0 range.
            outInfo = OperationValuesManageError
            (
                new UnitInfo(outInfo)
                {
                    Value = secondInfo2.Value,
                    BaseTenExponent = 0
                },
                new UnitInfo()
                {
                    Value = outInfo.Value,
                    BaseTenExponent = outInfo.BaseTenExponent
                },
                operation
            );
        }

        return outInfo;
    }

    static UnitInfo ConvertValueToBaseTen(double value)
    {
        value = Math.Abs(value);
        return FromValueToBaseTenExponent
        (
             new UnitInfo(value), Math.Abs(value), false
        );
    }

    static UnitInfo ConvertBaseTenToValue(UnitInfo unitInfo)
    {
        if (unitInfo.BaseTenExponent == 0) return unitInfo;

        UnitInfo outInfo = new UnitInfo(unitInfo);
        boolean decrease = unitInfo.BaseTenExponent > 0;
        int sign = Math.Sign(outInfo.Value);
        double absValue = Math.Abs(outInfo.Value);

        while (outInfo.BaseTenExponent != 0.0)
        {
            if (decrease)
            {
                if (absValue >= MaxValueDec / 10.0) break;
                absValue *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }
            else
            {
                if (absValue <= MinValueDec * 10.0) break;
                absValue /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
        }

        outInfo.Value = sign * absValue;

        return outInfo;
    }

    static UnitInfo NormaliseUnitInfo(UnitInfo unitInfo)
    {
        if (unitInfo.Value == 0 && unitInfo.Prefix.Factor == 1.0)
        {
            return unitInfo;
        }
        UnitInfo outInfo = new UnitInfo(unitInfo);

        if (outInfo.Prefix.Factor != 1)
        {
            outInfo = FromValueToBaseTenExponent
            (
                outInfo, outInfo.Prefix.Factor, true
            );
            outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage);
        }
        if (outInfo.Value == 0.0) return outInfo;

        outInfo = FromValueToBaseTenExponent
        (
            outInfo, outInfo.Value, false
        );

        return outInfo;
    }

    static UnitInfo FromValueToBaseTenExponent(UnitInfo outInfo, double value, boolean isPrefix)
    {
        if (value == 0.0) return outInfo;

        double valueAbs = Math.Abs(value);
        boolean decrease = (valueAbs > 1.0);
        if (!isPrefix)
        {
            outInfo.Value = outInfo.Value / valueAbs;
        }

        while (valueAbs != 1.0)
        {
            if ((valueAbs < 10.0 && valueAbs > 1.0) || (valueAbs > 0.1.0 && valueAbs < 1.0))
            {
                if (!isPrefix) outInfo.Value = value;
                else
                {
                    outInfo = PerformManagedOperationValues
                    (
                        outInfo, value, Operations.Multiplication
                    );
                }

                return outInfo;
            }

            if (decrease)
            {
                value /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
            else
            {
                value *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }

            valueAbs = Math.Abs(value);
        }

        return outInfo;
    }

    //Method used to vary BaseTenExponent without provoking unhandled exceptions (i.e., bigger than Integer.MAX_VALUE).
    static UnitInfo VaryBaseTenExponent(UnitInfo info, int baseTenIncrease, boolean isDivision = false)
    {
        long val1 = info.BaseTenExponent;
        long val2 = baseTenIncrease;

        if (isDivision)
        {
            //Converting a negative value into positive might provoke an overflow error for the int type
            //(e.g., Math.Abs(Integer.MAIN_VALUE)). Converting both variables to long is a quick and effective
            //way to avoid this problem.
            val2 *= -1;
        }

        return
        (
             ((val2 > 0 && val1 > Integer.MAX_VALUE - val2) || (val2 < 0 && val1 < Integer.MAIN_VALUE - val2)) ?
            new UnitInfo(info, ErrorTypes.NumericError) : new UnitInfo(info){{ BaseTenExponent = (int)(val1 + val2); }}
        );
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2017-05-27 20:05:45.795
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2017-05-27 20:05:45.795
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2017-05-27 20:05:45.814
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
public class OperationsManaged
{
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, double second, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            firstInfo, new UnitInfo(second), operation
        );
    }

    public static UnitInfo PerformManagedOperationUnits(double first, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            new UnitInfo(first), secondInfo, operation
        );
    }

    //This method should always be used when dealing with random UnitInfo variables because it accounts for all the
    //possible scenarios. On the other hand, with simple operations (e.g., random UnitInfo & numeric type) it might
    //be better to use PerformManagedOperationValues. 
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        ErrorTypes errorType = InternalMethods.GetOperationError
        (
            firstInfo, secondInfo, operation
        );
        if (errorType != ErrorTypes.None)
        {
            return new UnitInfo(firstInfo) 
            {{
                Error = new ErrorInfo(errorType); 
            }};
        }

        return
        (
            operation == Operations.Addition || operation == Operations.Subtraction ?
            PerformManagedOperationAddition(firstInfo, secondInfo, operation) :
            PerformManagedOperationMultiplication(firstInfo, secondInfo, operation)
        );
    }

    static UnitInfo PerformManagedOperationAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {   
        //After being normalised, the operands might require further modifications.
        UnitInfo[] normalised = GetOperandsAddition(firstInfo, secondInfo, operation);

        return PerformManagedOperationNormalisedValues
        (
            firstInfo, normalised, operation
        );
    }

    static UnitInfo[] GetOperandsAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        UnitInfo[] operands2 = new UnitInfo[] 
        {
            new UnitInfo(firstInfo), new UnitInfo(secondInfo)
        };

        if (operands2[0].BaseTenExponent != operands2[1].BaseTenExponent || operands2[0].Prefix.Factor != operands2[1].Prefix.Factor)
        {
            //The addition/subtraction might not be performed right away even with normalised values.
            //For example: 5 and 6 from 5*10^2 and 6*10^7 cannot be added right away.
            operands2 = AdaptNormalisedValuesForAddition
            (
                new UnitInfo[] 
                { 
                    NormaliseUnitInfo(operands2[0]), 
                    NormaliseUnitInfo(operands2[1])
                },
                operation
            );
        }

        return operands2;
    }
    
    static UnitInfo[] AdaptNormalisedValuesForAddition(UnitInfo[] unitInfos2, Operations operation)
    {
        if (unitInfos2[0].BaseTenExponent == unitInfos2[1].BaseTenExponent)
        {
            //Having the same BaseTenExponent values means that the given operation can be performed right away.
            return unitInfos2;
        }

        int[] bigSmallI = 
        (
            unitInfos2[0].BaseTenExponent > unitInfos2[1].BaseTenExponent ?
            new int[] { 0, 1 } : new int[] { 1, 0 }
        );

        //Only the variable with the bigger value is modified. For example: 5*10^5 & 3*10^3 is converted
        //into 500*10^3 & 3*10^3 in order to allow the addition 500 + 3. 
        UnitInfo big2 = AdaptBiggerAdditionOperand(unitInfos2, bigSmallI, operation);
        if (big2.Error.Type != ErrorTypes.None)
        {
            return TooBigGapAddition(unitInfos2, bigSmallI, operation);
        }

        unitInfos2[bigSmallI[0]].Value = big2.Value;
        unitInfos2[bigSmallI[0]].BaseTenExponent = unitInfos2[bigSmallI[1]].BaseTenExponent;

        return unitInfos2;
    }

    //When adding/subtracting two numbers whose gap is bigger than the maximum double range, there
    //is no need to perform any operation (i.e., no change will be observed because of being outside
    //the maximum supported precision). This method takes care of these cases and returns the expected
    //output (i.e., biggest value).
    static UnitInfo[] TooBigGapAddition(UnitInfo[] unitInfos2, int[] bigSmallI, Operations operation)
    {
        UnitInfo[] outInfos = new UnitInfo[] 
        {
            //First operand (i.e., one whose information defines the operation) together with the
            //numeric information (i.e., just Value and BaseTenExponent because both are normalised)
            //which is associated with the biggest one.
            new UnitInfo(unitInfos2[0])
            {{
                Value = unitInfos2[bigSmallI[0]].Value;
                BaseTenExponent = unitInfos2[bigSmallI[0]].BaseTenExponent;
            }}
        };

        if (operation == Operations.Subtraction && bigSmallI[0] == 1)
        {
            outInfos[0].Value = -1.0 * outInfos[0].Value;
        }

        if (outInfos[0].Unit == Units.Unitless)
        {
            outInfos[0].Unit = unitInfos2[bigSmallI[1]].Unit;
        }

        return outInfos;
    }

    static UnitInfo AdaptBiggerAdditionOperand(UnitInfo[] unitInfos2, Integer[] bigSmallI, Operations operation)
    {
        int gapExponent = unitInfos2[bigSmallI[0]].BaseTenExponent - unitInfos2[bigSmallI[1]].BaseTenExponent;
        if (gapExponent >= 27)
        {
            //The difference between both inputs is bigger than (or, at least, very close to) the maximum double value/precision;
            //what makes this situation calculation unworthy and the first operand to be returned as the result.
            //Note that the error below these lines is just an easy way to tell the calling function about this eventuality.
            return new UnitInfo(unitInfos2[0]) 
            {{ 
                Error = new ErrorInfo(ErrorTypes.InvalidOperation); 
            }};
        }

        //PerformManagedOperationValues is used to make sure that the resulting numeric information is stored
        //in Value (if possible).
        UnitInfo big2 = PerformManagedOperationValues
        (
            RaiseToIntegerExponent(10.0, gapExponent), unitInfos2[bigSmallI[0]].Value, 
            Operations.Multiplication                
        );

        boolean isWrong = 
        (
            big2.Error.Type != ErrorTypes.None || big2.BaseTenExponent != 0 ?
            
            //The value of the bigger input times 10^(gap between BaseTenExponent of inputs) is too big. 
            isWrong = true :
            
            //Overflow-check very unlikely to trigger an error. In fact, with properly normalised variables,
            //triggering an error would be plainly impossible.               
            AreAdditionFinalValuesWrong
            (
                unitInfos2[0].Value, unitInfos2[1].Value, operation
            )
        );

        UnitInfo temp = null;
        if (isWrong)
        {
        	temp = new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }};
            
            temp.Error = new ErrorInfo(ErrorTypes.InvalidOperation);
        }
        else
        {
        	new UnitInfo(unitInfos2[bigSmallI[0]])
            {{
                Value = big2.Value;
            }}
        }
        
        
        return temp;
        
        
        return
        (
            isWrong ?
            //This error is just an easy way to let the calling function know about the fact that no
            //calculation has been performed (too big gap). This isn't a properly-speaking error and
            //that's why it will not be notified to the user.
            new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }} :
            //Returning the new big value. For example: with 5*10^4 & 3*10^2, 500 would be returned.
            new UnitInfo(unitInfos2[bigSmallI[0]])
            {{
                Value = big2.Value;
            }}
        )
    }

    static boolean AreAdditionFinalValuesWrong(double val1, double val2, Operations operation)
    {
        boolean isWrong = false;

        try
        {
            val1 = val1 + val2 *
            (
                operation == Operations.Addition ? 1 : -1
            );
        }
        catch { isWrong = true; }

        return isWrong;
    }

    static UnitInfo PerformManagedOperationMultiplication(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationNormalisedValues
        (
            firstInfo, new UnitInfo[] 
            { 
                NormaliseUnitInfo(firstInfo),
                NormaliseUnitInfo(secondInfo) 
            },
            operation
        );
    }

    public static UnitInfo RaiseToIntegerExponent(double baseValue, int exponent)
    {
        return RaiseToIntegerExponent(new UnitInfo(baseValue), exponent);
    }

    static UnitInfo RaiseToIntegerExponent(UnitInfo baseInfo, int exponent)
    {
        if (exponent <= 1 && exponent >= 0)
        {
            baseInfo.Value = (exponent == 0 ? 1.0 : baseInfo.Value);
            return baseInfo;
        }

        UnitInfo outInfo = new UnitInfo(baseInfo);

        for (int i = 1; i < Math.Abs(exponent); i++)
        {
            outInfo = PerformManagedOperationValues
            (
                outInfo, baseInfo, Operations.Multiplication
            );
            if (outInfo.Error.Type != ErrorTypes.None) return outInfo;
        }

        return
        (
            exponent < 0 ?
            PerformManagedOperationValues(new UnitInfo(1.0), outInfo, Operations.Division) :
            outInfo
        );
    }

    static UnitInfo PerformManagedOperationNormalisedValues(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        outInfo =
        (
            normalisedInfos.Length == 1 ?
            //There is just one operand when the difference between both of them is too big.
            outInfo = normalisedInfos[0] :
            PerformManagedOperationTwoOperands(outInfo, normalisedInfos, operation)
        );

        return outInfo;
    }

    static UnitInfo PerformManagedOperationTwoOperands(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        UnitInfo outInfoNormalised = PerformManagedOperationValues
        (
            normalisedInfos[0], normalisedInfos[1], operation
        );

        if (outInfo.Error.Type != ErrorTypes.None)
        {
            return new UnitInfo(outInfo)
            {
                Error = new ErrorInfo(ErrorTypes.NumericError)
            };
        }

        outInfo.BaseTenExponent = outInfoNormalised.BaseTenExponent;
        outInfo.Value = outInfoNormalised.Value;
        //Normalised means no prefixes.
        outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage); 

        return outInfo;
    }

    static UnitInfo PerformManagedOperationValues(double firstValue, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            new UnitInfo(firstValue), new UnitInfo(secondValue), operation
        );
    }

    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            firstInfo, new UnitInfo(secondValue), operation
        );
    }

    //This method might be used to perform full operations (not just being the last calculation step) instead
    //of the default one (PerformManagedOperationUnits) for simple cases. That is: ones not dealing with the
    //complex numeric reality (Value, Prefix and BaseTenExponent) which makes a pre-analysis required.
    //Note that, unlikely what happens with PerformMangedOperationUnits, the outputs of this method aren't
    //normalised (= primarily stored under Value), what is useful in certain contexts.
    //NOTE: this function assumes that both inputs are normalised, what means that no prefix information is expected.
    //It might also be used with non-normalised inputs, but their prefix information would be plainly ignored.
    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        if (firstInfo.Value == 0.0 || secondInfo.Value == 0.0)
        {
            if (operation == Operations.Multiplication || operation == Operations.Division)
            {
                //Dividing by zero scenarios are taken into account somewhere else.
                return new UnitInfo(firstInfo) { Value = 0.0 };
            }
        }

        UnitInfo outInfo = new UnitInfo(firstInfo);
        UnitInfo firstInfo0 = new UnitInfo(firstInfo);
        UnitInfo secondInfo0 = new UnitInfo(secondInfo);

        boolean isWrong = false;
        try
        {
            if (operation == Operations.Addition)
            {
                outInfo.Value += secondInfo0.Value;
            }
            else if (operation == Operations.Subtraction)
            {
                outInfo.Value -= secondInfo.Value;
            }
            else
            {
                //The reason for checking whether BaseTenExponent is inside/outside the int range before performing 
                //the operation (rather than going ahead and eventually catching the resulting exception) isn't just
                //being quicker, but also the only option in many situations. Note that an addition/subtraction between
                //two int variables whose result is outside the int range might not trigger an exception (+ random 
                //negative value as output).
                if (VaryBaseTenExponent(outInfo, secondInfo0.BaseTenExponent, operation == Operations.Division).Error.Type != ErrorTypes.None)
                {
                    return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
                }

                if (operation == Operations.Multiplication)
                {
                    outInfo.Value *= secondInfo.Value;
                    outInfo.BaseTenExponent += secondInfo.BaseTenExponent;
                }
                else if (operation == Operations.Division)
                {
                    if (secondInfo.Value == 0.0)
                    {
                        return
                        (
                            new UnitInfo(outInfo) 
                            { 
                                Error = new ErrorInfo(ErrorTypes.NumericError) 
                            }
                        );
                    }
                    outInfo.Value /= secondInfo.Value;
                    outInfo.BaseTenExponent -= secondInfo.BaseTenExponent;
                }
            }
        }
        catch { isWrong = true; }

        return
        (
            //An error might not be triggered despite of dealing with numbers outside double precision.
            //For example: 0.00000000000000000001m * 0.0000000000000000000001m can output 0.0 without triggering an error. 
            isWrong || ((operation == Operations.Multiplication || operation == Operations.Division) && outInfo.Value == 0.0.0) ?
            OperationValuesManageError(firstInfo0, secondInfo0, operation) : outInfo
        );
    }

    static UnitInfo OperationValuesManageError(UnitInfo outInfo, UnitInfo secondInfo, Operations operation)
    {
        if (operation != Operations.Multiplication && operation != Operations.Division)
        {
            //This condition should never be true on account of the fact that the pre-modifications performed before
            //adding/subtracting should avoid erroneous situations.
            return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
        }

        UnitInfo secondInfo2 = ConvertValueToBaseTen(secondInfo.Value);
        outInfo = VaryBaseTenExponent(outInfo, secondInfo2.BaseTenExponent, operation == Operations.Division);
        if (Math.Abs(secondInfo2.Value) == 1.0 || outInfo.Error.Type != ErrorTypes.None) return outInfo;
        
        try
        {
            outInfo = PerformManagedOperationUnits
            (
                outInfo, secondInfo2.Value, operation
            );
        }
        catch
        {
            //Very unlikely scenario on account of the fact that Math.Abs(secondInfo2.Value)
            //lies within the 0.1-10.0 range.
            outInfo = OperationValuesManageError
            (
                new UnitInfo(outInfo)
                {
                    Value = secondInfo2.Value,
                    BaseTenExponent = 0
                },
                new UnitInfo()
                {
                    Value = outInfo.Value,
                    BaseTenExponent = outInfo.BaseTenExponent
                },
                operation
            );
        }

        return outInfo;
    }

    static UnitInfo ConvertValueToBaseTen(double value)
    {
        value = Math.Abs(value);
        return FromValueToBaseTenExponent
        (
             new UnitInfo(value), Math.Abs(value), false
        );
    }

    static UnitInfo ConvertBaseTenToValue(UnitInfo unitInfo)
    {
        if (unitInfo.BaseTenExponent == 0) return unitInfo;

        UnitInfo outInfo = new UnitInfo(unitInfo);
        boolean decrease = unitInfo.BaseTenExponent > 0;
        int sign = Math.Sign(outInfo.Value);
        double absValue = Math.Abs(outInfo.Value);

        while (outInfo.BaseTenExponent != 0.0)
        {
            if (decrease)
            {
                if (absValue >= MaxValueDec / 10.0) break;
                absValue *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }
            else
            {
                if (absValue <= MinValueDec * 10.0) break;
                absValue /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
        }

        outInfo.Value = sign * absValue;

        return outInfo;
    }

    static UnitInfo NormaliseUnitInfo(UnitInfo unitInfo)
    {
        if (unitInfo.Value == 0 && unitInfo.Prefix.Factor == 1.0)
        {
            return unitInfo;
        }
        UnitInfo outInfo = new UnitInfo(unitInfo);

        if (outInfo.Prefix.Factor != 1)
        {
            outInfo = FromValueToBaseTenExponent
            (
                outInfo, outInfo.Prefix.Factor, true
            );
            outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage);
        }
        if (outInfo.Value == 0.0) return outInfo;

        outInfo = FromValueToBaseTenExponent
        (
            outInfo, outInfo.Value, false
        );

        return outInfo;
    }

    static UnitInfo FromValueToBaseTenExponent(UnitInfo outInfo, double value, boolean isPrefix)
    {
        if (value == 0.0) return outInfo;

        double valueAbs = Math.Abs(value);
        boolean decrease = (valueAbs > 1.0);
        if (!isPrefix)
        {
            outInfo.Value = outInfo.Value / valueAbs;
        }

        while (valueAbs != 1.0)
        {
            if ((valueAbs < 10.0 && valueAbs > 1.0) || (valueAbs > 0.1.0 && valueAbs < 1.0))
            {
                if (!isPrefix) outInfo.Value = value;
                else
                {
                    outInfo = PerformManagedOperationValues
                    (
                        outInfo, value, Operations.Multiplication
                    );
                }

                return outInfo;
            }

            if (decrease)
            {
                value /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
            else
            {
                value *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }

            valueAbs = Math.Abs(value);
        }

        return outInfo;
    }

    //Method used to vary BaseTenExponent without provoking unhandled exceptions (i.e., bigger than Integer.MAX_VALUE).
    static UnitInfo VaryBaseTenExponent(UnitInfo info, int baseTenIncrease, boolean isDivision = false)
    {
        long val1 = info.BaseTenExponent;
        long val2 = baseTenIncrease;

        if (isDivision)
        {
            //Converting a negative value into positive might provoke an overflow error for the int type
            //(e.g., Math.Abs(Integer.MAIN_VALUE)). Converting both variables to long is a quick and effective
            //way to avoid this problem.
            val2 *= -1;
        }

        return
        (
             ((val2 > 0 && val1 > Integer.MAX_VALUE - val2) || (val2 < 0 && val1 < Integer.MAIN_VALUE - val2)) ?
            new UnitInfo(info, ErrorTypes.NumericError) : new UnitInfo(info){{ BaseTenExponent = (int)(val1 + val2); }}
        );
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:476)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 2 2017-05-27 20:05:45.815
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:476)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 0 2017-05-27 20:05:45.815
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:476)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.core 4 4 2017-05-27 20:05:47.897
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
public class OperationsManaged
{
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, double second, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            firstInfo, new UnitInfo(second), operation
        );
    }

    public static UnitInfo PerformManagedOperationUnits(double first, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            new UnitInfo(first), secondInfo, operation
        );
    }

    //This method should always be used when dealing with random UnitInfo variables because it accounts for all the
    //possible scenarios. On the other hand, with simple operations (e.g., random UnitInfo & numeric type) it might
    //be better to use PerformManagedOperationValues. 
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        ErrorTypes errorType = InternalMethods.GetOperationError
        (
            firstInfo, secondInfo, operation
        );
        if (errorType != ErrorTypes.None)
        {
            return new UnitInfo(firstInfo) 
            {{
                Error = new ErrorInfo(errorType); 
            }};
        }

        return
        (
            operation == Operations.Addition || operation == Operations.Subtraction ?
            PerformManagedOperationAddition(firstInfo, secondInfo, operation) :
            PerformManagedOperationMultiplication(firstInfo, secondInfo, operation)
        );
    }

    static UnitInfo PerformManagedOperationAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {   
        //After being normalised, the operands might require further modifications.
        UnitInfo[] normalised = GetOperandsAddition(firstInfo, secondInfo, operation);

        return PerformManagedOperationNormalisedValues
        (
            firstInfo, normalised, operation
        );
    }

    static UnitInfo[] GetOperandsAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        UnitInfo[] operands2 = new UnitInfo[] 
        {
            new UnitInfo(firstInfo), new UnitInfo(secondInfo)
        };

        if (operands2[0].BaseTenExponent != operands2[1].BaseTenExponent || operands2[0].Prefix.Factor != operands2[1].Prefix.Factor)
        {
            //The addition/subtraction might not be performed right away even with normalised values.
            //For example: 5 and 6 from 5*10^2 and 6*10^7 cannot be added right away.
            operands2 = AdaptNormalisedValuesForAddition
            (
                new UnitInfo[] 
                { 
                    NormaliseUnitInfo(operands2[0]), 
                    NormaliseUnitInfo(operands2[1])
                },
                operation
            );
        }

        return operands2;
    }
    
    static UnitInfo[] AdaptNormalisedValuesForAddition(UnitInfo[] unitInfos2, Operations operation)
    {
        if (unitInfos2[0].BaseTenExponent == unitInfos2[1].BaseTenExponent)
        {
            //Having the same BaseTenExponent values means that the given operation can be performed right away.
            return unitInfos2;
        }

        int[] bigSmallI = 
        (
            unitInfos2[0].BaseTenExponent > unitInfos2[1].BaseTenExponent ?
            new int[] { 0, 1 } : new int[] { 1, 0 }
        );

        //Only the variable with the bigger value is modified. For example: 5*10^5 & 3*10^3 is converted
        //into 500*10^3 & 3*10^3 in order to allow the addition 500 + 3. 
        UnitInfo big2 = AdaptBiggerAdditionOperand(unitInfos2, bigSmallI, operation);
        if (big2.Error.Type != ErrorTypes.None)
        {
            return TooBigGapAddition(unitInfos2, bigSmallI, operation);
        }

        unitInfos2[bigSmallI[0]].Value = big2.Value;
        unitInfos2[bigSmallI[0]].BaseTenExponent = unitInfos2[bigSmallI[1]].BaseTenExponent;

        return unitInfos2;
    }

    //When adding/subtracting two numbers whose gap is bigger than the maximum double range, there
    //is no need to perform any operation (i.e., no change will be observed because of being outside
    //the maximum supported precision). This method takes care of these cases and returns the expected
    //output (i.e., biggest value).
    static UnitInfo[] TooBigGapAddition(UnitInfo[] unitInfos2, int[] bigSmallI, Operations operation)
    {
        UnitInfo[] outInfos = new UnitInfo[] 
        {
            //First operand (i.e., one whose information defines the operation) together with the
            //numeric information (i.e., just Value and BaseTenExponent because both are normalised)
            //which is associated with the biggest one.
            new UnitInfo(unitInfos2[0])
            {{
                Value = unitInfos2[bigSmallI[0]].Value;
                BaseTenExponent = unitInfos2[bigSmallI[0]].BaseTenExponent;
            }}
        };

        if (operation == Operations.Subtraction && bigSmallI[0] == 1)
        {
            outInfos[0].Value = -1.0 * outInfos[0].Value;
        }

        if (outInfos[0].Unit == Units.Unitless)
        {
            outInfos[0].Unit = unitInfos2[bigSmallI[1]].Unit;
        }

        return outInfos;
    }

    static UnitInfo AdaptBiggerAdditionOperand(UnitInfo[] unitInfos2, Integer[] bigSmallI, Operations operation)
    {
        int gapExponent = unitInfos2[bigSmallI[0]].BaseTenExponent - unitInfos2[bigSmallI[1]].BaseTenExponent;
        if (gapExponent >= 27)
        {
            //The difference between both inputs is bigger than (or, at least, very close to) the maximum double value/precision;
            //what makes this situation calculation unworthy and the first operand to be returned as the result.
            //Note that the error below these lines is just an easy way to tell the calling function about this eventuality.
            return new UnitInfo(unitInfos2[0]) 
            {{ 
                Error = new ErrorInfo(ErrorTypes.InvalidOperation); 
            }};
        }

        //PerformManagedOperationValues is used to make sure that the resulting numeric information is stored
        //in Value (if possible).
        UnitInfo big2 = PerformManagedOperationValues
        (
            RaiseToIntegerExponent(10.0, gapExponent), unitInfos2[bigSmallI[0]].Value, 
            Operations.Multiplication                
        );

        boolean isWrong = 
        (
            big2.Error.Type != ErrorTypes.None || big2.BaseTenExponent != 0 ?
            
            //The value of the bigger input times 10^(gap between BaseTenExponent of inputs) is too big. 
            isWrong = true :
            
            //Overflow-check very unlikely to trigger an error. In fact, with properly normalised variables,
            //triggering an error would be plainly impossible.               
            AreAdditionFinalValuesWrong
            (
                unitInfos2[0].Value, unitInfos2[1].Value, operation
            )
        );

        UnitInfo temp = null;
        if (isWrong)
        {
        	temp = new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }};
            
            temp.Error = new ErrorInfo(ErrorTypes.InvalidOperation);
        }
        else
        {
        	new UnitInfo(unitInfos2[bigSmallI[0]])
            {{
                Value = big2.Value;
            }}
        }
        
        
        return temp;
        
        
        return
        (
            isWrong ?
            //This error is just an easy way to let the calling function know about the fact that no
            //calculation has been performed (too big gap). This isn't a properly-speaking error and
            //that's why it will not be notified to the user.
            new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }} :
            //Returning the new big value. For example: with 5*10^4 & 3*10^2, 500 would be returned.
            new UnitInfo(unitInfos2[bigSmallI[0]])
            {{
                Value = big2.Value;
            }}
        )
    }

    static boolean AreAdditionFinalValuesWrong(double val1, double val2, Operations operation)
    {
        boolean isWrong = false;

        try
        {
            val1 = val1 + val2 *
            (
                operation == Operations.Addition ? 1 : -1
            );
        }
        catch { isWrong = true; }

        return isWrong;
    }

    static UnitInfo PerformManagedOperationMultiplication(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationNormalisedValues
        (
            firstInfo, new UnitInfo[] 
            { 
                NormaliseUnitInfo(firstInfo),
                NormaliseUnitInfo(secondInfo) 
            },
            operation
        );
    }

    public static UnitInfo RaiseToIntegerExponent(double baseValue, int exponent)
    {
        return RaiseToIntegerExponent(new UnitInfo(baseValue), exponent);
    }

    static UnitInfo RaiseToIntegerExponent(UnitInfo baseInfo, int exponent)
    {
        if (exponent <= 1 && exponent >= 0)
        {
            baseInfo.Value = (exponent == 0 ? 1.0 : baseInfo.Value);
            return baseInfo;
        }

        UnitInfo outInfo = new UnitInfo(baseInfo);

        for (int i = 1; i < Math.Abs(exponent); i++)
        {
            outInfo = PerformManagedOperationValues
            (
                outInfo, baseInfo, Operations.Multiplication
            );
            if (outInfo.Error.Type != ErrorTypes.None) return outInfo;
        }

        return
        (
            exponent < 0 ?
            PerformManagedOperationValues(new UnitInfo(1.0), outInfo, Operations.Division) :
            outInfo
        );
    }

    static UnitInfo PerformManagedOperationNormalisedValues(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        outInfo =
        (
            normalisedInfos.Length == 1 ?
            //There is just one operand when the difference between both of them is too big.
            outInfo = normalisedInfos[0] :
            PerformManagedOperationTwoOperands(outInfo, normalisedInfos, operation)
        );

        return outInfo;
    }

    static UnitInfo PerformManagedOperationTwoOperands(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        UnitInfo outInfoNormalised = PerformManagedOperationValues
        (
            normalisedInfos[0], normalisedInfos[1], operation
        );

        if (outInfo.Error.Type != ErrorTypes.None)
        {
            return new UnitInfo(outInfo)
            {
                Error = new ErrorInfo(ErrorTypes.NumericError)
            };
        }

        outInfo.BaseTenExponent = outInfoNormalised.BaseTenExponent;
        outInfo.Value = outInfoNormalised.Value;
        //Normalised means no prefixes.
        outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage); 

        return outInfo;
    }

    static UnitInfo PerformManagedOperationValues(double firstValue, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            new UnitInfo(firstValue), new UnitInfo(secondValue), operation
        );
    }

    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            firstInfo, new UnitInfo(secondValue), operation
        );
    }

    //This method might be used to perform full operations (not just being the last calculation step) instead
    //of the default one (PerformManagedOperationUnits) for simple cases. That is: ones not dealing with the
    //complex numeric reality (Value, Prefix and BaseTenExponent) which makes a pre-analysis required.
    //Note that, unlikely what happens with PerformMangedOperationUnits, the outputs of this method aren't
    //normalised (= primarily stored under Value), what is useful in certain contexts.
    //NOTE: this function assumes that both inputs are normalised, what means that no prefix information is expected.
    //It might also be used with non-normalised inputs, but their prefix information would be plainly ignored.
    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        if (firstInfo.Value == 0.0 || secondInfo.Value == 0.0)
        {
            if (operation == Operations.Multiplication || operation == Operations.Division)
            {
                //Dividing by zero scenarios are taken into account somewhere else.
                return new UnitInfo(firstInfo) { Value = 0.0 };
            }
        }

        UnitInfo outInfo = new UnitInfo(firstInfo);
        UnitInfo firstInfo0 = new UnitInfo(firstInfo);
        UnitInfo secondInfo0 = new UnitInfo(secondInfo);

        boolean isWrong = false;
        try
        {
            if (operation == Operations.Addition)
            {
                outInfo.Value += secondInfo0.Value;
            }
            else if (operation == Operations.Subtraction)
            {
                outInfo.Value -= secondInfo.Value;
            }
            else
            {
                //The reason for checking whether BaseTenExponent is inside/outside the int range before performing 
                //the operation (rather than going ahead and eventually catching the resulting exception) isn't just
                //being quicker, but also the only option in many situations. Note that an addition/subtraction between
                //two int variables whose result is outside the int range might not trigger an exception (+ random 
                //negative value as output).
                if (VaryBaseTenExponent(outInfo, secondInfo0.BaseTenExponent, operation == Operations.Division).Error.Type != ErrorTypes.None)
                {
                    return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
                }

                if (operation == Operations.Multiplication)
                {
                    outInfo.Value *= secondInfo.Value;
                    outInfo.BaseTenExponent += secondInfo.BaseTenExponent;
                }
                else if (operation == Operations.Division)
                {
                    if (secondInfo.Value == 0.0)
                    {
                        return
                        (
                            new UnitInfo(outInfo) 
                            { 
                                Error = new ErrorInfo(ErrorTypes.NumericError) 
                            }
                        );
                    }
                    outInfo.Value /= secondInfo.Value;
                    outInfo.BaseTenExponent -= secondInfo.BaseTenExponent;
                }
            }
        }
        catch { isWrong = true; }

        return
        (
            //An error might not be triggered despite of dealing with numbers outside double precision.
            //For example: 0.00000000000000000001m * 0.0000000000000000000001m can output 0.0 without triggering an error. 
            isWrong || ((operation == Operations.Multiplication || operation == Operations.Division) && outInfo.Value == 0.0.0) ?
            OperationValuesManageError(firstInfo0, secondInfo0, operation) : outInfo
        );
    }

    static UnitInfo OperationValuesManageError(UnitInfo outInfo, UnitInfo secondInfo, Operations operation)
    {
        if (operation != Operations.Multiplication && operation != Operations.Division)
        {
            //This condition should never be true on account of the fact that the pre-modifications performed before
            //adding/subtracting should avoid erroneous situations.
            return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
        }

        UnitInfo secondInfo2 = ConvertValueToBaseTen(secondInfo.Value);
        outInfo = VaryBaseTenExponent(outInfo, secondInfo2.BaseTenExponent, operation == Operations.Division);
        if (Math.Abs(secondInfo2.Value) == 1.0 || outInfo.Error.Type != ErrorTypes.None) return outInfo;
        
        try
        {
            outInfo = PerformManagedOperationUnits
            (
                outInfo, secondInfo2.Value, operation
            );
        }
        catch
        {
            //Very unlikely scenario on account of the fact that Math.Abs(secondInfo2.Value)
            //lies within the 0.1-10.0 range.
            outInfo = OperationValuesManageError
            (
                new UnitInfo(outInfo)
                {
                    Value = secondInfo2.Value,
                    BaseTenExponent = 0
                },
                new UnitInfo()
                {
                    Value = outInfo.Value,
                    BaseTenExponent = outInfo.BaseTenExponent
                },
                operation
            );
        }

        return outInfo;
    }

    static UnitInfo ConvertValueToBaseTen(double value)
    {
        value = Math.Abs(value);
        return FromValueToBaseTenExponent
        (
             new UnitInfo(value), Math.Abs(value), false
        );
    }

    static UnitInfo ConvertBaseTenToValue(UnitInfo unitInfo)
    {
        if (unitInfo.BaseTenExponent == 0) return unitInfo;

        UnitInfo outInfo = new UnitInfo(unitInfo);
        boolean decrease = unitInfo.BaseTenExponent > 0;
        int sign = Math.Sign(outInfo.Value);
        double absValue = Math.Abs(outInfo.Value);

        while (outInfo.BaseTenExponent != 0.0)
        {
            if (decrease)
            {
                if (absValue >= MaxValueDec / 10.0) break;
                absValue *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }
            else
            {
                if (absValue <= MinValueDec * 10.0) break;
                absValue /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
        }

        outInfo.Value = sign * absValue;

        return outInfo;
    }

    static UnitInfo NormaliseUnitInfo(UnitInfo unitInfo)
    {
        if (unitInfo.Value == 0 && unitInfo.Prefix.Factor == 1.0)
        {
            return unitInfo;
        }
        UnitInfo outInfo = new UnitInfo(unitInfo);

        if (outInfo.Prefix.Factor != 1)
        {
            outInfo = FromValueToBaseTenExponent
            (
                outInfo, outInfo.Prefix.Factor, true
            );
            outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage);
        }
        if (outInfo.Value == 0.0) return outInfo;

        outInfo = FromValueToBaseTenExponent
        (
            outInfo, outInfo.Value, false
        );

        return outInfo;
    }

    static UnitInfo FromValueToBaseTenExponent(UnitInfo outInfo, double value, boolean isPrefix)
    {
        if (value == 0.0) return outInfo;

        double valueAbs = Math.Abs(value);
        boolean decrease = (valueAbs > 1.0);
        if (!isPrefix)
        {
            outInfo.Value = outInfo.Value / valueAbs;
        }

        while (valueAbs != 1.0)
        {
            if ((valueAbs < 10.0 && valueAbs > 1.0) || (valueAbs > 0.1.0 && valueAbs < 1.0))
            {
                if (!isPrefix) outInfo.Value = value;
                else
                {
                    outInfo = PerformManagedOperationValues
                    (
                        outInfo, value, Operations.Multiplication
                    );
                }

                return outInfo;
            }

            if (decrease)
            {
                value /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
            else
            {
                value *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }

            valueAbs = Math.Abs(value);
        }

        return outInfo;
    }

    //Method used to vary BaseTenExponent without provoking unhandled exceptions (i.e., bigger than Integer.MAX_VALUE).
    static UnitInfo VaryBaseTenExponent(UnitInfo info, int baseTenIncrease, boolean isDivision = false)
    {
        long val1 = info.BaseTenExponent;
        long val2 = baseTenIncrease;

        if (isDivision)
        {
            //Converting a negative value into positive might provoke an overflow error for the int type
            //(e.g., Math.Abs(Integer.MAIN_VALUE)). Converting both variables to long is a quick and effective
            //way to avoid this problem.
            val2 *= -1;
        }

        return
        (
             ((val2 > 0 && val1 > Integer.MAX_VALUE - val2) || (val2 < 0 && val1 < Integer.MAIN_VALUE - val2)) ?
            new UnitInfo(info, ErrorTypes.NumericError) : new UnitInfo(info){{ BaseTenExponent = (int)(val1 + val2); }}
        );
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 2 2017-05-27 20:05:47.897
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 0 2017-05-27 20:05:47.897
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.core 4 4 2017-05-27 20:05:47.988
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
public class OperationsManaged
{
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, double second, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            firstInfo, new UnitInfo(second), operation
        );
    }

    public static UnitInfo PerformManagedOperationUnits(double first, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            new UnitInfo(first), secondInfo, operation
        );
    }

    //This method should always be used when dealing with random UnitInfo variables because it accounts for all the
    //possible scenarios. On the other hand, with simple operations (e.g., random UnitInfo & numeric type) it might
    //be better to use PerformManagedOperationValues. 
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        ErrorTypes errorType = InternalMethods.GetOperationError
        (
            firstInfo, secondInfo, operation
        );
        if (errorType != ErrorTypes.None)
        {
            return new UnitInfo(firstInfo) 
            {{
                Error = new ErrorInfo(errorType); 
            }};
        }

        return
        (
            operation == Operations.Addition || operation == Operations.Subtraction ?
            PerformManagedOperationAddition(firstInfo, secondInfo, operation) :
            PerformManagedOperationMultiplication(firstInfo, secondInfo, operation)
        );
    }

    static UnitInfo PerformManagedOperationAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {   
        //After being normalised, the operands might require further modifications.
        UnitInfo[] normalised = GetOperandsAddition(firstInfo, secondInfo, operation);

        return PerformManagedOperationNormalisedValues
        (
            firstInfo, normalised, operation
        );
    }

    static UnitInfo[] GetOperandsAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        UnitInfo[] operands2 = new UnitInfo[] 
        {
            new UnitInfo(firstInfo), new UnitInfo(secondInfo)
        };

        if (operands2[0].BaseTenExponent != operands2[1].BaseTenExponent || operands2[0].Prefix.Factor != operands2[1].Prefix.Factor)
        {
            //The addition/subtraction might not be performed right away even with normalised values.
            //For example: 5 and 6 from 5*10^2 and 6*10^7 cannot be added right away.
            operands2 = AdaptNormalisedValuesForAddition
            (
                new UnitInfo[] 
                { 
                    NormaliseUnitInfo(operands2[0]), 
                    NormaliseUnitInfo(operands2[1])
                },
                operation
            );
        }

        return operands2;
    }
    
    static UnitInfo[] AdaptNormalisedValuesForAddition(UnitInfo[] unitInfos2, Operations operation)
    {
        if (unitInfos2[0].BaseTenExponent == unitInfos2[1].BaseTenExponent)
        {
            //Having the same BaseTenExponent values means that the given operation can be performed right away.
            return unitInfos2;
        }

        int[] bigSmallI = 
        (
            unitInfos2[0].BaseTenExponent > unitInfos2[1].BaseTenExponent ?
            new int[] { 0, 1 } : new int[] { 1, 0 }
        );

        //Only the variable with the bigger value is modified. For example: 5*10^5 & 3*10^3 is converted
        //into 500*10^3 & 3*10^3 in order to allow the addition 500 + 3. 
        UnitInfo big2 = AdaptBiggerAdditionOperand(unitInfos2, bigSmallI, operation);
        if (big2.Error.Type != ErrorTypes.None)
        {
            return TooBigGapAddition(unitInfos2, bigSmallI, operation);
        }

        unitInfos2[bigSmallI[0]].Value = big2.Value;
        unitInfos2[bigSmallI[0]].BaseTenExponent = unitInfos2[bigSmallI[1]].BaseTenExponent;

        return unitInfos2;
    }

    //When adding/subtracting two numbers whose gap is bigger than the maximum double range, there
    //is no need to perform any operation (i.e., no change will be observed because of being outside
    //the maximum supported precision). This method takes care of these cases and returns the expected
    //output (i.e., biggest value).
    static UnitInfo[] TooBigGapAddition(UnitInfo[] unitInfos2, int[] bigSmallI, Operations operation)
    {
        UnitInfo[] outInfos = new UnitInfo[] 
        {
            //First operand (i.e., one whose information defines the operation) together with the
            //numeric information (i.e., just Value and BaseTenExponent because both are normalised)
            //which is associated with the biggest one.
            new UnitInfo(unitInfos2[0])
            {{
                Value = unitInfos2[bigSmallI[0]].Value;
                BaseTenExponent = unitInfos2[bigSmallI[0]].BaseTenExponent;
            }}
        };

        if (operation == Operations.Subtraction && bigSmallI[0] == 1)
        {
            outInfos[0].Value = -1.0 * outInfos[0].Value;
        }

        if (outInfos[0].Unit == Units.Unitless)
        {
            outInfos[0].Unit = unitInfos2[bigSmallI[1]].Unit;
        }

        return outInfos;
    }

    static UnitInfo AdaptBiggerAdditionOperand(UnitInfo[] unitInfos2, Integer[] bigSmallI, Operations operation)
    {
        int gapExponent = unitInfos2[bigSmallI[0]].BaseTenExponent - unitInfos2[bigSmallI[1]].BaseTenExponent;
        if (gapExponent >= 27)
        {
            //The difference between both inputs is bigger than (or, at least, very close to) the maximum double value/precision;
            //what makes this situation calculation unworthy and the first operand to be returned as the result.
            //Note that the error below these lines is just an easy way to tell the calling function about this eventuality.
            return new UnitInfo(unitInfos2[0]) 
            {{ 
                Error = new ErrorInfo(ErrorTypes.InvalidOperation); 
            }};
        }

        //PerformManagedOperationValues is used to make sure that the resulting numeric information is stored
        //in Value (if possible).
        UnitInfo big2 = PerformManagedOperationValues
        (
            RaiseToIntegerExponent(10.0, gapExponent), unitInfos2[bigSmallI[0]].Value, 
            Operations.Multiplication                
        );

        boolean isWrong = 
        (
            big2.Error.Type != ErrorTypes.None || big2.BaseTenExponent != 0 ?
            
            //The value of the bigger input times 10^(gap between BaseTenExponent of inputs) is too big. 
            isWrong = true :
            
            //Overflow-check very unlikely to trigger an error. In fact, with properly normalised variables,
            //triggering an error would be plainly impossible.               
            AreAdditionFinalValuesWrong
            (
                unitInfos2[0].Value, unitInfos2[1].Value, operation
            )
        );

        UnitInfo temp = null;
        if (isWrong)
        {
        	temp = new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }};
            
            temp.Error = new ErrorInfo(ErrorTypes.InvalidOperation);
        }
        else
        {
        	new UnitInfo(unitInfos2[bigSmallI[0]])
            {{
                Value = big2.Value;
            }}
        }
        
        
        return temp;
        
        
        return
        (
            isWrong ?
            //This error is just an easy way to let the calling function know about the fact that no
            //calculation has been performed (too big gap). This isn't a properly-speaking error and
            //that's why it will not be notified to the user.
            new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }} :
            //Returning the new big value. For example: with 5*10^4 & 3*10^2, 500 would be returned.
            new UnitInfo(unitInfos2[bigSmallI[0]])
            {{
                Value = big2.Value;
            }}
        )
    }

    static boolean AreAdditionFinalValuesWrong(double val1, double val2, Operations operation)
    {
        boolean isWrong = false;

        try
        {
            val1 = val1 + val2 *
            (
                operation == Operations.Addition ? 1 : -1
            );
        }
        catch { isWrong = true; }

        return isWrong;
    }

    static UnitInfo PerformManagedOperationMultiplication(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationNormalisedValues
        (
            firstInfo, new UnitInfo[] 
            { 
                NormaliseUnitInfo(firstInfo),
                NormaliseUnitInfo(secondInfo) 
            },
            operation
        );
    }

    public static UnitInfo RaiseToIntegerExponent(double baseValue, int exponent)
    {
        return RaiseToIntegerExponent(new UnitInfo(baseValue), exponent);
    }

    static UnitInfo RaiseToIntegerExponent(UnitInfo baseInfo, int exponent)
    {
        if (exponent <= 1 && exponent >= 0)
        {
            baseInfo.Value = (exponent == 0 ? 1.0 : baseInfo.Value);
            return baseInfo;
        }

        UnitInfo outInfo = new UnitInfo(baseInfo);

        for (int i = 1; i < Math.Abs(exponent); i++)
        {
            outInfo = PerformManagedOperationValues
            (
                outInfo, baseInfo, Operations.Multiplication
            );
            if (outInfo.Error.Type != ErrorTypes.None) return outInfo;
        }

        return
        (
            exponent < 0 ?
            PerformManagedOperationValues(new UnitInfo(1.0), outInfo, Operations.Division) :
            outInfo
        );
    }

    static UnitInfo PerformManagedOperationNormalisedValues(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        outInfo =
        (
            normalisedInfos.Length == 1 ?
            //There is just one operand when the difference between both of them is too big.
            outInfo = normalisedInfos[0] :
            PerformManagedOperationTwoOperands(outInfo, normalisedInfos, operation)
        );

        return outInfo;
    }

    static UnitInfo PerformManagedOperationTwoOperands(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        UnitInfo outInfoNormalised = PerformManagedOperationValues
        (
            normalisedInfos[0], normalisedInfos[1], operation
        );

        if (outInfo.Error.Type != ErrorTypes.None)
        {
            return new UnitInfo(outInfo)
            {
                Error = new ErrorInfo(ErrorTypes.NumericError)
            };
        }

        outInfo.BaseTenExponent = outInfoNormalised.BaseTenExponent;
        outInfo.Value = outInfoNormalised.Value;
        //Normalised means no prefixes.
        outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage); 

        return outInfo;
    }

    static UnitInfo PerformManagedOperationValues(double firstValue, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            new UnitInfo(firstValue), new UnitInfo(secondValue), operation
        );
    }

    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            firstInfo, new UnitInfo(secondValue), operation
        );
    }

    //This method might be used to perform full operations (not just being the last calculation step) instead
    //of the default one (PerformManagedOperationUnits) for simple cases. That is: ones not dealing with the
    //complex numeric reality (Value, Prefix and BaseTenExponent) which makes a pre-analysis required.
    //Note that, unlikely what happens with PerformMangedOperationUnits, the outputs of this method aren't
    //normalised (= primarily stored under Value), what is useful in certain contexts.
    //NOTE: this function assumes that both inputs are normalised, what means that no prefix information is expected.
    //It might also be used with non-normalised inputs, but their prefix information would be plainly ignored.
    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        if (firstInfo.Value == 0.0 || secondInfo.Value == 0.0)
        {
            if (operation == Operations.Multiplication || operation == Operations.Division)
            {
                //Dividing by zero scenarios are taken into account somewhere else.
                return new UnitInfo(firstInfo) { Value = 0.0 };
            }
        }

        UnitInfo outInfo = new UnitInfo(firstInfo);
        UnitInfo firstInfo0 = new UnitInfo(firstInfo);
        UnitInfo secondInfo0 = new UnitInfo(secondInfo);

        boolean isWrong = false;
        try
        {
            if (operation == Operations.Addition)
            {
                outInfo.Value += secondInfo0.Value;
            }
            else if (operation == Operations.Subtraction)
            {
                outInfo.Value -= secondInfo.Value;
            }
            else
            {
                //The reason for checking whether BaseTenExponent is inside/outside the int range before performing 
                //the operation (rather than going ahead and eventually catching the resulting exception) isn't just
                //being quicker, but also the only option in many situations. Note that an addition/subtraction between
                //two int variables whose result is outside the int range might not trigger an exception (+ random 
                //negative value as output).
                if (VaryBaseTenExponent(outInfo, secondInfo0.BaseTenExponent, operation == Operations.Division).Error.Type != ErrorTypes.None)
                {
                    return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
                }

                if (operation == Operations.Multiplication)
                {
                    outInfo.Value *= secondInfo.Value;
                    outInfo.BaseTenExponent += secondInfo.BaseTenExponent;
                }
                else if (operation == Operations.Division)
                {
                    if (secondInfo.Value == 0.0)
                    {
                        return
                        (
                            new UnitInfo(outInfo) 
                            { 
                                Error = new ErrorInfo(ErrorTypes.NumericError) 
                            }
                        );
                    }
                    outInfo.Value /= secondInfo.Value;
                    outInfo.BaseTenExponent -= secondInfo.BaseTenExponent;
                }
            }
        }
        catch { isWrong = true; }

        return
        (
            //An error might not be triggered despite of dealing with numbers outside double precision.
            //For example: 0.00000000000000000001m * 0.0000000000000000000001m can output 0.0 without triggering an error. 
            isWrong || ((operation == Operations.Multiplication || operation == Operations.Division) && outInfo.Value == 0.0.0) ?
            OperationValuesManageError(firstInfo0, secondInfo0, operation) : outInfo
        );
    }

    static UnitInfo OperationValuesManageError(UnitInfo outInfo, UnitInfo secondInfo, Operations operation)
    {
        if (operation != Operations.Multiplication && operation != Operations.Division)
        {
            //This condition should never be true on account of the fact that the pre-modifications performed before
            //adding/subtracting should avoid erroneous situations.
            return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
        }

        UnitInfo secondInfo2 = ConvertValueToBaseTen(secondInfo.Value);
        outInfo = VaryBaseTenExponent(outInfo, secondInfo2.BaseTenExponent, operation == Operations.Division);
        if (Math.Abs(secondInfo2.Value) == 1.0 || outInfo.Error.Type != ErrorTypes.None) return outInfo;
        
        try
        {
            outInfo = PerformManagedOperationUnits
            (
                outInfo, secondInfo2.Value, operation
            );
        }
        catch
        {
            //Very unlikely scenario on account of the fact that Math.Abs(secondInfo2.Value)
            //lies within the 0.1-10.0 range.
            outInfo = OperationValuesManageError
            (
                new UnitInfo(outInfo)
                {
                    Value = secondInfo2.Value,
                    BaseTenExponent = 0
                },
                new UnitInfo()
                {
                    Value = outInfo.Value,
                    BaseTenExponent = outInfo.BaseTenExponent
                },
                operation
            );
        }

        return outInfo;
    }

    static UnitInfo ConvertValueToBaseTen(double value)
    {
        value = Math.Abs(value);
        return FromValueToBaseTenExponent
        (
             new UnitInfo(value), Math.Abs(value), false
        );
    }

    static UnitInfo ConvertBaseTenToValue(UnitInfo unitInfo)
    {
        if (unitInfo.BaseTenExponent == 0) return unitInfo;

        UnitInfo outInfo = new UnitInfo(unitInfo);
        boolean decrease = unitInfo.BaseTenExponent > 0;
        int sign = Math.Sign(outInfo.Value);
        double absValue = Math.Abs(outInfo.Value);

        while (outInfo.BaseTenExponent != 0.0)
        {
            if (decrease)
            {
                if (absValue >= MaxValueDec / 10.0) break;
                absValue *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }
            else
            {
                if (absValue <= MinValueDec * 10.0) break;
                absValue /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
        }

        outInfo.Value = sign * absValue;

        return outInfo;
    }

    static UnitInfo NormaliseUnitInfo(UnitInfo unitInfo)
    {
        if (unitInfo.Value == 0 && unitInfo.Prefix.Factor == 1.0)
        {
            return unitInfo;
        }
        UnitInfo outInfo = new UnitInfo(unitInfo);

        if (outInfo.Prefix.Factor != 1)
        {
            outInfo = FromValueToBaseTenExponent
            (
                outInfo, outInfo.Prefix.Factor, true
            );
            outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage);
        }
        if (outInfo.Value == 0.0) return outInfo;

        outInfo = FromValueToBaseTenExponent
        (
            outInfo, outInfo.Value, false
        );

        return outInfo;
    }

    static UnitInfo FromValueToBaseTenExponent(UnitInfo outInfo, double value, boolean isPrefix)
    {
        if (value == 0.0) return outInfo;

        double valueAbs = Math.Abs(value);
        boolean decrease = (valueAbs > 1.0);
        if (!isPrefix)
        {
            outInfo.Value = outInfo.Value / valueAbs;
        }

        while (valueAbs != 1.0)
        {
            if ((valueAbs < 10.0 && valueAbs > 1.0) || (valueAbs > 0.1.0 && valueAbs < 1.0))
            {
                if (!isPrefix) outInfo.Value = value;
                else
                {
                    outInfo = PerformManagedOperationValues
                    (
                        outInfo, value, Operations.Multiplication
                    );
                }

                return outInfo;
            }

            if (decrease)
            {
                value /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
            else
            {
                value *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }

            valueAbs = Math.Abs(value);
        }

        return outInfo;
    }

    //Method used to vary BaseTenExponent without provoking unhandled exceptions (i.e., bigger than Integer.MAX_VALUE).
    static UnitInfo VaryBaseTenExponent(UnitInfo info, int baseTenIncrease, boolean isDivision = false)
    {
        long val1 = info.BaseTenExponent;
        long val2 = baseTenIncrease;

        if (isDivision)
        {
            //Converting a negative value into positive might provoke an overflow error for the int type
            //(e.g., Math.Abs(Integer.MAIN_VALUE)). Converting both variables to long is a quick and effective
            //way to avoid this problem.
            val2 *= -1;
        }

        return
        (
             ((val2 > 0 && val1 > Integer.MAX_VALUE - val2) || (val2 < 0 && val1 < Integer.MAIN_VALUE - val2)) ?
            new UnitInfo(info, ErrorTypes.NumericError) : new UnitInfo(info){{ BaseTenExponent = (int)(val1 + val2); }}
        );
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.recommenders.rcp.utils.JdtUtils.findAstNodeFromEditorSelection(JdtUtils.java:669)
	at org.eclipse.recommenders.internal.rcp.JavaElementSelectionService.handleSelectionInEditor(JavaElementSelectionService.java:110)
	at org.eclipse.recommenders.internal.rcp.JavaElementSelectionService.access$1(JavaElementSelectionService.java:105)
	at org.eclipse.recommenders.internal.rcp.JavaElementSelectionService$1.run(JavaElementSelectionService.java:82)
	at java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source)
	at java.util.concurrent.FutureTask.run(Unknown Source)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(Unknown Source)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(Unknown Source)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source)
	at java.lang.Thread.run(Unknown Source)

!ENTRY org.eclipse.jdt.ui 4 2 2017-05-27 20:05:47.989
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.recommenders.rcp.utils.JdtUtils.findAstNodeFromEditorSelection(JdtUtils.java:669)
	at org.eclipse.recommenders.internal.rcp.JavaElementSelectionService.handleSelectionInEditor(JavaElementSelectionService.java:110)
	at org.eclipse.recommenders.internal.rcp.JavaElementSelectionService.access$1(JavaElementSelectionService.java:105)
	at org.eclipse.recommenders.internal.rcp.JavaElementSelectionService$1.run(JavaElementSelectionService.java:82)
	at java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source)
	at java.util.concurrent.FutureTask.run(Unknown Source)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(Unknown Source)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(Unknown Source)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source)
	at java.lang.Thread.run(Unknown Source)

!ENTRY org.eclipse.jdt.ui 4 0 2017-05-27 20:05:47.989
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.recommenders.rcp.utils.JdtUtils.findAstNodeFromEditorSelection(JdtUtils.java:669)
	at org.eclipse.recommenders.internal.rcp.JavaElementSelectionService.handleSelectionInEditor(JavaElementSelectionService.java:110)
	at org.eclipse.recommenders.internal.rcp.JavaElementSelectionService.access$1(JavaElementSelectionService.java:105)
	at org.eclipse.recommenders.internal.rcp.JavaElementSelectionService$1.run(JavaElementSelectionService.java:82)
	at java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source)
	at java.util.concurrent.FutureTask.run(Unknown Source)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(Unknown Source)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(Unknown Source)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source)
	at java.lang.Thread.run(Unknown Source)

!ENTRY org.eclipse.jdt.core 4 4 2017-05-27 20:05:48.628
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
public class OperationsManaged
{
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, double second, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            firstInfo, new UnitInfo(second), operation
        );
    }

    public static UnitInfo PerformManagedOperationUnits(double first, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            new UnitInfo(first), secondInfo, operation
        );
    }

    //This method should always be used when dealing with random UnitInfo variables because it accounts for all the
    //possible scenarios. On the other hand, with simple operations (e.g., random UnitInfo & numeric type) it might
    //be better to use PerformManagedOperationValues. 
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        ErrorTypes errorType = InternalMethods.GetOperationError
        (
            firstInfo, secondInfo, operation
        );
        if (errorType != ErrorTypes.None)
        {
            return new UnitInfo(firstInfo) 
            {{
                Error = new ErrorInfo(errorType); 
            }};
        }

        return
        (
            operation == Operations.Addition || operation == Operations.Subtraction ?
            PerformManagedOperationAddition(firstInfo, secondInfo, operation) :
            PerformManagedOperationMultiplication(firstInfo, secondInfo, operation)
        );
    }

    static UnitInfo PerformManagedOperationAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {   
        //After being normalised, the operands might require further modifications.
        UnitInfo[] normalised = GetOperandsAddition(firstInfo, secondInfo, operation);

        return PerformManagedOperationNormalisedValues
        (
            firstInfo, normalised, operation
        );
    }

    static UnitInfo[] GetOperandsAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        UnitInfo[] operands2 = new UnitInfo[] 
        {
            new UnitInfo(firstInfo), new UnitInfo(secondInfo)
        };

        if (operands2[0].BaseTenExponent != operands2[1].BaseTenExponent || operands2[0].Prefix.Factor != operands2[1].Prefix.Factor)
        {
            //The addition/subtraction might not be performed right away even with normalised values.
            //For example: 5 and 6 from 5*10^2 and 6*10^7 cannot be added right away.
            operands2 = AdaptNormalisedValuesForAddition
            (
                new UnitInfo[] 
                { 
                    NormaliseUnitInfo(operands2[0]), 
                    NormaliseUnitInfo(operands2[1])
                },
                operation
            );
        }

        return operands2;
    }
    
    static UnitInfo[] AdaptNormalisedValuesForAddition(UnitInfo[] unitInfos2, Operations operation)
    {
        if (unitInfos2[0].BaseTenExponent == unitInfos2[1].BaseTenExponent)
        {
            //Having the same BaseTenExponent values means that the given operation can be performed right away.
            return unitInfos2;
        }

        int[] bigSmallI = 
        (
            unitInfos2[0].BaseTenExponent > unitInfos2[1].BaseTenExponent ?
            new int[] { 0, 1 } : new int[] { 1, 0 }
        );

        //Only the variable with the bigger value is modified. For example: 5*10^5 & 3*10^3 is converted
        //into 500*10^3 & 3*10^3 in order to allow the addition 500 + 3. 
        UnitInfo big2 = AdaptBiggerAdditionOperand(unitInfos2, bigSmallI, operation);
        if (big2.Error.Type != ErrorTypes.None)
        {
            return TooBigGapAddition(unitInfos2, bigSmallI, operation);
        }

        unitInfos2[bigSmallI[0]].Value = big2.Value;
        unitInfos2[bigSmallI[0]].BaseTenExponent = unitInfos2[bigSmallI[1]].BaseTenExponent;

        return unitInfos2;
    }

    //When adding/subtracting two numbers whose gap is bigger than the maximum double range, there
    //is no need to perform any operation (i.e., no change will be observed because of being outside
    //the maximum supported precision). This method takes care of these cases and returns the expected
    //output (i.e., biggest value).
    static UnitInfo[] TooBigGapAddition(UnitInfo[] unitInfos2, int[] bigSmallI, Operations operation)
    {
        UnitInfo[] outInfos = new UnitInfo[] 
        {
            //First operand (i.e., one whose information defines the operation) together with the
            //numeric information (i.e., just Value and BaseTenExponent because both are normalised)
            //which is associated with the biggest one.
            new UnitInfo(unitInfos2[0])
            {{
                Value = unitInfos2[bigSmallI[0]].Value;
                BaseTenExponent = unitInfos2[bigSmallI[0]].BaseTenExponent;
            }}
        };

        if (operation == Operations.Subtraction && bigSmallI[0] == 1)
        {
            outInfos[0].Value = -1.0 * outInfos[0].Value;
        }

        if (outInfos[0].Unit == Units.Unitless)
        {
            outInfos[0].Unit = unitInfos2[bigSmallI[1]].Unit;
        }

        return outInfos;
    }

    static UnitInfo AdaptBiggerAdditionOperand(UnitInfo[] unitInfos2, Integer[] bigSmallI, Operations operation)
    {
        int gapExponent = unitInfos2[bigSmallI[0]].BaseTenExponent - unitInfos2[bigSmallI[1]].BaseTenExponent;
        if (gapExponent >= 27)
        {
            //The difference between both inputs is bigger than (or, at least, very close to) the maximum double value/precision;
            //what makes this situation calculation unworthy and the first operand to be returned as the result.
            //Note that the error below these lines is just an easy way to tell the calling function about this eventuality.
            return new UnitInfo(unitInfos2[0]) 
            {{ 
                Error = new ErrorInfo(ErrorTypes.InvalidOperation); 
            }};
        }

        //PerformManagedOperationValues is used to make sure that the resulting numeric information is stored
        //in Value (if possible).
        UnitInfo big2 = PerformManagedOperationValues
        (
            RaiseToIntegerExponent(10.0, gapExponent), unitInfos2[bigSmallI[0]].Value, 
            Operations.Multiplication                
        );

        boolean isWrong = 
        (
            big2.Error.Type != ErrorTypes.None || big2.BaseTenExponent != 0 ?
            
            //The value of the bigger input times 10^(gap between BaseTenExponent of inputs) is too big. 
            isWrong = true :
            
            //Overflow-check very unlikely to trigger an error. In fact, with properly normalised variables,
            //triggering an error would be plainly impossible.               
            AreAdditionFinalValuesWrong
            (
                unitInfos2[0].Value, unitInfos2[1].Value, operation
            )
        );

        UnitInfo temp = null;
        if (isWrong)
        {
        	temp = new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }};
            
            temp.Error = new ErrorInfo(ErrorTypes.InvalidOperation);
        }
        else
        {
        	new UnitInfo(unitInfos2[bigSmallI[0]])
            {{
                Value = big2.Value;
            }}
        }
        
        
        return temp;
        
        
        return
        (
            isWrong ?
            //This error is just an easy way to let the calling function know about the fact that no
            //calculation has been performed (too big gap). This isn't a properly-speaking error and
            //that's why it will not be notified to the user.
            new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }} :
            //Returning the new big value. For example: with 5*10^4 & 3*10^2, 500 would be returned.
            new UnitInfo(unitInfos2[bigSmallI[0]])
            {{
                Value = big2.Value;
            }}
        )
    }

    static boolean AreAdditionFinalValuesWrong(double val1, double val2, Operations operation)
    {
        boolean isWrong = false;

        try
        {
            val1 = val1 + val2 *
            (
                operation == Operations.Addition ? 1 : -1
            );
        }
        catch { isWrong = true; }

        return isWrong;
    }

    static UnitInfo PerformManagedOperationMultiplication(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationNormalisedValues
        (
            firstInfo, new UnitInfo[] 
            { 
                NormaliseUnitInfo(firstInfo),
                NormaliseUnitInfo(secondInfo) 
            },
            operation
        );
    }

    public static UnitInfo RaiseToIntegerExponent(double baseValue, int exponent)
    {
        return RaiseToIntegerExponent(new UnitInfo(baseValue), exponent);
    }

    static UnitInfo RaiseToIntegerExponent(UnitInfo baseInfo, int exponent)
    {
        if (exponent <= 1 && exponent >= 0)
        {
            baseInfo.Value = (exponent == 0 ? 1.0 : baseInfo.Value);
            return baseInfo;
        }

        UnitInfo outInfo = new UnitInfo(baseInfo);

        for (int i = 1; i < Math.Abs(exponent); i++)
        {
            outInfo = PerformManagedOperationValues
            (
                outInfo, baseInfo, Operations.Multiplication
            );
            if (outInfo.Error.Type != ErrorTypes.None) return outInfo;
        }

        return
        (
            exponent < 0 ?
            PerformManagedOperationValues(new UnitInfo(1.0), outInfo, Operations.Division) :
            outInfo
        );
    }

    static UnitInfo PerformManagedOperationNormalisedValues(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        outInfo =
        (
            normalisedInfos.Length == 1 ?
            //There is just one operand when the difference between both of them is too big.
            outInfo = normalisedInfos[0] :
            PerformManagedOperationTwoOperands(outInfo, normalisedInfos, operation)
        );

        return outInfo;
    }

    static UnitInfo PerformManagedOperationTwoOperands(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        UnitInfo outInfoNormalised = PerformManagedOperationValues
        (
            normalisedInfos[0], normalisedInfos[1], operation
        );

        if (outInfo.Error.Type != ErrorTypes.None)
        {
            return new UnitInfo(outInfo)
            {
                Error = new ErrorInfo(ErrorTypes.NumericError)
            };
        }

        outInfo.BaseTenExponent = outInfoNormalised.BaseTenExponent;
        outInfo.Value = outInfoNormalised.Value;
        //Normalised means no prefixes.
        outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage); 

        return outInfo;
    }

    static UnitInfo PerformManagedOperationValues(double firstValue, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            new UnitInfo(firstValue), new UnitInfo(secondValue), operation
        );
    }

    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            firstInfo, new UnitInfo(secondValue), operation
        );
    }

    //This method might be used to perform full operations (not just being the last calculation step) instead
    //of the default one (PerformManagedOperationUnits) for simple cases. That is: ones not dealing with the
    //complex numeric reality (Value, Prefix and BaseTenExponent) which makes a pre-analysis required.
    //Note that, unlikely what happens with PerformMangedOperationUnits, the outputs of this method aren't
    //normalised (= primarily stored under Value), what is useful in certain contexts.
    //NOTE: this function assumes that both inputs are normalised, what means that no prefix information is expected.
    //It might also be used with non-normalised inputs, but their prefix information would be plainly ignored.
    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        if (firstInfo.Value == 0.0 || secondInfo.Value == 0.0)
        {
            if (operation == Operations.Multiplication || operation == Operations.Division)
            {
                //Dividing by zero scenarios are taken into account somewhere else.
                return new UnitInfo(firstInfo) { Value = 0.0 };
            }
        }

        UnitInfo outInfo = new UnitInfo(firstInfo);
        UnitInfo firstInfo0 = new UnitInfo(firstInfo);
        UnitInfo secondInfo0 = new UnitInfo(secondInfo);

        boolean isWrong = false;
        try
        {
            if (operation == Operations.Addition)
            {
                outInfo.Value += secondInfo0.Value;
            }
            else if (operation == Operations.Subtraction)
            {
                outInfo.Value -= secondInfo.Value;
            }
            else
            {
                //The reason for checking whether BaseTenExponent is inside/outside the int range before performing 
                //the operation (rather than going ahead and eventually catching the resulting exception) isn't just
                //being quicker, but also the only option in many situations. Note that an addition/subtraction between
                //two int variables whose result is outside the int range might not trigger an exception (+ random 
                //negative value as output).
                if (VaryBaseTenExponent(outInfo, secondInfo0.BaseTenExponent, operation == Operations.Division).Error.Type != ErrorTypes.None)
                {
                    return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
                }

                if (operation == Operations.Multiplication)
                {
                    outInfo.Value *= secondInfo.Value;
                    outInfo.BaseTenExponent += secondInfo.BaseTenExponent;
                }
                else if (operation == Operations.Division)
                {
                    if (secondInfo.Value == 0.0)
                    {
                        return
                        (
                            new UnitInfo(outInfo) 
                            { 
                                Error = new ErrorInfo(ErrorTypes.NumericError) 
                            }
                        );
                    }
                    outInfo.Value /= secondInfo.Value;
                    outInfo.BaseTenExponent -= secondInfo.BaseTenExponent;
                }
            }
        }
        catch { isWrong = true; }

        return
        (
            //An error might not be triggered despite of dealing with numbers outside double precision.
            //For example: 0.00000000000000000001m * 0.0000000000000000000001m can output 0.0 without triggering an error. 
            isWrong || ((operation == Operations.Multiplication || operation == Operations.Division) && outInfo.Value == 0.0.0) ?
            OperationValuesManageError(firstInfo0, secondInfo0, operation) : outInfo
        );
    }

    static UnitInfo OperationValuesManageError(UnitInfo outInfo, UnitInfo secondInfo, Operations operation)
    {
        if (operation != Operations.Multiplication && operation != Operations.Division)
        {
            //This condition should never be true on account of the fact that the pre-modifications performed before
            //adding/subtracting should avoid erroneous situations.
            return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
        }

        UnitInfo secondInfo2 = ConvertValueToBaseTen(secondInfo.Value);
        outInfo = VaryBaseTenExponent(outInfo, secondInfo2.BaseTenExponent, operation == Operations.Division);
        if (Math.Abs(secondInfo2.Value) == 1.0 || outInfo.Error.Type != ErrorTypes.None) return outInfo;
        
        try
        {
            outInfo = PerformManagedOperationUnits
            (
                outInfo, secondInfo2.Value, operation
            );
        }
        catch
        {
            //Very unlikely scenario on account of the fact that Math.Abs(secondInfo2.Value)
            //lies within the 0.1-10.0 range.
            outInfo = OperationValuesManageError
            (
                new UnitInfo(outInfo)
                {
                    Value = secondInfo2.Value,
                    BaseTenExponent = 0
                },
                new UnitInfo()
                {
                    Value = outInfo.Value,
                    BaseTenExponent = outInfo.BaseTenExponent
                },
                operation
            );
        }

        return outInfo;
    }

    static UnitInfo ConvertValueToBaseTen(double value)
    {
        value = Math.Abs(value);
        return FromValueToBaseTenExponent
        (
             new UnitInfo(value), Math.Abs(value), false
        );
    }

    static UnitInfo ConvertBaseTenToValue(UnitInfo unitInfo)
    {
        if (unitInfo.BaseTenExponent == 0) return unitInfo;

        UnitInfo outInfo = new UnitInfo(unitInfo);
        boolean decrease = unitInfo.BaseTenExponent > 0;
        int sign = Math.Sign(outInfo.Value);
        double absValue = Math.Abs(outInfo.Value);

        while (outInfo.BaseTenExponent != 0.0)
        {
            if (decrease)
            {
                if (absValue >= MaxValueDec / 10.0) break;
                absValue *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }
            else
            {
                if (absValue <= MinValueDec * 10.0) break;
                absValue /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
        }

        outInfo.Value = sign * absValue;

        return outInfo;
    }

    static UnitInfo NormaliseUnitInfo(UnitInfo unitInfo)
    {
        if (unitInfo.Value == 0 && unitInfo.Prefix.Factor == 1.0)
        {
            return unitInfo;
        }
        UnitInfo outInfo = new UnitInfo(unitInfo);

        if (outInfo.Prefix.Factor != 1)
        {
            outInfo = FromValueToBaseTenExponent
            (
                outInfo, outInfo.Prefix.Factor, true
            );
            outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage);
        }
        if (outInfo.Value == 0.0) return outInfo;

        outInfo = FromValueToBaseTenExponent
        (
            outInfo, outInfo.Value, false
        );

        return outInfo;
    }

    static UnitInfo FromValueToBaseTenExponent(UnitInfo outInfo, double value, boolean isPrefix)
    {
        if (value == 0.0) return outInfo;

        double valueAbs = Math.Abs(value);
        boolean decrease = (valueAbs > 1.0);
        if (!isPrefix)
        {
            outInfo.Value = outInfo.Value / valueAbs;
        }

        while (valueAbs != 1.0)
        {
            if ((valueAbs < 10.0 && valueAbs > 1.0) || (valueAbs > 0.1.0 && valueAbs < 1.0))
            {
                if (!isPrefix) outInfo.Value = value;
                else
                {
                    outInfo = PerformManagedOperationValues
                    (
                        outInfo, value, Operations.Multiplication
                    );
                }

                return outInfo;
            }

            if (decrease)
            {
                value /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
            else
            {
                value *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }

            valueAbs = Math.Abs(value);
        }

        return outInfo;
    }

    //Method used to vary BaseTenExponent without provoking unhandled exceptions (i.e., bigger than Integer.MAX_VALUE).
    static UnitInfo VaryBaseTenExponent(UnitInfo info, int baseTenIncrease, boolean isDivision = false)
    {
        long val1 = info.BaseTenExponent;
        long val2 = baseTenIncrease;

        if (isDivision)
        {
            //Converting a negative value into positive might provoke an overflow error for the int type
            //(e.g., Math.Abs(Integer.MAIN_VALUE)). Converting both variables to long is a quick and effective
            //way to avoid this problem.
            val2 *= -1;
        }

        return
        (
             ((val2 > 0 && val1 > Integer.MAX_VALUE - val2) || (val2 < 0 && val1 < Integer.MAIN_VALUE - val2)) ?
            new UnitInfo(info, ErrorTypes.NumericError) : new UnitInfo(info){{ BaseTenExponent = (int)(val1 + val2); }}
        );
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData(ClipboardOperationAction.java:430)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImportsOperation(ClipboardOperationAction.java:357)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperation(ClipboardOperationAction.java:317)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction$1.run(ClipboardOperationAction.java:265)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:70)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run(ClipboardOperationAction.java:262)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:473)
	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:118)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:90)
	at sun.reflect.GeneratedMethodAccessor44.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:55)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:282)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:264)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:132)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:152)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:494)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:488)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:210)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:286)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:507)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:558)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:378)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.access$0(KeyBindingDispatcher.java:324)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:86)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1270)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1078)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1103)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1088)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1130)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1126)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1547)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4918)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:364)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4799)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:359)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5110)
	at org.eclipse.swt.internal.win32.OS.DispatchMessageW(Native Method)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(OS.java:2552)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3822)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:1121)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1022)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:150)
	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:693)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:610)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:148)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:138)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:388)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:243)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:673)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:610)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1519)

!ENTRY org.eclipse.jdt.ui 4 2 2017-05-27 20:05:48.629
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData(ClipboardOperationAction.java:430)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImportsOperation(ClipboardOperationAction.java:357)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperation(ClipboardOperationAction.java:317)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction$1.run(ClipboardOperationAction.java:265)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:70)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run(ClipboardOperationAction.java:262)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:473)
	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:118)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:90)
	at sun.reflect.GeneratedMethodAccessor44.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:55)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:282)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:264)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:132)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:152)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:494)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:488)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:210)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:286)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:507)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:558)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:378)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.access$0(KeyBindingDispatcher.java:324)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:86)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1270)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1078)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1103)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1088)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1130)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1126)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1547)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4918)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:364)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4799)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:359)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5110)
	at org.eclipse.swt.internal.win32.OS.DispatchMessageW(Native Method)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(OS.java:2552)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3822)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:1121)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1022)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:150)
	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:693)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:610)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:148)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:138)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:388)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:243)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:673)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:610)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1519)

!ENTRY org.eclipse.jdt.ui 4 0 2017-05-27 20:05:48.630
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData(ClipboardOperationAction.java:430)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImportsOperation(ClipboardOperationAction.java:357)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperation(ClipboardOperationAction.java:317)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction$1.run(ClipboardOperationAction.java:265)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:70)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run(ClipboardOperationAction.java:262)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:473)
	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:118)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:90)
	at sun.reflect.GeneratedMethodAccessor44.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:55)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:282)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:264)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:132)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:152)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:494)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:488)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:210)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:286)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:507)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:558)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:378)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.access$0(KeyBindingDispatcher.java:324)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:86)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1270)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1078)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1103)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1088)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1130)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1126)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1547)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4918)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:364)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4799)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:359)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5110)
	at org.eclipse.swt.internal.win32.OS.DispatchMessageW(Native Method)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(OS.java:2552)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3822)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:1121)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1022)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:150)
	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:693)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:610)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:148)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:138)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:388)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:243)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:673)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:610)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1519)

!ENTRY org.eclipse.jdt.core 4 4 2017-05-27 20:05:50.826
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
public class OperationsManaged
{
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, double second, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            firstInfo, new UnitInfo(second), operation
        );
    }

    public static UnitInfo PerformManagedOperationUnits(double first, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            new UnitInfo(first), secondInfo, operation
        );
    }

    //This method should always be used when dealing with random UnitInfo variables because it accounts for all the
    //possible scenarios. On the other hand, with simple operations (e.g., random UnitInfo & numeric type) it might
    //be better to use PerformManagedOperationValues. 
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        ErrorTypes errorType = InternalMethods.GetOperationError
        (
            firstInfo, secondInfo, operation
        );
        if (errorType != ErrorTypes.None)
        {
            return new UnitInfo(firstInfo) 
            {{
                Error = new ErrorInfo(errorType); 
            }};
        }

        return
        (
            operation == Operations.Addition || operation == Operations.Subtraction ?
            PerformManagedOperationAddition(firstInfo, secondInfo, operation) :
            PerformManagedOperationMultiplication(firstInfo, secondInfo, operation)
        );
    }

    static UnitInfo PerformManagedOperationAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {   
        //After being normalised, the operands might require further modifications.
        UnitInfo[] normalised = GetOperandsAddition(firstInfo, secondInfo, operation);

        return PerformManagedOperationNormalisedValues
        (
            firstInfo, normalised, operation
        );
    }

    static UnitInfo[] GetOperandsAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        UnitInfo[] operands2 = new UnitInfo[] 
        {
            new UnitInfo(firstInfo), new UnitInfo(secondInfo)
        };

        if (operands2[0].BaseTenExponent != operands2[1].BaseTenExponent || operands2[0].Prefix.Factor != operands2[1].Prefix.Factor)
        {
            //The addition/subtraction might not be performed right away even with normalised values.
            //For example: 5 and 6 from 5*10^2 and 6*10^7 cannot be added right away.
            operands2 = AdaptNormalisedValuesForAddition
            (
                new UnitInfo[] 
                { 
                    NormaliseUnitInfo(operands2[0]), 
                    NormaliseUnitInfo(operands2[1])
                },
                operation
            );
        }

        return operands2;
    }
    
    static UnitInfo[] AdaptNormalisedValuesForAddition(UnitInfo[] unitInfos2, Operations operation)
    {
        if (unitInfos2[0].BaseTenExponent == unitInfos2[1].BaseTenExponent)
        {
            //Having the same BaseTenExponent values means that the given operation can be performed right away.
            return unitInfos2;
        }

        int[] bigSmallI = 
        (
            unitInfos2[0].BaseTenExponent > unitInfos2[1].BaseTenExponent ?
            new int[] { 0, 1 } : new int[] { 1, 0 }
        );

        //Only the variable with the bigger value is modified. For example: 5*10^5 & 3*10^3 is converted
        //into 500*10^3 & 3*10^3 in order to allow the addition 500 + 3. 
        UnitInfo big2 = AdaptBiggerAdditionOperand(unitInfos2, bigSmallI, operation);
        if (big2.Error.Type != ErrorTypes.None)
        {
            return TooBigGapAddition(unitInfos2, bigSmallI, operation);
        }

        unitInfos2[bigSmallI[0]].Value = big2.Value;
        unitInfos2[bigSmallI[0]].BaseTenExponent = unitInfos2[bigSmallI[1]].BaseTenExponent;

        return unitInfos2;
    }

    //When adding/subtracting two numbers whose gap is bigger than the maximum double range, there
    //is no need to perform any operation (i.e., no change will be observed because of being outside
    //the maximum supported precision). This method takes care of these cases and returns the expected
    //output (i.e., biggest value).
    static UnitInfo[] TooBigGapAddition(UnitInfo[] unitInfos2, int[] bigSmallI, Operations operation)
    {
        UnitInfo[] outInfos = new UnitInfo[] 
        {
            //First operand (i.e., one whose information defines the operation) together with the
            //numeric information (i.e., just Value and BaseTenExponent because both are normalised)
            //which is associated with the biggest one.
            new UnitInfo(unitInfos2[0])
            {{
                Value = unitInfos2[bigSmallI[0]].Value;
                BaseTenExponent = unitInfos2[bigSmallI[0]].BaseTenExponent;
            }}
        };

        if (operation == Operations.Subtraction && bigSmallI[0] == 1)
        {
            outInfos[0].Value = -1.0 * outInfos[0].Value;
        }

        if (outInfos[0].Unit == Units.Unitless)
        {
            outInfos[0].Unit = unitInfos2[bigSmallI[1]].Unit;
        }

        return outInfos;
    }

    static UnitInfo AdaptBiggerAdditionOperand(UnitInfo[] unitInfos2, Integer[] bigSmallI, Operations operation)
    {
        int gapExponent = unitInfos2[bigSmallI[0]].BaseTenExponent - unitInfos2[bigSmallI[1]].BaseTenExponent;
        if (gapExponent >= 27)
        {
            //The difference between both inputs is bigger than (or, at least, very close to) the maximum double value/precision;
            //what makes this situation calculation unworthy and the first operand to be returned as the result.
            //Note that the error below these lines is just an easy way to tell the calling function about this eventuality.
            return new UnitInfo(unitInfos2[0]) 
            {{ 
                Error = new ErrorInfo(ErrorTypes.InvalidOperation); 
            }};
        }

        //PerformManagedOperationValues is used to make sure that the resulting numeric information is stored
        //in Value (if possible).
        UnitInfo big2 = PerformManagedOperationValues
        (
            RaiseToIntegerExponent(10.0, gapExponent), unitInfos2[bigSmallI[0]].Value, 
            Operations.Multiplication                
        );

        boolean isWrong = 
        (
            big2.Error.Type != ErrorTypes.None || big2.BaseTenExponent != 0 ?
            
            //The value of the bigger input times 10^(gap between BaseTenExponent of inputs) is too big. 
            isWrong = true :
            
            //Overflow-check very unlikely to trigger an error. In fact, with properly normalised variables,
            //triggering an error would be plainly impossible.               
            AreAdditionFinalValuesWrong
            (
                unitInfos2[0].Value, unitInfos2[1].Value, operation
            )
        );

        UnitInfo temp = null;
        if (isWrong)
        {
        	temp = new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }};
            
            temp.Error = new ErrorInfo(ErrorTypes.InvalidOperation);
        }
        else
        {
        	temp = new UnitInfo(unitInfos2[bigSmallI[0]])
            {{
                Value = big2.Value;
            }}
        }
        
        
        return temp;
        
        
        return
        (
            isWrong ?
            //This error is just an easy way to let the calling function know about the fact that no
            //calculation has been performed (too big gap). This isn't a properly-speaking error and
            //that's why it will not be notified to the user.
            new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }} :
            //Returning the new big value. For example: with 5*10^4 & 3*10^2, 500 would be returned.
            new UnitInfo(unitInfos2[bigSmallI[0]])
            {{
                Value = big2.Value;
            }}
        )
    }

    static boolean AreAdditionFinalValuesWrong(double val1, double val2, Operations operation)
    {
        boolean isWrong = false;

        try
        {
            val1 = val1 + val2 *
            (
                operation == Operations.Addition ? 1 : -1
            );
        }
        catch { isWrong = true; }

        return isWrong;
    }

    static UnitInfo PerformManagedOperationMultiplication(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationNormalisedValues
        (
            firstInfo, new UnitInfo[] 
            { 
                NormaliseUnitInfo(firstInfo),
                NormaliseUnitInfo(secondInfo) 
            },
            operation
        );
    }

    public static UnitInfo RaiseToIntegerExponent(double baseValue, int exponent)
    {
        return RaiseToIntegerExponent(new UnitInfo(baseValue), exponent);
    }

    static UnitInfo RaiseToIntegerExponent(UnitInfo baseInfo, int exponent)
    {
        if (exponent <= 1 && exponent >= 0)
        {
            baseInfo.Value = (exponent == 0 ? 1.0 : baseInfo.Value);
            return baseInfo;
        }

        UnitInfo outInfo = new UnitInfo(baseInfo);

        for (int i = 1; i < Math.Abs(exponent); i++)
        {
            outInfo = PerformManagedOperationValues
            (
                outInfo, baseInfo, Operations.Multiplication
            );
            if (outInfo.Error.Type != ErrorTypes.None) return outInfo;
        }

        return
        (
            exponent < 0 ?
            PerformManagedOperationValues(new UnitInfo(1.0), outInfo, Operations.Division) :
            outInfo
        );
    }

    static UnitInfo PerformManagedOperationNormalisedValues(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        outInfo =
        (
            normalisedInfos.Length == 1 ?
            //There is just one operand when the difference between both of them is too big.
            outInfo = normalisedInfos[0] :
            PerformManagedOperationTwoOperands(outInfo, normalisedInfos, operation)
        );

        return outInfo;
    }

    static UnitInfo PerformManagedOperationTwoOperands(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        UnitInfo outInfoNormalised = PerformManagedOperationValues
        (
            normalisedInfos[0], normalisedInfos[1], operation
        );

        if (outInfo.Error.Type != ErrorTypes.None)
        {
            return new UnitInfo(outInfo)
            {
                Error = new ErrorInfo(ErrorTypes.NumericError)
            };
        }

        outInfo.BaseTenExponent = outInfoNormalised.BaseTenExponent;
        outInfo.Value = outInfoNormalised.Value;
        //Normalised means no prefixes.
        outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage); 

        return outInfo;
    }

    static UnitInfo PerformManagedOperationValues(double firstValue, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            new UnitInfo(firstValue), new UnitInfo(secondValue), operation
        );
    }

    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            firstInfo, new UnitInfo(secondValue), operation
        );
    }

    //This method might be used to perform full operations (not just being the last calculation step) instead
    //of the default one (PerformManagedOperationUnits) for simple cases. That is: ones not dealing with the
    //complex numeric reality (Value, Prefix and BaseTenExponent) which makes a pre-analysis required.
    //Note that, unlikely what happens with PerformMangedOperationUnits, the outputs of this method aren't
    //normalised (= primarily stored under Value), what is useful in certain contexts.
    //NOTE: this function assumes that both inputs are normalised, what means that no prefix information is expected.
    //It might also be used with non-normalised inputs, but their prefix information would be plainly ignored.
    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        if (firstInfo.Value == 0.0 || secondInfo.Value == 0.0)
        {
            if (operation == Operations.Multiplication || operation == Operations.Division)
            {
                //Dividing by zero scenarios are taken into account somewhere else.
                return new UnitInfo(firstInfo) { Value = 0.0 };
            }
        }

        UnitInfo outInfo = new UnitInfo(firstInfo);
        UnitInfo firstInfo0 = new UnitInfo(firstInfo);
        UnitInfo secondInfo0 = new UnitInfo(secondInfo);

        boolean isWrong = false;
        try
        {
            if (operation == Operations.Addition)
            {
                outInfo.Value += secondInfo0.Value;
            }
            else if (operation == Operations.Subtraction)
            {
                outInfo.Value -= secondInfo.Value;
            }
            else
            {
                //The reason for checking whether BaseTenExponent is inside/outside the int range before performing 
                //the operation (rather than going ahead and eventually catching the resulting exception) isn't just
                //being quicker, but also the only option in many situations. Note that an addition/subtraction between
                //two int variables whose result is outside the int range might not trigger an exception (+ random 
                //negative value as output).
                if (VaryBaseTenExponent(outInfo, secondInfo0.BaseTenExponent, operation == Operations.Division).Error.Type != ErrorTypes.None)
                {
                    return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
                }

                if (operation == Operations.Multiplication)
                {
                    outInfo.Value *= secondInfo.Value;
                    outInfo.BaseTenExponent += secondInfo.BaseTenExponent;
                }
                else if (operation == Operations.Division)
                {
                    if (secondInfo.Value == 0.0)
                    {
                        return
                        (
                            new UnitInfo(outInfo) 
                            { 
                                Error = new ErrorInfo(ErrorTypes.NumericError) 
                            }
                        );
                    }
                    outInfo.Value /= secondInfo.Value;
                    outInfo.BaseTenExponent -= secondInfo.BaseTenExponent;
                }
            }
        }
        catch { isWrong = true; }

        return
        (
            //An error might not be triggered despite of dealing with numbers outside double precision.
            //For example: 0.00000000000000000001m * 0.0000000000000000000001m can output 0.0 without triggering an error. 
            isWrong || ((operation == Operations.Multiplication || operation == Operations.Division) && outInfo.Value == 0.0.0) ?
            OperationValuesManageError(firstInfo0, secondInfo0, operation) : outInfo
        );
    }

    static UnitInfo OperationValuesManageError(UnitInfo outInfo, UnitInfo secondInfo, Operations operation)
    {
        if (operation != Operations.Multiplication && operation != Operations.Division)
        {
            //This condition should never be true on account of the fact that the pre-modifications performed before
            //adding/subtracting should avoid erroneous situations.
            return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
        }

        UnitInfo secondInfo2 = ConvertValueToBaseTen(secondInfo.Value);
        outInfo = VaryBaseTenExponent(outInfo, secondInfo2.BaseTenExponent, operation == Operations.Division);
        if (Math.Abs(secondInfo2.Value) == 1.0 || outInfo.Error.Type != ErrorTypes.None) return outInfo;
        
        try
        {
            outInfo = PerformManagedOperationUnits
            (
                outInfo, secondInfo2.Value, operation
            );
        }
        catch
        {
            //Very unlikely scenario on account of the fact that Math.Abs(secondInfo2.Value)
            //lies within the 0.1-10.0 range.
            outInfo = OperationValuesManageError
            (
                new UnitInfo(outInfo)
                {
                    Value = secondInfo2.Value,
                    BaseTenExponent = 0
                },
                new UnitInfo()
                {
                    Value = outInfo.Value,
                    BaseTenExponent = outInfo.BaseTenExponent
                },
                operation
            );
        }

        return outInfo;
    }

    static UnitInfo ConvertValueToBaseTen(double value)
    {
        value = Math.Abs(value);
        return FromValueToBaseTenExponent
        (
             new UnitInfo(value), Math.Abs(value), false
        );
    }

    static UnitInfo ConvertBaseTenToValue(UnitInfo unitInfo)
    {
        if (unitInfo.BaseTenExponent == 0) return unitInfo;

        UnitInfo outInfo = new UnitInfo(unitInfo);
        boolean decrease = unitInfo.BaseTenExponent > 0;
        int sign = Math.Sign(outInfo.Value);
        double absValue = Math.Abs(outInfo.Value);

        while (outInfo.BaseTenExponent != 0.0)
        {
            if (decrease)
            {
                if (absValue >= MaxValueDec / 10.0) break;
                absValue *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }
            else
            {
                if (absValue <= MinValueDec * 10.0) break;
                absValue /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
        }

        outInfo.Value = sign * absValue;

        return outInfo;
    }

    static UnitInfo NormaliseUnitInfo(UnitInfo unitInfo)
    {
        if (unitInfo.Value == 0 && unitInfo.Prefix.Factor == 1.0)
        {
            return unitInfo;
        }
        UnitInfo outInfo = new UnitInfo(unitInfo);

        if (outInfo.Prefix.Factor != 1)
        {
            outInfo = FromValueToBaseTenExponent
            (
                outInfo, outInfo.Prefix.Factor, true
            );
            outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage);
        }
        if (outInfo.Value == 0.0) return outInfo;

        outInfo = FromValueToBaseTenExponent
        (
            outInfo, outInfo.Value, false
        );

        return outInfo;
    }

    static UnitInfo FromValueToBaseTenExponent(UnitInfo outInfo, double value, boolean isPrefix)
    {
        if (value == 0.0) return outInfo;

        double valueAbs = Math.Abs(value);
        boolean decrease = (valueAbs > 1.0);
        if (!isPrefix)
        {
            outInfo.Value = outInfo.Value / valueAbs;
        }

        while (valueAbs != 1.0)
        {
            if ((valueAbs < 10.0 && valueAbs > 1.0) || (valueAbs > 0.1.0 && valueAbs < 1.0))
            {
                if (!isPrefix) outInfo.Value = value;
                else
                {
                    outInfo = PerformManagedOperationValues
                    (
                        outInfo, value, Operations.Multiplication
                    );
                }

                return outInfo;
            }

            if (decrease)
            {
                value /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
            else
            {
                value *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }

            valueAbs = Math.Abs(value);
        }

        return outInfo;
    }

    //Method used to vary BaseTenExponent without provoking unhandled exceptions (i.e., bigger than Integer.MAX_VALUE).
    static UnitInfo VaryBaseTenExponent(UnitInfo info, int baseTenIncrease, boolean isDivision = false)
    {
        long val1 = info.BaseTenExponent;
        long val2 = baseTenIncrease;

        if (isDivision)
        {
            //Converting a negative value into positive might provoke an overflow error for the int type
            //(e.g., Math.Abs(Integer.MAIN_VALUE)). Converting both variables to long is a quick and effective
            //way to avoid this problem.
            val2 *= -1;
        }

        return
        (
             ((val2 > 0 && val1 > Integer.MAX_VALUE - val2) || (val2 < 0 && val1 < Integer.MAIN_VALUE - val2)) ?
            new UnitInfo(info, ErrorTypes.NumericError) : new UnitInfo(info){{ BaseTenExponent = (int)(val1 + val2); }}
        );
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2017-05-27 20:05:50.827
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2017-05-27 20:05:50.828
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2017-05-27 20:05:51.191
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
public class OperationsManaged
{
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, double second, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            firstInfo, new UnitInfo(second), operation
        );
    }

    public static UnitInfo PerformManagedOperationUnits(double first, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            new UnitInfo(first), secondInfo, operation
        );
    }

    //This method should always be used when dealing with random UnitInfo variables because it accounts for all the
    //possible scenarios. On the other hand, with simple operations (e.g., random UnitInfo & numeric type) it might
    //be better to use PerformManagedOperationValues. 
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        ErrorTypes errorType = InternalMethods.GetOperationError
        (
            firstInfo, secondInfo, operation
        );
        if (errorType != ErrorTypes.None)
        {
            return new UnitInfo(firstInfo) 
            {{
                Error = new ErrorInfo(errorType); 
            }};
        }

        return
        (
            operation == Operations.Addition || operation == Operations.Subtraction ?
            PerformManagedOperationAddition(firstInfo, secondInfo, operation) :
            PerformManagedOperationMultiplication(firstInfo, secondInfo, operation)
        );
    }

    static UnitInfo PerformManagedOperationAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {   
        //After being normalised, the operands might require further modifications.
        UnitInfo[] normalised = GetOperandsAddition(firstInfo, secondInfo, operation);

        return PerformManagedOperationNormalisedValues
        (
            firstInfo, normalised, operation
        );
    }

    static UnitInfo[] GetOperandsAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        UnitInfo[] operands2 = new UnitInfo[] 
        {
            new UnitInfo(firstInfo), new UnitInfo(secondInfo)
        };

        if (operands2[0].BaseTenExponent != operands2[1].BaseTenExponent || operands2[0].Prefix.Factor != operands2[1].Prefix.Factor)
        {
            //The addition/subtraction might not be performed right away even with normalised values.
            //For example: 5 and 6 from 5*10^2 and 6*10^7 cannot be added right away.
            operands2 = AdaptNormalisedValuesForAddition
            (
                new UnitInfo[] 
                { 
                    NormaliseUnitInfo(operands2[0]), 
                    NormaliseUnitInfo(operands2[1])
                },
                operation
            );
        }

        return operands2;
    }
    
    static UnitInfo[] AdaptNormalisedValuesForAddition(UnitInfo[] unitInfos2, Operations operation)
    {
        if (unitInfos2[0].BaseTenExponent == unitInfos2[1].BaseTenExponent)
        {
            //Having the same BaseTenExponent values means that the given operation can be performed right away.
            return unitInfos2;
        }

        int[] bigSmallI = 
        (
            unitInfos2[0].BaseTenExponent > unitInfos2[1].BaseTenExponent ?
            new int[] { 0, 1 } : new int[] { 1, 0 }
        );

        //Only the variable with the bigger value is modified. For example: 5*10^5 & 3*10^3 is converted
        //into 500*10^3 & 3*10^3 in order to allow the addition 500 + 3. 
        UnitInfo big2 = AdaptBiggerAdditionOperand(unitInfos2, bigSmallI, operation);
        if (big2.Error.Type != ErrorTypes.None)
        {
            return TooBigGapAddition(unitInfos2, bigSmallI, operation);
        }

        unitInfos2[bigSmallI[0]].Value = big2.Value;
        unitInfos2[bigSmallI[0]].BaseTenExponent = unitInfos2[bigSmallI[1]].BaseTenExponent;

        return unitInfos2;
    }

    //When adding/subtracting two numbers whose gap is bigger than the maximum double range, there
    //is no need to perform any operation (i.e., no change will be observed because of being outside
    //the maximum supported precision). This method takes care of these cases and returns the expected
    //output (i.e., biggest value).
    static UnitInfo[] TooBigGapAddition(UnitInfo[] unitInfos2, int[] bigSmallI, Operations operation)
    {
        UnitInfo[] outInfos = new UnitInfo[] 
        {
            //First operand (i.e., one whose information defines the operation) together with the
            //numeric information (i.e., just Value and BaseTenExponent because both are normalised)
            //which is associated with the biggest one.
            new UnitInfo(unitInfos2[0])
            {{
                Value = unitInfos2[bigSmallI[0]].Value;
                BaseTenExponent = unitInfos2[bigSmallI[0]].BaseTenExponent;
            }}
        };

        if (operation == Operations.Subtraction && bigSmallI[0] == 1)
        {
            outInfos[0].Value = -1.0 * outInfos[0].Value;
        }

        if (outInfos[0].Unit == Units.Unitless)
        {
            outInfos[0].Unit = unitInfos2[bigSmallI[1]].Unit;
        }

        return outInfos;
    }

    static UnitInfo AdaptBiggerAdditionOperand(UnitInfo[] unitInfos2, Integer[] bigSmallI, Operations operation)
    {
        int gapExponent = unitInfos2[bigSmallI[0]].BaseTenExponent - unitInfos2[bigSmallI[1]].BaseTenExponent;
        if (gapExponent >= 27)
        {
            //The difference between both inputs is bigger than (or, at least, very close to) the maximum double value/precision;
            //what makes this situation calculation unworthy and the first operand to be returned as the result.
            //Note that the error below these lines is just an easy way to tell the calling function about this eventuality.
            return new UnitInfo(unitInfos2[0]) 
            {{ 
                Error = new ErrorInfo(ErrorTypes.InvalidOperation); 
            }};
        }

        //PerformManagedOperationValues is used to make sure that the resulting numeric information is stored
        //in Value (if possible).
        UnitInfo big2 = PerformManagedOperationValues
        (
            RaiseToIntegerExponent(10.0, gapExponent), unitInfos2[bigSmallI[0]].Value, 
            Operations.Multiplication                
        );

        boolean isWrong = 
        (
            big2.Error.Type != ErrorTypes.None || big2.BaseTenExponent != 0 ?
            
            //The value of the bigger input times 10^(gap between BaseTenExponent of inputs) is too big. 
            isWrong = true :
            
            //Overflow-check very unlikely to trigger an error. In fact, with properly normalised variables,
            //triggering an error would be plainly impossible.               
            AreAdditionFinalValuesWrong
            (
                unitInfos2[0].Value, unitInfos2[1].Value, operation
            )
        );

        UnitInfo temp = null;
        if (isWrong)
        {
        	temp = new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }};
            
            temp.Error = new ErrorInfo(ErrorTypes.InvalidOperation);
        }
        else
        {
        	temp = new UnitInfo(unitInfos2[bigSmallI[0]])
            {{
                Value = big2.Value;
            }}
        }
        
        
        return temp;
        
        
        return
        (
            isWrong ?
            //This error is just an easy way to let the calling function know about the fact that no
            //calculation has been performed (too big gap). This isn't a properly-speaking error and
            //that's why it will not be notified to the user.
            new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }} :
            //Returning the new big value. For example: with 5*10^4 & 3*10^2, 500 would be returned.
            new UnitInfo(unitInfos2[bigSmallI[0]])
            {{
                Value = big2.Value;
            }}
        )
    }

    static boolean AreAdditionFinalValuesWrong(double val1, double val2, Operations operation)
    {
        boolean isWrong = false;

        try
        {
            val1 = val1 + val2 *
            (
                operation == Operations.Addition ? 1 : -1
            );
        }
        catch { isWrong = true; }

        return isWrong;
    }

    static UnitInfo PerformManagedOperationMultiplication(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationNormalisedValues
        (
            firstInfo, new UnitInfo[] 
            { 
                NormaliseUnitInfo(firstInfo),
                NormaliseUnitInfo(secondInfo) 
            },
            operation
        );
    }

    public static UnitInfo RaiseToIntegerExponent(double baseValue, int exponent)
    {
        return RaiseToIntegerExponent(new UnitInfo(baseValue), exponent);
    }

    static UnitInfo RaiseToIntegerExponent(UnitInfo baseInfo, int exponent)
    {
        if (exponent <= 1 && exponent >= 0)
        {
            baseInfo.Value = (exponent == 0 ? 1.0 : baseInfo.Value);
            return baseInfo;
        }

        UnitInfo outInfo = new UnitInfo(baseInfo);

        for (int i = 1; i < Math.Abs(exponent); i++)
        {
            outInfo = PerformManagedOperationValues
            (
                outInfo, baseInfo, Operations.Multiplication
            );
            if (outInfo.Error.Type != ErrorTypes.None) return outInfo;
        }

        return
        (
            exponent < 0 ?
            PerformManagedOperationValues(new UnitInfo(1.0), outInfo, Operations.Division) :
            outInfo
        );
    }

    static UnitInfo PerformManagedOperationNormalisedValues(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        outInfo =
        (
            normalisedInfos.Length == 1 ?
            //There is just one operand when the difference between both of them is too big.
            outInfo = normalisedInfos[0] :
            PerformManagedOperationTwoOperands(outInfo, normalisedInfos, operation)
        );

        return outInfo;
    }

    static UnitInfo PerformManagedOperationTwoOperands(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        UnitInfo outInfoNormalised = PerformManagedOperationValues
        (
            normalisedInfos[0], normalisedInfos[1], operation
        );

        if (outInfo.Error.Type != ErrorTypes.None)
        {
            return new UnitInfo(outInfo)
            {
                Error = new ErrorInfo(ErrorTypes.NumericError)
            };
        }

        outInfo.BaseTenExponent = outInfoNormalised.BaseTenExponent;
        outInfo.Value = outInfoNormalised.Value;
        //Normalised means no prefixes.
        outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage); 

        return outInfo;
    }

    static UnitInfo PerformManagedOperationValues(double firstValue, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            new UnitInfo(firstValue), new UnitInfo(secondValue), operation
        );
    }

    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            firstInfo, new UnitInfo(secondValue), operation
        );
    }

    //This method might be used to perform full operations (not just being the last calculation step) instead
    //of the default one (PerformManagedOperationUnits) for simple cases. That is: ones not dealing with the
    //complex numeric reality (Value, Prefix and BaseTenExponent) which makes a pre-analysis required.
    //Note that, unlikely what happens with PerformMangedOperationUnits, the outputs of this method aren't
    //normalised (= primarily stored under Value), what is useful in certain contexts.
    //NOTE: this function assumes that both inputs are normalised, what means that no prefix information is expected.
    //It might also be used with non-normalised inputs, but their prefix information would be plainly ignored.
    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        if (firstInfo.Value == 0.0 || secondInfo.Value == 0.0)
        {
            if (operation == Operations.Multiplication || operation == Operations.Division)
            {
                //Dividing by zero scenarios are taken into account somewhere else.
                return new UnitInfo(firstInfo) { Value = 0.0 };
            }
        }

        UnitInfo outInfo = new UnitInfo(firstInfo);
        UnitInfo firstInfo0 = new UnitInfo(firstInfo);
        UnitInfo secondInfo0 = new UnitInfo(secondInfo);

        boolean isWrong = false;
        try
        {
            if (operation == Operations.Addition)
            {
                outInfo.Value += secondInfo0.Value;
            }
            else if (operation == Operations.Subtraction)
            {
                outInfo.Value -= secondInfo.Value;
            }
            else
            {
                //The reason for checking whether BaseTenExponent is inside/outside the int range before performing 
                //the operation (rather than going ahead and eventually catching the resulting exception) isn't just
                //being quicker, but also the only option in many situations. Note that an addition/subtraction between
                //two int variables whose result is outside the int range might not trigger an exception (+ random 
                //negative value as output).
                if (VaryBaseTenExponent(outInfo, secondInfo0.BaseTenExponent, operation == Operations.Division).Error.Type != ErrorTypes.None)
                {
                    return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
                }

                if (operation == Operations.Multiplication)
                {
                    outInfo.Value *= secondInfo.Value;
                    outInfo.BaseTenExponent += secondInfo.BaseTenExponent;
                }
                else if (operation == Operations.Division)
                {
                    if (secondInfo.Value == 0.0)
                    {
                        return
                        (
                            new UnitInfo(outInfo) 
                            { 
                                Error = new ErrorInfo(ErrorTypes.NumericError) 
                            }
                        );
                    }
                    outInfo.Value /= secondInfo.Value;
                    outInfo.BaseTenExponent -= secondInfo.BaseTenExponent;
                }
            }
        }
        catch { isWrong = true; }

        return
        (
            //An error might not be triggered despite of dealing with numbers outside double precision.
            //For example: 0.00000000000000000001m * 0.0000000000000000000001m can output 0.0 without triggering an error. 
            isWrong || ((operation == Operations.Multiplication || operation == Operations.Division) && outInfo.Value == 0.0.0) ?
            OperationValuesManageError(firstInfo0, secondInfo0, operation) : outInfo
        );
    }

    static UnitInfo OperationValuesManageError(UnitInfo outInfo, UnitInfo secondInfo, Operations operation)
    {
        if (operation != Operations.Multiplication && operation != Operations.Division)
        {
            //This condition should never be true on account of the fact that the pre-modifications performed before
            //adding/subtracting should avoid erroneous situations.
            return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
        }

        UnitInfo secondInfo2 = ConvertValueToBaseTen(secondInfo.Value);
        outInfo = VaryBaseTenExponent(outInfo, secondInfo2.BaseTenExponent, operation == Operations.Division);
        if (Math.Abs(secondInfo2.Value) == 1.0 || outInfo.Error.Type != ErrorTypes.None) return outInfo;
        
        try
        {
            outInfo = PerformManagedOperationUnits
            (
                outInfo, secondInfo2.Value, operation
            );
        }
        catch
        {
            //Very unlikely scenario on account of the fact that Math.Abs(secondInfo2.Value)
            //lies within the 0.1-10.0 range.
            outInfo = OperationValuesManageError
            (
                new UnitInfo(outInfo)
                {
                    Value = secondInfo2.Value,
                    BaseTenExponent = 0
                },
                new UnitInfo()
                {
                    Value = outInfo.Value,
                    BaseTenExponent = outInfo.BaseTenExponent
                },
                operation
            );
        }

        return outInfo;
    }

    static UnitInfo ConvertValueToBaseTen(double value)
    {
        value = Math.Abs(value);
        return FromValueToBaseTenExponent
        (
             new UnitInfo(value), Math.Abs(value), false
        );
    }

    static UnitInfo ConvertBaseTenToValue(UnitInfo unitInfo)
    {
        if (unitInfo.BaseTenExponent == 0) return unitInfo;

        UnitInfo outInfo = new UnitInfo(unitInfo);
        boolean decrease = unitInfo.BaseTenExponent > 0;
        int sign = Math.Sign(outInfo.Value);
        double absValue = Math.Abs(outInfo.Value);

        while (outInfo.BaseTenExponent != 0.0)
        {
            if (decrease)
            {
                if (absValue >= MaxValueDec / 10.0) break;
                absValue *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }
            else
            {
                if (absValue <= MinValueDec * 10.0) break;
                absValue /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
        }

        outInfo.Value = sign * absValue;

        return outInfo;
    }

    static UnitInfo NormaliseUnitInfo(UnitInfo unitInfo)
    {
        if (unitInfo.Value == 0 && unitInfo.Prefix.Factor == 1.0)
        {
            return unitInfo;
        }
        UnitInfo outInfo = new UnitInfo(unitInfo);

        if (outInfo.Prefix.Factor != 1)
        {
            outInfo = FromValueToBaseTenExponent
            (
                outInfo, outInfo.Prefix.Factor, true
            );
            outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage);
        }
        if (outInfo.Value == 0.0) return outInfo;

        outInfo = FromValueToBaseTenExponent
        (
            outInfo, outInfo.Value, false
        );

        return outInfo;
    }

    static UnitInfo FromValueToBaseTenExponent(UnitInfo outInfo, double value, boolean isPrefix)
    {
        if (value == 0.0) return outInfo;

        double valueAbs = Math.Abs(value);
        boolean decrease = (valueAbs > 1.0);
        if (!isPrefix)
        {
            outInfo.Value = outInfo.Value / valueAbs;
        }

        while (valueAbs != 1.0)
        {
            if ((valueAbs < 10.0 && valueAbs > 1.0) || (valueAbs > 0.1.0 && valueAbs < 1.0))
            {
                if (!isPrefix) outInfo.Value = value;
                else
                {
                    outInfo = PerformManagedOperationValues
                    (
                        outInfo, value, Operations.Multiplication
                    );
                }

                return outInfo;
            }

            if (decrease)
            {
                value /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
            else
            {
                value *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }

            valueAbs = Math.Abs(value);
        }

        return outInfo;
    }

    //Method used to vary BaseTenExponent without provoking unhandled exceptions (i.e., bigger than Integer.MAX_VALUE).
    static UnitInfo VaryBaseTenExponent(UnitInfo info, int baseTenIncrease, boolean isDivision = false)
    {
        long val1 = info.BaseTenExponent;
        long val2 = baseTenIncrease;

        if (isDivision)
        {
            //Converting a negative value into positive might provoke an overflow error for the int type
            //(e.g., Math.Abs(Integer.MAIN_VALUE)). Converting both variables to long is a quick and effective
            //way to avoid this problem.
            val2 *= -1;
        }

        return
        (
             ((val2 > 0 && val1 > Integer.MAX_VALUE - val2) || (val2 < 0 && val1 < Integer.MAIN_VALUE - val2)) ?
            new UnitInfo(info, ErrorTypes.NumericError) : new UnitInfo(info){{ BaseTenExponent = (int)(val1 + val2); }}
        );
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 2 2017-05-27 20:05:51.192
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 0 2017-05-27 20:05:51.192
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.core 4 4 2017-05-27 20:05:52.864
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
public class OperationsManaged
{
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, double second, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            firstInfo, new UnitInfo(second), operation
        );
    }

    public static UnitInfo PerformManagedOperationUnits(double first, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            new UnitInfo(first), secondInfo, operation
        );
    }

    //This method should always be used when dealing with random UnitInfo variables because it accounts for all the
    //possible scenarios. On the other hand, with simple operations (e.g., random UnitInfo & numeric type) it might
    //be better to use PerformManagedOperationValues. 
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        ErrorTypes errorType = InternalMethods.GetOperationError
        (
            firstInfo, secondInfo, operation
        );
        if (errorType != ErrorTypes.None)
        {
            return new UnitInfo(firstInfo) 
            {{
                Error = new ErrorInfo(errorType); 
            }};
        }

        return
        (
            operation == Operations.Addition || operation == Operations.Subtraction ?
            PerformManagedOperationAddition(firstInfo, secondInfo, operation) :
            PerformManagedOperationMultiplication(firstInfo, secondInfo, operation)
        );
    }

    static UnitInfo PerformManagedOperationAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {   
        //After being normalised, the operands might require further modifications.
        UnitInfo[] normalised = GetOperandsAddition(firstInfo, secondInfo, operation);

        return PerformManagedOperationNormalisedValues
        (
            firstInfo, normalised, operation
        );
    }

    static UnitInfo[] GetOperandsAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        UnitInfo[] operands2 = new UnitInfo[] 
        {
            new UnitInfo(firstInfo), new UnitInfo(secondInfo)
        };

        if (operands2[0].BaseTenExponent != operands2[1].BaseTenExponent || operands2[0].Prefix.Factor != operands2[1].Prefix.Factor)
        {
            //The addition/subtraction might not be performed right away even with normalised values.
            //For example: 5 and 6 from 5*10^2 and 6*10^7 cannot be added right away.
            operands2 = AdaptNormalisedValuesForAddition
            (
                new UnitInfo[] 
                { 
                    NormaliseUnitInfo(operands2[0]), 
                    NormaliseUnitInfo(operands2[1])
                },
                operation
            );
        }

        return operands2;
    }
    
    static UnitInfo[] AdaptNormalisedValuesForAddition(UnitInfo[] unitInfos2, Operations operation)
    {
        if (unitInfos2[0].BaseTenExponent == unitInfos2[1].BaseTenExponent)
        {
            //Having the same BaseTenExponent values means that the given operation can be performed right away.
            return unitInfos2;
        }

        int[] bigSmallI = 
        (
            unitInfos2[0].BaseTenExponent > unitInfos2[1].BaseTenExponent ?
            new int[] { 0, 1 } : new int[] { 1, 0 }
        );

        //Only the variable with the bigger value is modified. For example: 5*10^5 & 3*10^3 is converted
        //into 500*10^3 & 3*10^3 in order to allow the addition 500 + 3. 
        UnitInfo big2 = AdaptBiggerAdditionOperand(unitInfos2, bigSmallI, operation);
        if (big2.Error.Type != ErrorTypes.None)
        {
            return TooBigGapAddition(unitInfos2, bigSmallI, operation);
        }

        unitInfos2[bigSmallI[0]].Value = big2.Value;
        unitInfos2[bigSmallI[0]].BaseTenExponent = unitInfos2[bigSmallI[1]].BaseTenExponent;

        return unitInfos2;
    }

    //When adding/subtracting two numbers whose gap is bigger than the maximum double range, there
    //is no need to perform any operation (i.e., no change will be observed because of being outside
    //the maximum supported precision). This method takes care of these cases and returns the expected
    //output (i.e., biggest value).
    static UnitInfo[] TooBigGapAddition(UnitInfo[] unitInfos2, int[] bigSmallI, Operations operation)
    {
        UnitInfo[] outInfos = new UnitInfo[] 
        {
            //First operand (i.e., one whose information defines the operation) together with the
            //numeric information (i.e., just Value and BaseTenExponent because both are normalised)
            //which is associated with the biggest one.
            new UnitInfo(unitInfos2[0])
            {{
                Value = unitInfos2[bigSmallI[0]].Value;
                BaseTenExponent = unitInfos2[bigSmallI[0]].BaseTenExponent;
            }}
        };

        if (operation == Operations.Subtraction && bigSmallI[0] == 1)
        {
            outInfos[0].Value = -1.0 * outInfos[0].Value;
        }

        if (outInfos[0].Unit == Units.Unitless)
        {
            outInfos[0].Unit = unitInfos2[bigSmallI[1]].Unit;
        }

        return outInfos;
    }

    static UnitInfo AdaptBiggerAdditionOperand(UnitInfo[] unitInfos2, Integer[] bigSmallI, Operations operation)
    {
        int gapExponent = unitInfos2[bigSmallI[0]].BaseTenExponent - unitInfos2[bigSmallI[1]].BaseTenExponent;
        if (gapExponent >= 27)
        {
            //The difference between both inputs is bigger than (or, at least, very close to) the maximum double value/precision;
            //what makes this situation calculation unworthy and the first operand to be returned as the result.
            //Note that the error below these lines is just an easy way to tell the calling function about this eventuality.
            return new UnitInfo(unitInfos2[0]) 
            {{ 
                Error = new ErrorInfo(ErrorTypes.InvalidOperation); 
            }};
        }

        //PerformManagedOperationValues is used to make sure that the resulting numeric information is stored
        //in Value (if possible).
        UnitInfo big2 = PerformManagedOperationValues
        (
            RaiseToIntegerExponent(10.0, gapExponent), unitInfos2[bigSmallI[0]].Value, 
            Operations.Multiplication                
        );

        boolean isWrong = 
        (
            big2.Error.Type != ErrorTypes.None || big2.BaseTenExponent != 0 ?
            
            //The value of the bigger input times 10^(gap between BaseTenExponent of inputs) is too big. 
            isWrong = true :
            
            //Overflow-check very unlikely to trigger an error. In fact, with properly normalised variables,
            //triggering an error would be plainly impossible.               
            AreAdditionFinalValuesWrong
            (
                unitInfos2[0].Value, unitInfos2[1].Value, operation
            )
        );

        UnitInfo temp = null;
        if (isWrong)
        {
        	temp = new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }};
            
            temp.Error = new ErrorInfo(ErrorTypes.InvalidOperation);
        }
        else
        {
        	temp = new UnitInfo(unitInfos2[bigSmallI[0]])
            {{
                Value = big2.Value;
            }};
        }
        
        
        return temp;
        
        
        return
        (
            isWrong ?
            //This error is just an easy way to let the calling function know about the fact that no
            //calculation has been performed (too big gap). This isn't a properly-speaking error and
            //that's why it will not be notified to the user.
            new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }} :
            //Returning the new big value. For example: with 5*10^4 & 3*10^2, 500 would be returned.
            new UnitInfo(unitInfos2[bigSmallI[0]])
            {{
                Value = big2.Value;
            }}
        )
    }

    static boolean AreAdditionFinalValuesWrong(double val1, double val2, Operations operation)
    {
        boolean isWrong = false;

        try
        {
            val1 = val1 + val2 *
            (
                operation == Operations.Addition ? 1 : -1
            );
        }
        catch { isWrong = true; }

        return isWrong;
    }

    static UnitInfo PerformManagedOperationMultiplication(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationNormalisedValues
        (
            firstInfo, new UnitInfo[] 
            { 
                NormaliseUnitInfo(firstInfo),
                NormaliseUnitInfo(secondInfo) 
            },
            operation
        );
    }

    public static UnitInfo RaiseToIntegerExponent(double baseValue, int exponent)
    {
        return RaiseToIntegerExponent(new UnitInfo(baseValue), exponent);
    }

    static UnitInfo RaiseToIntegerExponent(UnitInfo baseInfo, int exponent)
    {
        if (exponent <= 1 && exponent >= 0)
        {
            baseInfo.Value = (exponent == 0 ? 1.0 : baseInfo.Value);
            return baseInfo;
        }

        UnitInfo outInfo = new UnitInfo(baseInfo);

        for (int i = 1; i < Math.Abs(exponent); i++)
        {
            outInfo = PerformManagedOperationValues
            (
                outInfo, baseInfo, Operations.Multiplication
            );
            if (outInfo.Error.Type != ErrorTypes.None) return outInfo;
        }

        return
        (
            exponent < 0 ?
            PerformManagedOperationValues(new UnitInfo(1.0), outInfo, Operations.Division) :
            outInfo
        );
    }

    static UnitInfo PerformManagedOperationNormalisedValues(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        outInfo =
        (
            normalisedInfos.Length == 1 ?
            //There is just one operand when the difference between both of them is too big.
            outInfo = normalisedInfos[0] :
            PerformManagedOperationTwoOperands(outInfo, normalisedInfos, operation)
        );

        return outInfo;
    }

    static UnitInfo PerformManagedOperationTwoOperands(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        UnitInfo outInfoNormalised = PerformManagedOperationValues
        (
            normalisedInfos[0], normalisedInfos[1], operation
        );

        if (outInfo.Error.Type != ErrorTypes.None)
        {
            return new UnitInfo(outInfo)
            {
                Error = new ErrorInfo(ErrorTypes.NumericError)
            };
        }

        outInfo.BaseTenExponent = outInfoNormalised.BaseTenExponent;
        outInfo.Value = outInfoNormalised.Value;
        //Normalised means no prefixes.
        outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage); 

        return outInfo;
    }

    static UnitInfo PerformManagedOperationValues(double firstValue, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            new UnitInfo(firstValue), new UnitInfo(secondValue), operation
        );
    }

    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            firstInfo, new UnitInfo(secondValue), operation
        );
    }

    //This method might be used to perform full operations (not just being the last calculation step) instead
    //of the default one (PerformManagedOperationUnits) for simple cases. That is: ones not dealing with the
    //complex numeric reality (Value, Prefix and BaseTenExponent) which makes a pre-analysis required.
    //Note that, unlikely what happens with PerformMangedOperationUnits, the outputs of this method aren't
    //normalised (= primarily stored under Value), what is useful in certain contexts.
    //NOTE: this function assumes that both inputs are normalised, what means that no prefix information is expected.
    //It might also be used with non-normalised inputs, but their prefix information would be plainly ignored.
    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        if (firstInfo.Value == 0.0 || secondInfo.Value == 0.0)
        {
            if (operation == Operations.Multiplication || operation == Operations.Division)
            {
                //Dividing by zero scenarios are taken into account somewhere else.
                return new UnitInfo(firstInfo) { Value = 0.0 };
            }
        }

        UnitInfo outInfo = new UnitInfo(firstInfo);
        UnitInfo firstInfo0 = new UnitInfo(firstInfo);
        UnitInfo secondInfo0 = new UnitInfo(secondInfo);

        boolean isWrong = false;
        try
        {
            if (operation == Operations.Addition)
            {
                outInfo.Value += secondInfo0.Value;
            }
            else if (operation == Operations.Subtraction)
            {
                outInfo.Value -= secondInfo.Value;
            }
            else
            {
                //The reason for checking whether BaseTenExponent is inside/outside the int range before performing 
                //the operation (rather than going ahead and eventually catching the resulting exception) isn't just
                //being quicker, but also the only option in many situations. Note that an addition/subtraction between
                //two int variables whose result is outside the int range might not trigger an exception (+ random 
                //negative value as output).
                if (VaryBaseTenExponent(outInfo, secondInfo0.BaseTenExponent, operation == Operations.Division).Error.Type != ErrorTypes.None)
                {
                    return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
                }

                if (operation == Operations.Multiplication)
                {
                    outInfo.Value *= secondInfo.Value;
                    outInfo.BaseTenExponent += secondInfo.BaseTenExponent;
                }
                else if (operation == Operations.Division)
                {
                    if (secondInfo.Value == 0.0)
                    {
                        return
                        (
                            new UnitInfo(outInfo) 
                            { 
                                Error = new ErrorInfo(ErrorTypes.NumericError) 
                            }
                        );
                    }
                    outInfo.Value /= secondInfo.Value;
                    outInfo.BaseTenExponent -= secondInfo.BaseTenExponent;
                }
            }
        }
        catch { isWrong = true; }

        return
        (
            //An error might not be triggered despite of dealing with numbers outside double precision.
            //For example: 0.00000000000000000001m * 0.0000000000000000000001m can output 0.0 without triggering an error. 
            isWrong || ((operation == Operations.Multiplication || operation == Operations.Division) && outInfo.Value == 0.0.0) ?
            OperationValuesManageError(firstInfo0, secondInfo0, operation) : outInfo
        );
    }

    static UnitInfo OperationValuesManageError(UnitInfo outInfo, UnitInfo secondInfo, Operations operation)
    {
        if (operation != Operations.Multiplication && operation != Operations.Division)
        {
            //This condition should never be true on account of the fact that the pre-modifications performed before
            //adding/subtracting should avoid erroneous situations.
            return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
        }

        UnitInfo secondInfo2 = ConvertValueToBaseTen(secondInfo.Value);
        outInfo = VaryBaseTenExponent(outInfo, secondInfo2.BaseTenExponent, operation == Operations.Division);
        if (Math.Abs(secondInfo2.Value) == 1.0 || outInfo.Error.Type != ErrorTypes.None) return outInfo;
        
        try
        {
            outInfo = PerformManagedOperationUnits
            (
                outInfo, secondInfo2.Value, operation
            );
        }
        catch
        {
            //Very unlikely scenario on account of the fact that Math.Abs(secondInfo2.Value)
            //lies within the 0.1-10.0 range.
            outInfo = OperationValuesManageError
            (
                new UnitInfo(outInfo)
                {
                    Value = secondInfo2.Value,
                    BaseTenExponent = 0
                },
                new UnitInfo()
                {
                    Value = outInfo.Value,
                    BaseTenExponent = outInfo.BaseTenExponent
                },
                operation
            );
        }

        return outInfo;
    }

    static UnitInfo ConvertValueToBaseTen(double value)
    {
        value = Math.Abs(value);
        return FromValueToBaseTenExponent
        (
             new UnitInfo(value), Math.Abs(value), false
        );
    }

    static UnitInfo ConvertBaseTenToValue(UnitInfo unitInfo)
    {
        if (unitInfo.BaseTenExponent == 0) return unitInfo;

        UnitInfo outInfo = new UnitInfo(unitInfo);
        boolean decrease = unitInfo.BaseTenExponent > 0;
        int sign = Math.Sign(outInfo.Value);
        double absValue = Math.Abs(outInfo.Value);

        while (outInfo.BaseTenExponent != 0.0)
        {
            if (decrease)
            {
                if (absValue >= MaxValueDec / 10.0) break;
                absValue *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }
            else
            {
                if (absValue <= MinValueDec * 10.0) break;
                absValue /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
        }

        outInfo.Value = sign * absValue;

        return outInfo;
    }

    static UnitInfo NormaliseUnitInfo(UnitInfo unitInfo)
    {
        if (unitInfo.Value == 0 && unitInfo.Prefix.Factor == 1.0)
        {
            return unitInfo;
        }
        UnitInfo outInfo = new UnitInfo(unitInfo);

        if (outInfo.Prefix.Factor != 1)
        {
            outInfo = FromValueToBaseTenExponent
            (
                outInfo, outInfo.Prefix.Factor, true
            );
            outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage);
        }
        if (outInfo.Value == 0.0) return outInfo;

        outInfo = FromValueToBaseTenExponent
        (
            outInfo, outInfo.Value, false
        );

        return outInfo;
    }

    static UnitInfo FromValueToBaseTenExponent(UnitInfo outInfo, double value, boolean isPrefix)
    {
        if (value == 0.0) return outInfo;

        double valueAbs = Math.Abs(value);
        boolean decrease = (valueAbs > 1.0);
        if (!isPrefix)
        {
            outInfo.Value = outInfo.Value / valueAbs;
        }

        while (valueAbs != 1.0)
        {
            if ((valueAbs < 10.0 && valueAbs > 1.0) || (valueAbs > 0.1.0 && valueAbs < 1.0))
            {
                if (!isPrefix) outInfo.Value = value;
                else
                {
                    outInfo = PerformManagedOperationValues
                    (
                        outInfo, value, Operations.Multiplication
                    );
                }

                return outInfo;
            }

            if (decrease)
            {
                value /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
            else
            {
                value *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }

            valueAbs = Math.Abs(value);
        }

        return outInfo;
    }

    //Method used to vary BaseTenExponent without provoking unhandled exceptions (i.e., bigger than Integer.MAX_VALUE).
    static UnitInfo VaryBaseTenExponent(UnitInfo info, int baseTenIncrease, boolean isDivision = false)
    {
        long val1 = info.BaseTenExponent;
        long val2 = baseTenIncrease;

        if (isDivision)
        {
            //Converting a negative value into positive might provoke an overflow error for the int type
            //(e.g., Math.Abs(Integer.MAIN_VALUE)). Converting both variables to long is a quick and effective
            //way to avoid this problem.
            val2 *= -1;
        }

        return
        (
             ((val2 > 0 && val1 > Integer.MAX_VALUE - val2) || (val2 < 0 && val1 < Integer.MAIN_VALUE - val2)) ?
            new UnitInfo(info, ErrorTypes.NumericError) : new UnitInfo(info){{ BaseTenExponent = (int)(val1 + val2); }}
        );
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2017-05-27 20:05:52.865
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2017-05-27 20:05:52.866
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2017-05-27 20:05:52.888
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
public class OperationsManaged
{
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, double second, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            firstInfo, new UnitInfo(second), operation
        );
    }

    public static UnitInfo PerformManagedOperationUnits(double first, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            new UnitInfo(first), secondInfo, operation
        );
    }

    //This method should always be used when dealing with random UnitInfo variables because it accounts for all the
    //possible scenarios. On the other hand, with simple operations (e.g., random UnitInfo & numeric type) it might
    //be better to use PerformManagedOperationValues. 
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        ErrorTypes errorType = InternalMethods.GetOperationError
        (
            firstInfo, secondInfo, operation
        );
        if (errorType != ErrorTypes.None)
        {
            return new UnitInfo(firstInfo) 
            {{
                Error = new ErrorInfo(errorType); 
            }};
        }

        return
        (
            operation == Operations.Addition || operation == Operations.Subtraction ?
            PerformManagedOperationAddition(firstInfo, secondInfo, operation) :
            PerformManagedOperationMultiplication(firstInfo, secondInfo, operation)
        );
    }

    static UnitInfo PerformManagedOperationAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {   
        //After being normalised, the operands might require further modifications.
        UnitInfo[] normalised = GetOperandsAddition(firstInfo, secondInfo, operation);

        return PerformManagedOperationNormalisedValues
        (
            firstInfo, normalised, operation
        );
    }

    static UnitInfo[] GetOperandsAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        UnitInfo[] operands2 = new UnitInfo[] 
        {
            new UnitInfo(firstInfo), new UnitInfo(secondInfo)
        };

        if (operands2[0].BaseTenExponent != operands2[1].BaseTenExponent || operands2[0].Prefix.Factor != operands2[1].Prefix.Factor)
        {
            //The addition/subtraction might not be performed right away even with normalised values.
            //For example: 5 and 6 from 5*10^2 and 6*10^7 cannot be added right away.
            operands2 = AdaptNormalisedValuesForAddition
            (
                new UnitInfo[] 
                { 
                    NormaliseUnitInfo(operands2[0]), 
                    NormaliseUnitInfo(operands2[1])
                },
                operation
            );
        }

        return operands2;
    }
    
    static UnitInfo[] AdaptNormalisedValuesForAddition(UnitInfo[] unitInfos2, Operations operation)
    {
        if (unitInfos2[0].BaseTenExponent == unitInfos2[1].BaseTenExponent)
        {
            //Having the same BaseTenExponent values means that the given operation can be performed right away.
            return unitInfos2;
        }

        int[] bigSmallI = 
        (
            unitInfos2[0].BaseTenExponent > unitInfos2[1].BaseTenExponent ?
            new int[] { 0, 1 } : new int[] { 1, 0 }
        );

        //Only the variable with the bigger value is modified. For example: 5*10^5 & 3*10^3 is converted
        //into 500*10^3 & 3*10^3 in order to allow the addition 500 + 3. 
        UnitInfo big2 = AdaptBiggerAdditionOperand(unitInfos2, bigSmallI, operation);
        if (big2.Error.Type != ErrorTypes.None)
        {
            return TooBigGapAddition(unitInfos2, bigSmallI, operation);
        }

        unitInfos2[bigSmallI[0]].Value = big2.Value;
        unitInfos2[bigSmallI[0]].BaseTenExponent = unitInfos2[bigSmallI[1]].BaseTenExponent;

        return unitInfos2;
    }

    //When adding/subtracting two numbers whose gap is bigger than the maximum double range, there
    //is no need to perform any operation (i.e., no change will be observed because of being outside
    //the maximum supported precision). This method takes care of these cases and returns the expected
    //output (i.e., biggest value).
    static UnitInfo[] TooBigGapAddition(UnitInfo[] unitInfos2, int[] bigSmallI, Operations operation)
    {
        UnitInfo[] outInfos = new UnitInfo[] 
        {
            //First operand (i.e., one whose information defines the operation) together with the
            //numeric information (i.e., just Value and BaseTenExponent because both are normalised)
            //which is associated with the biggest one.
            new UnitInfo(unitInfos2[0])
            {{
                Value = unitInfos2[bigSmallI[0]].Value;
                BaseTenExponent = unitInfos2[bigSmallI[0]].BaseTenExponent;
            }}
        };

        if (operation == Operations.Subtraction && bigSmallI[0] == 1)
        {
            outInfos[0].Value = -1.0 * outInfos[0].Value;
        }

        if (outInfos[0].Unit == Units.Unitless)
        {
            outInfos[0].Unit = unitInfos2[bigSmallI[1]].Unit;
        }

        return outInfos;
    }

    static UnitInfo AdaptBiggerAdditionOperand(UnitInfo[] unitInfos2, Integer[] bigSmallI, Operations operation)
    {
        int gapExponent = unitInfos2[bigSmallI[0]].BaseTenExponent - unitInfos2[bigSmallI[1]].BaseTenExponent;
        if (gapExponent >= 27)
        {
            //The difference between both inputs is bigger than (or, at least, very close to) the maximum double value/precision;
            //what makes this situation calculation unworthy and the first operand to be returned as the result.
            //Note that the error below these lines is just an easy way to tell the calling function about this eventuality.
            return new UnitInfo(unitInfos2[0]) 
            {{ 
                Error = new ErrorInfo(ErrorTypes.InvalidOperation); 
            }};
        }

        //PerformManagedOperationValues is used to make sure that the resulting numeric information is stored
        //in Value (if possible).
        UnitInfo big2 = PerformManagedOperationValues
        (
            RaiseToIntegerExponent(10.0, gapExponent), unitInfos2[bigSmallI[0]].Value, 
            Operations.Multiplication                
        );

        boolean isWrong = 
        (
            big2.Error.Type != ErrorTypes.None || big2.BaseTenExponent != 0 ?
            
            //The value of the bigger input times 10^(gap between BaseTenExponent of inputs) is too big. 
            isWrong = true :
            
            //Overflow-check very unlikely to trigger an error. In fact, with properly normalised variables,
            //triggering an error would be plainly impossible.               
            AreAdditionFinalValuesWrong
            (
                unitInfos2[0].Value, unitInfos2[1].Value, operation
            )
        );

        UnitInfo temp = null;
        if (isWrong)
        {
        	temp = new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }};
            
            temp.Error = new ErrorInfo(ErrorTypes.InvalidOperation);
        }
        else
        {
        	temp = new UnitInfo(unitInfos2[bigSmallI[0]])
            {{
                Value = big2.Value;
            }};
        }
        
        
        return temp;
        
        
        return
        (
            isWrong ?
            //This error is just an easy way to let the calling function know about the fact that no
            //calculation has been performed (too big gap). This isn't a properly-speaking error and
            //that's why it will not be notified to the user.
            new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }} :
            //Returning the new big value. For example: with 5*10^4 & 3*10^2, 500 would be returned.
            new UnitInfo(unitInfos2[bigSmallI[0]])
            {{
                Value = big2.Value;
            }}
        )
    }

    static boolean AreAdditionFinalValuesWrong(double val1, double val2, Operations operation)
    {
        boolean isWrong = false;

        try
        {
            val1 = val1 + val2 *
            (
                operation == Operations.Addition ? 1 : -1
            );
        }
        catch { isWrong = true; }

        return isWrong;
    }

    static UnitInfo PerformManagedOperationMultiplication(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationNormalisedValues
        (
            firstInfo, new UnitInfo[] 
            { 
                NormaliseUnitInfo(firstInfo),
                NormaliseUnitInfo(secondInfo) 
            },
            operation
        );
    }

    public static UnitInfo RaiseToIntegerExponent(double baseValue, int exponent)
    {
        return RaiseToIntegerExponent(new UnitInfo(baseValue), exponent);
    }

    static UnitInfo RaiseToIntegerExponent(UnitInfo baseInfo, int exponent)
    {
        if (exponent <= 1 && exponent >= 0)
        {
            baseInfo.Value = (exponent == 0 ? 1.0 : baseInfo.Value);
            return baseInfo;
        }

        UnitInfo outInfo = new UnitInfo(baseInfo);

        for (int i = 1; i < Math.Abs(exponent); i++)
        {
            outInfo = PerformManagedOperationValues
            (
                outInfo, baseInfo, Operations.Multiplication
            );
            if (outInfo.Error.Type != ErrorTypes.None) return outInfo;
        }

        return
        (
            exponent < 0 ?
            PerformManagedOperationValues(new UnitInfo(1.0), outInfo, Operations.Division) :
            outInfo
        );
    }

    static UnitInfo PerformManagedOperationNormalisedValues(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        outInfo =
        (
            normalisedInfos.Length == 1 ?
            //There is just one operand when the difference between both of them is too big.
            outInfo = normalisedInfos[0] :
            PerformManagedOperationTwoOperands(outInfo, normalisedInfos, operation)
        );

        return outInfo;
    }

    static UnitInfo PerformManagedOperationTwoOperands(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        UnitInfo outInfoNormalised = PerformManagedOperationValues
        (
            normalisedInfos[0], normalisedInfos[1], operation
        );

        if (outInfo.Error.Type != ErrorTypes.None)
        {
            return new UnitInfo(outInfo)
            {
                Error = new ErrorInfo(ErrorTypes.NumericError)
            };
        }

        outInfo.BaseTenExponent = outInfoNormalised.BaseTenExponent;
        outInfo.Value = outInfoNormalised.Value;
        //Normalised means no prefixes.
        outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage); 

        return outInfo;
    }

    static UnitInfo PerformManagedOperationValues(double firstValue, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            new UnitInfo(firstValue), new UnitInfo(secondValue), operation
        );
    }

    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            firstInfo, new UnitInfo(secondValue), operation
        );
    }

    //This method might be used to perform full operations (not just being the last calculation step) instead
    //of the default one (PerformManagedOperationUnits) for simple cases. That is: ones not dealing with the
    //complex numeric reality (Value, Prefix and BaseTenExponent) which makes a pre-analysis required.
    //Note that, unlikely what happens with PerformMangedOperationUnits, the outputs of this method aren't
    //normalised (= primarily stored under Value), what is useful in certain contexts.
    //NOTE: this function assumes that both inputs are normalised, what means that no prefix information is expected.
    //It might also be used with non-normalised inputs, but their prefix information would be plainly ignored.
    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        if (firstInfo.Value == 0.0 || secondInfo.Value == 0.0)
        {
            if (operation == Operations.Multiplication || operation == Operations.Division)
            {
                //Dividing by zero scenarios are taken into account somewhere else.
                return new UnitInfo(firstInfo) { Value = 0.0 };
            }
        }

        UnitInfo outInfo = new UnitInfo(firstInfo);
        UnitInfo firstInfo0 = new UnitInfo(firstInfo);
        UnitInfo secondInfo0 = new UnitInfo(secondInfo);

        boolean isWrong = false;
        try
        {
            if (operation == Operations.Addition)
            {
                outInfo.Value += secondInfo0.Value;
            }
            else if (operation == Operations.Subtraction)
            {
                outInfo.Value -= secondInfo.Value;
            }
            else
            {
                //The reason for checking whether BaseTenExponent is inside/outside the int range before performing 
                //the operation (rather than going ahead and eventually catching the resulting exception) isn't just
                //being quicker, but also the only option in many situations. Note that an addition/subtraction between
                //two int variables whose result is outside the int range might not trigger an exception (+ random 
                //negative value as output).
                if (VaryBaseTenExponent(outInfo, secondInfo0.BaseTenExponent, operation == Operations.Division).Error.Type != ErrorTypes.None)
                {
                    return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
                }

                if (operation == Operations.Multiplication)
                {
                    outInfo.Value *= secondInfo.Value;
                    outInfo.BaseTenExponent += secondInfo.BaseTenExponent;
                }
                else if (operation == Operations.Division)
                {
                    if (secondInfo.Value == 0.0)
                    {
                        return
                        (
                            new UnitInfo(outInfo) 
                            { 
                                Error = new ErrorInfo(ErrorTypes.NumericError) 
                            }
                        );
                    }
                    outInfo.Value /= secondInfo.Value;
                    outInfo.BaseTenExponent -= secondInfo.BaseTenExponent;
                }
            }
        }
        catch { isWrong = true; }

        return
        (
            //An error might not be triggered despite of dealing with numbers outside double precision.
            //For example: 0.00000000000000000001m * 0.0000000000000000000001m can output 0.0 without triggering an error. 
            isWrong || ((operation == Operations.Multiplication || operation == Operations.Division) && outInfo.Value == 0.0.0) ?
            OperationValuesManageError(firstInfo0, secondInfo0, operation) : outInfo
        );
    }

    static UnitInfo OperationValuesManageError(UnitInfo outInfo, UnitInfo secondInfo, Operations operation)
    {
        if (operation != Operations.Multiplication && operation != Operations.Division)
        {
            //This condition should never be true on account of the fact that the pre-modifications performed before
            //adding/subtracting should avoid erroneous situations.
            return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
        }

        UnitInfo secondInfo2 = ConvertValueToBaseTen(secondInfo.Value);
        outInfo = VaryBaseTenExponent(outInfo, secondInfo2.BaseTenExponent, operation == Operations.Division);
        if (Math.Abs(secondInfo2.Value) == 1.0 || outInfo.Error.Type != ErrorTypes.None) return outInfo;
        
        try
        {
            outInfo = PerformManagedOperationUnits
            (
                outInfo, secondInfo2.Value, operation
            );
        }
        catch
        {
            //Very unlikely scenario on account of the fact that Math.Abs(secondInfo2.Value)
            //lies within the 0.1-10.0 range.
            outInfo = OperationValuesManageError
            (
                new UnitInfo(outInfo)
                {
                    Value = secondInfo2.Value,
                    BaseTenExponent = 0
                },
                new UnitInfo()
                {
                    Value = outInfo.Value,
                    BaseTenExponent = outInfo.BaseTenExponent
                },
                operation
            );
        }

        return outInfo;
    }

    static UnitInfo ConvertValueToBaseTen(double value)
    {
        value = Math.Abs(value);
        return FromValueToBaseTenExponent
        (
             new UnitInfo(value), Math.Abs(value), false
        );
    }

    static UnitInfo ConvertBaseTenToValue(UnitInfo unitInfo)
    {
        if (unitInfo.BaseTenExponent == 0) return unitInfo;

        UnitInfo outInfo = new UnitInfo(unitInfo);
        boolean decrease = unitInfo.BaseTenExponent > 0;
        int sign = Math.Sign(outInfo.Value);
        double absValue = Math.Abs(outInfo.Value);

        while (outInfo.BaseTenExponent != 0.0)
        {
            if (decrease)
            {
                if (absValue >= MaxValueDec / 10.0) break;
                absValue *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }
            else
            {
                if (absValue <= MinValueDec * 10.0) break;
                absValue /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
        }

        outInfo.Value = sign * absValue;

        return outInfo;
    }

    static UnitInfo NormaliseUnitInfo(UnitInfo unitInfo)
    {
        if (unitInfo.Value == 0 && unitInfo.Prefix.Factor == 1.0)
        {
            return unitInfo;
        }
        UnitInfo outInfo = new UnitInfo(unitInfo);

        if (outInfo.Prefix.Factor != 1)
        {
            outInfo = FromValueToBaseTenExponent
            (
                outInfo, outInfo.Prefix.Factor, true
            );
            outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage);
        }
        if (outInfo.Value == 0.0) return outInfo;

        outInfo = FromValueToBaseTenExponent
        (
            outInfo, outInfo.Value, false
        );

        return outInfo;
    }

    static UnitInfo FromValueToBaseTenExponent(UnitInfo outInfo, double value, boolean isPrefix)
    {
        if (value == 0.0) return outInfo;

        double valueAbs = Math.Abs(value);
        boolean decrease = (valueAbs > 1.0);
        if (!isPrefix)
        {
            outInfo.Value = outInfo.Value / valueAbs;
        }

        while (valueAbs != 1.0)
        {
            if ((valueAbs < 10.0 && valueAbs > 1.0) || (valueAbs > 0.1.0 && valueAbs < 1.0))
            {
                if (!isPrefix) outInfo.Value = value;
                else
                {
                    outInfo = PerformManagedOperationValues
                    (
                        outInfo, value, Operations.Multiplication
                    );
                }

                return outInfo;
            }

            if (decrease)
            {
                value /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
            else
            {
                value *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }

            valueAbs = Math.Abs(value);
        }

        return outInfo;
    }

    //Method used to vary BaseTenExponent without provoking unhandled exceptions (i.e., bigger than Integer.MAX_VALUE).
    static UnitInfo VaryBaseTenExponent(UnitInfo info, int baseTenIncrease, boolean isDivision = false)
    {
        long val1 = info.BaseTenExponent;
        long val2 = baseTenIncrease;

        if (isDivision)
        {
            //Converting a negative value into positive might provoke an overflow error for the int type
            //(e.g., Math.Abs(Integer.MAIN_VALUE)). Converting both variables to long is a quick and effective
            //way to avoid this problem.
            val2 *= -1;
        }

        return
        (
             ((val2 > 0 && val1 > Integer.MAX_VALUE - val2) || (val2 < 0 && val1 < Integer.MAIN_VALUE - val2)) ?
            new UnitInfo(info, ErrorTypes.NumericError) : new UnitInfo(info){{ BaseTenExponent = (int)(val1 + val2); }}
        );
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:476)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 2 2017-05-27 20:05:52.889
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:476)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 0 2017-05-27 20:05:52.889
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:476)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.core 4 4 2017-05-27 20:05:57.708
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
public class OperationsManaged
{
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, double second, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            firstInfo, new UnitInfo(second), operation
        );
    }

    public static UnitInfo PerformManagedOperationUnits(double first, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            new UnitInfo(first), secondInfo, operation
        );
    }

    //This method should always be used when dealing with random UnitInfo variables because it accounts for all the
    //possible scenarios. On the other hand, with simple operations (e.g., random UnitInfo & numeric type) it might
    //be better to use PerformManagedOperationValues. 
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        ErrorTypes errorType = InternalMethods.GetOperationError
        (
            firstInfo, secondInfo, operation
        );
        if (errorType != ErrorTypes.None)
        {
            return new UnitInfo(firstInfo) 
            {{
                Error = new ErrorInfo(errorType); 
            }};
        }

        return
        (
            operation == Operations.Addition || operation == Operations.Subtraction ?
            PerformManagedOperationAddition(firstInfo, secondInfo, operation) :
            PerformManagedOperationMultiplication(firstInfo, secondInfo, operation)
        );
    }

    static UnitInfo PerformManagedOperationAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {   
        //After being normalised, the operands might require further modifications.
        UnitInfo[] normalised = GetOperandsAddition(firstInfo, secondInfo, operation);

        return PerformManagedOperationNormalisedValues
        (
            firstInfo, normalised, operation
        );
    }

    static UnitInfo[] GetOperandsAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        UnitInfo[] operands2 = new UnitInfo[] 
        {
            new UnitInfo(firstInfo), new UnitInfo(secondInfo)
        };

        if (operands2[0].BaseTenExponent != operands2[1].BaseTenExponent || operands2[0].Prefix.Factor != operands2[1].Prefix.Factor)
        {
            //The addition/subtraction might not be performed right away even with normalised values.
            //For example: 5 and 6 from 5*10^2 and 6*10^7 cannot be added right away.
            operands2 = AdaptNormalisedValuesForAddition
            (
                new UnitInfo[] 
                { 
                    NormaliseUnitInfo(operands2[0]), 
                    NormaliseUnitInfo(operands2[1])
                },
                operation
            );
        }

        return operands2;
    }
    
    static UnitInfo[] AdaptNormalisedValuesForAddition(UnitInfo[] unitInfos2, Operations operation)
    {
        if (unitInfos2[0].BaseTenExponent == unitInfos2[1].BaseTenExponent)
        {
            //Having the same BaseTenExponent values means that the given operation can be performed right away.
            return unitInfos2;
        }

        int[] bigSmallI = 
        (
            unitInfos2[0].BaseTenExponent > unitInfos2[1].BaseTenExponent ?
            new int[] { 0, 1 } : new int[] { 1, 0 }
        );

        //Only the variable with the bigger value is modified. For example: 5*10^5 & 3*10^3 is converted
        //into 500*10^3 & 3*10^3 in order to allow the addition 500 + 3. 
        UnitInfo big2 = AdaptBiggerAdditionOperand(unitInfos2, bigSmallI, operation);
        if (big2.Error.Type != ErrorTypes.None)
        {
            return TooBigGapAddition(unitInfos2, bigSmallI, operation);
        }

        unitInfos2[bigSmallI[0]].Value = big2.Value;
        unitInfos2[bigSmallI[0]].BaseTenExponent = unitInfos2[bigSmallI[1]].BaseTenExponent;

        return unitInfos2;
    }

    //When adding/subtracting two numbers whose gap is bigger than the maximum double range, there
    //is no need to perform any operation (i.e., no change will be observed because of being outside
    //the maximum supported precision). This method takes care of these cases and returns the expected
    //output (i.e., biggest value).
    static UnitInfo[] TooBigGapAddition(UnitInfo[] unitInfos2, int[] bigSmallI, Operations operation)
    {
        UnitInfo[] outInfos = new UnitInfo[] 
        {
            //First operand (i.e., one whose information defines the operation) together with the
            //numeric information (i.e., just Value and BaseTenExponent because both are normalised)
            //which is associated with the biggest one.
            new UnitInfo(unitInfos2[0])
            {{
                Value = unitInfos2[bigSmallI[0]].Value;
                BaseTenExponent = unitInfos2[bigSmallI[0]].BaseTenExponent;
            }}
        };

        if (operation == Operations.Subtraction && bigSmallI[0] == 1)
        {
            outInfos[0].Value = -1.0 * outInfos[0].Value;
        }

        if (outInfos[0].Unit == Units.Unitless)
        {
            outInfos[0].Unit = unitInfos2[bigSmallI[1]].Unit;
        }

        return outInfos;
    }

    static UnitInfo AdaptBiggerAdditionOperand(UnitInfo[] unitInfos2, Integer[] bigSmallI, Operations operation)
    {
        int gapExponent = unitInfos2[bigSmallI[0]].BaseTenExponent - unitInfos2[bigSmallI[1]].BaseTenExponent;
        if (gapExponent >= 27)
        {
            //The difference between both inputs is bigger than (or, at least, very close to) the maximum double value/precision;
            //what makes this situation calculation unworthy and the first operand to be returned as the result.
            //Note that the error below these lines is just an easy way to tell the calling function about this eventuality.
            return new UnitInfo(unitInfos2[0]) 
            {{ 
                Error = new ErrorInfo(ErrorTypes.InvalidOperation); 
            }};
        }

        //PerformManagedOperationValues is used to make sure that the resulting numeric information is stored
        //in Value (if possible).
        UnitInfo big2 = PerformManagedOperationValues
        (
            RaiseToIntegerExponent(10.0, gapExponent), unitInfos2[bigSmallI[0]].Value, 
            Operations.Multiplication                
        );

        boolean isWrong = 
        (
            big2.Error.Type != ErrorTypes.None || big2.BaseTenExponent != 0 ?
            
            //The value of the bigger input times 10^(gap between BaseTenExponent of inputs) is too big. 
            isWrong = true :
            
            //Overflow-check very unlikely to trigger an error. In fact, with properly normalised variables,
            //triggering an error would be plainly impossible.               
            AreAdditionFinalValuesWrong
            (
                unitInfos2[0].Value, unitInfos2[1].Value, operation
            )
        );

        UnitInfo temp = null;
        if (isWrong)
        {
        	temp = new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }};
            
            temp.Error = new ErrorInfo(ErrorTypes.InvalidOperation);
        }
        else
        {
        	temp = new UnitInfo(unitInfos2[bigSmallI[0]])
            {{
                Value = big2.Value;
            }};
        }
        
        
        return temp;
        
        
        return
        (
            isWrong ?
            //This error is just an easy way to let the calling function know about the fact that no
            //calculation has been performed (too big gap). This isn't a properly-speaking error and
            //that's why it will not be notified to the user.
            new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }} :
            //Returning the new big value. For example: with 5*10^4 & 3*10^2, 500 would be returned.
            new UnitInfo(unitInfos2[bigSmallI[0]])
            {{
                Value = big2.Value;
            }}
        )
    }

    static boolean AreAdditionFinalValuesWrong(double val1, double val2, Operations operation)
    {
        boolean isWrong = false;

        try
        {
            val1 = val1 + val2 *
            (
                operation == Operations.Addition ? 1 : -1
            );
        }
        catch { isWrong = true; }

        return isWrong;
    }

    static UnitInfo PerformManagedOperationMultiplication(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationNormalisedValues
        (
            firstInfo, new UnitInfo[] 
            { 
                NormaliseUnitInfo(firstInfo),
                NormaliseUnitInfo(secondInfo) 
            },
            operation
        );
    }

    public static UnitInfo RaiseToIntegerExponent(double baseValue, int exponent)
    {
        return RaiseToIntegerExponent(new UnitInfo(baseValue), exponent);
    }

    static UnitInfo RaiseToIntegerExponent(UnitInfo baseInfo, int exponent)
    {
        if (exponent <= 1 && exponent >= 0)
        {
            baseInfo.Value = (exponent == 0 ? 1.0 : baseInfo.Value);
            return baseInfo;
        }

        UnitInfo outInfo = new UnitInfo(baseInfo);

        for (int i = 1; i < Math.Abs(exponent); i++)
        {
            outInfo = PerformManagedOperationValues
            (
                outInfo, baseInfo, Operations.Multiplication
            );
            if (outInfo.Error.Type != ErrorTypes.None) return outInfo;
        }

        return
        (
            exponent < 0 ?
            PerformManagedOperationValues(new UnitInfo(1.0), outInfo, Operations.Division) :
            outInfo
        );
    }

    static UnitInfo PerformManagedOperationNormalisedValues(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        outInfo =
        (
            normalisedInfos.Length == 1 ?
            //There is just one operand when the difference between both of them is too big.
            outInfo = normalisedInfos[0] :
            PerformManagedOperationTwoOperands(outInfo, normalisedInfos, operation)
        );

        return outInfo;
    }

    static UnitInfo PerformManagedOperationTwoOperands(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        UnitInfo outInfoNormalised = PerformManagedOperationValues
        (
            normalisedInfos[0], normalisedInfos[1], operation
        );

        if (outInfo.Error.Type != ErrorTypes.None)
        {
            return new UnitInfo(outInfo)
            {
                Error = new ErrorInfo(ErrorTypes.NumericError)
            };
        }

        outInfo.BaseTenExponent = outInfoNormalised.BaseTenExponent;
        outInfo.Value = outInfoNormalised.Value;
        //Normalised means no prefixes.
        outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage); 

        return outInfo;
    }

    static UnitInfo PerformManagedOperationValues(double firstValue, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            new UnitInfo(firstValue), new UnitInfo(secondValue), operation
        );
    }

    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            firstInfo, new UnitInfo(secondValue), operation
        );
    }

    //This method might be used to perform full operations (not just being the last calculation step) instead
    //of the default one (PerformManagedOperationUnits) for simple cases. That is: ones not dealing with the
    //complex numeric reality (Value, Prefix and BaseTenExponent) which makes a pre-analysis required.
    //Note that, unlikely what happens with PerformMangedOperationUnits, the outputs of this method aren't
    //normalised (= primarily stored under Value), what is useful in certain contexts.
    //NOTE: this function assumes that both inputs are normalised, what means that no prefix information is expected.
    //It might also be used with non-normalised inputs, but their prefix information would be plainly ignored.
    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        if (firstInfo.Value == 0.0 || secondInfo.Value == 0.0)
        {
            if (operation == Operations.Multiplication || operation == Operations.Division)
            {
                //Dividing by zero scenarios are taken into account somewhere else.
                return new UnitInfo(firstInfo) { Value = 0.0 };
            }
        }

        UnitInfo outInfo = new UnitInfo(firstInfo);
        UnitInfo firstInfo0 = new UnitInfo(firstInfo);
        UnitInfo secondInfo0 = new UnitInfo(secondInfo);

        boolean isWrong = false;
        try
        {
            if (operation == Operations.Addition)
            {
                outInfo.Value += secondInfo0.Value;
            }
            else if (operation == Operations.Subtraction)
            {
                outInfo.Value -= secondInfo.Value;
            }
            else
            {
                //The reason for checking whether BaseTenExponent is inside/outside the int range before performing 
                //the operation (rather than going ahead and eventually catching the resulting exception) isn't just
                //being quicker, but also the only option in many situations. Note that an addition/subtraction between
                //two int variables whose result is outside the int range might not trigger an exception (+ random 
                //negative value as output).
                if (VaryBaseTenExponent(outInfo, secondInfo0.BaseTenExponent, operation == Operations.Division).Error.Type != ErrorTypes.None)
                {
                    return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
                }

                if (operation == Operations.Multiplication)
                {
                    outInfo.Value *= secondInfo.Value;
                    outInfo.BaseTenExponent += secondInfo.BaseTenExponent;
                }
                else if (operation == Operations.Division)
                {
                    if (secondInfo.Value == 0.0)
                    {
                        return
                        (
                            new UnitInfo(outInfo) 
                            { 
                                Error = new ErrorInfo(ErrorTypes.NumericError) 
                            }
                        );
                    }
                    outInfo.Value /= secondInfo.Value;
                    outInfo.BaseTenExponent -= secondInfo.BaseTenExponent;
                }
            }
        }
        catch { isWrong = true; }

        return
        (
            //An error might not be triggered despite of dealing with numbers outside double precision.
            //For example: 0.00000000000000000001m * 0.0000000000000000000001m can output 0.0 without triggering an error. 
            isWrong || ((operation == Operations.Multiplication || operation == Operations.Division) && outInfo.Value == 0.0.0) ?
            OperationValuesManageError(firstInfo0, secondInfo0, operation) : outInfo
        );
    }

    static UnitInfo OperationValuesManageError(UnitInfo outInfo, UnitInfo secondInfo, Operations operation)
    {
        if (operation != Operations.Multiplication && operation != Operations.Division)
        {
            //This condition should never be true on account of the fact that the pre-modifications performed before
            //adding/subtracting should avoid erroneous situations.
            return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
        }

        UnitInfo secondInfo2 = ConvertValueToBaseTen(secondInfo.Value);
        outInfo = VaryBaseTenExponent(outInfo, secondInfo2.BaseTenExponent, operation == Operations.Division);
        if (Math.Abs(secondInfo2.Value) == 1.0 || outInfo.Error.Type != ErrorTypes.None) return outInfo;
        
        try
        {
            outInfo = PerformManagedOperationUnits
            (
                outInfo, secondInfo2.Value, operation
            );
        }
        catch
        {
            //Very unlikely scenario on account of the fact that Math.Abs(secondInfo2.Value)
            //lies within the 0.1-10.0 range.
            outInfo = OperationValuesManageError
            (
                new UnitInfo(outInfo)
                {
                    Value = secondInfo2.Value,
                    BaseTenExponent = 0
                },
                new UnitInfo()
                {
                    Value = outInfo.Value,
                    BaseTenExponent = outInfo.BaseTenExponent
                },
                operation
            );
        }

        return outInfo;
    }

    static UnitInfo ConvertValueToBaseTen(double value)
    {
        value = Math.Abs(value);
        return FromValueToBaseTenExponent
        (
             new UnitInfo(value), Math.Abs(value), false
        );
    }

    static UnitInfo ConvertBaseTenToValue(UnitInfo unitInfo)
    {
        if (unitInfo.BaseTenExponent == 0) return unitInfo;

        UnitInfo outInfo = new UnitInfo(unitInfo);
        boolean decrease = unitInfo.BaseTenExponent > 0;
        int sign = Math.Sign(outInfo.Value);
        double absValue = Math.Abs(outInfo.Value);

        while (outInfo.BaseTenExponent != 0.0)
        {
            if (decrease)
            {
                if (absValue >= MaxValueDec / 10.0) break;
                absValue *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }
            else
            {
                if (absValue <= MinValueDec * 10.0) break;
                absValue /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
        }

        outInfo.Value = sign * absValue;

        return outInfo;
    }

    static UnitInfo NormaliseUnitInfo(UnitInfo unitInfo)
    {
        if (unitInfo.Value == 0 && unitInfo.Prefix.Factor == 1.0)
        {
            return unitInfo;
        }
        UnitInfo outInfo = new UnitInfo(unitInfo);

        if (outInfo.Prefix.Factor != 1)
        {
            outInfo = FromValueToBaseTenExponent
            (
                outInfo, outInfo.Prefix.Factor, true
            );
            outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage);
        }
        if (outInfo.Value == 0.0) return outInfo;

        outInfo = FromValueToBaseTenExponent
        (
            outInfo, outInfo.Value, false
        );

        return outInfo;
    }

    static UnitInfo FromValueToBaseTenExponent(UnitInfo outInfo, double value, boolean isPrefix)
    {
        if (value == 0.0) return outInfo;

        double valueAbs = Math.Abs(value);
        boolean decrease = (valueAbs > 1.0);
        if (!isPrefix)
        {
            outInfo.Value = outInfo.Value / valueAbs;
        }

        while (valueAbs != 1.0)
        {
            if ((valueAbs < 10.0 && valueAbs > 1.0) || (valueAbs > 0.1.0 && valueAbs < 1.0))
            {
                if (!isPrefix) outInfo.Value = value;
                else
                {
                    outInfo = PerformManagedOperationValues
                    (
                        outInfo, value, Operations.Multiplication
                    );
                }

                return outInfo;
            }

            if (decrease)
            {
                value /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
            else
            {
                value *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }

            valueAbs = Math.Abs(value);
        }

        return outInfo;
    }

    //Method used to vary BaseTenExponent without provoking unhandled exceptions (i.e., bigger than Integer.MAX_VALUE).
    static UnitInfo VaryBaseTenExponent(UnitInfo info, int baseTenIncrease, boolean isDivision = false)
    {
        long val1 = info.BaseTenExponent;
        long val2 = baseTenIncrease;

        if (isDivision)
        {
            //Converting a negative value into positive might provoke an overflow error for the int type
            //(e.g., Math.Abs(Integer.MAIN_VALUE)). Converting both variables to long is a quick and effective
            //way to avoid this problem.
            val2 *= -1;
        }

        return
        (
             ((val2 > 0 && val1 > Integer.MAX_VALUE - val2) || (val2 < 0 && val1 < Integer.MAIN_VALUE - val2)) ?
            new UnitInfo(info, ErrorTypes.NumericError) : new UnitInfo(info){{ BaseTenExponent = (int)(val1 + val2); }}
        );
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 2 2017-05-27 20:05:57.709
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 0 2017-05-27 20:05:57.710
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)
!SESSION 2017-05-29 13:41:51.196 -----------------------------------------------
eclipse.buildId=4.6.3.M20170301-0400
java.version=1.8.0_131
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_ES
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.core.resources 4 567 2017-05-29 13:41:52.845
!MESSAGE Workspace restored, but some problems occurred.
!SUBENTRY 1 org.eclipse.core.resources 4 567 2017-05-29 13:41:52.846
!MESSAGE Could not read metadata for 'UnitParser'.
!STACK 1
org.eclipse.core.internal.resources.ResourceException: The project description file (.project) for 'UnitParser' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:907)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:904)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:884)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:735)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1587)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2399)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2156)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:464)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$3.run(BundleContextImpl.java:774)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$3.run(BundleContextImpl.java:1)
	at java.security.AccessController.doPrivileged(Native Method)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:767)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:724)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:932)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:309)
	at org.eclipse.osgi.container.Module.doStart(Module.java:581)
	at org.eclipse.osgi.container.Module.start(Module.java:449)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:470)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:107)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:529)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:325)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:345)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:36)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClassInternal(BundleLoader.java:419)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:372)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:364)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:161)
	at java.lang.ClassLoader.loadClass(Unknown Source)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:139)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:388)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:243)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:673)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:610)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1519)
!SUBENTRY 2 org.eclipse.core.resources 4 567 2017-05-29 13:41:52.847
!MESSAGE The project description file (.project) for 'UnitParser' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
!SUBENTRY 1 org.eclipse.core.resources 4 567 2017-05-29 13:41:52.847
!MESSAGE Could not read metadata for 'testing'.
!STACK 1
org.eclipse.core.internal.resources.ResourceException: The project description file (.project) for 'testing' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:907)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:904)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:884)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:735)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1587)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2399)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2156)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:464)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$3.run(BundleContextImpl.java:774)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$3.run(BundleContextImpl.java:1)
	at java.security.AccessController.doPrivileged(Native Method)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:767)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:724)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:932)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:309)
	at org.eclipse.osgi.container.Module.doStart(Module.java:581)
	at org.eclipse.osgi.container.Module.start(Module.java:449)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:470)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:107)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:529)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:325)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:345)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:36)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClassInternal(BundleLoader.java:419)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:372)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:364)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:161)
	at java.lang.ClassLoader.loadClass(Unknown Source)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:139)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:388)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:243)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:673)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:610)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1519)
!SUBENTRY 2 org.eclipse.core.resources 4 567 2017-05-29 13:41:52.848
!MESSAGE The project description file (.project) for 'testing' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.

!ENTRY org.eclipse.egit.ui 2 0 2017-05-29 13:41:58.536
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Alvaro'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2017-05-29 13:42:10.211 -----------------------------------------------
eclipse.buildId=4.6.3.M20170301-0400
java.version=1.8.0_131
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_ES
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.egit.ui 2 0 2017-05-29 13:42:16.493
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Alvaro'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.recommenders.rcp 4 18 2017-05-29 14:02:46.918
!MESSAGE Failed to resolve selection in ‘=testing/src<testing{Testing.java’ at offset 1,253.
!STACK 0
org.eclipse.recommenders.utils.Logs$LogTraceException
	at org.eclipse.recommenders.utils.Logs$LogTraceException.newTrace(Logs.java:381)
	at org.eclipse.recommenders.utils.Logs.log(Logs.java:134)
	at org.eclipse.recommenders.internal.rcp.JavaElementSelections.resolveJavaElementFromTypeRootInEditor(JavaElementSelections.java:164)
	at org.eclipse.recommenders.internal.rcp.JavaElementSelections.resolveJavaElementFromEditor(JavaElementSelections.java:119)
	at org.eclipse.recommenders.internal.rcp.JavaElementSelections.resolveJavaElementFromEditor(JavaElementSelections.java:102)
	at org.eclipse.recommenders.internal.rcp.JavaElementSelectionService.handleSelectionInEditor(JavaElementSelectionService.java:108)
	at org.eclipse.recommenders.internal.rcp.JavaElementSelectionService.access$1(JavaElementSelectionService.java:105)
	at org.eclipse.recommenders.internal.rcp.JavaElementSelectionService$1.run(JavaElementSelectionService.java:82)
	at java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source)
	at java.util.concurrent.FutureTask.run(Unknown Source)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(Unknown Source)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(Unknown Source)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source)
	at java.lang.Thread.run(Unknown Source)

!ENTRY org.eclipse.recommenders.subwords.rcp 4 1 2017-05-29 14:02:55.603
!MESSAGE Exception during code completion
!STACK 0
org.eclipse.core.runtime.OperationCanceledException
	at org.eclipse.jdt.internal.codeassist.CompletionEngine.checkCancel(CompletionEngine.java:1688)
	at org.eclipse.jdt.internal.codeassist.CompletionEngine.completionOnSingleNameReference(CompletionEngine.java:3298)
	at org.eclipse.jdt.internal.codeassist.CompletionEngine.complete(CompletionEngine.java:1718)
	at org.eclipse.jdt.internal.codeassist.CompletionEngine.complete(CompletionEngine.java:1944)
	at org.eclipse.jdt.internal.core.Openable.codeComplete(Openable.java:131)
	at org.eclipse.jdt.internal.core.CompilationUnit.codeComplete(CompilationUnit.java:357)
	at org.eclipse.jdt.internal.core.CompilationUnit.codeComplete(CompilationUnit.java:345)
	at org.eclipse.recommenders.internal.subwords.rcp.SubwordsSessionProcessor.computeProposals(SubwordsSessionProcessor.java:338)
	at org.eclipse.recommenders.internal.subwords.rcp.SubwordsSessionProcessor.getNewProposals(SubwordsSessionProcessor.java:227)
	at org.eclipse.recommenders.internal.subwords.rcp.SubwordsSessionProcessor.initializeContext(SubwordsSessionProcessor.java:167)
	at org.eclipse.recommenders.completion.rcp.processable.IntelligentCompletionProposalComputer.fireInitializeContext(IntelligentCompletionProposalComputer.java:292)
	at org.eclipse.recommenders.completion.rcp.processable.IntelligentCompletionProposalComputer.computeCompletionProposals(IntelligentCompletionProposalComputer.java:169)
	at org.eclipse.jdt.internal.ui.text.java.CompletionProposalComputerDescriptor.computeCompletionProposals(CompletionProposalComputerDescriptor.java:333)
	at org.eclipse.jdt.internal.ui.text.java.CompletionProposalCategory.computeCompletionProposals(CompletionProposalCategory.java:337)
	at org.eclipse.jdt.internal.ui.text.java.ContentAssistProcessor.collectProposals(ContentAssistProcessor.java:331)
	at org.eclipse.jdt.internal.ui.text.java.ContentAssistProcessor.computeCompletionProposals(ContentAssistProcessor.java:288)
	at org.eclipse.jface.text.contentassist.ContentAssistant$3.run(ContentAssistant.java:1931)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jface.text.contentassist.ContentAssistant.computeCompletionProposals(ContentAssistant.java:1928)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.computeProposals(CompletionProposalPopup.java:565)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.computeFilteredProposals(CompletionProposalPopup.java:1523)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.access$4(CompletionProposalPopup.java:1512)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup$1.run(CompletionProposalPopup.java:362)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:182)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4211)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3827)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:1121)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1022)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:150)
	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:693)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:610)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:148)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:138)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:388)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:243)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:673)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:610)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1519)

!ENTRY org.eclipse.jdt.ui 2 0 2017-05-29 14:02:55.607
!MESSAGE The 'org.eclipse.recommenders.completion.rcp.javaCompletionProposalComputer.intelligent' proposal computer from the 'org.eclipse.recommenders.completion.rcp' plug-in did not complete normally. The extension took too long to return from the 'computeCompletionProposals()' operation.
!SESSION 2017-05-29 15:58:05.745 -----------------------------------------------
eclipse.buildId=4.6.3.M20170301-0400
java.version=1.8.0_131
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_ES
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.egit.ui 2 0 2017-05-29 15:58:12.522
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Alvaro'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.recommenders.subwords.rcp 4 1 2017-05-29 16:00:48.718
!MESSAGE Exception during code completion
!STACK 0
org.eclipse.core.runtime.OperationCanceledException
	at org.eclipse.jdt.internal.codeassist.CompletionEngine.checkCancel(CompletionEngine.java:1688)
	at org.eclipse.jdt.internal.codeassist.CompletionEngine.completionOnSingleNameReference(CompletionEngine.java:3298)
	at org.eclipse.jdt.internal.codeassist.CompletionEngine.complete(CompletionEngine.java:1718)
	at org.eclipse.jdt.internal.codeassist.CompletionEngine.complete(CompletionEngine.java:1944)
	at org.eclipse.jdt.internal.core.Openable.codeComplete(Openable.java:131)
	at org.eclipse.jdt.internal.core.CompilationUnit.codeComplete(CompilationUnit.java:357)
	at org.eclipse.jdt.internal.core.CompilationUnit.codeComplete(CompilationUnit.java:345)
	at org.eclipse.recommenders.internal.subwords.rcp.SubwordsSessionProcessor.computeProposals(SubwordsSessionProcessor.java:338)
	at org.eclipse.recommenders.internal.subwords.rcp.SubwordsSessionProcessor.getNewProposals(SubwordsSessionProcessor.java:227)
	at org.eclipse.recommenders.internal.subwords.rcp.SubwordsSessionProcessor.initializeContext(SubwordsSessionProcessor.java:167)
	at org.eclipse.recommenders.completion.rcp.processable.IntelligentCompletionProposalComputer.fireInitializeContext(IntelligentCompletionProposalComputer.java:292)
	at org.eclipse.recommenders.completion.rcp.processable.IntelligentCompletionProposalComputer.computeCompletionProposals(IntelligentCompletionProposalComputer.java:169)
	at org.eclipse.jdt.internal.ui.text.java.CompletionProposalComputerDescriptor.computeCompletionProposals(CompletionProposalComputerDescriptor.java:333)
	at org.eclipse.jdt.internal.ui.text.java.CompletionProposalCategory.computeCompletionProposals(CompletionProposalCategory.java:337)
	at org.eclipse.jdt.internal.ui.text.java.ContentAssistProcessor.collectProposals(ContentAssistProcessor.java:331)
	at org.eclipse.jdt.internal.ui.text.java.ContentAssistProcessor.computeCompletionProposals(ContentAssistProcessor.java:288)
	at org.eclipse.jface.text.contentassist.ContentAssistant$3.run(ContentAssistant.java:1931)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jface.text.contentassist.ContentAssistant.computeCompletionProposals(ContentAssistant.java:1928)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.computeProposals(CompletionProposalPopup.java:565)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.computeFilteredProposals(CompletionProposalPopup.java:1523)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.access$4(CompletionProposalPopup.java:1512)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup$1.run(CompletionProposalPopup.java:362)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:182)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4211)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3827)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:1121)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1022)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:150)
	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:693)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:610)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:148)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:138)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:388)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:243)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:673)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:610)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1519)

!ENTRY org.eclipse.jdt.ui 2 0 2017-05-29 16:00:48.747
!MESSAGE The 'org.eclipse.recommenders.completion.rcp.javaCompletionProposalComputer.intelligent' proposal computer from the 'org.eclipse.recommenders.completion.rcp' plug-in did not complete normally. The extension took too long to return from the 'computeCompletionProposals()' operation.

!ENTRY org.eclipse.recommenders.subwords.rcp 4 1 2017-05-29 16:02:33.420
!MESSAGE Exception during code completion
!STACK 0
org.eclipse.core.runtime.OperationCanceledException
	at org.eclipse.jdt.internal.codeassist.CompletionEngine.checkCancel(CompletionEngine.java:1688)
	at org.eclipse.jdt.internal.codeassist.CompletionEngine.completionOnSingleNameReference(CompletionEngine.java:3298)
	at org.eclipse.jdt.internal.codeassist.CompletionEngine.complete(CompletionEngine.java:1718)
	at org.eclipse.jdt.internal.codeassist.CompletionEngine.complete(CompletionEngine.java:1944)
	at org.eclipse.jdt.internal.core.Openable.codeComplete(Openable.java:131)
	at org.eclipse.jdt.internal.core.CompilationUnit.codeComplete(CompilationUnit.java:357)
	at org.eclipse.jdt.internal.core.CompilationUnit.codeComplete(CompilationUnit.java:345)
	at org.eclipse.recommenders.internal.subwords.rcp.SubwordsSessionProcessor.computeProposals(SubwordsSessionProcessor.java:338)
	at org.eclipse.recommenders.internal.subwords.rcp.SubwordsSessionProcessor.getNewProposals(SubwordsSessionProcessor.java:227)
	at org.eclipse.recommenders.internal.subwords.rcp.SubwordsSessionProcessor.initializeContext(SubwordsSessionProcessor.java:167)
	at org.eclipse.recommenders.completion.rcp.processable.IntelligentCompletionProposalComputer.fireInitializeContext(IntelligentCompletionProposalComputer.java:292)
	at org.eclipse.recommenders.completion.rcp.processable.IntelligentCompletionProposalComputer.computeCompletionProposals(IntelligentCompletionProposalComputer.java:169)
	at org.eclipse.jdt.internal.ui.text.java.CompletionProposalComputerDescriptor.computeCompletionProposals(CompletionProposalComputerDescriptor.java:333)
	at org.eclipse.jdt.internal.ui.text.java.CompletionProposalCategory.computeCompletionProposals(CompletionProposalCategory.java:337)
	at org.eclipse.jdt.internal.ui.text.java.ContentAssistProcessor.collectProposals(ContentAssistProcessor.java:331)
	at org.eclipse.jdt.internal.ui.text.java.ContentAssistProcessor.computeCompletionProposals(ContentAssistProcessor.java:288)
	at org.eclipse.jface.text.contentassist.ContentAssistant$3.run(ContentAssistant.java:1931)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jface.text.contentassist.ContentAssistant.computeCompletionProposals(ContentAssistant.java:1928)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.computeProposals(CompletionProposalPopup.java:565)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.computeFilteredProposals(CompletionProposalPopup.java:1523)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.access$4(CompletionProposalPopup.java:1512)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup$1.run(CompletionProposalPopup.java:362)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:182)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4211)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3827)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:1121)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1022)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:150)
	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:693)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:610)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:148)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:138)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:388)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:243)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:673)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:610)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1519)

!ENTRY org.eclipse.jdt.ui 2 0 2017-05-29 16:02:33.433
!MESSAGE The 'org.eclipse.recommenders.completion.rcp.javaCompletionProposalComputer.intelligent' proposal computer from the 'org.eclipse.recommenders.completion.rcp' plug-in did not complete normally. The extension took too long to return from the 'computeCompletionProposals()' operation.

!ENTRY org.eclipse.recommenders.subwords.rcp 4 1 2017-05-29 16:08:57.339
!MESSAGE Exception during code completion
!STACK 0
org.eclipse.core.runtime.OperationCanceledException
	at org.eclipse.jdt.internal.codeassist.CompletionEngine.checkCancel(CompletionEngine.java:1688)
	at org.eclipse.jdt.internal.codeassist.CompletionEngine.completionOnSingleNameReference(CompletionEngine.java:3298)
	at org.eclipse.jdt.internal.codeassist.CompletionEngine.complete(CompletionEngine.java:1718)
	at org.eclipse.jdt.internal.codeassist.CompletionEngine.complete(CompletionEngine.java:1944)
	at org.eclipse.jdt.internal.core.Openable.codeComplete(Openable.java:131)
	at org.eclipse.jdt.internal.core.CompilationUnit.codeComplete(CompilationUnit.java:357)
	at org.eclipse.jdt.internal.core.CompilationUnit.codeComplete(CompilationUnit.java:345)
	at org.eclipse.recommenders.internal.subwords.rcp.SubwordsSessionProcessor.computeProposals(SubwordsSessionProcessor.java:338)
	at org.eclipse.recommenders.internal.subwords.rcp.SubwordsSessionProcessor.getNewProposals(SubwordsSessionProcessor.java:227)
	at org.eclipse.recommenders.internal.subwords.rcp.SubwordsSessionProcessor.initializeContext(SubwordsSessionProcessor.java:167)
	at org.eclipse.recommenders.completion.rcp.processable.IntelligentCompletionProposalComputer.fireInitializeContext(IntelligentCompletionProposalComputer.java:292)
	at org.eclipse.recommenders.completion.rcp.processable.IntelligentCompletionProposalComputer.computeCompletionProposals(IntelligentCompletionProposalComputer.java:169)
	at org.eclipse.jdt.internal.ui.text.java.CompletionProposalComputerDescriptor.computeCompletionProposals(CompletionProposalComputerDescriptor.java:333)
	at org.eclipse.jdt.internal.ui.text.java.CompletionProposalCategory.computeCompletionProposals(CompletionProposalCategory.java:337)
	at org.eclipse.jdt.internal.ui.text.java.ContentAssistProcessor.collectProposals(ContentAssistProcessor.java:331)
	at org.eclipse.jdt.internal.ui.text.java.ContentAssistProcessor.computeCompletionProposals(ContentAssistProcessor.java:288)
	at org.eclipse.jface.text.contentassist.ContentAssistant$3.run(ContentAssistant.java:1931)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jface.text.contentassist.ContentAssistant.computeCompletionProposals(ContentAssistant.java:1928)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.computeProposals(CompletionProposalPopup.java:565)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.computeFilteredProposals(CompletionProposalPopup.java:1523)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.access$4(CompletionProposalPopup.java:1512)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup$1.run(CompletionProposalPopup.java:362)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:182)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4211)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3827)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:1121)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1022)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:150)
	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:693)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:610)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:148)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:138)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:388)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:243)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:673)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:610)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1519)

!ENTRY org.eclipse.jdt.ui 2 0 2017-05-29 16:08:57.344
!MESSAGE The 'org.eclipse.recommenders.completion.rcp.javaCompletionProposalComputer.intelligent' proposal computer from the 'org.eclipse.recommenders.completion.rcp' plug-in did not complete normally. The extension took too long to return from the 'computeCompletionProposals()' operation.

!ENTRY org.eclipse.jdt.ui 4 10001 2017-05-29 16:19:21.800
!MESSAGE Internal Error
!STACK 1
Java Model Exception: Core Exception [code 0] Illegal hierarchy
	at org.eclipse.jdt.internal.ui.text.java.LazyGenericTypeProposal.findMatchingSuperTypeSignature(LazyGenericTypeProposal.java:572)
	at org.eclipse.jdt.internal.ui.text.java.LazyGenericTypeProposal.mapTypeParameterIndex(LazyGenericTypeProposal.java:532)
	at org.eclipse.jdt.internal.ui.text.java.LazyGenericTypeProposal.computeTypeArgumentProposals(LazyGenericTypeProposal.java:351)
	at org.eclipse.jdt.internal.ui.text.java.LazyGenericTypeProposal.apply(LazyGenericTypeProposal.java:225)
	at org.eclipse.jdt.internal.ui.text.java.AbstractJavaCompletionProposal.apply(AbstractJavaCompletionProposal.java:519)
	at org.eclipse.jdt.internal.ui.text.java.LazyJavaCompletionProposal.apply(LazyJavaCompletionProposal.java:443)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.insertProposal(CompletionProposalPopup.java:989)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.insertSelectedProposalWithMask(CompletionProposalPopup.java:938)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.access$27(CompletionProposalPopup.java:934)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup$5.widgetDefaultSelected(CompletionProposalPopup.java:679)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:120)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4418)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1079)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4236)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3824)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:1121)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1022)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:150)
	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:693)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:610)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:148)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:138)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:388)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:243)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:673)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:610)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1519)
Caused by: org.eclipse.core.runtime.CoreException: Illegal hierarchy
	at org.eclipse.jdt.internal.ui.text.java.LazyGenericTypeProposal.findMatchingSuperTypeSignature(LazyGenericTypeProposal.java:572)
	at org.eclipse.jdt.internal.ui.text.java.LazyGenericTypeProposal.mapTypeParameterIndex(LazyGenericTypeProposal.java:532)
	at org.eclipse.jdt.internal.ui.text.java.LazyGenericTypeProposal.computeTypeArgumentProposals(LazyGenericTypeProposal.java:351)
	at org.eclipse.jdt.internal.ui.text.java.LazyGenericTypeProposal.apply(LazyGenericTypeProposal.java:225)
	at org.eclipse.jdt.internal.ui.text.java.AbstractJavaCompletionProposal.apply(AbstractJavaCompletionProposal.java:519)
	at org.eclipse.jdt.internal.ui.text.java.LazyJavaCompletionProposal.apply(LazyJavaCompletionProposal.java:443)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.insertProposal(CompletionProposalPopup.java:989)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.insertSelectedProposalWithMask(CompletionProposalPopup.java:938)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.access$27(CompletionProposalPopup.java:934)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup$5.widgetDefaultSelected(CompletionProposalPopup.java:679)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:120)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4418)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1079)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4236)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3824)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:1121)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1022)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:150)
	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:693)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:610)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:148)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:138)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:388)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:243)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:673)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:610)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1519)
!SUBENTRY 1 org.eclipse.jdt.ui 4 0 2017-05-29 16:19:21.800
!MESSAGE Illegal hierarchy

!ENTRY org.eclipse.jdt.ui 4 2 2017-05-29 17:04:40.924
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.ClassCastException: org.eclipse.jdt.internal.core.TypeParameter cannot be cast to org.eclipse.jdt.core.IType
	at org.eclipse.jdt.internal.ui.text.correction.UnresolvedElementsSubProcessor.addNewTypeProposals(UnresolvedElementsSubProcessor.java:913)
	at org.eclipse.jdt.internal.ui.text.correction.UnresolvedElementsSubProcessor.getTypeProposals(UnresolvedElementsSubProcessor.java:631)
	at org.eclipse.jdt.internal.ui.text.correction.QuickFixProcessor.process(QuickFixProcessor.java:375)
	at org.eclipse.jdt.internal.ui.text.correction.QuickFixProcessor.getCorrections(QuickFixProcessor.java:316)
	at org.eclipse.jdt.internal.ui.text.correction.JavaCorrectionProcessor$SafeCorrectionCollector.safeRun(JavaCorrectionProcessor.java:384)
	at org.eclipse.jdt.internal.ui.text.correction.JavaCorrectionProcessor$SafeCorrectionProcessorAccess.run(JavaCorrectionProcessor.java:344)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.correction.JavaCorrectionProcessor$SafeCorrectionProcessorAccess.process(JavaCorrectionProcessor.java:339)
	at org.eclipse.jdt.internal.ui.text.correction.JavaCorrectionProcessor.collectCorrections(JavaCorrectionProcessor.java:474)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:102)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:76)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:287)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:187)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1194)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1163)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:894)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:244)
	at org.eclipse.jface.text.TextViewerHoverManager$5.run(TextViewerHoverManager.java:234)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:182)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4211)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3827)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:1121)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1022)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:150)
	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:693)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:610)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:148)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:138)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:388)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:243)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:673)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:610)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1519)
!SESSION 2017-05-29 17:19:29.920 -----------------------------------------------
eclipse.buildId=4.6.3.M20170301-0400
java.version=1.8.0_131
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_ES
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.egit.ui 2 0 2017-05-29 17:19:36.721
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Alvaro'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.ui 4 10001 2017-05-29 18:00:31.607
!MESSAGE Internal Error
!STACK 1
Java Model Exception: Core Exception [code 0] Illegal hierarchy
	at org.eclipse.jdt.internal.ui.text.java.LazyGenericTypeProposal.findMatchingSuperTypeSignature(LazyGenericTypeProposal.java:572)
	at org.eclipse.jdt.internal.ui.text.java.LazyGenericTypeProposal.mapTypeParameterIndex(LazyGenericTypeProposal.java:532)
	at org.eclipse.jdt.internal.ui.text.java.LazyGenericTypeProposal.computeTypeArgumentProposals(LazyGenericTypeProposal.java:351)
	at org.eclipse.jdt.internal.ui.text.java.LazyGenericTypeProposal.apply(LazyGenericTypeProposal.java:225)
	at org.eclipse.jdt.internal.ui.text.java.AbstractJavaCompletionProposal.apply(AbstractJavaCompletionProposal.java:519)
	at org.eclipse.jdt.internal.ui.text.java.LazyJavaCompletionProposal.apply(LazyJavaCompletionProposal.java:443)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.insertProposal(CompletionProposalPopup.java:989)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.insertSelectedProposalWithMask(CompletionProposalPopup.java:938)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.access$27(CompletionProposalPopup.java:934)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup$5.widgetDefaultSelected(CompletionProposalPopup.java:679)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:120)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4418)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1079)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4236)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3824)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:1121)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1022)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:150)
	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:693)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:610)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:148)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:138)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:388)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:243)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:673)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:610)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1519)
Caused by: org.eclipse.core.runtime.CoreException: Illegal hierarchy
	at org.eclipse.jdt.internal.ui.text.java.LazyGenericTypeProposal.findMatchingSuperTypeSignature(LazyGenericTypeProposal.java:572)
	at org.eclipse.jdt.internal.ui.text.java.LazyGenericTypeProposal.mapTypeParameterIndex(LazyGenericTypeProposal.java:532)
	at org.eclipse.jdt.internal.ui.text.java.LazyGenericTypeProposal.computeTypeArgumentProposals(LazyGenericTypeProposal.java:351)
	at org.eclipse.jdt.internal.ui.text.java.LazyGenericTypeProposal.apply(LazyGenericTypeProposal.java:225)
	at org.eclipse.jdt.internal.ui.text.java.AbstractJavaCompletionProposal.apply(AbstractJavaCompletionProposal.java:519)
	at org.eclipse.jdt.internal.ui.text.java.LazyJavaCompletionProposal.apply(LazyJavaCompletionProposal.java:443)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.insertProposal(CompletionProposalPopup.java:989)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.insertSelectedProposalWithMask(CompletionProposalPopup.java:938)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.access$27(CompletionProposalPopup.java:934)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup$5.widgetDefaultSelected(CompletionProposalPopup.java:679)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:120)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4418)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1079)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4236)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3824)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:1121)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1022)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:150)
	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:693)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:610)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:148)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:138)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:388)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:243)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:673)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:610)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1519)
!SUBENTRY 1 org.eclipse.jdt.ui 4 0 2017-05-29 18:00:31.608
!MESSAGE Illegal hierarchy
!SESSION 2017-05-29 21:35:36.875 -----------------------------------------------
eclipse.buildId=4.6.3.M20170301-0400
java.version=1.8.0_131
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_ES
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.egit.ui 2 0 2017-05-29 21:35:44.958
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Alvaro'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2017-05-30 10:02:31.887 -----------------------------------------------
eclipse.buildId=4.6.3.M20170301-0400
java.version=1.8.0_131
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_ES
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.egit.ui 2 0 2017-05-30 10:02:58.111
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Alvaro'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2017-05-30 10:24:01.374 -----------------------------------------------
eclipse.buildId=4.6.3.M20170301-0400
java.version=1.8.0_131
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_ES
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.egit.ui 2 0 2017-05-30 10:24:08.363
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Alvaro'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.core.resources 4 2 2017-05-30 10:27:00.358
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.core.resources".
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.BinaryExpression.analyseCode(BinaryExpression.java:65)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.analyseCode(ForStatement.java:95)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:125)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:739)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:263)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:873)
	at org.eclipse.jdt.internal.compiler.ProcessTaskManager.run(ProcessTaskManager.java:141)
	at java.lang.Thread.run(Unknown Source)

!ENTRY org.eclipse.core.resources 4 75 2017-05-30 10:27:00.483
!MESSAGE Errors occurred during the build.
!SUBENTRY 1 org.eclipse.jdt.core 4 75 2017-05-30 10:27:00.483
!MESSAGE Errors running builder 'Java Builder' on project 'UnitParser'.
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.BinaryExpression.analyseCode(BinaryExpression.java:65)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.analyseCode(ForStatement.java:95)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:125)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:739)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:263)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:873)
	at org.eclipse.jdt.internal.compiler.ProcessTaskManager.run(ProcessTaskManager.java:141)
	at java.lang.Thread.run(Unknown Source)

!ENTRY org.eclipse.core.resources 4 2 2017-05-30 10:28:32.688
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.core.resources".
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.BinaryExpression.analyseCode(BinaryExpression.java:65)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.analyseCode(ForStatement.java:95)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:125)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:739)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:263)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:873)
	at org.eclipse.jdt.internal.compiler.ProcessTaskManager.run(ProcessTaskManager.java:141)
	at java.lang.Thread.run(Unknown Source)

!ENTRY org.eclipse.core.resources 4 75 2017-05-30 10:28:32.690
!MESSAGE Errors occurred during the build.
!SUBENTRY 1 org.eclipse.jdt.core 4 75 2017-05-30 10:28:32.690
!MESSAGE Errors running builder 'Java Builder' on project 'UnitParser'.
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.BinaryExpression.analyseCode(BinaryExpression.java:65)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.analyseCode(ForStatement.java:95)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:125)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:739)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:263)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:118)
	at org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:873)
	at org.eclipse.jdt.internal.compiler.ProcessTaskManager.run(ProcessTaskManager.java:141)
	at java.lang.Thread.run(Unknown Source)

!ENTRY org.eclipse.jdt.ui 4 10001 2017-05-30 11:21:34.902
!MESSAGE Internal Error
!STACK 1
Java Model Exception: Core Exception [code 0] Illegal hierarchy
	at org.eclipse.jdt.internal.ui.text.java.LazyGenericTypeProposal.findMatchingSuperTypeSignature(LazyGenericTypeProposal.java:572)
	at org.eclipse.jdt.internal.ui.text.java.LazyGenericTypeProposal.mapTypeParameterIndex(LazyGenericTypeProposal.java:532)
	at org.eclipse.jdt.internal.ui.text.java.LazyGenericTypeProposal.computeTypeArgumentProposals(LazyGenericTypeProposal.java:351)
	at org.eclipse.jdt.internal.ui.text.java.LazyGenericTypeProposal.apply(LazyGenericTypeProposal.java:225)
	at org.eclipse.jdt.internal.ui.text.java.AbstractJavaCompletionProposal.apply(AbstractJavaCompletionProposal.java:519)
	at org.eclipse.jdt.internal.ui.text.java.LazyJavaCompletionProposal.apply(LazyJavaCompletionProposal.java:443)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.insertProposal(CompletionProposalPopup.java:989)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.insertSelectedProposalWithMask(CompletionProposalPopup.java:938)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.access$27(CompletionProposalPopup.java:934)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup$5.widgetDefaultSelected(CompletionProposalPopup.java:679)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:120)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4418)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1079)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4236)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3824)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:1121)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1022)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:150)
	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:693)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:610)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:148)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:138)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:388)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:243)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:673)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:610)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1519)
Caused by: org.eclipse.core.runtime.CoreException: Illegal hierarchy
	at org.eclipse.jdt.internal.ui.text.java.LazyGenericTypeProposal.findMatchingSuperTypeSignature(LazyGenericTypeProposal.java:572)
	at org.eclipse.jdt.internal.ui.text.java.LazyGenericTypeProposal.mapTypeParameterIndex(LazyGenericTypeProposal.java:532)
	at org.eclipse.jdt.internal.ui.text.java.LazyGenericTypeProposal.computeTypeArgumentProposals(LazyGenericTypeProposal.java:351)
	at org.eclipse.jdt.internal.ui.text.java.LazyGenericTypeProposal.apply(LazyGenericTypeProposal.java:225)
	at org.eclipse.jdt.internal.ui.text.java.AbstractJavaCompletionProposal.apply(AbstractJavaCompletionProposal.java:519)
	at org.eclipse.jdt.internal.ui.text.java.LazyJavaCompletionProposal.apply(LazyJavaCompletionProposal.java:443)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.insertProposal(CompletionProposalPopup.java:989)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.insertSelectedProposalWithMask(CompletionProposalPopup.java:938)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.access$27(CompletionProposalPopup.java:934)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup$5.widgetDefaultSelected(CompletionProposalPopup.java:679)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:120)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4418)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1079)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4236)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3824)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:1121)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1022)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:150)
	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:693)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:610)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:148)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:138)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:388)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:243)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:673)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:610)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1519)
!SUBENTRY 1 org.eclipse.jdt.ui 4 0 2017-05-30 11:21:34.903
!MESSAGE Illegal hierarchy
!SESSION 2017-05-30 13:09:39.087 -----------------------------------------------
eclipse.buildId=4.6.3.M20170301-0400
java.version=1.8.0_131
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_ES
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.egit.ui 2 0 2017-05-30 13:09:44.844
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Alvaro'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2017-05-30 15:18:51.408 -----------------------------------------------
eclipse.buildId=4.6.3.M20170301-0400
java.version=1.8.0_131
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_ES
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.egit.ui 2 0 2017-05-30 15:18:58.419
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Alvaro'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.ui 4 10001 2017-05-30 18:03:50.966
!MESSAGE Internal Error
!STACK 1
Java Model Exception: Core Exception [code 0] Illegal hierarchy
	at org.eclipse.jdt.internal.ui.text.java.LazyGenericTypeProposal.findMatchingSuperTypeSignature(LazyGenericTypeProposal.java:572)
	at org.eclipse.jdt.internal.ui.text.java.LazyGenericTypeProposal.mapTypeParameterIndex(LazyGenericTypeProposal.java:532)
	at org.eclipse.jdt.internal.ui.text.java.LazyGenericTypeProposal.computeTypeArgumentProposals(LazyGenericTypeProposal.java:351)
	at org.eclipse.jdt.internal.ui.text.java.LazyGenericTypeProposal.apply(LazyGenericTypeProposal.java:225)
	at org.eclipse.jdt.internal.ui.text.java.AbstractJavaCompletionProposal.apply(AbstractJavaCompletionProposal.java:519)
	at org.eclipse.jdt.internal.ui.text.java.LazyJavaCompletionProposal.apply(LazyJavaCompletionProposal.java:443)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.insertProposal(CompletionProposalPopup.java:989)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.insertSelectedProposalWithMask(CompletionProposalPopup.java:938)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.access$27(CompletionProposalPopup.java:934)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup$5.widgetDefaultSelected(CompletionProposalPopup.java:679)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:120)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4418)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1079)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4236)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3824)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:1121)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1022)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:150)
	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:693)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:610)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:148)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:138)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:388)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:243)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:673)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:610)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1519)
Caused by: org.eclipse.core.runtime.CoreException: Illegal hierarchy
	at org.eclipse.jdt.internal.ui.text.java.LazyGenericTypeProposal.findMatchingSuperTypeSignature(LazyGenericTypeProposal.java:572)
	at org.eclipse.jdt.internal.ui.text.java.LazyGenericTypeProposal.mapTypeParameterIndex(LazyGenericTypeProposal.java:532)
	at org.eclipse.jdt.internal.ui.text.java.LazyGenericTypeProposal.computeTypeArgumentProposals(LazyGenericTypeProposal.java:351)
	at org.eclipse.jdt.internal.ui.text.java.LazyGenericTypeProposal.apply(LazyGenericTypeProposal.java:225)
	at org.eclipse.jdt.internal.ui.text.java.AbstractJavaCompletionProposal.apply(AbstractJavaCompletionProposal.java:519)
	at org.eclipse.jdt.internal.ui.text.java.LazyJavaCompletionProposal.apply(LazyJavaCompletionProposal.java:443)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.insertProposal(CompletionProposalPopup.java:989)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.insertSelectedProposalWithMask(CompletionProposalPopup.java:938)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.access$27(CompletionProposalPopup.java:934)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup$5.widgetDefaultSelected(CompletionProposalPopup.java:679)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:120)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4418)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1079)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4236)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3824)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:1121)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1022)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:150)
	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:693)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:610)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:148)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:138)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:388)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:243)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:673)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:610)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1519)
!SUBENTRY 1 org.eclipse.jdt.ui 4 0 2017-05-30 18:03:50.967
!MESSAGE Illegal hierarchy
!SESSION 2017-05-30 18:14:43.952 -----------------------------------------------
eclipse.buildId=4.6.3.M20170301-0400
java.version=1.8.0_131
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_ES
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.egit.ui 2 0 2017-05-30 18:14:50.864
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Alvaro'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.ui 4 10001 2017-05-30 18:25:16.443
!MESSAGE Internal Error
!STACK 1
Java Model Exception: Core Exception [code 0] Illegal hierarchy
	at org.eclipse.jdt.internal.ui.text.java.LazyGenericTypeProposal.findMatchingSuperTypeSignature(LazyGenericTypeProposal.java:572)
	at org.eclipse.jdt.internal.ui.text.java.LazyGenericTypeProposal.mapTypeParameterIndex(LazyGenericTypeProposal.java:532)
	at org.eclipse.jdt.internal.ui.text.java.LazyGenericTypeProposal.computeTypeArgumentProposals(LazyGenericTypeProposal.java:351)
	at org.eclipse.jdt.internal.ui.text.java.LazyGenericTypeProposal.apply(LazyGenericTypeProposal.java:225)
	at org.eclipse.jdt.internal.ui.text.java.AbstractJavaCompletionProposal.apply(AbstractJavaCompletionProposal.java:519)
	at org.eclipse.jdt.internal.ui.text.java.LazyJavaCompletionProposal.apply(LazyJavaCompletionProposal.java:443)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.insertProposal(CompletionProposalPopup.java:989)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.insertSelectedProposalWithMask(CompletionProposalPopup.java:938)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.access$27(CompletionProposalPopup.java:934)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup$5.widgetDefaultSelected(CompletionProposalPopup.java:679)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:120)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4418)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1079)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4236)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3824)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:1121)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1022)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:150)
	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:693)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:610)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:148)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:138)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:388)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:243)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:673)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:610)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1519)
Caused by: org.eclipse.core.runtime.CoreException: Illegal hierarchy
	at org.eclipse.jdt.internal.ui.text.java.LazyGenericTypeProposal.findMatchingSuperTypeSignature(LazyGenericTypeProposal.java:572)
	at org.eclipse.jdt.internal.ui.text.java.LazyGenericTypeProposal.mapTypeParameterIndex(LazyGenericTypeProposal.java:532)
	at org.eclipse.jdt.internal.ui.text.java.LazyGenericTypeProposal.computeTypeArgumentProposals(LazyGenericTypeProposal.java:351)
	at org.eclipse.jdt.internal.ui.text.java.LazyGenericTypeProposal.apply(LazyGenericTypeProposal.java:225)
	at org.eclipse.jdt.internal.ui.text.java.AbstractJavaCompletionProposal.apply(AbstractJavaCompletionProposal.java:519)
	at org.eclipse.jdt.internal.ui.text.java.LazyJavaCompletionProposal.apply(LazyJavaCompletionProposal.java:443)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.insertProposal(CompletionProposalPopup.java:989)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.insertSelectedProposalWithMask(CompletionProposalPopup.java:938)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.access$27(CompletionProposalPopup.java:934)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup$5.widgetDefaultSelected(CompletionProposalPopup.java:679)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:120)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4418)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1079)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4236)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3824)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:1121)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1022)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:150)
	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:693)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:610)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:148)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:138)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:388)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:243)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:673)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:610)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1519)
!SUBENTRY 1 org.eclipse.jdt.ui 4 0 2017-05-30 18:25:16.444
!MESSAGE Illegal hierarchy

!ENTRY org.eclipse.jdt.ui 4 10001 2017-05-30 18:27:21.425
!MESSAGE Internal Error
!STACK 1
Java Model Exception: Core Exception [code 0] Illegal hierarchy
	at org.eclipse.jdt.internal.ui.text.java.LazyGenericTypeProposal.findMatchingSuperTypeSignature(LazyGenericTypeProposal.java:572)
	at org.eclipse.jdt.internal.ui.text.java.LazyGenericTypeProposal.mapTypeParameterIndex(LazyGenericTypeProposal.java:532)
	at org.eclipse.jdt.internal.ui.text.java.LazyGenericTypeProposal.computeTypeArgumentProposals(LazyGenericTypeProposal.java:351)
	at org.eclipse.jdt.internal.ui.text.java.LazyGenericTypeProposal.apply(LazyGenericTypeProposal.java:225)
	at org.eclipse.jdt.internal.ui.text.java.AbstractJavaCompletionProposal.apply(AbstractJavaCompletionProposal.java:519)
	at org.eclipse.jdt.internal.ui.text.java.LazyJavaCompletionProposal.apply(LazyJavaCompletionProposal.java:443)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.insertProposal(CompletionProposalPopup.java:989)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.insertSelectedProposalWithMask(CompletionProposalPopup.java:938)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.access$27(CompletionProposalPopup.java:934)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup$5.widgetDefaultSelected(CompletionProposalPopup.java:679)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:120)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4418)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1079)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4236)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3824)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:1121)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1022)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:150)
	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:693)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:610)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:148)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:138)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:388)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:243)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:673)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:610)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1519)
Caused by: org.eclipse.core.runtime.CoreException: Illegal hierarchy
	at org.eclipse.jdt.internal.ui.text.java.LazyGenericTypeProposal.findMatchingSuperTypeSignature(LazyGenericTypeProposal.java:572)
	at org.eclipse.jdt.internal.ui.text.java.LazyGenericTypeProposal.mapTypeParameterIndex(LazyGenericTypeProposal.java:532)
	at org.eclipse.jdt.internal.ui.text.java.LazyGenericTypeProposal.computeTypeArgumentProposals(LazyGenericTypeProposal.java:351)
	at org.eclipse.jdt.internal.ui.text.java.LazyGenericTypeProposal.apply(LazyGenericTypeProposal.java:225)
	at org.eclipse.jdt.internal.ui.text.java.AbstractJavaCompletionProposal.apply(AbstractJavaCompletionProposal.java:519)
	at org.eclipse.jdt.internal.ui.text.java.LazyJavaCompletionProposal.apply(LazyJavaCompletionProposal.java:443)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.insertProposal(CompletionProposalPopup.java:989)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.insertSelectedProposalWithMask(CompletionProposalPopup.java:938)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.access$27(CompletionProposalPopup.java:934)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup$5.widgetDefaultSelected(CompletionProposalPopup.java:679)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:120)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4418)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1079)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4236)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3824)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:1121)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1022)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:150)
	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:693)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:610)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:148)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:138)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:388)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:243)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:673)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:610)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1519)
!SUBENTRY 1 org.eclipse.jdt.ui 4 0 2017-05-30 18:27:21.426
!MESSAGE Illegal hierarchy
!SESSION 2017-05-30 21:15:48.643 -----------------------------------------------
eclipse.buildId=4.6.3.M20170301-0400
java.version=1.8.0_131
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_ES
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.egit.ui 2 0 2017-05-30 21:15:55.290
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Alvaro'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.ui 4 2 2017-05-30 21:26:07.992
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:141)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:819)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1085)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4790)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4757)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:773)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1656)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1557)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2524)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.findMethodBinding(MessageSend.java:914)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:729)
	at org.eclipse.jdt.internal.compiler.ast.EqualExpression.resolveType(EqualExpression.java:827)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolveTypeExpecting(Expression.java:1056)
	at org.eclipse.jdt.internal.compiler.ast.IfStatement.resolve(IfStatement.java:273)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:634)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:306)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:544)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1195)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1308)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:593)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1218)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:692)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1190)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 0 2017-05-30 21:26:08.002
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:141)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:819)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1085)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4790)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4757)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:773)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1656)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1557)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2524)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.findMethodBinding(MessageSend.java:914)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:729)
	at org.eclipse.jdt.internal.compiler.ast.EqualExpression.resolveType(EqualExpression.java:827)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolveTypeExpecting(Expression.java:1056)
	at org.eclipse.jdt.internal.compiler.ast.IfStatement.resolve(IfStatement.java:273)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:634)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:306)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:544)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1195)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1308)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:593)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1218)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:692)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1190)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 2 2017-05-30 21:26:08.095
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:141)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:819)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1085)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4790)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4757)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:773)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1656)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1557)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2524)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.findMethodBinding(MessageSend.java:914)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:729)
	at org.eclipse.jdt.internal.compiler.ast.EqualExpression.resolveType(EqualExpression.java:827)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolveTypeExpecting(Expression.java:1056)
	at org.eclipse.jdt.internal.compiler.ast.IfStatement.resolve(IfStatement.java:273)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:634)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:306)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:544)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1195)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1308)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:593)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1218)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:692)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1190)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.recommenders.rcp.utils.JdtUtils.findAstNodeFromEditorSelection(JdtUtils.java:669)
	at org.eclipse.recommenders.internal.rcp.JavaElementSelectionService.handleSelectionInEditor(JavaElementSelectionService.java:110)
	at org.eclipse.recommenders.internal.rcp.JavaElementSelectionService.access$1(JavaElementSelectionService.java:105)
	at org.eclipse.recommenders.internal.rcp.JavaElementSelectionService$1.run(JavaElementSelectionService.java:82)
	at java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source)
	at java.util.concurrent.FutureTask.run(Unknown Source)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(Unknown Source)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(Unknown Source)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source)
	at java.lang.Thread.run(Unknown Source)

!ENTRY org.eclipse.jdt.ui 4 0 2017-05-30 21:26:08.098
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:141)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:819)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1085)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4790)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4757)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:773)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1656)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1557)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2524)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.findMethodBinding(MessageSend.java:914)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:729)
	at org.eclipse.jdt.internal.compiler.ast.EqualExpression.resolveType(EqualExpression.java:827)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolveTypeExpecting(Expression.java:1056)
	at org.eclipse.jdt.internal.compiler.ast.IfStatement.resolve(IfStatement.java:273)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:634)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:306)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:544)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1195)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1308)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:593)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1218)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:692)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1190)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.recommenders.rcp.utils.JdtUtils.findAstNodeFromEditorSelection(JdtUtils.java:669)
	at org.eclipse.recommenders.internal.rcp.JavaElementSelectionService.handleSelectionInEditor(JavaElementSelectionService.java:110)
	at org.eclipse.recommenders.internal.rcp.JavaElementSelectionService.access$1(JavaElementSelectionService.java:105)
	at org.eclipse.recommenders.internal.rcp.JavaElementSelectionService$1.run(JavaElementSelectionService.java:82)
	at java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source)
	at java.util.concurrent.FutureTask.run(Unknown Source)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(Unknown Source)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(Unknown Source)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source)
	at java.lang.Thread.run(Unknown Source)
!SESSION 2017-05-31 10:07:17.384 -----------------------------------------------
eclipse.buildId=4.6.3.M20170301-0400
java.version=1.8.0_131
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_ES
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.egit.ui 2 0 2017-05-31 10:07:43.640
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Alvaro'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2017-05-31 15:34:07.553 -----------------------------------------------
eclipse.buildId=4.6.3.M20170301-0400
java.version=1.8.0_131
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_ES
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.egit.ui 2 0 2017-05-31 15:34:14.552
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Alvaro'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2017-05-31 17:45:11.958 -----------------------------------------------
eclipse.buildId=4.6.3.M20170301-0400
java.version=1.8.0_131
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_ES
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.egit.ui 2 0 2017-05-31 17:45:17.512
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Alvaro'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2017-05-31 22:55:31.033 -----------------------------------------------
eclipse.buildId=4.6.3.M20170301-0400
java.version=1.8.0_131
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_ES
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.egit.ui 2 0 2017-05-31 22:55:37.634
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Alvaro'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2017-06-01 15:45:27.022 -----------------------------------------------
eclipse.buildId=4.6.3.M20170301-0400
java.version=1.8.0_131
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_ES
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.egit.ui 2 0 2017-06-01 15:45:37.943
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Alvaro'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2017-06-01 16:42:29.042 -----------------------------------------------
eclipse.buildId=4.6.3.M20170301-0400
java.version=1.8.0_131
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_ES
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.egit.ui 2 0 2017-06-01 16:42:35.534
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Alvaro'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2017-06-01 16:55:48.373 -----------------------------------------------
eclipse.buildId=4.6.3.M20170301-0400
java.version=1.8.0_131
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_ES
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.egit.ui 2 0 2017-06-01 16:55:54.505
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Alvaro'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.core 4 4 2017-06-01 18:38:29.011
!MESSAGE Exception occurred during problem detection:
----------------------------------- SOURCE BEGIN -------------------------------------
package InternalUnitParser.CSharpAdaptation;

import java.util.ArrayList;

public class CSharpOther
{
	public static ArrayList<Character> StringToCharacters(String input)
	{
		ArrayList<Character> chars = new ArrayList<Character>();
		if (input == null) return chars;
		
		for (char item: input.toCharArray())
		{
			chars.add(item);
		}
		
		return chars;
	}
	
	public static String StringJoin(String separator, String[] parts, int start, int length)
	{
		if (parts == null) return null;
		if (parts.length == 1) return parts[0].toString();
		
		String outString = parts[0].toString();
		
		for (int i = 1; i < parts.length; i++)
		{
			outString += separator + parts[i].toString();
		}
		
		return outString;
	}
	
	public static String StringJoin(String separator, Character[] parts)
	{

	}
	
	static String StringInternal(String separator, String[] parts, Character[] parts2, int start, int length)
	{
		if (parts == null && parts2 == null) return null;
		if (parts.length == 1) return parts[0].toString();
		
		int total = 
		(
			parts == null ? parts2[0].toString() : parts[0]
		);
				
		
		String outString = 
		(
			parts == null ? parts2[0].toString() : parts[0]
		);
		
		for (int i = 1; i < total; i++)
		{
			outString += StringInternalBit(String[] parts, Character[] parts2, int i, String separator) 
			(
				parts == null ? parts2[i].toString() : parts[i]
			);
		}
		
		return outString;		
	}
	
	static String StringInternalBit(String[] parts, Character[] parts2, int i, String separator)
	{
		return separator + 
		(
			parts == null ? parts2[i].toString() : parts[i]
		);
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:141)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:819)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1085)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4790)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4757)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:773)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1656)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1557)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2524)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.findMethodBinding(MessageSend.java:914)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:729)
	at org.eclipse.jdt.internal.compiler.ast.CompoundAssignment.resolveType(CompoundAssignment.java:132)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1026)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:634)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:306)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:544)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1195)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1308)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:593)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1030)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2017-06-01 18:38:29.031
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 1
Java Model Exception: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:249)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:141)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:819)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1085)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4790)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4757)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:773)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1656)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1557)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2524)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.findMethodBinding(MessageSend.java:914)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:729)
	at org.eclipse.jdt.internal.compiler.ast.CompoundAssignment.resolveType(CompoundAssignment.java:132)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1026)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:634)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:306)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:544)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1195)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1308)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:593)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1030)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	... 19 more
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:141)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:819)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1085)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4790)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4757)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:773)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1656)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1557)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2524)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.findMethodBinding(MessageSend.java:914)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:729)
	at org.eclipse.jdt.internal.compiler.ast.CompoundAssignment.resolveType(CompoundAssignment.java:132)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1026)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:634)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:306)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:544)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1195)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1308)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:593)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1030)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2017-06-01 18:38:29.031
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:141)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:819)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1085)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4790)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4757)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:773)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1656)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1557)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2524)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.findMethodBinding(MessageSend.java:914)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:729)
	at org.eclipse.jdt.internal.compiler.ast.CompoundAssignment.resolveType(CompoundAssignment.java:132)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1026)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:634)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:306)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:544)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1195)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1308)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:593)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1030)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2017-06-01 18:38:29.031
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:141)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:819)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1085)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4790)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4757)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:773)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1656)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1557)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2524)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.findMethodBinding(MessageSend.java:914)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:729)
	at org.eclipse.jdt.internal.compiler.ast.CompoundAssignment.resolveType(CompoundAssignment.java:132)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1026)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:634)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:306)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:544)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1195)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1308)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:593)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1030)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2017-06-01 18:38:29.041
!MESSAGE Error in JDT Core during reconcile
!STACK 1
Java Model Exception: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:249)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:141)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:819)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1085)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4790)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4757)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:773)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1656)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1557)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2524)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.findMethodBinding(MessageSend.java:914)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:729)
	at org.eclipse.jdt.internal.compiler.ast.CompoundAssignment.resolveType(CompoundAssignment.java:132)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1026)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:634)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:306)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:544)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1195)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1308)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:593)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1030)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	... 19 more
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:141)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:819)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1085)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4790)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4757)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:773)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1656)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1557)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2524)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.findMethodBinding(MessageSend.java:914)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:729)
	at org.eclipse.jdt.internal.compiler.ast.CompoundAssignment.resolveType(CompoundAssignment.java:132)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1026)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:634)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:306)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:544)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1195)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1308)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:593)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1030)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2017-06-01 18:38:29.041
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:141)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:819)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1085)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4790)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4757)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:773)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1656)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1557)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2524)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.findMethodBinding(MessageSend.java:914)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:729)
	at org.eclipse.jdt.internal.compiler.ast.CompoundAssignment.resolveType(CompoundAssignment.java:132)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1026)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:634)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:306)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:544)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1195)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1308)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:593)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1030)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2017-06-01 18:38:29.242
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:141)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:819)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1085)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4790)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4757)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:773)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1656)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1557)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2524)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.findMethodBinding(MessageSend.java:914)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:729)
	at org.eclipse.jdt.internal.compiler.ast.CompoundAssignment.resolveType(CompoundAssignment.java:132)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1026)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:634)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:306)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:544)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1195)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1308)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:593)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1218)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:692)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1190)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 0 2017-06-01 18:38:29.252
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:141)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:819)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1085)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4790)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4757)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:773)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1656)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1557)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2524)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.findMethodBinding(MessageSend.java:914)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:729)
	at org.eclipse.jdt.internal.compiler.ast.CompoundAssignment.resolveType(CompoundAssignment.java:132)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1026)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:634)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:306)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:544)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1195)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1308)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:593)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1218)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:692)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1190)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 2 2017-06-01 18:38:35.630
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:141)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:819)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1085)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4790)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4757)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:773)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1656)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1557)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2524)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.findMethodBinding(MessageSend.java:914)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:729)
	at org.eclipse.jdt.internal.compiler.ast.CompoundAssignment.resolveType(CompoundAssignment.java:132)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1026)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:634)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:306)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:544)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1195)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1308)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:593)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1218)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:692)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1190)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:137)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:116)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:164)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:86)
	at org.eclipse.jface.text.TextViewerHoverManager$4.run(TextViewerHoverManager.java:165)

!ENTRY org.eclipse.jdt.ui 4 0 2017-06-01 18:38:35.640
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:141)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:819)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1085)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4790)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4757)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:773)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1656)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1557)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2524)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.findMethodBinding(MessageSend.java:914)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:729)
	at org.eclipse.jdt.internal.compiler.ast.CompoundAssignment.resolveType(CompoundAssignment.java:132)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1026)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:634)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:306)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:544)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1195)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1308)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:593)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1218)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:692)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1190)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:137)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:116)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:164)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:86)
	at org.eclipse.jface.text.TextViewerHoverManager$4.run(TextViewerHoverManager.java:165)

!ENTRY org.eclipse.jdt.ui 4 2 2017-06-01 18:38:36.898
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:141)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:819)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1085)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4790)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4757)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:773)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1656)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1557)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2524)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.findMethodBinding(MessageSend.java:914)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:729)
	at org.eclipse.jdt.internal.compiler.ast.CompoundAssignment.resolveType(CompoundAssignment.java:132)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1026)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:634)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:306)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:544)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1195)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1308)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:593)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1218)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:692)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1190)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 0 2017-06-01 18:38:36.908
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:141)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:819)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1085)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4790)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4757)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:773)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1656)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1557)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2524)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.findMethodBinding(MessageSend.java:914)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:729)
	at org.eclipse.jdt.internal.compiler.ast.CompoundAssignment.resolveType(CompoundAssignment.java:132)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1026)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:634)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:306)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:544)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1195)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1308)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:593)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1218)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:692)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1190)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.core 4 4 2017-06-01 18:38:40.081
!MESSAGE Exception occurred during problem detection:
----------------------------------- SOURCE BEGIN -------------------------------------
package InternalUnitParser.CSharpAdaptation;

import java.util.ArrayList;

public class CSharpOther
{
	public static ArrayList<Character> StringToCharacters(String input)
	{
		ArrayList<Character> chars = new ArrayList<Character>();
		if (input == null) return chars;
		
		for (char item: input.toCharArray())
		{
			chars.add(item);
		}
		
		return chars;
	}
	
	public static String StringJoin(String separator, String[] parts, int start, int length)
	{
		if (parts == null) return null;
		if (parts.length == 1) return parts[0].toString();
		
		String outString = parts[0].toString();
		
		for (int i = 1; i < parts.length; i++)
		{
			outString += separator + parts[i].toString();
		}
		
		return outString;
	}
	
	public static String StringJoin(String separator, Character[] parts)
	{

	}
	
	static String StringInternal(String separator, String[] parts, Character[] parts2, int start, int length)
	{
		if (parts == null && parts2 == null) return null;
		if (parts.length == 1) return parts[0].toString();
		
		int total = 
		(
			parts == null ? parts2[0].toString() : parts[0]
		);
				
		
		String outString = 
		(
			parts == null ? parts2[0].toString() : parts[0]
		);
		
		for (int i = 1; i < total; i++)
		{
			outString += StringInternalBit
			(
				String[] parts, Character[] parts2, int i, String separator) 
			(
				parts == null ? parts2[i].toString() : parts[i]
			);
		}
		
		return outString;		
	}
	
	static String StringInternalBit(String[] parts, Character[] parts2, int i, String separator)
	{
		return separator + 
		(
			parts == null ? parts2[i].toString() : parts[i]
		);
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:141)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:819)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1085)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4790)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4757)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:773)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1656)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1557)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2524)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.findMethodBinding(MessageSend.java:914)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:729)
	at org.eclipse.jdt.internal.compiler.ast.CompoundAssignment.resolveType(CompoundAssignment.java:132)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1026)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:634)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:306)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:544)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1195)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1308)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:593)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1030)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2017-06-01 18:38:40.091
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 1
Java Model Exception: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:249)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:141)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:819)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1085)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4790)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4757)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:773)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1656)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1557)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2524)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.findMethodBinding(MessageSend.java:914)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:729)
	at org.eclipse.jdt.internal.compiler.ast.CompoundAssignment.resolveType(CompoundAssignment.java:132)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1026)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:634)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:306)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:544)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1195)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1308)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:593)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1030)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	... 19 more
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:141)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:819)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1085)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4790)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4757)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:773)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1656)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1557)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2524)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.findMethodBinding(MessageSend.java:914)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:729)
	at org.eclipse.jdt.internal.compiler.ast.CompoundAssignment.resolveType(CompoundAssignment.java:132)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1026)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:634)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:306)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:544)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1195)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1308)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:593)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1030)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2017-06-01 18:38:40.091
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:141)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:819)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1085)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4790)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4757)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:773)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1656)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1557)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2524)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.findMethodBinding(MessageSend.java:914)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:729)
	at org.eclipse.jdt.internal.compiler.ast.CompoundAssignment.resolveType(CompoundAssignment.java:132)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1026)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:634)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:306)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:544)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1195)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1308)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:593)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1030)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2017-06-01 18:38:40.091
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:141)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:819)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1085)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4790)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4757)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:773)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1656)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1557)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2524)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.findMethodBinding(MessageSend.java:914)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:729)
	at org.eclipse.jdt.internal.compiler.ast.CompoundAssignment.resolveType(CompoundAssignment.java:132)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1026)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:634)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:306)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:544)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1195)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1308)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:593)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1030)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2017-06-01 18:38:40.091
!MESSAGE Error in JDT Core during reconcile
!STACK 1
Java Model Exception: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:249)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:141)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:819)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1085)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4790)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4757)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:773)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1656)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1557)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2524)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.findMethodBinding(MessageSend.java:914)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:729)
	at org.eclipse.jdt.internal.compiler.ast.CompoundAssignment.resolveType(CompoundAssignment.java:132)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1026)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:634)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:306)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:544)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1195)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1308)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:593)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1030)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	... 19 more
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:141)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:819)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1085)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4790)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4757)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:773)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1656)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1557)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2524)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.findMethodBinding(MessageSend.java:914)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:729)
	at org.eclipse.jdt.internal.compiler.ast.CompoundAssignment.resolveType(CompoundAssignment.java:132)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1026)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:634)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:306)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:544)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1195)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1308)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:593)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1030)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2017-06-01 18:38:40.091
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:141)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:819)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1085)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4790)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4757)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:773)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1656)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1557)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2524)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.findMethodBinding(MessageSend.java:914)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:729)
	at org.eclipse.jdt.internal.compiler.ast.CompoundAssignment.resolveType(CompoundAssignment.java:132)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1026)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:634)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:306)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:544)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1195)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1308)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:593)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1030)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2017-06-01 18:38:40.101
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:141)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:819)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1085)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4790)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4757)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:773)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1656)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1557)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2524)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.findMethodBinding(MessageSend.java:914)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:729)
	at org.eclipse.jdt.internal.compiler.ast.CompoundAssignment.resolveType(CompoundAssignment.java:132)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1026)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:634)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:306)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:544)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1195)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1308)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:593)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1218)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:692)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1190)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:476)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.recommenders.rcp.utils.JdtUtils.findAstNodeFromEditorSelection(JdtUtils.java:669)
	at org.eclipse.recommenders.internal.rcp.JavaElementSelectionService.handleSelectionInEditor(JavaElementSelectionService.java:110)
	at org.eclipse.recommenders.internal.rcp.JavaElementSelectionService.access$1(JavaElementSelectionService.java:105)
	at org.eclipse.recommenders.internal.rcp.JavaElementSelectionService$1.run(JavaElementSelectionService.java:82)
	at java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source)
	at java.util.concurrent.FutureTask.run(Unknown Source)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(Unknown Source)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(Unknown Source)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source)
	at java.lang.Thread.run(Unknown Source)

!ENTRY org.eclipse.jdt.ui 4 0 2017-06-01 18:38:40.101
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:141)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:819)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1085)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4790)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4757)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:773)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1656)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1557)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2524)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.findMethodBinding(MessageSend.java:914)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:729)
	at org.eclipse.jdt.internal.compiler.ast.CompoundAssignment.resolveType(CompoundAssignment.java:132)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1026)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:634)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:306)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:544)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1195)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1308)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:593)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1218)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:692)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1190)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:476)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.recommenders.rcp.utils.JdtUtils.findAstNodeFromEditorSelection(JdtUtils.java:669)
	at org.eclipse.recommenders.internal.rcp.JavaElementSelectionService.handleSelectionInEditor(JavaElementSelectionService.java:110)
	at org.eclipse.recommenders.internal.rcp.JavaElementSelectionService.access$1(JavaElementSelectionService.java:105)
	at org.eclipse.recommenders.internal.rcp.JavaElementSelectionService$1.run(JavaElementSelectionService.java:82)
	at java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source)
	at java.util.concurrent.FutureTask.run(Unknown Source)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(Unknown Source)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(Unknown Source)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source)
	at java.lang.Thread.run(Unknown Source)

!ENTRY org.eclipse.jdt.ui 4 2 2017-06-01 18:38:40.101
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:141)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:819)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1085)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4790)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4757)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:773)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1656)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1557)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2524)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.findMethodBinding(MessageSend.java:914)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:729)
	at org.eclipse.jdt.internal.compiler.ast.CompoundAssignment.resolveType(CompoundAssignment.java:132)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1026)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:634)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:306)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:544)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1195)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1308)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:593)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1218)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:692)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1190)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:476)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:476)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 0 2017-06-01 18:38:40.101
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:141)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:819)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1085)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4790)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4757)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:773)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1656)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1557)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2524)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.findMethodBinding(MessageSend.java:914)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:729)
	at org.eclipse.jdt.internal.compiler.ast.CompoundAssignment.resolveType(CompoundAssignment.java:132)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1026)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:634)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:306)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:544)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1195)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1308)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:593)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1218)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:692)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1190)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:476)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:476)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 2 2017-06-01 18:38:42.110
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:141)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:819)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1085)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4790)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4757)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:773)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1656)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1557)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2524)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.findMethodBinding(MessageSend.java:914)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:729)
	at org.eclipse.jdt.internal.compiler.ast.CompoundAssignment.resolveType(CompoundAssignment.java:132)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1026)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:634)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:306)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:544)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1195)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1308)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:593)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1218)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:692)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1190)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 0 2017-06-01 18:38:42.110
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:141)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:819)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1085)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4790)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4757)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:773)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1656)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1557)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2524)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.findMethodBinding(MessageSend.java:914)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:729)
	at org.eclipse.jdt.internal.compiler.ast.CompoundAssignment.resolveType(CompoundAssignment.java:132)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1026)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:634)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:306)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:544)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1195)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1308)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:593)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1218)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:692)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1190)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 2 2017-06-01 18:38:42.230
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:141)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:819)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1085)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4790)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4757)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:773)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1656)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1557)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2524)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.findMethodBinding(MessageSend.java:914)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:729)
	at org.eclipse.jdt.internal.compiler.ast.CompoundAssignment.resolveType(CompoundAssignment.java:132)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1026)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:634)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:306)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:544)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1195)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1308)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:593)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1218)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:692)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1190)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.recommenders.rcp.utils.JdtUtils.findAstNodeFromEditorSelection(JdtUtils.java:669)
	at org.eclipse.recommenders.internal.rcp.JavaElementSelectionService.handleSelectionInEditor(JavaElementSelectionService.java:110)
	at org.eclipse.recommenders.internal.rcp.JavaElementSelectionService.access$1(JavaElementSelectionService.java:105)
	at org.eclipse.recommenders.internal.rcp.JavaElementSelectionService$1.run(JavaElementSelectionService.java:82)
	at java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source)
	at java.util.concurrent.FutureTask.run(Unknown Source)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(Unknown Source)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(Unknown Source)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source)
	at java.lang.Thread.run(Unknown Source)

!ENTRY org.eclipse.jdt.ui 4 0 2017-06-01 18:38:42.230
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:141)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:819)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1085)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4790)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4757)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:773)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1656)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1557)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2524)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.findMethodBinding(MessageSend.java:914)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:729)
	at org.eclipse.jdt.internal.compiler.ast.CompoundAssignment.resolveType(CompoundAssignment.java:132)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1026)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:634)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:306)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:544)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1195)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1308)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:593)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1218)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:692)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1190)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.recommenders.rcp.utils.JdtUtils.findAstNodeFromEditorSelection(JdtUtils.java:669)
	at org.eclipse.recommenders.internal.rcp.JavaElementSelectionService.handleSelectionInEditor(JavaElementSelectionService.java:110)
	at org.eclipse.recommenders.internal.rcp.JavaElementSelectionService.access$1(JavaElementSelectionService.java:105)
	at org.eclipse.recommenders.internal.rcp.JavaElementSelectionService$1.run(JavaElementSelectionService.java:82)
	at java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source)
	at java.util.concurrent.FutureTask.run(Unknown Source)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(Unknown Source)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(Unknown Source)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source)
	at java.lang.Thread.run(Unknown Source)

!ENTRY org.eclipse.jdt.core 4 4 2017-06-01 18:38:43.604
!MESSAGE Exception occurred during problem detection:
----------------------------------- SOURCE BEGIN -------------------------------------
package InternalUnitParser.CSharpAdaptation;

import java.util.ArrayList;

public class CSharpOther
{
	public static ArrayList<Character> StringToCharacters(String input)
	{
		ArrayList<Character> chars = new ArrayList<Character>();
		if (input == null) return chars;
		
		for (char item: input.toCharArray())
		{
			chars.add(item);
		}
		
		return chars;
	}
	
	public static String StringJoin(String separator, String[] parts, int start, int length)
	{
		if (parts == null) return null;
		if (parts.length == 1) return parts[0].toString();
		
		String outString = parts[0].toString();
		
		for (int i = 1; i < parts.length; i++)
		{
			outString += separator + parts[i].toString();
		}
		
		return outString;
	}
	
	public static String StringJoin(String separator, Character[] parts)
	{

	}
	
	static String StringInternal(String separator, String[] parts, Character[] parts2, int start, int length)
	{
		if (parts == null && parts2 == null) return null;
		if (parts.length == 1) return parts[0].toString();
		
		int total = 
		(
			parts == null ? parts2[0].toString() : parts[0]
		);
				
		
		String outString = 
		(
			parts == null ? parts2[0].toString() : parts[0]
		);
		
		for (int i = 1; i < total; i++)
		{
			outString += StringInternalBit
			(
				String[] parts, Character[] parts2, int i, String separator
			) 
			(
				parts == null ? parts2[i].toString() : parts[i]
			);
		}
		
		return outString;		
	}
	
	static String StringInternalBit(String[] parts, Character[] parts2, int i, String separator)
	{
		return separator + 
		(
			parts == null ? parts2[i].toString() : parts[i]
		);
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:141)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:819)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1085)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4790)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4757)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:773)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1656)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1557)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2524)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.findMethodBinding(MessageSend.java:914)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:729)
	at org.eclipse.jdt.internal.compiler.ast.CompoundAssignment.resolveType(CompoundAssignment.java:132)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1026)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:634)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:306)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:544)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1195)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1308)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:593)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1030)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2017-06-01 18:38:43.604
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 1
Java Model Exception: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:249)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:141)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:819)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1085)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4790)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4757)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:773)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1656)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1557)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2524)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.findMethodBinding(MessageSend.java:914)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:729)
	at org.eclipse.jdt.internal.compiler.ast.CompoundAssignment.resolveType(CompoundAssignment.java:132)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1026)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:634)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:306)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:544)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1195)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1308)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:593)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1030)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	... 19 more
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:141)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:819)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1085)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4790)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4757)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:773)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1656)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1557)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2524)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.findMethodBinding(MessageSend.java:914)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:729)
	at org.eclipse.jdt.internal.compiler.ast.CompoundAssignment.resolveType(CompoundAssignment.java:132)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1026)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:634)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:306)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:544)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1195)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1308)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:593)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1030)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2017-06-01 18:38:43.604
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:141)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:819)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1085)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4790)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4757)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:773)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1656)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1557)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2524)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.findMethodBinding(MessageSend.java:914)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:729)
	at org.eclipse.jdt.internal.compiler.ast.CompoundAssignment.resolveType(CompoundAssignment.java:132)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1026)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:634)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:306)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:544)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1195)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1308)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:593)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1030)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2017-06-01 18:38:43.604
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:141)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:819)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1085)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4790)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4757)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:773)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1656)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1557)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2524)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.findMethodBinding(MessageSend.java:914)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:729)
	at org.eclipse.jdt.internal.compiler.ast.CompoundAssignment.resolveType(CompoundAssignment.java:132)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1026)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:634)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:306)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:544)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1195)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1308)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:593)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1030)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2017-06-01 18:38:43.614
!MESSAGE Error in JDT Core during reconcile
!STACK 1
Java Model Exception: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:249)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:141)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:819)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1085)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4790)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4757)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:773)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1656)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1557)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2524)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.findMethodBinding(MessageSend.java:914)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:729)
	at org.eclipse.jdt.internal.compiler.ast.CompoundAssignment.resolveType(CompoundAssignment.java:132)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1026)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:634)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:306)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:544)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1195)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1308)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:593)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1030)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	... 19 more
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:141)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:819)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1085)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4790)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4757)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:773)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1656)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1557)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2524)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.findMethodBinding(MessageSend.java:914)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:729)
	at org.eclipse.jdt.internal.compiler.ast.CompoundAssignment.resolveType(CompoundAssignment.java:132)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1026)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:634)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:306)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:544)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1195)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1308)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:593)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1030)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2017-06-01 18:38:43.614
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:141)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:819)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1085)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4790)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4757)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:773)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1656)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1557)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2524)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.findMethodBinding(MessageSend.java:914)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:729)
	at org.eclipse.jdt.internal.compiler.ast.CompoundAssignment.resolveType(CompoundAssignment.java:132)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1026)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:634)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:306)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:544)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1195)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1308)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:593)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1030)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2017-06-01 18:38:43.614
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:141)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:819)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1085)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4790)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4757)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:773)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1656)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1557)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2524)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.findMethodBinding(MessageSend.java:914)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:729)
	at org.eclipse.jdt.internal.compiler.ast.CompoundAssignment.resolveType(CompoundAssignment.java:132)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1026)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:634)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:306)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:544)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1195)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1308)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:593)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1218)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:692)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1190)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:476)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 0 2017-06-01 18:38:43.624
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:141)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:819)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1085)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4790)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4757)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:773)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1656)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1557)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2524)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.findMethodBinding(MessageSend.java:914)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:729)
	at org.eclipse.jdt.internal.compiler.ast.CompoundAssignment.resolveType(CompoundAssignment.java:132)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1026)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:634)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:306)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:544)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1195)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1308)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:593)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1218)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:692)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1190)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:476)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 2 2017-06-01 18:38:47.463
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:141)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:819)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1085)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4790)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4757)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:773)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1656)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1557)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2524)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.findMethodBinding(MessageSend.java:914)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:729)
	at org.eclipse.jdt.internal.compiler.ast.CompoundAssignment.resolveType(CompoundAssignment.java:132)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1026)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:634)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:306)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:544)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1195)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1308)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:593)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1218)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:692)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1190)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 0 2017-06-01 18:38:47.463
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:141)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:819)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1085)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4790)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4757)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:773)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1656)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1557)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2524)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.findMethodBinding(MessageSend.java:914)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:729)
	at org.eclipse.jdt.internal.compiler.ast.CompoundAssignment.resolveType(CompoundAssignment.java:132)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1026)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:634)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:306)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:544)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1195)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1308)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:593)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1218)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:692)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1190)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 2 2017-06-01 18:38:47.583
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:141)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:819)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1085)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4790)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4757)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:773)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1656)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1557)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2524)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.findMethodBinding(MessageSend.java:914)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:729)
	at org.eclipse.jdt.internal.compiler.ast.CompoundAssignment.resolveType(CompoundAssignment.java:132)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1026)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:634)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:306)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:544)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1195)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1308)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:593)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1218)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:692)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1190)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.recommenders.rcp.utils.JdtUtils.findAstNodeFromEditorSelection(JdtUtils.java:669)
	at org.eclipse.recommenders.internal.rcp.JavaElementSelectionService.handleSelectionInEditor(JavaElementSelectionService.java:110)
	at org.eclipse.recommenders.internal.rcp.JavaElementSelectionService.access$1(JavaElementSelectionService.java:105)
	at org.eclipse.recommenders.internal.rcp.JavaElementSelectionService$1.run(JavaElementSelectionService.java:82)
	at java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source)
	at java.util.concurrent.FutureTask.run(Unknown Source)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(Unknown Source)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(Unknown Source)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source)
	at java.lang.Thread.run(Unknown Source)

!ENTRY org.eclipse.jdt.ui 4 0 2017-06-01 18:38:47.583
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:141)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:819)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1085)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4790)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4757)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:773)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1656)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1557)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2524)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.findMethodBinding(MessageSend.java:914)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:729)
	at org.eclipse.jdt.internal.compiler.ast.CompoundAssignment.resolveType(CompoundAssignment.java:132)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1026)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:634)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:306)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:544)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1195)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1308)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:593)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1218)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:692)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1190)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.recommenders.rcp.utils.JdtUtils.findAstNodeFromEditorSelection(JdtUtils.java:669)
	at org.eclipse.recommenders.internal.rcp.JavaElementSelectionService.handleSelectionInEditor(JavaElementSelectionService.java:110)
	at org.eclipse.recommenders.internal.rcp.JavaElementSelectionService.access$1(JavaElementSelectionService.java:105)
	at org.eclipse.recommenders.internal.rcp.JavaElementSelectionService$1.run(JavaElementSelectionService.java:82)
	at java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source)
	at java.util.concurrent.FutureTask.run(Unknown Source)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(Unknown Source)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(Unknown Source)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source)
	at java.lang.Thread.run(Unknown Source)

!ENTRY org.eclipse.jdt.core 4 4 2017-06-01 18:38:49.140
!MESSAGE Exception occurred during problem detection:
----------------------------------- SOURCE BEGIN -------------------------------------
package InternalUnitParser.CSharpAdaptation;

import java.util.ArrayList;

public class CSharpOther
{
	public static ArrayList<Character> StringToCharacters(String input)
	{
		ArrayList<Character> chars = new ArrayList<Character>();
		if (input == null) return chars;
		
		for (char item: input.toCharArray())
		{
			chars.add(item);
		}
		
		return chars;
	}
	
	public static String StringJoin(String separator, String[] parts, int start, int length)
	{
		if (parts == null) return null;
		if (parts.length == 1) return parts[0].toString();
		
		String outString = parts[0].toString();
		
		for (int i = 1; i < parts.length; i++)
		{
			outString += separator + parts[i].toString();
		}
		
		return outString;
	}
	
	public static String StringJoin(String separator, Character[] parts)
	{

	}
	
	static String StringInternal(String separator, String[] parts, Character[] parts2, int start, int length)
	{
		if (parts == null && parts2 == null) return null;
		if (parts.length == 1) return parts[0].toString();
		
		int total = 
		(
			parts == null ? parts2[0].toString() : parts[0]
		);
				
		
		String outString = 
		(
			parts == null ? parts2[0].toString() : parts[0]
		);
		
		for (int i = 1; i < total; i++)
		{
			outString += StringInternalBit
			(
				String[] parts, Character[] parts2, i, String separator
			) 
			(
				parts == null ? parts2[i].toString() : parts[i]
			);
		}
		
		return outString;		
	}
	
	static String StringInternalBit(String[] parts, Character[] parts2, int i, String separator)
	{
		return separator + 
		(
			parts == null ? parts2[i].toString() : parts[i]
		);
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:141)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:819)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1085)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4790)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4757)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:773)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1656)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1557)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2524)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.findMethodBinding(MessageSend.java:914)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:729)
	at org.eclipse.jdt.internal.compiler.ast.CompoundAssignment.resolveType(CompoundAssignment.java:132)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1026)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:634)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:306)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:544)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1195)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1308)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:593)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1030)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2017-06-01 18:38:49.140
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 1
Java Model Exception: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:249)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:141)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:819)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1085)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4790)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4757)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:773)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1656)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1557)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2524)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.findMethodBinding(MessageSend.java:914)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:729)
	at org.eclipse.jdt.internal.compiler.ast.CompoundAssignment.resolveType(CompoundAssignment.java:132)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1026)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:634)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:306)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:544)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1195)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1308)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:593)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1030)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	... 19 more
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:141)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:819)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1085)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4790)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4757)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:773)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1656)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1557)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2524)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.findMethodBinding(MessageSend.java:914)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:729)
	at org.eclipse.jdt.internal.compiler.ast.CompoundAssignment.resolveType(CompoundAssignment.java:132)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1026)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:634)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:306)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:544)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1195)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1308)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:593)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1030)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2017-06-01 18:38:49.140
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:141)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:819)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1085)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4790)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4757)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:773)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1656)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1557)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2524)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.findMethodBinding(MessageSend.java:914)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:729)
	at org.eclipse.jdt.internal.compiler.ast.CompoundAssignment.resolveType(CompoundAssignment.java:132)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1026)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:634)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:306)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:544)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1195)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1308)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:593)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1030)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2017-06-01 18:38:49.140
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:141)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:819)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1085)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4790)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4757)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:773)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1656)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1557)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2524)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.findMethodBinding(MessageSend.java:914)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:729)
	at org.eclipse.jdt.internal.compiler.ast.CompoundAssignment.resolveType(CompoundAssignment.java:132)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1026)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:634)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:306)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:544)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1195)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1308)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:593)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1030)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2017-06-01 18:38:49.150
!MESSAGE Error in JDT Core during reconcile
!STACK 1
Java Model Exception: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:249)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:141)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:819)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1085)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4790)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4757)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:773)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1656)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1557)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2524)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.findMethodBinding(MessageSend.java:914)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:729)
	at org.eclipse.jdt.internal.compiler.ast.CompoundAssignment.resolveType(CompoundAssignment.java:132)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1026)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:634)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:306)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:544)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1195)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1308)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:593)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1030)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	... 19 more
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:141)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:819)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1085)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4790)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4757)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:773)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1656)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1557)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2524)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.findMethodBinding(MessageSend.java:914)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:729)
	at org.eclipse.jdt.internal.compiler.ast.CompoundAssignment.resolveType(CompoundAssignment.java:132)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1026)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:634)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:306)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:544)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1195)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1308)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:593)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1030)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2017-06-01 18:38:49.150
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:141)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:819)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1085)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4790)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4757)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:773)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1656)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1557)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2524)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.findMethodBinding(MessageSend.java:914)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:729)
	at org.eclipse.jdt.internal.compiler.ast.CompoundAssignment.resolveType(CompoundAssignment.java:132)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1026)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:634)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:306)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:544)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1195)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1308)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:593)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1030)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2017-06-01 18:38:49.210
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:141)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:819)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1085)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4790)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4757)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:773)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1656)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1557)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2524)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.findMethodBinding(MessageSend.java:914)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:729)
	at org.eclipse.jdt.internal.compiler.ast.CompoundAssignment.resolveType(CompoundAssignment.java:132)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1026)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:634)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:306)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:544)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1195)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1308)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:593)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1218)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:692)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1190)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 0 2017-06-01 18:38:49.210
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:141)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:819)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1085)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4790)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4757)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:773)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1656)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1557)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2524)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.findMethodBinding(MessageSend.java:914)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:729)
	at org.eclipse.jdt.internal.compiler.ast.CompoundAssignment.resolveType(CompoundAssignment.java:132)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1026)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:634)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:306)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:544)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1195)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1308)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:593)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1218)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:692)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1190)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 2 2017-06-01 18:38:49.340
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:141)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:819)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1085)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4790)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4757)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:773)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1656)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1557)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2524)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.findMethodBinding(MessageSend.java:914)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:729)
	at org.eclipse.jdt.internal.compiler.ast.CompoundAssignment.resolveType(CompoundAssignment.java:132)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1026)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:634)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:306)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:544)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1195)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1308)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:593)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1218)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:692)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1190)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.recommenders.rcp.utils.JdtUtils.findAstNodeFromEditorSelection(JdtUtils.java:669)
	at org.eclipse.recommenders.internal.rcp.JavaElementSelectionService.handleSelectionInEditor(JavaElementSelectionService.java:110)
	at org.eclipse.recommenders.internal.rcp.JavaElementSelectionService.access$1(JavaElementSelectionService.java:105)
	at org.eclipse.recommenders.internal.rcp.JavaElementSelectionService$1.run(JavaElementSelectionService.java:82)
	at java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source)
	at java.util.concurrent.FutureTask.run(Unknown Source)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(Unknown Source)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(Unknown Source)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source)
	at java.lang.Thread.run(Unknown Source)

!ENTRY org.eclipse.jdt.ui 4 0 2017-06-01 18:38:49.340
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:141)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:819)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1085)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4790)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4757)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:773)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1656)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1557)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2524)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.findMethodBinding(MessageSend.java:914)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:729)
	at org.eclipse.jdt.internal.compiler.ast.CompoundAssignment.resolveType(CompoundAssignment.java:132)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1026)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:634)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:306)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:544)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1195)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1308)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:593)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1218)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:692)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1190)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.recommenders.rcp.utils.JdtUtils.findAstNodeFromEditorSelection(JdtUtils.java:669)
	at org.eclipse.recommenders.internal.rcp.JavaElementSelectionService.handleSelectionInEditor(JavaElementSelectionService.java:110)
	at org.eclipse.recommenders.internal.rcp.JavaElementSelectionService.access$1(JavaElementSelectionService.java:105)
	at org.eclipse.recommenders.internal.rcp.JavaElementSelectionService$1.run(JavaElementSelectionService.java:82)
	at java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source)
	at java.util.concurrent.FutureTask.run(Unknown Source)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(Unknown Source)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(Unknown Source)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source)
	at java.lang.Thread.run(Unknown Source)

!ENTRY org.eclipse.jdt.core 4 4 2017-06-01 18:38:55.176
!MESSAGE Exception occurred during problem detection:
----------------------------------- SOURCE BEGIN -------------------------------------
package InternalUnitParser.CSharpAdaptation;

import java.util.ArrayList;

public class CSharpOther
{
	public static ArrayList<Character> StringToCharacters(String input)
	{
		ArrayList<Character> chars = new ArrayList<Character>();
		if (input == null) return chars;
		
		for (char item: input.toCharArray())
		{
			chars.add(item);
		}
		
		return chars;
	}
	
	public static String StringJoin(String separator, String[] parts, int start, int length)
	{
		if (parts == null) return null;
		if (parts.length == 1) return parts[0].toString();
		
		String outString = parts[0].toString();
		
		for (int i = 1; i < parts.length; i++)
		{
			outString += separator + parts[i].toString();
		}
		
		return outString;
	}
	
	public static String StringJoin(String separator, Character[] parts)
	{

	}
	
	static String StringInternal(String separator, String[] parts, Character[] parts2, int start, int length)
	{
		if (parts == null && parts2 == null) return null;
		if (parts.length == 1) return parts[0].toString();
		
		int total = 
		(
			parts == null ? parts2[0].toString() : parts[0]
		);
				
		
		String outString = 
		(
			parts == null ? parts2[0].toString() : parts[0]
		);
		
		for (int i = 1; i < total; i++)
		{
			outString += StringInternalBit
			(
				String[] parts, parts2, i, String separator
			) 
			(
				parts == null ? parts2[i].toString() : parts[i]
			);
		}
		
		return outString;		
	}
	
	static String StringInternalBit(String[] parts, Character[] parts2, int i, String separator)
	{
		return separator + 
		(
			parts == null ? parts2[i].toString() : parts[i]
		);
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:141)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:819)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1085)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4790)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4757)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:773)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1656)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1557)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2524)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.findMethodBinding(MessageSend.java:914)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:729)
	at org.eclipse.jdt.internal.compiler.ast.CompoundAssignment.resolveType(CompoundAssignment.java:132)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1026)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:634)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:306)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:544)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1195)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1308)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:593)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1030)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2017-06-01 18:38:55.176
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 1
Java Model Exception: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:249)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:141)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:819)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1085)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4790)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4757)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:773)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1656)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1557)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2524)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.findMethodBinding(MessageSend.java:914)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:729)
	at org.eclipse.jdt.internal.compiler.ast.CompoundAssignment.resolveType(CompoundAssignment.java:132)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1026)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:634)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:306)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:544)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1195)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1308)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:593)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1030)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	... 19 more
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:141)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:819)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1085)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4790)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4757)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:773)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1656)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1557)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2524)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.findMethodBinding(MessageSend.java:914)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:729)
	at org.eclipse.jdt.internal.compiler.ast.CompoundAssignment.resolveType(CompoundAssignment.java:132)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1026)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:634)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:306)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:544)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1195)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1308)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:593)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1030)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2017-06-01 18:38:55.176
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:141)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:819)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1085)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4790)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4757)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:773)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1656)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1557)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2524)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.findMethodBinding(MessageSend.java:914)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:729)
	at org.eclipse.jdt.internal.compiler.ast.CompoundAssignment.resolveType(CompoundAssignment.java:132)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1026)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:634)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:306)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:544)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1195)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1308)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:593)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1030)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2017-06-01 18:38:55.176
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:141)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:819)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1085)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4790)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4757)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:773)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1656)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1557)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2524)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.findMethodBinding(MessageSend.java:914)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:729)
	at org.eclipse.jdt.internal.compiler.ast.CompoundAssignment.resolveType(CompoundAssignment.java:132)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1026)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:634)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:306)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:544)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1195)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1308)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:593)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1030)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2017-06-01 18:38:55.176
!MESSAGE Error in JDT Core during reconcile
!STACK 1
Java Model Exception: java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:249)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:141)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:819)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1085)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4790)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4757)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:773)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1656)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1557)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2524)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.findMethodBinding(MessageSend.java:914)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:729)
	at org.eclipse.jdt.internal.compiler.ast.CompoundAssignment.resolveType(CompoundAssignment.java:132)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1026)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:634)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:306)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:544)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1195)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1308)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:593)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1030)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	... 19 more
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:141)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:819)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1085)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4790)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4757)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:773)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1656)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1557)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2524)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.findMethodBinding(MessageSend.java:914)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:729)
	at org.eclipse.jdt.internal.compiler.ast.CompoundAssignment.resolveType(CompoundAssignment.java:132)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1026)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:634)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:306)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:544)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1195)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1308)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:593)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1030)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2017-06-01 18:38:55.176
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:141)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:819)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1085)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4790)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4757)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:773)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1656)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1557)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2524)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.findMethodBinding(MessageSend.java:914)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:729)
	at org.eclipse.jdt.internal.compiler.ast.CompoundAssignment.resolveType(CompoundAssignment.java:132)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1026)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:634)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:306)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:544)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1195)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1308)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:593)
	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1030)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2017-06-01 18:38:55.186
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:141)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:819)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1085)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4790)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4757)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:773)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1656)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1557)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2524)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.findMethodBinding(MessageSend.java:914)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:729)
	at org.eclipse.jdt.internal.compiler.ast.CompoundAssignment.resolveType(CompoundAssignment.java:132)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1026)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:634)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:306)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:544)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1195)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1308)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:593)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1218)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:692)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1190)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:476)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.recommenders.rcp.utils.JdtUtils.findAstNodeFromEditorSelection(JdtUtils.java:669)
	at org.eclipse.recommenders.internal.rcp.JavaElementSelectionService.handleSelectionInEditor(JavaElementSelectionService.java:110)
	at org.eclipse.recommenders.internal.rcp.JavaElementSelectionService.access$1(JavaElementSelectionService.java:105)
	at org.eclipse.recommenders.internal.rcp.JavaElementSelectionService$1.run(JavaElementSelectionService.java:82)
	at java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source)
	at java.util.concurrent.FutureTask.run(Unknown Source)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(Unknown Source)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(Unknown Source)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source)
	at java.lang.Thread.run(Unknown Source)

!ENTRY org.eclipse.jdt.ui 4 0 2017-06-01 18:38:55.186
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:141)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:819)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1085)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4790)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4757)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:773)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1656)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1557)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2524)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.findMethodBinding(MessageSend.java:914)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:729)
	at org.eclipse.jdt.internal.compiler.ast.CompoundAssignment.resolveType(CompoundAssignment.java:132)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1026)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:634)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:306)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:544)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1195)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1308)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:593)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1218)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:692)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1190)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:476)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.recommenders.rcp.utils.JdtUtils.findAstNodeFromEditorSelection(JdtUtils.java:669)
	at org.eclipse.recommenders.internal.rcp.JavaElementSelectionService.handleSelectionInEditor(JavaElementSelectionService.java:110)
	at org.eclipse.recommenders.internal.rcp.JavaElementSelectionService.access$1(JavaElementSelectionService.java:105)
	at org.eclipse.recommenders.internal.rcp.JavaElementSelectionService$1.run(JavaElementSelectionService.java:82)
	at java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source)
	at java.util.concurrent.FutureTask.run(Unknown Source)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(Unknown Source)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(Unknown Source)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source)
	at java.lang.Thread.run(Unknown Source)

!ENTRY org.eclipse.jdt.ui 4 2 2017-06-01 18:38:55.186
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:141)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:819)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1085)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4790)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4757)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:773)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1656)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1557)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2524)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.findMethodBinding(MessageSend.java:914)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:729)
	at org.eclipse.jdt.internal.compiler.ast.CompoundAssignment.resolveType(CompoundAssignment.java:132)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1026)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:634)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:306)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:544)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1195)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1308)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:593)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1218)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:692)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1190)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:476)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 0 2017-06-01 18:38:55.206
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:141)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:819)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1085)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4790)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4757)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:773)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1656)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1557)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2524)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.findMethodBinding(MessageSend.java:914)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:729)
	at org.eclipse.jdt.internal.compiler.ast.CompoundAssignment.resolveType(CompoundAssignment.java:132)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1026)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:634)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:306)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:544)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1195)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1308)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:593)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1218)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:692)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1190)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:476)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 2 2017-06-01 18:38:56.169
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:141)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:819)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1085)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4790)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4757)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:773)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1656)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1557)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2524)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.findMethodBinding(MessageSend.java:914)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:729)
	at org.eclipse.jdt.internal.compiler.ast.CompoundAssignment.resolveType(CompoundAssignment.java:132)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1026)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:634)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:306)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:544)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1195)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1308)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:593)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1218)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:692)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1190)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 0 2017-06-01 18:38:56.179
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:141)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:819)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1085)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4790)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4757)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:773)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1656)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1557)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2524)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.findMethodBinding(MessageSend.java:914)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:729)
	at org.eclipse.jdt.internal.compiler.ast.CompoundAssignment.resolveType(CompoundAssignment.java:132)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1026)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:634)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:306)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:544)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1195)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1308)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:593)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1218)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:692)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1190)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 2 2017-06-01 18:38:56.289
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:141)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:819)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1085)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4790)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4757)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:773)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1656)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1557)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2524)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.findMethodBinding(MessageSend.java:914)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:729)
	at org.eclipse.jdt.internal.compiler.ast.CompoundAssignment.resolveType(CompoundAssignment.java:132)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1026)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:634)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:306)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:544)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1195)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1308)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:593)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1218)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:692)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1190)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.recommenders.rcp.utils.JdtUtils.findAstNodeFromEditorSelection(JdtUtils.java:669)
	at org.eclipse.recommenders.internal.rcp.JavaElementSelectionService.handleSelectionInEditor(JavaElementSelectionService.java:110)
	at org.eclipse.recommenders.internal.rcp.JavaElementSelectionService.access$1(JavaElementSelectionService.java:105)
	at org.eclipse.recommenders.internal.rcp.JavaElementSelectionService$1.run(JavaElementSelectionService.java:82)
	at java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source)
	at java.util.concurrent.FutureTask.run(Unknown Source)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(Unknown Source)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(Unknown Source)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source)
	at java.lang.Thread.run(Unknown Source)

!ENTRY org.eclipse.jdt.ui 4 0 2017-06-01 18:38:56.289
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:141)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:819)
	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:1085)
	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4790)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4757)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:773)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1656)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1557)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2524)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.findMethodBinding(MessageSend.java:914)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:729)
	at org.eclipse.jdt.internal.compiler.ast.CompoundAssignment.resolveType(CompoundAssignment.java:132)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1026)
	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)
	at org.eclipse.jdt.internal.compiler.ast.ForStatement.resolve(ForStatement.java:404)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:634)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:306)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:544)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1195)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1308)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:593)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1218)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:692)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1190)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.recommenders.rcp.utils.JdtUtils.findAstNodeFromEditorSelection(JdtUtils.java:669)
	at org.eclipse.recommenders.internal.rcp.JavaElementSelectionService.handleSelectionInEditor(JavaElementSelectionService.java:110)
	at org.eclipse.recommenders.internal.rcp.JavaElementSelectionService.access$1(JavaElementSelectionService.java:105)
	at org.eclipse.recommenders.internal.rcp.JavaElementSelectionService$1.run(JavaElementSelectionService.java:82)
	at java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source)
	at java.util.concurrent.FutureTask.run(Unknown Source)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(Unknown Source)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(Unknown Source)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source)
	at java.lang.Thread.run(Unknown Source)
