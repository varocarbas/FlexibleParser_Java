!SESSION 2017-05-27 19:54:17.091 -----------------------------------------------
eclipse.buildId=4.6.3.M20170301-0400
java.version=1.8.0_131
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_ES
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

This is a continuation of log file C:\Users\Alvaro\Desktop\workspace\.metadata\.bak_2.log
Created Time: 2017-05-27 20:04:39.170

!ENTRY org.eclipse.jdt.ui 4 2 2017-05-27 20:04:39.170
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2017-05-27 20:04:39.170
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2017-05-27 20:04:39.192
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
public class OperationsManaged
{
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, double second, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            firstInfo, new UnitInfo(second), operation
        );
    }

    public static UnitInfo PerformManagedOperationUnits(double first, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            new UnitInfo(first), secondInfo, operation
        );
    }

    //This method should always be used when dealing with random UnitInfo variables because it accounts for all the
    //possible scenarios. On the other hand, with simple operations (e.g., random UnitInfo & numeric type) it might
    //be better to use PerformManagedOperationValues. 
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        ErrorTypes errorType = InternalMethods.GetOperationError
        (
            firstInfo, secondInfo, operation
        );
        if (errorType != ErrorTypes.None)
        {
            return new UnitInfo(firstInfo) 
            {{
                Error = new ErrorInfo(errorType); 
            }};
        }

        return
        (
            operation == Operations.Addition || operation == Operations.Subtraction ?
            PerformManagedOperationAddition(firstInfo, secondInfo, operation) :
            PerformManagedOperationMultiplication(firstInfo, secondInfo, operation)
        );
    }

    static UnitInfo PerformManagedOperationAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {   
        //After being normalised, the operands might require further modifications.
        UnitInfo[] normalised = GetOperandsAddition(firstInfo, secondInfo, operation);

        return PerformManagedOperationNormalisedValues
        (
            firstInfo, normalised, operation
        );
    }

    static UnitInfo[] GetOperandsAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        UnitInfo[] operands2 = new UnitInfo[] 
        {
            new UnitInfo(firstInfo), new UnitInfo(secondInfo)
        };

        if (operands2[0].BaseTenExponent != operands2[1].BaseTenExponent || operands2[0].Prefix.Factor != operands2[1].Prefix.Factor)
        {
            //The addition/subtraction might not be performed right away even with normalised values.
            //For example: 5 and 6 from 5*10^2 and 6*10^7 cannot be added right away.
            operands2 = AdaptNormalisedValuesForAddition
            (
                new UnitInfo[] 
                { 
                    NormaliseUnitInfo(operands2[0]), 
                    NormaliseUnitInfo(operands2[1])
                },
                operation
            );
        }

        return operands2;
    }
    
    static UnitInfo[] AdaptNormalisedValuesForAddition(UnitInfo[] unitInfos2, Operations operation)
    {
        if (unitInfos2[0].BaseTenExponent == unitInfos2[1].BaseTenExponent)
        {
            //Having the same BaseTenExponent values means that the given operation can be performed right away.
            return unitInfos2;
        }

        int[] bigSmallI = 
        (
            unitInfos2[0].BaseTenExponent > unitInfos2[1].BaseTenExponent ?
            new int[] { 0, 1 } : new int[] { 1, 0 }
        );

        //Only the variable with the bigger value is modified. For example: 5*10^5 & 3*10^3 is converted
        //into 500*10^3 & 3*10^3 in order to allow the addition 500 + 3. 
        UnitInfo big2 = AdaptBiggerAdditionOperand(unitInfos2, bigSmallI, operation);
        if (big2.Error.Type != ErrorTypes.None)
        {
            return TooBigGapAddition(unitInfos2, bigSmallI, operation);
        }

        unitInfos2[bigSmallI[0]].Value = big2.Value;
        unitInfos2[bigSmallI[0]].BaseTenExponent = unitInfos2[bigSmallI[1]].BaseTenExponent;

        return unitInfos2;
    }

    //When adding/subtracting two numbers whose gap is bigger than the maximum double range, there
    //is no need to perform any operation (i.e., no change will be observed because of being outside
    //the maximum supported precision). This method takes care of these cases and returns the expected
    //output (i.e., biggest value).
    static UnitInfo[] TooBigGapAddition(UnitInfo[] unitInfos2, int[] bigSmallI, Operations operation)
    {
        UnitInfo[] outInfos = new UnitInfo[] 
        {
            //First operand (i.e., one whose information defines the operation) together with the
            //numeric information (i.e., just Value and BaseTenExponent because both are normalised)
            //which is associated with the biggest one.
            new UnitInfo(unitInfos2[0])
            {{
                Value = unitInfos2[bigSmallI[0]].Value;
                BaseTenExponent = unitInfos2[bigSmallI[0]].BaseTenExponent;
            }}
        };

        if (operation == Operations.Subtraction && bigSmallI[0] == 1)
        {
            outInfos[0].Value = -1.0 * outInfos[0].Value;
        }

        if (outInfos[0].Unit == Units.Unitless)
        {
            outInfos[0].Unit = unitInfos2[bigSmallI[1]].Unit;
        }

        return outInfos;
    }

    static UnitInfo AdaptBiggerAdditionOperand(UnitInfo[] unitInfos2, Integer[] bigSmallI, Operations operation)
    {
        int gapExponent = unitInfos2[bigSmallI[0]].BaseTenExponent - unitInfos2[bigSmallI[1]].BaseTenExponent;
        if (gapExponent >= 27)
        {
            //The difference between both inputs is bigger than (or, at least, very close to) the maximum double value/precision;
            //what makes this situation calculation unworthy and the first operand to be returned as the result.
            //Note that the error below these lines is just an easy way to tell the calling function about this eventuality.
            return new UnitInfo(unitInfos2[0]) 
            {{ 
                Error = new ErrorInfo(ErrorTypes.InvalidOperation); 
            }};
        }

        //PerformManagedOperationValues is used to make sure that the resulting numeric information is stored
        //in Value (if possible).
        UnitInfo big2 = PerformManagedOperationValues
        (
            RaiseToIntegerExponent(10.0, gapExponent), unitInfos2[bigSmallI[0]].Value, 
            Operations.Multiplication                
        );

        boolean isWrong = 
        (
            big2.Error.Type != ErrorTypes.None || big2.BaseTenExponent != 0 ?
            
            //The value of the bigger input times 10^(gap between BaseTenExponent of inputs) is too big. 
            isWrong = true :
            
            //Overflow-check very unlikely to trigger an error. In fact, with properly normalised variables,
            //triggering an error would be plainly impossible.               
            AreAdditionFinalValuesWrong
            (
                unitInfos2[0].Value, unitInfos2[1].Value, operation
            )
        );

        if (isWrong)
        {
        	new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }}
        }
        
        return
        (
            isWrong ?
            //This error is just an easy way to let the calling function know about the fact that no
            //calculation has been performed (too big gap). This isn't a properly-speaking error and
            //that's why it will not be notified to the user.
            new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }} :
            //Returning the new big value. For example: with 5*10^4 & 3*10^2, 500 would be returned.
            new UnitInfo(unitInfos2[bigSmallI[0]])
            {{
                Value = big2.Value;
            }}
        )
    }

    static boolean AreAdditionFinalValuesWrong(double val1, double val2, Operations operation)
    {
        boolean isWrong = false;

        try
        {
            val1 = val1 + val2 *
            (
                operation == Operations.Addition ? 1 : -1
            );
        }
        catch { isWrong = true; }

        return isWrong;
    }

    static UnitInfo PerformManagedOperationMultiplication(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationNormalisedValues
        (
            firstInfo, new UnitInfo[] 
            { 
                NormaliseUnitInfo(firstInfo),
                NormaliseUnitInfo(secondInfo) 
            },
            operation
        );
    }

    public static UnitInfo RaiseToIntegerExponent(double baseValue, int exponent)
    {
        return RaiseToIntegerExponent(new UnitInfo(baseValue), exponent);
    }

    static UnitInfo RaiseToIntegerExponent(UnitInfo baseInfo, int exponent)
    {
        if (exponent <= 1 && exponent >= 0)
        {
            baseInfo.Value = (exponent == 0 ? 1.0 : baseInfo.Value);
            return baseInfo;
        }

        UnitInfo outInfo = new UnitInfo(baseInfo);

        for (int i = 1; i < Math.Abs(exponent); i++)
        {
            outInfo = PerformManagedOperationValues
            (
                outInfo, baseInfo, Operations.Multiplication
            );
            if (outInfo.Error.Type != ErrorTypes.None) return outInfo;
        }

        return
        (
            exponent < 0 ?
            PerformManagedOperationValues(new UnitInfo(1.0), outInfo, Operations.Division) :
            outInfo
        );
    }

    static UnitInfo PerformManagedOperationNormalisedValues(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        outInfo =
        (
            normalisedInfos.Length == 1 ?
            //There is just one operand when the difference between both of them is too big.
            outInfo = normalisedInfos[0] :
            PerformManagedOperationTwoOperands(outInfo, normalisedInfos, operation)
        );

        return outInfo;
    }

    static UnitInfo PerformManagedOperationTwoOperands(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        UnitInfo outInfoNormalised = PerformManagedOperationValues
        (
            normalisedInfos[0], normalisedInfos[1], operation
        );

        if (outInfo.Error.Type != ErrorTypes.None)
        {
            return new UnitInfo(outInfo)
            {
                Error = new ErrorInfo(ErrorTypes.NumericError)
            };
        }

        outInfo.BaseTenExponent = outInfoNormalised.BaseTenExponent;
        outInfo.Value = outInfoNormalised.Value;
        //Normalised means no prefixes.
        outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage); 

        return outInfo;
    }

    static UnitInfo PerformManagedOperationValues(double firstValue, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            new UnitInfo(firstValue), new UnitInfo(secondValue), operation
        );
    }

    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            firstInfo, new UnitInfo(secondValue), operation
        );
    }

    //This method might be used to perform full operations (not just being the last calculation step) instead
    //of the default one (PerformManagedOperationUnits) for simple cases. That is: ones not dealing with the
    //complex numeric reality (Value, Prefix and BaseTenExponent) which makes a pre-analysis required.
    //Note that, unlikely what happens with PerformMangedOperationUnits, the outputs of this method aren't
    //normalised (= primarily stored under Value), what is useful in certain contexts.
    //NOTE: this function assumes that both inputs are normalised, what means that no prefix information is expected.
    //It might also be used with non-normalised inputs, but their prefix information would be plainly ignored.
    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        if (firstInfo.Value == 0.0 || secondInfo.Value == 0.0)
        {
            if (operation == Operations.Multiplication || operation == Operations.Division)
            {
                //Dividing by zero scenarios are taken into account somewhere else.
                return new UnitInfo(firstInfo) { Value = 0.0 };
            }
        }

        UnitInfo outInfo = new UnitInfo(firstInfo);
        UnitInfo firstInfo0 = new UnitInfo(firstInfo);
        UnitInfo secondInfo0 = new UnitInfo(secondInfo);

        boolean isWrong = false;
        try
        {
            if (operation == Operations.Addition)
            {
                outInfo.Value += secondInfo0.Value;
            }
            else if (operation == Operations.Subtraction)
            {
                outInfo.Value -= secondInfo.Value;
            }
            else
            {
                //The reason for checking whether BaseTenExponent is inside/outside the int range before performing 
                //the operation (rather than going ahead and eventually catching the resulting exception) isn't just
                //being quicker, but also the only option in many situations. Note that an addition/subtraction between
                //two int variables whose result is outside the int range might not trigger an exception (+ random 
                //negative value as output).
                if (VaryBaseTenExponent(outInfo, secondInfo0.BaseTenExponent, operation == Operations.Division).Error.Type != ErrorTypes.None)
                {
                    return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
                }

                if (operation == Operations.Multiplication)
                {
                    outInfo.Value *= secondInfo.Value;
                    outInfo.BaseTenExponent += secondInfo.BaseTenExponent;
                }
                else if (operation == Operations.Division)
                {
                    if (secondInfo.Value == 0.0)
                    {
                        return
                        (
                            new UnitInfo(outInfo) 
                            { 
                                Error = new ErrorInfo(ErrorTypes.NumericError) 
                            }
                        );
                    }
                    outInfo.Value /= secondInfo.Value;
                    outInfo.BaseTenExponent -= secondInfo.BaseTenExponent;
                }
            }
        }
        catch { isWrong = true; }

        return
        (
            //An error might not be triggered despite of dealing with numbers outside double precision.
            //For example: 0.00000000000000000001m * 0.0000000000000000000001m can output 0.0 without triggering an error. 
            isWrong || ((operation == Operations.Multiplication || operation == Operations.Division) && outInfo.Value == 0.0.0) ?
            OperationValuesManageError(firstInfo0, secondInfo0, operation) : outInfo
        );
    }

    static UnitInfo OperationValuesManageError(UnitInfo outInfo, UnitInfo secondInfo, Operations operation)
    {
        if (operation != Operations.Multiplication && operation != Operations.Division)
        {
            //This condition should never be true on account of the fact that the pre-modifications performed before
            //adding/subtracting should avoid erroneous situations.
            return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
        }

        UnitInfo secondInfo2 = ConvertValueToBaseTen(secondInfo.Value);
        outInfo = VaryBaseTenExponent(outInfo, secondInfo2.BaseTenExponent, operation == Operations.Division);
        if (Math.Abs(secondInfo2.Value) == 1.0 || outInfo.Error.Type != ErrorTypes.None) return outInfo;
        
        try
        {
            outInfo = PerformManagedOperationUnits
            (
                outInfo, secondInfo2.Value, operation
            );
        }
        catch
        {
            //Very unlikely scenario on account of the fact that Math.Abs(secondInfo2.Value)
            //lies within the 0.1-10.0 range.
            outInfo = OperationValuesManageError
            (
                new UnitInfo(outInfo)
                {
                    Value = secondInfo2.Value,
                    BaseTenExponent = 0
                },
                new UnitInfo()
                {
                    Value = outInfo.Value,
                    BaseTenExponent = outInfo.BaseTenExponent
                },
                operation
            );
        }

        return outInfo;
    }

    static UnitInfo ConvertValueToBaseTen(double value)
    {
        value = Math.Abs(value);
        return FromValueToBaseTenExponent
        (
             new UnitInfo(value), Math.Abs(value), false
        );
    }

    static UnitInfo ConvertBaseTenToValue(UnitInfo unitInfo)
    {
        if (unitInfo.BaseTenExponent == 0) return unitInfo;

        UnitInfo outInfo = new UnitInfo(unitInfo);
        boolean decrease = unitInfo.BaseTenExponent > 0;
        int sign = Math.Sign(outInfo.Value);
        double absValue = Math.Abs(outInfo.Value);

        while (outInfo.BaseTenExponent != 0.0)
        {
            if (decrease)
            {
                if (absValue >= MaxValueDec / 10.0) break;
                absValue *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }
            else
            {
                if (absValue <= MinValueDec * 10.0) break;
                absValue /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
        }

        outInfo.Value = sign * absValue;

        return outInfo;
    }

    static UnitInfo NormaliseUnitInfo(UnitInfo unitInfo)
    {
        if (unitInfo.Value == 0 && unitInfo.Prefix.Factor == 1.0)
        {
            return unitInfo;
        }
        UnitInfo outInfo = new UnitInfo(unitInfo);

        if (outInfo.Prefix.Factor != 1)
        {
            outInfo = FromValueToBaseTenExponent
            (
                outInfo, outInfo.Prefix.Factor, true
            );
            outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage);
        }
        if (outInfo.Value == 0.0) return outInfo;

        outInfo = FromValueToBaseTenExponent
        (
            outInfo, outInfo.Value, false
        );

        return outInfo;
    }

    static UnitInfo FromValueToBaseTenExponent(UnitInfo outInfo, double value, boolean isPrefix)
    {
        if (value == 0.0) return outInfo;

        double valueAbs = Math.Abs(value);
        boolean decrease = (valueAbs > 1.0);
        if (!isPrefix)
        {
            outInfo.Value = outInfo.Value / valueAbs;
        }

        while (valueAbs != 1.0)
        {
            if ((valueAbs < 10.0 && valueAbs > 1.0) || (valueAbs > 0.1.0 && valueAbs < 1.0))
            {
                if (!isPrefix) outInfo.Value = value;
                else
                {
                    outInfo = PerformManagedOperationValues
                    (
                        outInfo, value, Operations.Multiplication
                    );
                }

                return outInfo;
            }

            if (decrease)
            {
                value /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
            else
            {
                value *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }

            valueAbs = Math.Abs(value);
        }

        return outInfo;
    }

    //Method used to vary BaseTenExponent without provoking unhandled exceptions (i.e., bigger than Integer.MAX_VALUE).
    static UnitInfo VaryBaseTenExponent(UnitInfo info, int baseTenIncrease, boolean isDivision = false)
    {
        long val1 = info.BaseTenExponent;
        long val2 = baseTenIncrease;

        if (isDivision)
        {
            //Converting a negative value into positive might provoke an overflow error for the int type
            //(e.g., Math.Abs(Integer.MAIN_VALUE)). Converting both variables to long is a quick and effective
            //way to avoid this problem.
            val2 *= -1;
        }

        return
        (
             ((val2 > 0 && val1 > Integer.MAX_VALUE - val2) || (val2 < 0 && val1 < Integer.MAIN_VALUE - val2)) ?
            new UnitInfo(info, ErrorTypes.NumericError) : new UnitInfo(info){{ BaseTenExponent = (int)(val1 + val2); }}
        );
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:476)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 2 2017-05-27 20:04:39.193
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:476)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 0 2017-05-27 20:04:39.193
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:476)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.core 4 4 2017-05-27 20:04:40.334
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
public class OperationsManaged
{
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, double second, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            firstInfo, new UnitInfo(second), operation
        );
    }

    public static UnitInfo PerformManagedOperationUnits(double first, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            new UnitInfo(first), secondInfo, operation
        );
    }

    //This method should always be used when dealing with random UnitInfo variables because it accounts for all the
    //possible scenarios. On the other hand, with simple operations (e.g., random UnitInfo & numeric type) it might
    //be better to use PerformManagedOperationValues. 
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        ErrorTypes errorType = InternalMethods.GetOperationError
        (
            firstInfo, secondInfo, operation
        );
        if (errorType != ErrorTypes.None)
        {
            return new UnitInfo(firstInfo) 
            {{
                Error = new ErrorInfo(errorType); 
            }};
        }

        return
        (
            operation == Operations.Addition || operation == Operations.Subtraction ?
            PerformManagedOperationAddition(firstInfo, secondInfo, operation) :
            PerformManagedOperationMultiplication(firstInfo, secondInfo, operation)
        );
    }

    static UnitInfo PerformManagedOperationAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {   
        //After being normalised, the operands might require further modifications.
        UnitInfo[] normalised = GetOperandsAddition(firstInfo, secondInfo, operation);

        return PerformManagedOperationNormalisedValues
        (
            firstInfo, normalised, operation
        );
    }

    static UnitInfo[] GetOperandsAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        UnitInfo[] operands2 = new UnitInfo[] 
        {
            new UnitInfo(firstInfo), new UnitInfo(secondInfo)
        };

        if (operands2[0].BaseTenExponent != operands2[1].BaseTenExponent || operands2[0].Prefix.Factor != operands2[1].Prefix.Factor)
        {
            //The addition/subtraction might not be performed right away even with normalised values.
            //For example: 5 and 6 from 5*10^2 and 6*10^7 cannot be added right away.
            operands2 = AdaptNormalisedValuesForAddition
            (
                new UnitInfo[] 
                { 
                    NormaliseUnitInfo(operands2[0]), 
                    NormaliseUnitInfo(operands2[1])
                },
                operation
            );
        }

        return operands2;
    }
    
    static UnitInfo[] AdaptNormalisedValuesForAddition(UnitInfo[] unitInfos2, Operations operation)
    {
        if (unitInfos2[0].BaseTenExponent == unitInfos2[1].BaseTenExponent)
        {
            //Having the same BaseTenExponent values means that the given operation can be performed right away.
            return unitInfos2;
        }

        int[] bigSmallI = 
        (
            unitInfos2[0].BaseTenExponent > unitInfos2[1].BaseTenExponent ?
            new int[] { 0, 1 } : new int[] { 1, 0 }
        );

        //Only the variable with the bigger value is modified. For example: 5*10^5 & 3*10^3 is converted
        //into 500*10^3 & 3*10^3 in order to allow the addition 500 + 3. 
        UnitInfo big2 = AdaptBiggerAdditionOperand(unitInfos2, bigSmallI, operation);
        if (big2.Error.Type != ErrorTypes.None)
        {
            return TooBigGapAddition(unitInfos2, bigSmallI, operation);
        }

        unitInfos2[bigSmallI[0]].Value = big2.Value;
        unitInfos2[bigSmallI[0]].BaseTenExponent = unitInfos2[bigSmallI[1]].BaseTenExponent;

        return unitInfos2;
    }

    //When adding/subtracting two numbers whose gap is bigger than the maximum double range, there
    //is no need to perform any operation (i.e., no change will be observed because of being outside
    //the maximum supported precision). This method takes care of these cases and returns the expected
    //output (i.e., biggest value).
    static UnitInfo[] TooBigGapAddition(UnitInfo[] unitInfos2, int[] bigSmallI, Operations operation)
    {
        UnitInfo[] outInfos = new UnitInfo[] 
        {
            //First operand (i.e., one whose information defines the operation) together with the
            //numeric information (i.e., just Value and BaseTenExponent because both are normalised)
            //which is associated with the biggest one.
            new UnitInfo(unitInfos2[0])
            {{
                Value = unitInfos2[bigSmallI[0]].Value;
                BaseTenExponent = unitInfos2[bigSmallI[0]].BaseTenExponent;
            }}
        };

        if (operation == Operations.Subtraction && bigSmallI[0] == 1)
        {
            outInfos[0].Value = -1.0 * outInfos[0].Value;
        }

        if (outInfos[0].Unit == Units.Unitless)
        {
            outInfos[0].Unit = unitInfos2[bigSmallI[1]].Unit;
        }

        return outInfos;
    }

    static UnitInfo AdaptBiggerAdditionOperand(UnitInfo[] unitInfos2, Integer[] bigSmallI, Operations operation)
    {
        int gapExponent = unitInfos2[bigSmallI[0]].BaseTenExponent - unitInfos2[bigSmallI[1]].BaseTenExponent;
        if (gapExponent >= 27)
        {
            //The difference between both inputs is bigger than (or, at least, very close to) the maximum double value/precision;
            //what makes this situation calculation unworthy and the first operand to be returned as the result.
            //Note that the error below these lines is just an easy way to tell the calling function about this eventuality.
            return new UnitInfo(unitInfos2[0]) 
            {{ 
                Error = new ErrorInfo(ErrorTypes.InvalidOperation); 
            }};
        }

        //PerformManagedOperationValues is used to make sure that the resulting numeric information is stored
        //in Value (if possible).
        UnitInfo big2 = PerformManagedOperationValues
        (
            RaiseToIntegerExponent(10.0, gapExponent), unitInfos2[bigSmallI[0]].Value, 
            Operations.Multiplication                
        );

        boolean isWrong = 
        (
            big2.Error.Type != ErrorTypes.None || big2.BaseTenExponent != 0 ?
            
            //The value of the bigger input times 10^(gap between BaseTenExponent of inputs) is too big. 
            isWrong = true :
            
            //Overflow-check very unlikely to trigger an error. In fact, with properly normalised variables,
            //triggering an error would be plainly impossible.               
            AreAdditionFinalValuesWrong
            (
                unitInfos2[0].Value, unitInfos2[1].Value, operation
            )
        );

        if (isWrong)
        {
        	new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }}
        }
        
        return
        (
            isWrong ?
            //This error is just an easy way to let the calling function know about the fact that no
            //calculation has been performed (too big gap). This isn't a properly-speaking error and
            //that's why it will not be notified to the user.
            new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }} :
            //Returning the new big value. For example: with 5*10^4 & 3*10^2, 500 would be returned.
            new UnitInfo(unitInfos2[bigSmallI[0]])
            {{
                Value = big2.Value;
            }}
        )
    }

    static boolean AreAdditionFinalValuesWrong(double val1, double val2, Operations operation)
    {
        boolean isWrong = false;

        try
        {
            val1 = val1 + val2 *
            (
                operation == Operations.Addition ? 1 : -1
            );
        }
        catch { isWrong = true; }

        return isWrong;
    }

    static UnitInfo PerformManagedOperationMultiplication(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationNormalisedValues
        (
            firstInfo, new UnitInfo[] 
            { 
                NormaliseUnitInfo(firstInfo),
                NormaliseUnitInfo(secondInfo) 
            },
            operation
        );
    }

    public static UnitInfo RaiseToIntegerExponent(double baseValue, int exponent)
    {
        return RaiseToIntegerExponent(new UnitInfo(baseValue), exponent);
    }

    static UnitInfo RaiseToIntegerExponent(UnitInfo baseInfo, int exponent)
    {
        if (exponent <= 1 && exponent >= 0)
        {
            baseInfo.Value = (exponent == 0 ? 1.0 : baseInfo.Value);
            return baseInfo;
        }

        UnitInfo outInfo = new UnitInfo(baseInfo);

        for (int i = 1; i < Math.Abs(exponent); i++)
        {
            outInfo = PerformManagedOperationValues
            (
                outInfo, baseInfo, Operations.Multiplication
            );
            if (outInfo.Error.Type != ErrorTypes.None) return outInfo;
        }

        return
        (
            exponent < 0 ?
            PerformManagedOperationValues(new UnitInfo(1.0), outInfo, Operations.Division) :
            outInfo
        );
    }

    static UnitInfo PerformManagedOperationNormalisedValues(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        outInfo =
        (
            normalisedInfos.Length == 1 ?
            //There is just one operand when the difference between both of them is too big.
            outInfo = normalisedInfos[0] :
            PerformManagedOperationTwoOperands(outInfo, normalisedInfos, operation)
        );

        return outInfo;
    }

    static UnitInfo PerformManagedOperationTwoOperands(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        UnitInfo outInfoNormalised = PerformManagedOperationValues
        (
            normalisedInfos[0], normalisedInfos[1], operation
        );

        if (outInfo.Error.Type != ErrorTypes.None)
        {
            return new UnitInfo(outInfo)
            {
                Error = new ErrorInfo(ErrorTypes.NumericError)
            };
        }

        outInfo.BaseTenExponent = outInfoNormalised.BaseTenExponent;
        outInfo.Value = outInfoNormalised.Value;
        //Normalised means no prefixes.
        outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage); 

        return outInfo;
    }

    static UnitInfo PerformManagedOperationValues(double firstValue, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            new UnitInfo(firstValue), new UnitInfo(secondValue), operation
        );
    }

    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            firstInfo, new UnitInfo(secondValue), operation
        );
    }

    //This method might be used to perform full operations (not just being the last calculation step) instead
    //of the default one (PerformManagedOperationUnits) for simple cases. That is: ones not dealing with the
    //complex numeric reality (Value, Prefix and BaseTenExponent) which makes a pre-analysis required.
    //Note that, unlikely what happens with PerformMangedOperationUnits, the outputs of this method aren't
    //normalised (= primarily stored under Value), what is useful in certain contexts.
    //NOTE: this function assumes that both inputs are normalised, what means that no prefix information is expected.
    //It might also be used with non-normalised inputs, but their prefix information would be plainly ignored.
    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        if (firstInfo.Value == 0.0 || secondInfo.Value == 0.0)
        {
            if (operation == Operations.Multiplication || operation == Operations.Division)
            {
                //Dividing by zero scenarios are taken into account somewhere else.
                return new UnitInfo(firstInfo) { Value = 0.0 };
            }
        }

        UnitInfo outInfo = new UnitInfo(firstInfo);
        UnitInfo firstInfo0 = new UnitInfo(firstInfo);
        UnitInfo secondInfo0 = new UnitInfo(secondInfo);

        boolean isWrong = false;
        try
        {
            if (operation == Operations.Addition)
            {
                outInfo.Value += secondInfo0.Value;
            }
            else if (operation == Operations.Subtraction)
            {
                outInfo.Value -= secondInfo.Value;
            }
            else
            {
                //The reason for checking whether BaseTenExponent is inside/outside the int range before performing 
                //the operation (rather than going ahead and eventually catching the resulting exception) isn't just
                //being quicker, but also the only option in many situations. Note that an addition/subtraction between
                //two int variables whose result is outside the int range might not trigger an exception (+ random 
                //negative value as output).
                if (VaryBaseTenExponent(outInfo, secondInfo0.BaseTenExponent, operation == Operations.Division).Error.Type != ErrorTypes.None)
                {
                    return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
                }

                if (operation == Operations.Multiplication)
                {
                    outInfo.Value *= secondInfo.Value;
                    outInfo.BaseTenExponent += secondInfo.BaseTenExponent;
                }
                else if (operation == Operations.Division)
                {
                    if (secondInfo.Value == 0.0)
                    {
                        return
                        (
                            new UnitInfo(outInfo) 
                            { 
                                Error = new ErrorInfo(ErrorTypes.NumericError) 
                            }
                        );
                    }
                    outInfo.Value /= secondInfo.Value;
                    outInfo.BaseTenExponent -= secondInfo.BaseTenExponent;
                }
            }
        }
        catch { isWrong = true; }

        return
        (
            //An error might not be triggered despite of dealing with numbers outside double precision.
            //For example: 0.00000000000000000001m * 0.0000000000000000000001m can output 0.0 without triggering an error. 
            isWrong || ((operation == Operations.Multiplication || operation == Operations.Division) && outInfo.Value == 0.0.0) ?
            OperationValuesManageError(firstInfo0, secondInfo0, operation) : outInfo
        );
    }

    static UnitInfo OperationValuesManageError(UnitInfo outInfo, UnitInfo secondInfo, Operations operation)
    {
        if (operation != Operations.Multiplication && operation != Operations.Division)
        {
            //This condition should never be true on account of the fact that the pre-modifications performed before
            //adding/subtracting should avoid erroneous situations.
            return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
        }

        UnitInfo secondInfo2 = ConvertValueToBaseTen(secondInfo.Value);
        outInfo = VaryBaseTenExponent(outInfo, secondInfo2.BaseTenExponent, operation == Operations.Division);
        if (Math.Abs(secondInfo2.Value) == 1.0 || outInfo.Error.Type != ErrorTypes.None) return outInfo;
        
        try
        {
            outInfo = PerformManagedOperationUnits
            (
                outInfo, secondInfo2.Value, operation
            );
        }
        catch
        {
            //Very unlikely scenario on account of the fact that Math.Abs(secondInfo2.Value)
            //lies within the 0.1-10.0 range.
            outInfo = OperationValuesManageError
            (
                new UnitInfo(outInfo)
                {
                    Value = secondInfo2.Value,
                    BaseTenExponent = 0
                },
                new UnitInfo()
                {
                    Value = outInfo.Value,
                    BaseTenExponent = outInfo.BaseTenExponent
                },
                operation
            );
        }

        return outInfo;
    }

    static UnitInfo ConvertValueToBaseTen(double value)
    {
        value = Math.Abs(value);
        return FromValueToBaseTenExponent
        (
             new UnitInfo(value), Math.Abs(value), false
        );
    }

    static UnitInfo ConvertBaseTenToValue(UnitInfo unitInfo)
    {
        if (unitInfo.BaseTenExponent == 0) return unitInfo;

        UnitInfo outInfo = new UnitInfo(unitInfo);
        boolean decrease = unitInfo.BaseTenExponent > 0;
        int sign = Math.Sign(outInfo.Value);
        double absValue = Math.Abs(outInfo.Value);

        while (outInfo.BaseTenExponent != 0.0)
        {
            if (decrease)
            {
                if (absValue >= MaxValueDec / 10.0) break;
                absValue *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }
            else
            {
                if (absValue <= MinValueDec * 10.0) break;
                absValue /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
        }

        outInfo.Value = sign * absValue;

        return outInfo;
    }

    static UnitInfo NormaliseUnitInfo(UnitInfo unitInfo)
    {
        if (unitInfo.Value == 0 && unitInfo.Prefix.Factor == 1.0)
        {
            return unitInfo;
        }
        UnitInfo outInfo = new UnitInfo(unitInfo);

        if (outInfo.Prefix.Factor != 1)
        {
            outInfo = FromValueToBaseTenExponent
            (
                outInfo, outInfo.Prefix.Factor, true
            );
            outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage);
        }
        if (outInfo.Value == 0.0) return outInfo;

        outInfo = FromValueToBaseTenExponent
        (
            outInfo, outInfo.Value, false
        );

        return outInfo;
    }

    static UnitInfo FromValueToBaseTenExponent(UnitInfo outInfo, double value, boolean isPrefix)
    {
        if (value == 0.0) return outInfo;

        double valueAbs = Math.Abs(value);
        boolean decrease = (valueAbs > 1.0);
        if (!isPrefix)
        {
            outInfo.Value = outInfo.Value / valueAbs;
        }

        while (valueAbs != 1.0)
        {
            if ((valueAbs < 10.0 && valueAbs > 1.0) || (valueAbs > 0.1.0 && valueAbs < 1.0))
            {
                if (!isPrefix) outInfo.Value = value;
                else
                {
                    outInfo = PerformManagedOperationValues
                    (
                        outInfo, value, Operations.Multiplication
                    );
                }

                return outInfo;
            }

            if (decrease)
            {
                value /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
            else
            {
                value *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }

            valueAbs = Math.Abs(value);
        }

        return outInfo;
    }

    //Method used to vary BaseTenExponent without provoking unhandled exceptions (i.e., bigger than Integer.MAX_VALUE).
    static UnitInfo VaryBaseTenExponent(UnitInfo info, int baseTenIncrease, boolean isDivision = false)
    {
        long val1 = info.BaseTenExponent;
        long val2 = baseTenIncrease;

        if (isDivision)
        {
            //Converting a negative value into positive might provoke an overflow error for the int type
            //(e.g., Math.Abs(Integer.MAIN_VALUE)). Converting both variables to long is a quick and effective
            //way to avoid this problem.
            val2 *= -1;
        }

        return
        (
             ((val2 > 0 && val1 > Integer.MAX_VALUE - val2) || (val2 < 0 && val1 < Integer.MAIN_VALUE - val2)) ?
            new UnitInfo(info, ErrorTypes.NumericError) : new UnitInfo(info){{ BaseTenExponent = (int)(val1 + val2); }}
        );
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 2 2017-05-27 20:04:40.335
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 0 2017-05-27 20:04:40.335
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.core 4 4 2017-05-27 20:04:41.699
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
public class OperationsManaged
{
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, double second, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            firstInfo, new UnitInfo(second), operation
        );
    }

    public static UnitInfo PerformManagedOperationUnits(double first, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            new UnitInfo(first), secondInfo, operation
        );
    }

    //This method should always be used when dealing with random UnitInfo variables because it accounts for all the
    //possible scenarios. On the other hand, with simple operations (e.g., random UnitInfo & numeric type) it might
    //be better to use PerformManagedOperationValues. 
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        ErrorTypes errorType = InternalMethods.GetOperationError
        (
            firstInfo, secondInfo, operation
        );
        if (errorType != ErrorTypes.None)
        {
            return new UnitInfo(firstInfo) 
            {{
                Error = new ErrorInfo(errorType); 
            }};
        }

        return
        (
            operation == Operations.Addition || operation == Operations.Subtraction ?
            PerformManagedOperationAddition(firstInfo, secondInfo, operation) :
            PerformManagedOperationMultiplication(firstInfo, secondInfo, operation)
        );
    }

    static UnitInfo PerformManagedOperationAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {   
        //After being normalised, the operands might require further modifications.
        UnitInfo[] normalised = GetOperandsAddition(firstInfo, secondInfo, operation);

        return PerformManagedOperationNormalisedValues
        (
            firstInfo, normalised, operation
        );
    }

    static UnitInfo[] GetOperandsAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        UnitInfo[] operands2 = new UnitInfo[] 
        {
            new UnitInfo(firstInfo), new UnitInfo(secondInfo)
        };

        if (operands2[0].BaseTenExponent != operands2[1].BaseTenExponent || operands2[0].Prefix.Factor != operands2[1].Prefix.Factor)
        {
            //The addition/subtraction might not be performed right away even with normalised values.
            //For example: 5 and 6 from 5*10^2 and 6*10^7 cannot be added right away.
            operands2 = AdaptNormalisedValuesForAddition
            (
                new UnitInfo[] 
                { 
                    NormaliseUnitInfo(operands2[0]), 
                    NormaliseUnitInfo(operands2[1])
                },
                operation
            );
        }

        return operands2;
    }
    
    static UnitInfo[] AdaptNormalisedValuesForAddition(UnitInfo[] unitInfos2, Operations operation)
    {
        if (unitInfos2[0].BaseTenExponent == unitInfos2[1].BaseTenExponent)
        {
            //Having the same BaseTenExponent values means that the given operation can be performed right away.
            return unitInfos2;
        }

        int[] bigSmallI = 
        (
            unitInfos2[0].BaseTenExponent > unitInfos2[1].BaseTenExponent ?
            new int[] { 0, 1 } : new int[] { 1, 0 }
        );

        //Only the variable with the bigger value is modified. For example: 5*10^5 & 3*10^3 is converted
        //into 500*10^3 & 3*10^3 in order to allow the addition 500 + 3. 
        UnitInfo big2 = AdaptBiggerAdditionOperand(unitInfos2, bigSmallI, operation);
        if (big2.Error.Type != ErrorTypes.None)
        {
            return TooBigGapAddition(unitInfos2, bigSmallI, operation);
        }

        unitInfos2[bigSmallI[0]].Value = big2.Value;
        unitInfos2[bigSmallI[0]].BaseTenExponent = unitInfos2[bigSmallI[1]].BaseTenExponent;

        return unitInfos2;
    }

    //When adding/subtracting two numbers whose gap is bigger than the maximum double range, there
    //is no need to perform any operation (i.e., no change will be observed because of being outside
    //the maximum supported precision). This method takes care of these cases and returns the expected
    //output (i.e., biggest value).
    static UnitInfo[] TooBigGapAddition(UnitInfo[] unitInfos2, int[] bigSmallI, Operations operation)
    {
        UnitInfo[] outInfos = new UnitInfo[] 
        {
            //First operand (i.e., one whose information defines the operation) together with the
            //numeric information (i.e., just Value and BaseTenExponent because both are normalised)
            //which is associated with the biggest one.
            new UnitInfo(unitInfos2[0])
            {{
                Value = unitInfos2[bigSmallI[0]].Value;
                BaseTenExponent = unitInfos2[bigSmallI[0]].BaseTenExponent;
            }}
        };

        if (operation == Operations.Subtraction && bigSmallI[0] == 1)
        {
            outInfos[0].Value = -1.0 * outInfos[0].Value;
        }

        if (outInfos[0].Unit == Units.Unitless)
        {
            outInfos[0].Unit = unitInfos2[bigSmallI[1]].Unit;
        }

        return outInfos;
    }

    static UnitInfo AdaptBiggerAdditionOperand(UnitInfo[] unitInfos2, Integer[] bigSmallI, Operations operation)
    {
        int gapExponent = unitInfos2[bigSmallI[0]].BaseTenExponent - unitInfos2[bigSmallI[1]].BaseTenExponent;
        if (gapExponent >= 27)
        {
            //The difference between both inputs is bigger than (or, at least, very close to) the maximum double value/precision;
            //what makes this situation calculation unworthy and the first operand to be returned as the result.
            //Note that the error below these lines is just an easy way to tell the calling function about this eventuality.
            return new UnitInfo(unitInfos2[0]) 
            {{ 
                Error = new ErrorInfo(ErrorTypes.InvalidOperation); 
            }};
        }

        //PerformManagedOperationValues is used to make sure that the resulting numeric information is stored
        //in Value (if possible).
        UnitInfo big2 = PerformManagedOperationValues
        (
            RaiseToIntegerExponent(10.0, gapExponent), unitInfos2[bigSmallI[0]].Value, 
            Operations.Multiplication                
        );

        boolean isWrong = 
        (
            big2.Error.Type != ErrorTypes.None || big2.BaseTenExponent != 0 ?
            
            //The value of the bigger input times 10^(gap between BaseTenExponent of inputs) is too big. 
            isWrong = true :
            
            //Overflow-check very unlikely to trigger an error. In fact, with properly normalised variables,
            //triggering an error would be plainly impossible.               
            AreAdditionFinalValuesWrong
            (
                unitInfos2[0].Value, unitInfos2[1].Value, operation
            )
        );

        if (isWrong)
        {
        	 new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }}
        }
        
        return
        (
            isWrong ?
            //This error is just an easy way to let the calling function know about the fact that no
            //calculation has been performed (too big gap). This isn't a properly-speaking error and
            //that's why it will not be notified to the user.
            new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }} :
            //Returning the new big value. For example: with 5*10^4 & 3*10^2, 500 would be returned.
            new UnitInfo(unitInfos2[bigSmallI[0]])
            {{
                Value = big2.Value;
            }}
        )
    }

    static boolean AreAdditionFinalValuesWrong(double val1, double val2, Operations operation)
    {
        boolean isWrong = false;

        try
        {
            val1 = val1 + val2 *
            (
                operation == Operations.Addition ? 1 : -1
            );
        }
        catch { isWrong = true; }

        return isWrong;
    }

    static UnitInfo PerformManagedOperationMultiplication(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationNormalisedValues
        (
            firstInfo, new UnitInfo[] 
            { 
                NormaliseUnitInfo(firstInfo),
                NormaliseUnitInfo(secondInfo) 
            },
            operation
        );
    }

    public static UnitInfo RaiseToIntegerExponent(double baseValue, int exponent)
    {
        return RaiseToIntegerExponent(new UnitInfo(baseValue), exponent);
    }

    static UnitInfo RaiseToIntegerExponent(UnitInfo baseInfo, int exponent)
    {
        if (exponent <= 1 && exponent >= 0)
        {
            baseInfo.Value = (exponent == 0 ? 1.0 : baseInfo.Value);
            return baseInfo;
        }

        UnitInfo outInfo = new UnitInfo(baseInfo);

        for (int i = 1; i < Math.Abs(exponent); i++)
        {
            outInfo = PerformManagedOperationValues
            (
                outInfo, baseInfo, Operations.Multiplication
            );
            if (outInfo.Error.Type != ErrorTypes.None) return outInfo;
        }

        return
        (
            exponent < 0 ?
            PerformManagedOperationValues(new UnitInfo(1.0), outInfo, Operations.Division) :
            outInfo
        );
    }

    static UnitInfo PerformManagedOperationNormalisedValues(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        outInfo =
        (
            normalisedInfos.Length == 1 ?
            //There is just one operand when the difference between both of them is too big.
            outInfo = normalisedInfos[0] :
            PerformManagedOperationTwoOperands(outInfo, normalisedInfos, operation)
        );

        return outInfo;
    }

    static UnitInfo PerformManagedOperationTwoOperands(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        UnitInfo outInfoNormalised = PerformManagedOperationValues
        (
            normalisedInfos[0], normalisedInfos[1], operation
        );

        if (outInfo.Error.Type != ErrorTypes.None)
        {
            return new UnitInfo(outInfo)
            {
                Error = new ErrorInfo(ErrorTypes.NumericError)
            };
        }

        outInfo.BaseTenExponent = outInfoNormalised.BaseTenExponent;
        outInfo.Value = outInfoNormalised.Value;
        //Normalised means no prefixes.
        outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage); 

        return outInfo;
    }

    static UnitInfo PerformManagedOperationValues(double firstValue, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            new UnitInfo(firstValue), new UnitInfo(secondValue), operation
        );
    }

    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            firstInfo, new UnitInfo(secondValue), operation
        );
    }

    //This method might be used to perform full operations (not just being the last calculation step) instead
    //of the default one (PerformManagedOperationUnits) for simple cases. That is: ones not dealing with the
    //complex numeric reality (Value, Prefix and BaseTenExponent) which makes a pre-analysis required.
    //Note that, unlikely what happens with PerformMangedOperationUnits, the outputs of this method aren't
    //normalised (= primarily stored under Value), what is useful in certain contexts.
    //NOTE: this function assumes that both inputs are normalised, what means that no prefix information is expected.
    //It might also be used with non-normalised inputs, but their prefix information would be plainly ignored.
    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        if (firstInfo.Value == 0.0 || secondInfo.Value == 0.0)
        {
            if (operation == Operations.Multiplication || operation == Operations.Division)
            {
                //Dividing by zero scenarios are taken into account somewhere else.
                return new UnitInfo(firstInfo) { Value = 0.0 };
            }
        }

        UnitInfo outInfo = new UnitInfo(firstInfo);
        UnitInfo firstInfo0 = new UnitInfo(firstInfo);
        UnitInfo secondInfo0 = new UnitInfo(secondInfo);

        boolean isWrong = false;
        try
        {
            if (operation == Operations.Addition)
            {
                outInfo.Value += secondInfo0.Value;
            }
            else if (operation == Operations.Subtraction)
            {
                outInfo.Value -= secondInfo.Value;
            }
            else
            {
                //The reason for checking whether BaseTenExponent is inside/outside the int range before performing 
                //the operation (rather than going ahead and eventually catching the resulting exception) isn't just
                //being quicker, but also the only option in many situations. Note that an addition/subtraction between
                //two int variables whose result is outside the int range might not trigger an exception (+ random 
                //negative value as output).
                if (VaryBaseTenExponent(outInfo, secondInfo0.BaseTenExponent, operation == Operations.Division).Error.Type != ErrorTypes.None)
                {
                    return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
                }

                if (operation == Operations.Multiplication)
                {
                    outInfo.Value *= secondInfo.Value;
                    outInfo.BaseTenExponent += secondInfo.BaseTenExponent;
                }
                else if (operation == Operations.Division)
                {
                    if (secondInfo.Value == 0.0)
                    {
                        return
                        (
                            new UnitInfo(outInfo) 
                            { 
                                Error = new ErrorInfo(ErrorTypes.NumericError) 
                            }
                        );
                    }
                    outInfo.Value /= secondInfo.Value;
                    outInfo.BaseTenExponent -= secondInfo.BaseTenExponent;
                }
            }
        }
        catch { isWrong = true; }

        return
        (
            //An error might not be triggered despite of dealing with numbers outside double precision.
            //For example: 0.00000000000000000001m * 0.0000000000000000000001m can output 0.0 without triggering an error. 
            isWrong || ((operation == Operations.Multiplication || operation == Operations.Division) && outInfo.Value == 0.0.0) ?
            OperationValuesManageError(firstInfo0, secondInfo0, operation) : outInfo
        );
    }

    static UnitInfo OperationValuesManageError(UnitInfo outInfo, UnitInfo secondInfo, Operations operation)
    {
        if (operation != Operations.Multiplication && operation != Operations.Division)
        {
            //This condition should never be true on account of the fact that the pre-modifications performed before
            //adding/subtracting should avoid erroneous situations.
            return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
        }

        UnitInfo secondInfo2 = ConvertValueToBaseTen(secondInfo.Value);
        outInfo = VaryBaseTenExponent(outInfo, secondInfo2.BaseTenExponent, operation == Operations.Division);
        if (Math.Abs(secondInfo2.Value) == 1.0 || outInfo.Error.Type != ErrorTypes.None) return outInfo;
        
        try
        {
            outInfo = PerformManagedOperationUnits
            (
                outInfo, secondInfo2.Value, operation
            );
        }
        catch
        {
            //Very unlikely scenario on account of the fact that Math.Abs(secondInfo2.Value)
            //lies within the 0.1-10.0 range.
            outInfo = OperationValuesManageError
            (
                new UnitInfo(outInfo)
                {
                    Value = secondInfo2.Value,
                    BaseTenExponent = 0
                },
                new UnitInfo()
                {
                    Value = outInfo.Value,
                    BaseTenExponent = outInfo.BaseTenExponent
                },
                operation
            );
        }

        return outInfo;
    }

    static UnitInfo ConvertValueToBaseTen(double value)
    {
        value = Math.Abs(value);
        return FromValueToBaseTenExponent
        (
             new UnitInfo(value), Math.Abs(value), false
        );
    }

    static UnitInfo ConvertBaseTenToValue(UnitInfo unitInfo)
    {
        if (unitInfo.BaseTenExponent == 0) return unitInfo;

        UnitInfo outInfo = new UnitInfo(unitInfo);
        boolean decrease = unitInfo.BaseTenExponent > 0;
        int sign = Math.Sign(outInfo.Value);
        double absValue = Math.Abs(outInfo.Value);

        while (outInfo.BaseTenExponent != 0.0)
        {
            if (decrease)
            {
                if (absValue >= MaxValueDec / 10.0) break;
                absValue *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }
            else
            {
                if (absValue <= MinValueDec * 10.0) break;
                absValue /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
        }

        outInfo.Value = sign * absValue;

        return outInfo;
    }

    static UnitInfo NormaliseUnitInfo(UnitInfo unitInfo)
    {
        if (unitInfo.Value == 0 && unitInfo.Prefix.Factor == 1.0)
        {
            return unitInfo;
        }
        UnitInfo outInfo = new UnitInfo(unitInfo);

        if (outInfo.Prefix.Factor != 1)
        {
            outInfo = FromValueToBaseTenExponent
            (
                outInfo, outInfo.Prefix.Factor, true
            );
            outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage);
        }
        if (outInfo.Value == 0.0) return outInfo;

        outInfo = FromValueToBaseTenExponent
        (
            outInfo, outInfo.Value, false
        );

        return outInfo;
    }

    static UnitInfo FromValueToBaseTenExponent(UnitInfo outInfo, double value, boolean isPrefix)
    {
        if (value == 0.0) return outInfo;

        double valueAbs = Math.Abs(value);
        boolean decrease = (valueAbs > 1.0);
        if (!isPrefix)
        {
            outInfo.Value = outInfo.Value / valueAbs;
        }

        while (valueAbs != 1.0)
        {
            if ((valueAbs < 10.0 && valueAbs > 1.0) || (valueAbs > 0.1.0 && valueAbs < 1.0))
            {
                if (!isPrefix) outInfo.Value = value;
                else
                {
                    outInfo = PerformManagedOperationValues
                    (
                        outInfo, value, Operations.Multiplication
                    );
                }

                return outInfo;
            }

            if (decrease)
            {
                value /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
            else
            {
                value *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }

            valueAbs = Math.Abs(value);
        }

        return outInfo;
    }

    //Method used to vary BaseTenExponent without provoking unhandled exceptions (i.e., bigger than Integer.MAX_VALUE).
    static UnitInfo VaryBaseTenExponent(UnitInfo info, int baseTenIncrease, boolean isDivision = false)
    {
        long val1 = info.BaseTenExponent;
        long val2 = baseTenIncrease;

        if (isDivision)
        {
            //Converting a negative value into positive might provoke an overflow error for the int type
            //(e.g., Math.Abs(Integer.MAIN_VALUE)). Converting both variables to long is a quick and effective
            //way to avoid this problem.
            val2 *= -1;
        }

        return
        (
             ((val2 > 0 && val1 > Integer.MAX_VALUE - val2) || (val2 < 0 && val1 < Integer.MAIN_VALUE - val2)) ?
            new UnitInfo(info, ErrorTypes.NumericError) : new UnitInfo(info){{ BaseTenExponent = (int)(val1 + val2); }}
        );
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2017-05-27 20:04:41.700
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2017-05-27 20:04:41.703
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2017-05-27 20:04:45.239
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
public class OperationsManaged
{
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, double second, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            firstInfo, new UnitInfo(second), operation
        );
    }

    public static UnitInfo PerformManagedOperationUnits(double first, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            new UnitInfo(first), secondInfo, operation
        );
    }

    //This method should always be used when dealing with random UnitInfo variables because it accounts for all the
    //possible scenarios. On the other hand, with simple operations (e.g., random UnitInfo & numeric type) it might
    //be better to use PerformManagedOperationValues. 
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        ErrorTypes errorType = InternalMethods.GetOperationError
        (
            firstInfo, secondInfo, operation
        );
        if (errorType != ErrorTypes.None)
        {
            return new UnitInfo(firstInfo) 
            {{
                Error = new ErrorInfo(errorType); 
            }};
        }

        return
        (
            operation == Operations.Addition || operation == Operations.Subtraction ?
            PerformManagedOperationAddition(firstInfo, secondInfo, operation) :
            PerformManagedOperationMultiplication(firstInfo, secondInfo, operation)
        );
    }

    static UnitInfo PerformManagedOperationAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {   
        //After being normalised, the operands might require further modifications.
        UnitInfo[] normalised = GetOperandsAddition(firstInfo, secondInfo, operation);

        return PerformManagedOperationNormalisedValues
        (
            firstInfo, normalised, operation
        );
    }

    static UnitInfo[] GetOperandsAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        UnitInfo[] operands2 = new UnitInfo[] 
        {
            new UnitInfo(firstInfo), new UnitInfo(secondInfo)
        };

        if (operands2[0].BaseTenExponent != operands2[1].BaseTenExponent || operands2[0].Prefix.Factor != operands2[1].Prefix.Factor)
        {
            //The addition/subtraction might not be performed right away even with normalised values.
            //For example: 5 and 6 from 5*10^2 and 6*10^7 cannot be added right away.
            operands2 = AdaptNormalisedValuesForAddition
            (
                new UnitInfo[] 
                { 
                    NormaliseUnitInfo(operands2[0]), 
                    NormaliseUnitInfo(operands2[1])
                },
                operation
            );
        }

        return operands2;
    }
    
    static UnitInfo[] AdaptNormalisedValuesForAddition(UnitInfo[] unitInfos2, Operations operation)
    {
        if (unitInfos2[0].BaseTenExponent == unitInfos2[1].BaseTenExponent)
        {
            //Having the same BaseTenExponent values means that the given operation can be performed right away.
            return unitInfos2;
        }

        int[] bigSmallI = 
        (
            unitInfos2[0].BaseTenExponent > unitInfos2[1].BaseTenExponent ?
            new int[] { 0, 1 } : new int[] { 1, 0 }
        );

        //Only the variable with the bigger value is modified. For example: 5*10^5 & 3*10^3 is converted
        //into 500*10^3 & 3*10^3 in order to allow the addition 500 + 3. 
        UnitInfo big2 = AdaptBiggerAdditionOperand(unitInfos2, bigSmallI, operation);
        if (big2.Error.Type != ErrorTypes.None)
        {
            return TooBigGapAddition(unitInfos2, bigSmallI, operation);
        }

        unitInfos2[bigSmallI[0]].Value = big2.Value;
        unitInfos2[bigSmallI[0]].BaseTenExponent = unitInfos2[bigSmallI[1]].BaseTenExponent;

        return unitInfos2;
    }

    //When adding/subtracting two numbers whose gap is bigger than the maximum double range, there
    //is no need to perform any operation (i.e., no change will be observed because of being outside
    //the maximum supported precision). This method takes care of these cases and returns the expected
    //output (i.e., biggest value).
    static UnitInfo[] TooBigGapAddition(UnitInfo[] unitInfos2, int[] bigSmallI, Operations operation)
    {
        UnitInfo[] outInfos = new UnitInfo[] 
        {
            //First operand (i.e., one whose information defines the operation) together with the
            //numeric information (i.e., just Value and BaseTenExponent because both are normalised)
            //which is associated with the biggest one.
            new UnitInfo(unitInfos2[0])
            {{
                Value = unitInfos2[bigSmallI[0]].Value;
                BaseTenExponent = unitInfos2[bigSmallI[0]].BaseTenExponent;
            }}
        };

        if (operation == Operations.Subtraction && bigSmallI[0] == 1)
        {
            outInfos[0].Value = -1.0 * outInfos[0].Value;
        }

        if (outInfos[0].Unit == Units.Unitless)
        {
            outInfos[0].Unit = unitInfos2[bigSmallI[1]].Unit;
        }

        return outInfos;
    }

    static UnitInfo AdaptBiggerAdditionOperand(UnitInfo[] unitInfos2, Integer[] bigSmallI, Operations operation)
    {
        int gapExponent = unitInfos2[bigSmallI[0]].BaseTenExponent - unitInfos2[bigSmallI[1]].BaseTenExponent;
        if (gapExponent >= 27)
        {
            //The difference between both inputs is bigger than (or, at least, very close to) the maximum double value/precision;
            //what makes this situation calculation unworthy and the first operand to be returned as the result.
            //Note that the error below these lines is just an easy way to tell the calling function about this eventuality.
            return new UnitInfo(unitInfos2[0]) 
            {{ 
                Error = new ErrorInfo(ErrorTypes.InvalidOperation); 
            }};
        }

        //PerformManagedOperationValues is used to make sure that the resulting numeric information is stored
        //in Value (if possible).
        UnitInfo big2 = PerformManagedOperationValues
        (
            RaiseToIntegerExponent(10.0, gapExponent), unitInfos2[bigSmallI[0]].Value, 
            Operations.Multiplication                
        );

        boolean isWrong = 
        (
            big2.Error.Type != ErrorTypes.None || big2.BaseTenExponent != 0 ?
            
            //The value of the bigger input times 10^(gap between BaseTenExponent of inputs) is too big. 
            isWrong = true :
            
            //Overflow-check very unlikely to trigger an error. In fact, with properly normalised variables,
            //triggering an error would be plainly impossible.               
            AreAdditionFinalValuesWrong
            (
                unitInfos2[0].Value, unitInfos2[1].Value, operation
            )
        );

        if (isWrong)
        {
        	UnitInfo temp = new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }}
        }
        
        return
        (
            isWrong ?
            //This error is just an easy way to let the calling function know about the fact that no
            //calculation has been performed (too big gap). This isn't a properly-speaking error and
            //that's why it will not be notified to the user.
            new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }} :
            //Returning the new big value. For example: with 5*10^4 & 3*10^2, 500 would be returned.
            new UnitInfo(unitInfos2[bigSmallI[0]])
            {{
                Value = big2.Value;
            }}
        )
    }

    static boolean AreAdditionFinalValuesWrong(double val1, double val2, Operations operation)
    {
        boolean isWrong = false;

        try
        {
            val1 = val1 + val2 *
            (
                operation == Operations.Addition ? 1 : -1
            );
        }
        catch { isWrong = true; }

        return isWrong;
    }

    static UnitInfo PerformManagedOperationMultiplication(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationNormalisedValues
        (
            firstInfo, new UnitInfo[] 
            { 
                NormaliseUnitInfo(firstInfo),
                NormaliseUnitInfo(secondInfo) 
            },
            operation
        );
    }

    public static UnitInfo RaiseToIntegerExponent(double baseValue, int exponent)
    {
        return RaiseToIntegerExponent(new UnitInfo(baseValue), exponent);
    }

    static UnitInfo RaiseToIntegerExponent(UnitInfo baseInfo, int exponent)
    {
        if (exponent <= 1 && exponent >= 0)
        {
            baseInfo.Value = (exponent == 0 ? 1.0 : baseInfo.Value);
            return baseInfo;
        }

        UnitInfo outInfo = new UnitInfo(baseInfo);

        for (int i = 1; i < Math.Abs(exponent); i++)
        {
            outInfo = PerformManagedOperationValues
            (
                outInfo, baseInfo, Operations.Multiplication
            );
            if (outInfo.Error.Type != ErrorTypes.None) return outInfo;
        }

        return
        (
            exponent < 0 ?
            PerformManagedOperationValues(new UnitInfo(1.0), outInfo, Operations.Division) :
            outInfo
        );
    }

    static UnitInfo PerformManagedOperationNormalisedValues(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        outInfo =
        (
            normalisedInfos.Length == 1 ?
            //There is just one operand when the difference between both of them is too big.
            outInfo = normalisedInfos[0] :
            PerformManagedOperationTwoOperands(outInfo, normalisedInfos, operation)
        );

        return outInfo;
    }

    static UnitInfo PerformManagedOperationTwoOperands(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        UnitInfo outInfoNormalised = PerformManagedOperationValues
        (
            normalisedInfos[0], normalisedInfos[1], operation
        );

        if (outInfo.Error.Type != ErrorTypes.None)
        {
            return new UnitInfo(outInfo)
            {
                Error = new ErrorInfo(ErrorTypes.NumericError)
            };
        }

        outInfo.BaseTenExponent = outInfoNormalised.BaseTenExponent;
        outInfo.Value = outInfoNormalised.Value;
        //Normalised means no prefixes.
        outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage); 

        return outInfo;
    }

    static UnitInfo PerformManagedOperationValues(double firstValue, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            new UnitInfo(firstValue), new UnitInfo(secondValue), operation
        );
    }

    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            firstInfo, new UnitInfo(secondValue), operation
        );
    }

    //This method might be used to perform full operations (not just being the last calculation step) instead
    //of the default one (PerformManagedOperationUnits) for simple cases. That is: ones not dealing with the
    //complex numeric reality (Value, Prefix and BaseTenExponent) which makes a pre-analysis required.
    //Note that, unlikely what happens with PerformMangedOperationUnits, the outputs of this method aren't
    //normalised (= primarily stored under Value), what is useful in certain contexts.
    //NOTE: this function assumes that both inputs are normalised, what means that no prefix information is expected.
    //It might also be used with non-normalised inputs, but their prefix information would be plainly ignored.
    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        if (firstInfo.Value == 0.0 || secondInfo.Value == 0.0)
        {
            if (operation == Operations.Multiplication || operation == Operations.Division)
            {
                //Dividing by zero scenarios are taken into account somewhere else.
                return new UnitInfo(firstInfo) { Value = 0.0 };
            }
        }

        UnitInfo outInfo = new UnitInfo(firstInfo);
        UnitInfo firstInfo0 = new UnitInfo(firstInfo);
        UnitInfo secondInfo0 = new UnitInfo(secondInfo);

        boolean isWrong = false;
        try
        {
            if (operation == Operations.Addition)
            {
                outInfo.Value += secondInfo0.Value;
            }
            else if (operation == Operations.Subtraction)
            {
                outInfo.Value -= secondInfo.Value;
            }
            else
            {
                //The reason for checking whether BaseTenExponent is inside/outside the int range before performing 
                //the operation (rather than going ahead and eventually catching the resulting exception) isn't just
                //being quicker, but also the only option in many situations. Note that an addition/subtraction between
                //two int variables whose result is outside the int range might not trigger an exception (+ random 
                //negative value as output).
                if (VaryBaseTenExponent(outInfo, secondInfo0.BaseTenExponent, operation == Operations.Division).Error.Type != ErrorTypes.None)
                {
                    return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
                }

                if (operation == Operations.Multiplication)
                {
                    outInfo.Value *= secondInfo.Value;
                    outInfo.BaseTenExponent += secondInfo.BaseTenExponent;
                }
                else if (operation == Operations.Division)
                {
                    if (secondInfo.Value == 0.0)
                    {
                        return
                        (
                            new UnitInfo(outInfo) 
                            { 
                                Error = new ErrorInfo(ErrorTypes.NumericError) 
                            }
                        );
                    }
                    outInfo.Value /= secondInfo.Value;
                    outInfo.BaseTenExponent -= secondInfo.BaseTenExponent;
                }
            }
        }
        catch { isWrong = true; }

        return
        (
            //An error might not be triggered despite of dealing with numbers outside double precision.
            //For example: 0.00000000000000000001m * 0.0000000000000000000001m can output 0.0 without triggering an error. 
            isWrong || ((operation == Operations.Multiplication || operation == Operations.Division) && outInfo.Value == 0.0.0) ?
            OperationValuesManageError(firstInfo0, secondInfo0, operation) : outInfo
        );
    }

    static UnitInfo OperationValuesManageError(UnitInfo outInfo, UnitInfo secondInfo, Operations operation)
    {
        if (operation != Operations.Multiplication && operation != Operations.Division)
        {
            //This condition should never be true on account of the fact that the pre-modifications performed before
            //adding/subtracting should avoid erroneous situations.
            return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
        }

        UnitInfo secondInfo2 = ConvertValueToBaseTen(secondInfo.Value);
        outInfo = VaryBaseTenExponent(outInfo, secondInfo2.BaseTenExponent, operation == Operations.Division);
        if (Math.Abs(secondInfo2.Value) == 1.0 || outInfo.Error.Type != ErrorTypes.None) return outInfo;
        
        try
        {
            outInfo = PerformManagedOperationUnits
            (
                outInfo, secondInfo2.Value, operation
            );
        }
        catch
        {
            //Very unlikely scenario on account of the fact that Math.Abs(secondInfo2.Value)
            //lies within the 0.1-10.0 range.
            outInfo = OperationValuesManageError
            (
                new UnitInfo(outInfo)
                {
                    Value = secondInfo2.Value,
                    BaseTenExponent = 0
                },
                new UnitInfo()
                {
                    Value = outInfo.Value,
                    BaseTenExponent = outInfo.BaseTenExponent
                },
                operation
            );
        }

        return outInfo;
    }

    static UnitInfo ConvertValueToBaseTen(double value)
    {
        value = Math.Abs(value);
        return FromValueToBaseTenExponent
        (
             new UnitInfo(value), Math.Abs(value), false
        );
    }

    static UnitInfo ConvertBaseTenToValue(UnitInfo unitInfo)
    {
        if (unitInfo.BaseTenExponent == 0) return unitInfo;

        UnitInfo outInfo = new UnitInfo(unitInfo);
        boolean decrease = unitInfo.BaseTenExponent > 0;
        int sign = Math.Sign(outInfo.Value);
        double absValue = Math.Abs(outInfo.Value);

        while (outInfo.BaseTenExponent != 0.0)
        {
            if (decrease)
            {
                if (absValue >= MaxValueDec / 10.0) break;
                absValue *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }
            else
            {
                if (absValue <= MinValueDec * 10.0) break;
                absValue /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
        }

        outInfo.Value = sign * absValue;

        return outInfo;
    }

    static UnitInfo NormaliseUnitInfo(UnitInfo unitInfo)
    {
        if (unitInfo.Value == 0 && unitInfo.Prefix.Factor == 1.0)
        {
            return unitInfo;
        }
        UnitInfo outInfo = new UnitInfo(unitInfo);

        if (outInfo.Prefix.Factor != 1)
        {
            outInfo = FromValueToBaseTenExponent
            (
                outInfo, outInfo.Prefix.Factor, true
            );
            outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage);
        }
        if (outInfo.Value == 0.0) return outInfo;

        outInfo = FromValueToBaseTenExponent
        (
            outInfo, outInfo.Value, false
        );

        return outInfo;
    }

    static UnitInfo FromValueToBaseTenExponent(UnitInfo outInfo, double value, boolean isPrefix)
    {
        if (value == 0.0) return outInfo;

        double valueAbs = Math.Abs(value);
        boolean decrease = (valueAbs > 1.0);
        if (!isPrefix)
        {
            outInfo.Value = outInfo.Value / valueAbs;
        }

        while (valueAbs != 1.0)
        {
            if ((valueAbs < 10.0 && valueAbs > 1.0) || (valueAbs > 0.1.0 && valueAbs < 1.0))
            {
                if (!isPrefix) outInfo.Value = value;
                else
                {
                    outInfo = PerformManagedOperationValues
                    (
                        outInfo, value, Operations.Multiplication
                    );
                }

                return outInfo;
            }

            if (decrease)
            {
                value /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
            else
            {
                value *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }

            valueAbs = Math.Abs(value);
        }

        return outInfo;
    }

    //Method used to vary BaseTenExponent without provoking unhandled exceptions (i.e., bigger than Integer.MAX_VALUE).
    static UnitInfo VaryBaseTenExponent(UnitInfo info, int baseTenIncrease, boolean isDivision = false)
    {
        long val1 = info.BaseTenExponent;
        long val2 = baseTenIncrease;

        if (isDivision)
        {
            //Converting a negative value into positive might provoke an overflow error for the int type
            //(e.g., Math.Abs(Integer.MAIN_VALUE)). Converting both variables to long is a quick and effective
            //way to avoid this problem.
            val2 *= -1;
        }

        return
        (
             ((val2 > 0 && val1 > Integer.MAX_VALUE - val2) || (val2 < 0 && val1 < Integer.MAIN_VALUE - val2)) ?
            new UnitInfo(info, ErrorTypes.NumericError) : new UnitInfo(info){{ BaseTenExponent = (int)(val1 + val2); }}
        );
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2017-05-27 20:04:45.240
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2017-05-27 20:04:45.241
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2017-05-27 20:04:45.326
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
public class OperationsManaged
{
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, double second, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            firstInfo, new UnitInfo(second), operation
        );
    }

    public static UnitInfo PerformManagedOperationUnits(double first, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            new UnitInfo(first), secondInfo, operation
        );
    }

    //This method should always be used when dealing with random UnitInfo variables because it accounts for all the
    //possible scenarios. On the other hand, with simple operations (e.g., random UnitInfo & numeric type) it might
    //be better to use PerformManagedOperationValues. 
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        ErrorTypes errorType = InternalMethods.GetOperationError
        (
            firstInfo, secondInfo, operation
        );
        if (errorType != ErrorTypes.None)
        {
            return new UnitInfo(firstInfo) 
            {{
                Error = new ErrorInfo(errorType); 
            }};
        }

        return
        (
            operation == Operations.Addition || operation == Operations.Subtraction ?
            PerformManagedOperationAddition(firstInfo, secondInfo, operation) :
            PerformManagedOperationMultiplication(firstInfo, secondInfo, operation)
        );
    }

    static UnitInfo PerformManagedOperationAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {   
        //After being normalised, the operands might require further modifications.
        UnitInfo[] normalised = GetOperandsAddition(firstInfo, secondInfo, operation);

        return PerformManagedOperationNormalisedValues
        (
            firstInfo, normalised, operation
        );
    }

    static UnitInfo[] GetOperandsAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        UnitInfo[] operands2 = new UnitInfo[] 
        {
            new UnitInfo(firstInfo), new UnitInfo(secondInfo)
        };

        if (operands2[0].BaseTenExponent != operands2[1].BaseTenExponent || operands2[0].Prefix.Factor != operands2[1].Prefix.Factor)
        {
            //The addition/subtraction might not be performed right away even with normalised values.
            //For example: 5 and 6 from 5*10^2 and 6*10^7 cannot be added right away.
            operands2 = AdaptNormalisedValuesForAddition
            (
                new UnitInfo[] 
                { 
                    NormaliseUnitInfo(operands2[0]), 
                    NormaliseUnitInfo(operands2[1])
                },
                operation
            );
        }

        return operands2;
    }
    
    static UnitInfo[] AdaptNormalisedValuesForAddition(UnitInfo[] unitInfos2, Operations operation)
    {
        if (unitInfos2[0].BaseTenExponent == unitInfos2[1].BaseTenExponent)
        {
            //Having the same BaseTenExponent values means that the given operation can be performed right away.
            return unitInfos2;
        }

        int[] bigSmallI = 
        (
            unitInfos2[0].BaseTenExponent > unitInfos2[1].BaseTenExponent ?
            new int[] { 0, 1 } : new int[] { 1, 0 }
        );

        //Only the variable with the bigger value is modified. For example: 5*10^5 & 3*10^3 is converted
        //into 500*10^3 & 3*10^3 in order to allow the addition 500 + 3. 
        UnitInfo big2 = AdaptBiggerAdditionOperand(unitInfos2, bigSmallI, operation);
        if (big2.Error.Type != ErrorTypes.None)
        {
            return TooBigGapAddition(unitInfos2, bigSmallI, operation);
        }

        unitInfos2[bigSmallI[0]].Value = big2.Value;
        unitInfos2[bigSmallI[0]].BaseTenExponent = unitInfos2[bigSmallI[1]].BaseTenExponent;

        return unitInfos2;
    }

    //When adding/subtracting two numbers whose gap is bigger than the maximum double range, there
    //is no need to perform any operation (i.e., no change will be observed because of being outside
    //the maximum supported precision). This method takes care of these cases and returns the expected
    //output (i.e., biggest value).
    static UnitInfo[] TooBigGapAddition(UnitInfo[] unitInfos2, int[] bigSmallI, Operations operation)
    {
        UnitInfo[] outInfos = new UnitInfo[] 
        {
            //First operand (i.e., one whose information defines the operation) together with the
            //numeric information (i.e., just Value and BaseTenExponent because both are normalised)
            //which is associated with the biggest one.
            new UnitInfo(unitInfos2[0])
            {{
                Value = unitInfos2[bigSmallI[0]].Value;
                BaseTenExponent = unitInfos2[bigSmallI[0]].BaseTenExponent;
            }}
        };

        if (operation == Operations.Subtraction && bigSmallI[0] == 1)
        {
            outInfos[0].Value = -1.0 * outInfos[0].Value;
        }

        if (outInfos[0].Unit == Units.Unitless)
        {
            outInfos[0].Unit = unitInfos2[bigSmallI[1]].Unit;
        }

        return outInfos;
    }

    static UnitInfo AdaptBiggerAdditionOperand(UnitInfo[] unitInfos2, Integer[] bigSmallI, Operations operation)
    {
        int gapExponent = unitInfos2[bigSmallI[0]].BaseTenExponent - unitInfos2[bigSmallI[1]].BaseTenExponent;
        if (gapExponent >= 27)
        {
            //The difference between both inputs is bigger than (or, at least, very close to) the maximum double value/precision;
            //what makes this situation calculation unworthy and the first operand to be returned as the result.
            //Note that the error below these lines is just an easy way to tell the calling function about this eventuality.
            return new UnitInfo(unitInfos2[0]) 
            {{ 
                Error = new ErrorInfo(ErrorTypes.InvalidOperation); 
            }};
        }

        //PerformManagedOperationValues is used to make sure that the resulting numeric information is stored
        //in Value (if possible).
        UnitInfo big2 = PerformManagedOperationValues
        (
            RaiseToIntegerExponent(10.0, gapExponent), unitInfos2[bigSmallI[0]].Value, 
            Operations.Multiplication                
        );

        boolean isWrong = 
        (
            big2.Error.Type != ErrorTypes.None || big2.BaseTenExponent != 0 ?
            
            //The value of the bigger input times 10^(gap between BaseTenExponent of inputs) is too big. 
            isWrong = true :
            
            //Overflow-check very unlikely to trigger an error. In fact, with properly normalised variables,
            //triggering an error would be plainly impossible.               
            AreAdditionFinalValuesWrong
            (
                unitInfos2[0].Value, unitInfos2[1].Value, operation
            )
        );

        if (isWrong)
        {
        	UnitInfo temp = new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }}
        }
        
        return
        (
            isWrong ?
            //This error is just an easy way to let the calling function know about the fact that no
            //calculation has been performed (too big gap). This isn't a properly-speaking error and
            //that's why it will not be notified to the user.
            new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }} :
            //Returning the new big value. For example: with 5*10^4 & 3*10^2, 500 would be returned.
            new UnitInfo(unitInfos2[bigSmallI[0]])
            {{
                Value = big2.Value;
            }}
        )
    }

    static boolean AreAdditionFinalValuesWrong(double val1, double val2, Operations operation)
    {
        boolean isWrong = false;

        try
        {
            val1 = val1 + val2 *
            (
                operation == Operations.Addition ? 1 : -1
            );
        }
        catch { isWrong = true; }

        return isWrong;
    }

    static UnitInfo PerformManagedOperationMultiplication(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationNormalisedValues
        (
            firstInfo, new UnitInfo[] 
            { 
                NormaliseUnitInfo(firstInfo),
                NormaliseUnitInfo(secondInfo) 
            },
            operation
        );
    }

    public static UnitInfo RaiseToIntegerExponent(double baseValue, int exponent)
    {
        return RaiseToIntegerExponent(new UnitInfo(baseValue), exponent);
    }

    static UnitInfo RaiseToIntegerExponent(UnitInfo baseInfo, int exponent)
    {
        if (exponent <= 1 && exponent >= 0)
        {
            baseInfo.Value = (exponent == 0 ? 1.0 : baseInfo.Value);
            return baseInfo;
        }

        UnitInfo outInfo = new UnitInfo(baseInfo);

        for (int i = 1; i < Math.Abs(exponent); i++)
        {
            outInfo = PerformManagedOperationValues
            (
                outInfo, baseInfo, Operations.Multiplication
            );
            if (outInfo.Error.Type != ErrorTypes.None) return outInfo;
        }

        return
        (
            exponent < 0 ?
            PerformManagedOperationValues(new UnitInfo(1.0), outInfo, Operations.Division) :
            outInfo
        );
    }

    static UnitInfo PerformManagedOperationNormalisedValues(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        outInfo =
        (
            normalisedInfos.Length == 1 ?
            //There is just one operand when the difference between both of them is too big.
            outInfo = normalisedInfos[0] :
            PerformManagedOperationTwoOperands(outInfo, normalisedInfos, operation)
        );

        return outInfo;
    }

    static UnitInfo PerformManagedOperationTwoOperands(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        UnitInfo outInfoNormalised = PerformManagedOperationValues
        (
            normalisedInfos[0], normalisedInfos[1], operation
        );

        if (outInfo.Error.Type != ErrorTypes.None)
        {
            return new UnitInfo(outInfo)
            {
                Error = new ErrorInfo(ErrorTypes.NumericError)
            };
        }

        outInfo.BaseTenExponent = outInfoNormalised.BaseTenExponent;
        outInfo.Value = outInfoNormalised.Value;
        //Normalised means no prefixes.
        outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage); 

        return outInfo;
    }

    static UnitInfo PerformManagedOperationValues(double firstValue, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            new UnitInfo(firstValue), new UnitInfo(secondValue), operation
        );
    }

    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            firstInfo, new UnitInfo(secondValue), operation
        );
    }

    //This method might be used to perform full operations (not just being the last calculation step) instead
    //of the default one (PerformManagedOperationUnits) for simple cases. That is: ones not dealing with the
    //complex numeric reality (Value, Prefix and BaseTenExponent) which makes a pre-analysis required.
    //Note that, unlikely what happens with PerformMangedOperationUnits, the outputs of this method aren't
    //normalised (= primarily stored under Value), what is useful in certain contexts.
    //NOTE: this function assumes that both inputs are normalised, what means that no prefix information is expected.
    //It might also be used with non-normalised inputs, but their prefix information would be plainly ignored.
    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        if (firstInfo.Value == 0.0 || secondInfo.Value == 0.0)
        {
            if (operation == Operations.Multiplication || operation == Operations.Division)
            {
                //Dividing by zero scenarios are taken into account somewhere else.
                return new UnitInfo(firstInfo) { Value = 0.0 };
            }
        }

        UnitInfo outInfo = new UnitInfo(firstInfo);
        UnitInfo firstInfo0 = new UnitInfo(firstInfo);
        UnitInfo secondInfo0 = new UnitInfo(secondInfo);

        boolean isWrong = false;
        try
        {
            if (operation == Operations.Addition)
            {
                outInfo.Value += secondInfo0.Value;
            }
            else if (operation == Operations.Subtraction)
            {
                outInfo.Value -= secondInfo.Value;
            }
            else
            {
                //The reason for checking whether BaseTenExponent is inside/outside the int range before performing 
                //the operation (rather than going ahead and eventually catching the resulting exception) isn't just
                //being quicker, but also the only option in many situations. Note that an addition/subtraction between
                //two int variables whose result is outside the int range might not trigger an exception (+ random 
                //negative value as output).
                if (VaryBaseTenExponent(outInfo, secondInfo0.BaseTenExponent, operation == Operations.Division).Error.Type != ErrorTypes.None)
                {
                    return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
                }

                if (operation == Operations.Multiplication)
                {
                    outInfo.Value *= secondInfo.Value;
                    outInfo.BaseTenExponent += secondInfo.BaseTenExponent;
                }
                else if (operation == Operations.Division)
                {
                    if (secondInfo.Value == 0.0)
                    {
                        return
                        (
                            new UnitInfo(outInfo) 
                            { 
                                Error = new ErrorInfo(ErrorTypes.NumericError) 
                            }
                        );
                    }
                    outInfo.Value /= secondInfo.Value;
                    outInfo.BaseTenExponent -= secondInfo.BaseTenExponent;
                }
            }
        }
        catch { isWrong = true; }

        return
        (
            //An error might not be triggered despite of dealing with numbers outside double precision.
            //For example: 0.00000000000000000001m * 0.0000000000000000000001m can output 0.0 without triggering an error. 
            isWrong || ((operation == Operations.Multiplication || operation == Operations.Division) && outInfo.Value == 0.0.0) ?
            OperationValuesManageError(firstInfo0, secondInfo0, operation) : outInfo
        );
    }

    static UnitInfo OperationValuesManageError(UnitInfo outInfo, UnitInfo secondInfo, Operations operation)
    {
        if (operation != Operations.Multiplication && operation != Operations.Division)
        {
            //This condition should never be true on account of the fact that the pre-modifications performed before
            //adding/subtracting should avoid erroneous situations.
            return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
        }

        UnitInfo secondInfo2 = ConvertValueToBaseTen(secondInfo.Value);
        outInfo = VaryBaseTenExponent(outInfo, secondInfo2.BaseTenExponent, operation == Operations.Division);
        if (Math.Abs(secondInfo2.Value) == 1.0 || outInfo.Error.Type != ErrorTypes.None) return outInfo;
        
        try
        {
            outInfo = PerformManagedOperationUnits
            (
                outInfo, secondInfo2.Value, operation
            );
        }
        catch
        {
            //Very unlikely scenario on account of the fact that Math.Abs(secondInfo2.Value)
            //lies within the 0.1-10.0 range.
            outInfo = OperationValuesManageError
            (
                new UnitInfo(outInfo)
                {
                    Value = secondInfo2.Value,
                    BaseTenExponent = 0
                },
                new UnitInfo()
                {
                    Value = outInfo.Value,
                    BaseTenExponent = outInfo.BaseTenExponent
                },
                operation
            );
        }

        return outInfo;
    }

    static UnitInfo ConvertValueToBaseTen(double value)
    {
        value = Math.Abs(value);
        return FromValueToBaseTenExponent
        (
             new UnitInfo(value), Math.Abs(value), false
        );
    }

    static UnitInfo ConvertBaseTenToValue(UnitInfo unitInfo)
    {
        if (unitInfo.BaseTenExponent == 0) return unitInfo;

        UnitInfo outInfo = new UnitInfo(unitInfo);
        boolean decrease = unitInfo.BaseTenExponent > 0;
        int sign = Math.Sign(outInfo.Value);
        double absValue = Math.Abs(outInfo.Value);

        while (outInfo.BaseTenExponent != 0.0)
        {
            if (decrease)
            {
                if (absValue >= MaxValueDec / 10.0) break;
                absValue *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }
            else
            {
                if (absValue <= MinValueDec * 10.0) break;
                absValue /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
        }

        outInfo.Value = sign * absValue;

        return outInfo;
    }

    static UnitInfo NormaliseUnitInfo(UnitInfo unitInfo)
    {
        if (unitInfo.Value == 0 && unitInfo.Prefix.Factor == 1.0)
        {
            return unitInfo;
        }
        UnitInfo outInfo = new UnitInfo(unitInfo);

        if (outInfo.Prefix.Factor != 1)
        {
            outInfo = FromValueToBaseTenExponent
            (
                outInfo, outInfo.Prefix.Factor, true
            );
            outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage);
        }
        if (outInfo.Value == 0.0) return outInfo;

        outInfo = FromValueToBaseTenExponent
        (
            outInfo, outInfo.Value, false
        );

        return outInfo;
    }

    static UnitInfo FromValueToBaseTenExponent(UnitInfo outInfo, double value, boolean isPrefix)
    {
        if (value == 0.0) return outInfo;

        double valueAbs = Math.Abs(value);
        boolean decrease = (valueAbs > 1.0);
        if (!isPrefix)
        {
            outInfo.Value = outInfo.Value / valueAbs;
        }

        while (valueAbs != 1.0)
        {
            if ((valueAbs < 10.0 && valueAbs > 1.0) || (valueAbs > 0.1.0 && valueAbs < 1.0))
            {
                if (!isPrefix) outInfo.Value = value;
                else
                {
                    outInfo = PerformManagedOperationValues
                    (
                        outInfo, value, Operations.Multiplication
                    );
                }

                return outInfo;
            }

            if (decrease)
            {
                value /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
            else
            {
                value *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }

            valueAbs = Math.Abs(value);
        }

        return outInfo;
    }

    //Method used to vary BaseTenExponent without provoking unhandled exceptions (i.e., bigger than Integer.MAX_VALUE).
    static UnitInfo VaryBaseTenExponent(UnitInfo info, int baseTenIncrease, boolean isDivision = false)
    {
        long val1 = info.BaseTenExponent;
        long val2 = baseTenIncrease;

        if (isDivision)
        {
            //Converting a negative value into positive might provoke an overflow error for the int type
            //(e.g., Math.Abs(Integer.MAIN_VALUE)). Converting both variables to long is a quick and effective
            //way to avoid this problem.
            val2 *= -1;
        }

        return
        (
             ((val2 > 0 && val1 > Integer.MAX_VALUE - val2) || (val2 < 0 && val1 < Integer.MAIN_VALUE - val2)) ?
            new UnitInfo(info, ErrorTypes.NumericError) : new UnitInfo(info){{ BaseTenExponent = (int)(val1 + val2); }}
        );
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 2 2017-05-27 20:04:45.327
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 0 2017-05-27 20:04:45.327
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.core 4 4 2017-05-27 20:04:46.277
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
public class OperationsManaged
{
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, double second, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            firstInfo, new UnitInfo(second), operation
        );
    }

    public static UnitInfo PerformManagedOperationUnits(double first, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            new UnitInfo(first), secondInfo, operation
        );
    }

    //This method should always be used when dealing with random UnitInfo variables because it accounts for all the
    //possible scenarios. On the other hand, with simple operations (e.g., random UnitInfo & numeric type) it might
    //be better to use PerformManagedOperationValues. 
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        ErrorTypes errorType = InternalMethods.GetOperationError
        (
            firstInfo, secondInfo, operation
        );
        if (errorType != ErrorTypes.None)
        {
            return new UnitInfo(firstInfo) 
            {{
                Error = new ErrorInfo(errorType); 
            }};
        }

        return
        (
            operation == Operations.Addition || operation == Operations.Subtraction ?
            PerformManagedOperationAddition(firstInfo, secondInfo, operation) :
            PerformManagedOperationMultiplication(firstInfo, secondInfo, operation)
        );
    }

    static UnitInfo PerformManagedOperationAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {   
        //After being normalised, the operands might require further modifications.
        UnitInfo[] normalised = GetOperandsAddition(firstInfo, secondInfo, operation);

        return PerformManagedOperationNormalisedValues
        (
            firstInfo, normalised, operation
        );
    }

    static UnitInfo[] GetOperandsAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        UnitInfo[] operands2 = new UnitInfo[] 
        {
            new UnitInfo(firstInfo), new UnitInfo(secondInfo)
        };

        if (operands2[0].BaseTenExponent != operands2[1].BaseTenExponent || operands2[0].Prefix.Factor != operands2[1].Prefix.Factor)
        {
            //The addition/subtraction might not be performed right away even with normalised values.
            //For example: 5 and 6 from 5*10^2 and 6*10^7 cannot be added right away.
            operands2 = AdaptNormalisedValuesForAddition
            (
                new UnitInfo[] 
                { 
                    NormaliseUnitInfo(operands2[0]), 
                    NormaliseUnitInfo(operands2[1])
                },
                operation
            );
        }

        return operands2;
    }
    
    static UnitInfo[] AdaptNormalisedValuesForAddition(UnitInfo[] unitInfos2, Operations operation)
    {
        if (unitInfos2[0].BaseTenExponent == unitInfos2[1].BaseTenExponent)
        {
            //Having the same BaseTenExponent values means that the given operation can be performed right away.
            return unitInfos2;
        }

        int[] bigSmallI = 
        (
            unitInfos2[0].BaseTenExponent > unitInfos2[1].BaseTenExponent ?
            new int[] { 0, 1 } : new int[] { 1, 0 }
        );

        //Only the variable with the bigger value is modified. For example: 5*10^5 & 3*10^3 is converted
        //into 500*10^3 & 3*10^3 in order to allow the addition 500 + 3. 
        UnitInfo big2 = AdaptBiggerAdditionOperand(unitInfos2, bigSmallI, operation);
        if (big2.Error.Type != ErrorTypes.None)
        {
            return TooBigGapAddition(unitInfos2, bigSmallI, operation);
        }

        unitInfos2[bigSmallI[0]].Value = big2.Value;
        unitInfos2[bigSmallI[0]].BaseTenExponent = unitInfos2[bigSmallI[1]].BaseTenExponent;

        return unitInfos2;
    }

    //When adding/subtracting two numbers whose gap is bigger than the maximum double range, there
    //is no need to perform any operation (i.e., no change will be observed because of being outside
    //the maximum supported precision). This method takes care of these cases and returns the expected
    //output (i.e., biggest value).
    static UnitInfo[] TooBigGapAddition(UnitInfo[] unitInfos2, int[] bigSmallI, Operations operation)
    {
        UnitInfo[] outInfos = new UnitInfo[] 
        {
            //First operand (i.e., one whose information defines the operation) together with the
            //numeric information (i.e., just Value and BaseTenExponent because both are normalised)
            //which is associated with the biggest one.
            new UnitInfo(unitInfos2[0])
            {{
                Value = unitInfos2[bigSmallI[0]].Value;
                BaseTenExponent = unitInfos2[bigSmallI[0]].BaseTenExponent;
            }}
        };

        if (operation == Operations.Subtraction && bigSmallI[0] == 1)
        {
            outInfos[0].Value = -1.0 * outInfos[0].Value;
        }

        if (outInfos[0].Unit == Units.Unitless)
        {
            outInfos[0].Unit = unitInfos2[bigSmallI[1]].Unit;
        }

        return outInfos;
    }

    static UnitInfo AdaptBiggerAdditionOperand(UnitInfo[] unitInfos2, Integer[] bigSmallI, Operations operation)
    {
        int gapExponent = unitInfos2[bigSmallI[0]].BaseTenExponent - unitInfos2[bigSmallI[1]].BaseTenExponent;
        if (gapExponent >= 27)
        {
            //The difference between both inputs is bigger than (or, at least, very close to) the maximum double value/precision;
            //what makes this situation calculation unworthy and the first operand to be returned as the result.
            //Note that the error below these lines is just an easy way to tell the calling function about this eventuality.
            return new UnitInfo(unitInfos2[0]) 
            {{ 
                Error = new ErrorInfo(ErrorTypes.InvalidOperation); 
            }};
        }

        //PerformManagedOperationValues is used to make sure that the resulting numeric information is stored
        //in Value (if possible).
        UnitInfo big2 = PerformManagedOperationValues
        (
            RaiseToIntegerExponent(10.0, gapExponent), unitInfos2[bigSmallI[0]].Value, 
            Operations.Multiplication                
        );

        boolean isWrong = 
        (
            big2.Error.Type != ErrorTypes.None || big2.BaseTenExponent != 0 ?
            
            //The value of the bigger input times 10^(gap between BaseTenExponent of inputs) is too big. 
            isWrong = true :
            
            //Overflow-check very unlikely to trigger an error. In fact, with properly normalised variables,
            //triggering an error would be plainly impossible.               
            AreAdditionFinalValuesWrong
            (
                unitInfos2[0].Value, unitInfos2[1].Value, operation
            )
        );

        if (isWrong)
        {
        	UnitInfo temp = new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }}
        }
        
        return
        (
            isWrong ?
            //This error is just an easy way to let the calling function know about the fact that no
            //calculation has been performed (too big gap). This isn't a properly-speaking error and
            //that's why it will not be notified to the user.
            new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }} :
            //Returning the new big value. For example: with 5*10^4 & 3*10^2, 500 would be returned.
            new UnitInfo(unitInfos2[bigSmallI[0]])
            {{
                Value = big2.Value;
            }}
        )
    }

    static boolean AreAdditionFinalValuesWrong(double val1, double val2, Operations operation)
    {
        boolean isWrong = false;

        try
        {
            val1 = val1 + val2 *
            (
                operation == Operations.Addition ? 1 : -1
            );
        }
        catch { isWrong = true; }

        return isWrong;
    }

    static UnitInfo PerformManagedOperationMultiplication(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationNormalisedValues
        (
            firstInfo, new UnitInfo[] 
            { 
                NormaliseUnitInfo(firstInfo),
                NormaliseUnitInfo(secondInfo) 
            },
            operation
        );
    }

    public static UnitInfo RaiseToIntegerExponent(double baseValue, int exponent)
    {
        return RaiseToIntegerExponent(new UnitInfo(baseValue), exponent);
    }

    static UnitInfo RaiseToIntegerExponent(UnitInfo baseInfo, int exponent)
    {
        if (exponent <= 1 && exponent >= 0)
        {
            baseInfo.Value = (exponent == 0 ? 1.0 : baseInfo.Value);
            return baseInfo;
        }

        UnitInfo outInfo = new UnitInfo(baseInfo);

        for (int i = 1; i < Math.Abs(exponent); i++)
        {
            outInfo = PerformManagedOperationValues
            (
                outInfo, baseInfo, Operations.Multiplication
            );
            if (outInfo.Error.Type != ErrorTypes.None) return outInfo;
        }

        return
        (
            exponent < 0 ?
            PerformManagedOperationValues(new UnitInfo(1.0), outInfo, Operations.Division) :
            outInfo
        );
    }

    static UnitInfo PerformManagedOperationNormalisedValues(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        outInfo =
        (
            normalisedInfos.Length == 1 ?
            //There is just one operand when the difference between both of them is too big.
            outInfo = normalisedInfos[0] :
            PerformManagedOperationTwoOperands(outInfo, normalisedInfos, operation)
        );

        return outInfo;
    }

    static UnitInfo PerformManagedOperationTwoOperands(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        UnitInfo outInfoNormalised = PerformManagedOperationValues
        (
            normalisedInfos[0], normalisedInfos[1], operation
        );

        if (outInfo.Error.Type != ErrorTypes.None)
        {
            return new UnitInfo(outInfo)
            {
                Error = new ErrorInfo(ErrorTypes.NumericError)
            };
        }

        outInfo.BaseTenExponent = outInfoNormalised.BaseTenExponent;
        outInfo.Value = outInfoNormalised.Value;
        //Normalised means no prefixes.
        outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage); 

        return outInfo;
    }

    static UnitInfo PerformManagedOperationValues(double firstValue, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            new UnitInfo(firstValue), new UnitInfo(secondValue), operation
        );
    }

    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            firstInfo, new UnitInfo(secondValue), operation
        );
    }

    //This method might be used to perform full operations (not just being the last calculation step) instead
    //of the default one (PerformManagedOperationUnits) for simple cases. That is: ones not dealing with the
    //complex numeric reality (Value, Prefix and BaseTenExponent) which makes a pre-analysis required.
    //Note that, unlikely what happens with PerformMangedOperationUnits, the outputs of this method aren't
    //normalised (= primarily stored under Value), what is useful in certain contexts.
    //NOTE: this function assumes that both inputs are normalised, what means that no prefix information is expected.
    //It might also be used with non-normalised inputs, but their prefix information would be plainly ignored.
    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        if (firstInfo.Value == 0.0 || secondInfo.Value == 0.0)
        {
            if (operation == Operations.Multiplication || operation == Operations.Division)
            {
                //Dividing by zero scenarios are taken into account somewhere else.
                return new UnitInfo(firstInfo) { Value = 0.0 };
            }
        }

        UnitInfo outInfo = new UnitInfo(firstInfo);
        UnitInfo firstInfo0 = new UnitInfo(firstInfo);
        UnitInfo secondInfo0 = new UnitInfo(secondInfo);

        boolean isWrong = false;
        try
        {
            if (operation == Operations.Addition)
            {
                outInfo.Value += secondInfo0.Value;
            }
            else if (operation == Operations.Subtraction)
            {
                outInfo.Value -= secondInfo.Value;
            }
            else
            {
                //The reason for checking whether BaseTenExponent is inside/outside the int range before performing 
                //the operation (rather than going ahead and eventually catching the resulting exception) isn't just
                //being quicker, but also the only option in many situations. Note that an addition/subtraction between
                //two int variables whose result is outside the int range might not trigger an exception (+ random 
                //negative value as output).
                if (VaryBaseTenExponent(outInfo, secondInfo0.BaseTenExponent, operation == Operations.Division).Error.Type != ErrorTypes.None)
                {
                    return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
                }

                if (operation == Operations.Multiplication)
                {
                    outInfo.Value *= secondInfo.Value;
                    outInfo.BaseTenExponent += secondInfo.BaseTenExponent;
                }
                else if (operation == Operations.Division)
                {
                    if (secondInfo.Value == 0.0)
                    {
                        return
                        (
                            new UnitInfo(outInfo) 
                            { 
                                Error = new ErrorInfo(ErrorTypes.NumericError) 
                            }
                        );
                    }
                    outInfo.Value /= secondInfo.Value;
                    outInfo.BaseTenExponent -= secondInfo.BaseTenExponent;
                }
            }
        }
        catch { isWrong = true; }

        return
        (
            //An error might not be triggered despite of dealing with numbers outside double precision.
            //For example: 0.00000000000000000001m * 0.0000000000000000000001m can output 0.0 without triggering an error. 
            isWrong || ((operation == Operations.Multiplication || operation == Operations.Division) && outInfo.Value == 0.0.0) ?
            OperationValuesManageError(firstInfo0, secondInfo0, operation) : outInfo
        );
    }

    static UnitInfo OperationValuesManageError(UnitInfo outInfo, UnitInfo secondInfo, Operations operation)
    {
        if (operation != Operations.Multiplication && operation != Operations.Division)
        {
            //This condition should never be true on account of the fact that the pre-modifications performed before
            //adding/subtracting should avoid erroneous situations.
            return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
        }

        UnitInfo secondInfo2 = ConvertValueToBaseTen(secondInfo.Value);
        outInfo = VaryBaseTenExponent(outInfo, secondInfo2.BaseTenExponent, operation == Operations.Division);
        if (Math.Abs(secondInfo2.Value) == 1.0 || outInfo.Error.Type != ErrorTypes.None) return outInfo;
        
        try
        {
            outInfo = PerformManagedOperationUnits
            (
                outInfo, secondInfo2.Value, operation
            );
        }
        catch
        {
            //Very unlikely scenario on account of the fact that Math.Abs(secondInfo2.Value)
            //lies within the 0.1-10.0 range.
            outInfo = OperationValuesManageError
            (
                new UnitInfo(outInfo)
                {
                    Value = secondInfo2.Value,
                    BaseTenExponent = 0
                },
                new UnitInfo()
                {
                    Value = outInfo.Value,
                    BaseTenExponent = outInfo.BaseTenExponent
                },
                operation
            );
        }

        return outInfo;
    }

    static UnitInfo ConvertValueToBaseTen(double value)
    {
        value = Math.Abs(value);
        return FromValueToBaseTenExponent
        (
             new UnitInfo(value), Math.Abs(value), false
        );
    }

    static UnitInfo ConvertBaseTenToValue(UnitInfo unitInfo)
    {
        if (unitInfo.BaseTenExponent == 0) return unitInfo;

        UnitInfo outInfo = new UnitInfo(unitInfo);
        boolean decrease = unitInfo.BaseTenExponent > 0;
        int sign = Math.Sign(outInfo.Value);
        double absValue = Math.Abs(outInfo.Value);

        while (outInfo.BaseTenExponent != 0.0)
        {
            if (decrease)
            {
                if (absValue >= MaxValueDec / 10.0) break;
                absValue *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }
            else
            {
                if (absValue <= MinValueDec * 10.0) break;
                absValue /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
        }

        outInfo.Value = sign * absValue;

        return outInfo;
    }

    static UnitInfo NormaliseUnitInfo(UnitInfo unitInfo)
    {
        if (unitInfo.Value == 0 && unitInfo.Prefix.Factor == 1.0)
        {
            return unitInfo;
        }
        UnitInfo outInfo = new UnitInfo(unitInfo);

        if (outInfo.Prefix.Factor != 1)
        {
            outInfo = FromValueToBaseTenExponent
            (
                outInfo, outInfo.Prefix.Factor, true
            );
            outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage);
        }
        if (outInfo.Value == 0.0) return outInfo;

        outInfo = FromValueToBaseTenExponent
        (
            outInfo, outInfo.Value, false
        );

        return outInfo;
    }

    static UnitInfo FromValueToBaseTenExponent(UnitInfo outInfo, double value, boolean isPrefix)
    {
        if (value == 0.0) return outInfo;

        double valueAbs = Math.Abs(value);
        boolean decrease = (valueAbs > 1.0);
        if (!isPrefix)
        {
            outInfo.Value = outInfo.Value / valueAbs;
        }

        while (valueAbs != 1.0)
        {
            if ((valueAbs < 10.0 && valueAbs > 1.0) || (valueAbs > 0.1.0 && valueAbs < 1.0))
            {
                if (!isPrefix) outInfo.Value = value;
                else
                {
                    outInfo = PerformManagedOperationValues
                    (
                        outInfo, value, Operations.Multiplication
                    );
                }

                return outInfo;
            }

            if (decrease)
            {
                value /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
            else
            {
                value *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }

            valueAbs = Math.Abs(value);
        }

        return outInfo;
    }

    //Method used to vary BaseTenExponent without provoking unhandled exceptions (i.e., bigger than Integer.MAX_VALUE).
    static UnitInfo VaryBaseTenExponent(UnitInfo info, int baseTenIncrease, boolean isDivision = false)
    {
        long val1 = info.BaseTenExponent;
        long val2 = baseTenIncrease;

        if (isDivision)
        {
            //Converting a negative value into positive might provoke an overflow error for the int type
            //(e.g., Math.Abs(Integer.MAIN_VALUE)). Converting both variables to long is a quick and effective
            //way to avoid this problem.
            val2 *= -1;
        }

        return
        (
             ((val2 > 0 && val1 > Integer.MAX_VALUE - val2) || (val2 < 0 && val1 < Integer.MAIN_VALUE - val2)) ?
            new UnitInfo(info, ErrorTypes.NumericError) : new UnitInfo(info){{ BaseTenExponent = (int)(val1 + val2); }}
        );
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 2 2017-05-27 20:04:46.278
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 0 2017-05-27 20:04:46.278
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.core 4 4 2017-05-27 20:04:48.273
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
public class OperationsManaged
{
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, double second, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            firstInfo, new UnitInfo(second), operation
        );
    }

    public static UnitInfo PerformManagedOperationUnits(double first, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            new UnitInfo(first), secondInfo, operation
        );
    }

    //This method should always be used when dealing with random UnitInfo variables because it accounts for all the
    //possible scenarios. On the other hand, with simple operations (e.g., random UnitInfo & numeric type) it might
    //be better to use PerformManagedOperationValues. 
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        ErrorTypes errorType = InternalMethods.GetOperationError
        (
            firstInfo, secondInfo, operation
        );
        if (errorType != ErrorTypes.None)
        {
            return new UnitInfo(firstInfo) 
            {{
                Error = new ErrorInfo(errorType); 
            }};
        }

        return
        (
            operation == Operations.Addition || operation == Operations.Subtraction ?
            PerformManagedOperationAddition(firstInfo, secondInfo, operation) :
            PerformManagedOperationMultiplication(firstInfo, secondInfo, operation)
        );
    }

    static UnitInfo PerformManagedOperationAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {   
        //After being normalised, the operands might require further modifications.
        UnitInfo[] normalised = GetOperandsAddition(firstInfo, secondInfo, operation);

        return PerformManagedOperationNormalisedValues
        (
            firstInfo, normalised, operation
        );
    }

    static UnitInfo[] GetOperandsAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        UnitInfo[] operands2 = new UnitInfo[] 
        {
            new UnitInfo(firstInfo), new UnitInfo(secondInfo)
        };

        if (operands2[0].BaseTenExponent != operands2[1].BaseTenExponent || operands2[0].Prefix.Factor != operands2[1].Prefix.Factor)
        {
            //The addition/subtraction might not be performed right away even with normalised values.
            //For example: 5 and 6 from 5*10^2 and 6*10^7 cannot be added right away.
            operands2 = AdaptNormalisedValuesForAddition
            (
                new UnitInfo[] 
                { 
                    NormaliseUnitInfo(operands2[0]), 
                    NormaliseUnitInfo(operands2[1])
                },
                operation
            );
        }

        return operands2;
    }
    
    static UnitInfo[] AdaptNormalisedValuesForAddition(UnitInfo[] unitInfos2, Operations operation)
    {
        if (unitInfos2[0].BaseTenExponent == unitInfos2[1].BaseTenExponent)
        {
            //Having the same BaseTenExponent values means that the given operation can be performed right away.
            return unitInfos2;
        }

        int[] bigSmallI = 
        (
            unitInfos2[0].BaseTenExponent > unitInfos2[1].BaseTenExponent ?
            new int[] { 0, 1 } : new int[] { 1, 0 }
        );

        //Only the variable with the bigger value is modified. For example: 5*10^5 & 3*10^3 is converted
        //into 500*10^3 & 3*10^3 in order to allow the addition 500 + 3. 
        UnitInfo big2 = AdaptBiggerAdditionOperand(unitInfos2, bigSmallI, operation);
        if (big2.Error.Type != ErrorTypes.None)
        {
            return TooBigGapAddition(unitInfos2, bigSmallI, operation);
        }

        unitInfos2[bigSmallI[0]].Value = big2.Value;
        unitInfos2[bigSmallI[0]].BaseTenExponent = unitInfos2[bigSmallI[1]].BaseTenExponent;

        return unitInfos2;
    }

    //When adding/subtracting two numbers whose gap is bigger than the maximum double range, there
    //is no need to perform any operation (i.e., no change will be observed because of being outside
    //the maximum supported precision). This method takes care of these cases and returns the expected
    //output (i.e., biggest value).
    static UnitInfo[] TooBigGapAddition(UnitInfo[] unitInfos2, int[] bigSmallI, Operations operation)
    {
        UnitInfo[] outInfos = new UnitInfo[] 
        {
            //First operand (i.e., one whose information defines the operation) together with the
            //numeric information (i.e., just Value and BaseTenExponent because both are normalised)
            //which is associated with the biggest one.
            new UnitInfo(unitInfos2[0])
            {{
                Value = unitInfos2[bigSmallI[0]].Value;
                BaseTenExponent = unitInfos2[bigSmallI[0]].BaseTenExponent;
            }}
        };

        if (operation == Operations.Subtraction && bigSmallI[0] == 1)
        {
            outInfos[0].Value = -1.0 * outInfos[0].Value;
        }

        if (outInfos[0].Unit == Units.Unitless)
        {
            outInfos[0].Unit = unitInfos2[bigSmallI[1]].Unit;
        }

        return outInfos;
    }

    static UnitInfo AdaptBiggerAdditionOperand(UnitInfo[] unitInfos2, Integer[] bigSmallI, Operations operation)
    {
        int gapExponent = unitInfos2[bigSmallI[0]].BaseTenExponent - unitInfos2[bigSmallI[1]].BaseTenExponent;
        if (gapExponent >= 27)
        {
            //The difference between both inputs is bigger than (or, at least, very close to) the maximum double value/precision;
            //what makes this situation calculation unworthy and the first operand to be returned as the result.
            //Note that the error below these lines is just an easy way to tell the calling function about this eventuality.
            return new UnitInfo(unitInfos2[0]) 
            {{ 
                Error = new ErrorInfo(ErrorTypes.InvalidOperation); 
            }};
        }

        //PerformManagedOperationValues is used to make sure that the resulting numeric information is stored
        //in Value (if possible).
        UnitInfo big2 = PerformManagedOperationValues
        (
            RaiseToIntegerExponent(10.0, gapExponent), unitInfos2[bigSmallI[0]].Value, 
            Operations.Multiplication                
        );

        boolean isWrong = 
        (
            big2.Error.Type != ErrorTypes.None || big2.BaseTenExponent != 0 ?
            
            //The value of the bigger input times 10^(gap between BaseTenExponent of inputs) is too big. 
            isWrong = true :
            
            //Overflow-check very unlikely to trigger an error. In fact, with properly normalised variables,
            //triggering an error would be plainly impossible.               
            AreAdditionFinalValuesWrong
            (
                unitInfos2[0].Value, unitInfos2[1].Value, operation
            )
        );

        if (isWrong)
        {
        	UnitInfo temp = new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }};
            
        }
        
        return
        (
            isWrong ?
            //This error is just an easy way to let the calling function know about the fact that no
            //calculation has been performed (too big gap). This isn't a properly-speaking error and
            //that's why it will not be notified to the user.
            new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }} :
            //Returning the new big value. For example: with 5*10^4 & 3*10^2, 500 would be returned.
            new UnitInfo(unitInfos2[bigSmallI[0]])
            {{
                Value = big2.Value;
            }}
        )
    }

    static boolean AreAdditionFinalValuesWrong(double val1, double val2, Operations operation)
    {
        boolean isWrong = false;

        try
        {
            val1 = val1 + val2 *
            (
                operation == Operations.Addition ? 1 : -1
            );
        }
        catch { isWrong = true; }

        return isWrong;
    }

    static UnitInfo PerformManagedOperationMultiplication(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationNormalisedValues
        (
            firstInfo, new UnitInfo[] 
            { 
                NormaliseUnitInfo(firstInfo),
                NormaliseUnitInfo(secondInfo) 
            },
            operation
        );
    }

    public static UnitInfo RaiseToIntegerExponent(double baseValue, int exponent)
    {
        return RaiseToIntegerExponent(new UnitInfo(baseValue), exponent);
    }

    static UnitInfo RaiseToIntegerExponent(UnitInfo baseInfo, int exponent)
    {
        if (exponent <= 1 && exponent >= 0)
        {
            baseInfo.Value = (exponent == 0 ? 1.0 : baseInfo.Value);
            return baseInfo;
        }

        UnitInfo outInfo = new UnitInfo(baseInfo);

        for (int i = 1; i < Math.Abs(exponent); i++)
        {
            outInfo = PerformManagedOperationValues
            (
                outInfo, baseInfo, Operations.Multiplication
            );
            if (outInfo.Error.Type != ErrorTypes.None) return outInfo;
        }

        return
        (
            exponent < 0 ?
            PerformManagedOperationValues(new UnitInfo(1.0), outInfo, Operations.Division) :
            outInfo
        );
    }

    static UnitInfo PerformManagedOperationNormalisedValues(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        outInfo =
        (
            normalisedInfos.Length == 1 ?
            //There is just one operand when the difference between both of them is too big.
            outInfo = normalisedInfos[0] :
            PerformManagedOperationTwoOperands(outInfo, normalisedInfos, operation)
        );

        return outInfo;
    }

    static UnitInfo PerformManagedOperationTwoOperands(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        UnitInfo outInfoNormalised = PerformManagedOperationValues
        (
            normalisedInfos[0], normalisedInfos[1], operation
        );

        if (outInfo.Error.Type != ErrorTypes.None)
        {
            return new UnitInfo(outInfo)
            {
                Error = new ErrorInfo(ErrorTypes.NumericError)
            };
        }

        outInfo.BaseTenExponent = outInfoNormalised.BaseTenExponent;
        outInfo.Value = outInfoNormalised.Value;
        //Normalised means no prefixes.
        outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage); 

        return outInfo;
    }

    static UnitInfo PerformManagedOperationValues(double firstValue, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            new UnitInfo(firstValue), new UnitInfo(secondValue), operation
        );
    }

    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            firstInfo, new UnitInfo(secondValue), operation
        );
    }

    //This method might be used to perform full operations (not just being the last calculation step) instead
    //of the default one (PerformManagedOperationUnits) for simple cases. That is: ones not dealing with the
    //complex numeric reality (Value, Prefix and BaseTenExponent) which makes a pre-analysis required.
    //Note that, unlikely what happens with PerformMangedOperationUnits, the outputs of this method aren't
    //normalised (= primarily stored under Value), what is useful in certain contexts.
    //NOTE: this function assumes that both inputs are normalised, what means that no prefix information is expected.
    //It might also be used with non-normalised inputs, but their prefix information would be plainly ignored.
    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        if (firstInfo.Value == 0.0 || secondInfo.Value == 0.0)
        {
            if (operation == Operations.Multiplication || operation == Operations.Division)
            {
                //Dividing by zero scenarios are taken into account somewhere else.
                return new UnitInfo(firstInfo) { Value = 0.0 };
            }
        }

        UnitInfo outInfo = new UnitInfo(firstInfo);
        UnitInfo firstInfo0 = new UnitInfo(firstInfo);
        UnitInfo secondInfo0 = new UnitInfo(secondInfo);

        boolean isWrong = false;
        try
        {
            if (operation == Operations.Addition)
            {
                outInfo.Value += secondInfo0.Value;
            }
            else if (operation == Operations.Subtraction)
            {
                outInfo.Value -= secondInfo.Value;
            }
            else
            {
                //The reason for checking whether BaseTenExponent is inside/outside the int range before performing 
                //the operation (rather than going ahead and eventually catching the resulting exception) isn't just
                //being quicker, but also the only option in many situations. Note that an addition/subtraction between
                //two int variables whose result is outside the int range might not trigger an exception (+ random 
                //negative value as output).
                if (VaryBaseTenExponent(outInfo, secondInfo0.BaseTenExponent, operation == Operations.Division).Error.Type != ErrorTypes.None)
                {
                    return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
                }

                if (operation == Operations.Multiplication)
                {
                    outInfo.Value *= secondInfo.Value;
                    outInfo.BaseTenExponent += secondInfo.BaseTenExponent;
                }
                else if (operation == Operations.Division)
                {
                    if (secondInfo.Value == 0.0)
                    {
                        return
                        (
                            new UnitInfo(outInfo) 
                            { 
                                Error = new ErrorInfo(ErrorTypes.NumericError) 
                            }
                        );
                    }
                    outInfo.Value /= secondInfo.Value;
                    outInfo.BaseTenExponent -= secondInfo.BaseTenExponent;
                }
            }
        }
        catch { isWrong = true; }

        return
        (
            //An error might not be triggered despite of dealing with numbers outside double precision.
            //For example: 0.00000000000000000001m * 0.0000000000000000000001m can output 0.0 without triggering an error. 
            isWrong || ((operation == Operations.Multiplication || operation == Operations.Division) && outInfo.Value == 0.0.0) ?
            OperationValuesManageError(firstInfo0, secondInfo0, operation) : outInfo
        );
    }

    static UnitInfo OperationValuesManageError(UnitInfo outInfo, UnitInfo secondInfo, Operations operation)
    {
        if (operation != Operations.Multiplication && operation != Operations.Division)
        {
            //This condition should never be true on account of the fact that the pre-modifications performed before
            //adding/subtracting should avoid erroneous situations.
            return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
        }

        UnitInfo secondInfo2 = ConvertValueToBaseTen(secondInfo.Value);
        outInfo = VaryBaseTenExponent(outInfo, secondInfo2.BaseTenExponent, operation == Operations.Division);
        if (Math.Abs(secondInfo2.Value) == 1.0 || outInfo.Error.Type != ErrorTypes.None) return outInfo;
        
        try
        {
            outInfo = PerformManagedOperationUnits
            (
                outInfo, secondInfo2.Value, operation
            );
        }
        catch
        {
            //Very unlikely scenario on account of the fact that Math.Abs(secondInfo2.Value)
            //lies within the 0.1-10.0 range.
            outInfo = OperationValuesManageError
            (
                new UnitInfo(outInfo)
                {
                    Value = secondInfo2.Value,
                    BaseTenExponent = 0
                },
                new UnitInfo()
                {
                    Value = outInfo.Value,
                    BaseTenExponent = outInfo.BaseTenExponent
                },
                operation
            );
        }

        return outInfo;
    }

    static UnitInfo ConvertValueToBaseTen(double value)
    {
        value = Math.Abs(value);
        return FromValueToBaseTenExponent
        (
             new UnitInfo(value), Math.Abs(value), false
        );
    }

    static UnitInfo ConvertBaseTenToValue(UnitInfo unitInfo)
    {
        if (unitInfo.BaseTenExponent == 0) return unitInfo;

        UnitInfo outInfo = new UnitInfo(unitInfo);
        boolean decrease = unitInfo.BaseTenExponent > 0;
        int sign = Math.Sign(outInfo.Value);
        double absValue = Math.Abs(outInfo.Value);

        while (outInfo.BaseTenExponent != 0.0)
        {
            if (decrease)
            {
                if (absValue >= MaxValueDec / 10.0) break;
                absValue *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }
            else
            {
                if (absValue <= MinValueDec * 10.0) break;
                absValue /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
        }

        outInfo.Value = sign * absValue;

        return outInfo;
    }

    static UnitInfo NormaliseUnitInfo(UnitInfo unitInfo)
    {
        if (unitInfo.Value == 0 && unitInfo.Prefix.Factor == 1.0)
        {
            return unitInfo;
        }
        UnitInfo outInfo = new UnitInfo(unitInfo);

        if (outInfo.Prefix.Factor != 1)
        {
            outInfo = FromValueToBaseTenExponent
            (
                outInfo, outInfo.Prefix.Factor, true
            );
            outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage);
        }
        if (outInfo.Value == 0.0) return outInfo;

        outInfo = FromValueToBaseTenExponent
        (
            outInfo, outInfo.Value, false
        );

        return outInfo;
    }

    static UnitInfo FromValueToBaseTenExponent(UnitInfo outInfo, double value, boolean isPrefix)
    {
        if (value == 0.0) return outInfo;

        double valueAbs = Math.Abs(value);
        boolean decrease = (valueAbs > 1.0);
        if (!isPrefix)
        {
            outInfo.Value = outInfo.Value / valueAbs;
        }

        while (valueAbs != 1.0)
        {
            if ((valueAbs < 10.0 && valueAbs > 1.0) || (valueAbs > 0.1.0 && valueAbs < 1.0))
            {
                if (!isPrefix) outInfo.Value = value;
                else
                {
                    outInfo = PerformManagedOperationValues
                    (
                        outInfo, value, Operations.Multiplication
                    );
                }

                return outInfo;
            }

            if (decrease)
            {
                value /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
            else
            {
                value *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }

            valueAbs = Math.Abs(value);
        }

        return outInfo;
    }

    //Method used to vary BaseTenExponent without provoking unhandled exceptions (i.e., bigger than Integer.MAX_VALUE).
    static UnitInfo VaryBaseTenExponent(UnitInfo info, int baseTenIncrease, boolean isDivision = false)
    {
        long val1 = info.BaseTenExponent;
        long val2 = baseTenIncrease;

        if (isDivision)
        {
            //Converting a negative value into positive might provoke an overflow error for the int type
            //(e.g., Math.Abs(Integer.MAIN_VALUE)). Converting both variables to long is a quick and effective
            //way to avoid this problem.
            val2 *= -1;
        }

        return
        (
             ((val2 > 0 && val1 > Integer.MAX_VALUE - val2) || (val2 < 0 && val1 < Integer.MAIN_VALUE - val2)) ?
            new UnitInfo(info, ErrorTypes.NumericError) : new UnitInfo(info){{ BaseTenExponent = (int)(val1 + val2); }}
        );
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2017-05-27 20:04:48.274
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2017-05-27 20:04:48.275
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2017-05-27 20:04:48.323
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
public class OperationsManaged
{
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, double second, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            firstInfo, new UnitInfo(second), operation
        );
    }

    public static UnitInfo PerformManagedOperationUnits(double first, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            new UnitInfo(first), secondInfo, operation
        );
    }

    //This method should always be used when dealing with random UnitInfo variables because it accounts for all the
    //possible scenarios. On the other hand, with simple operations (e.g., random UnitInfo & numeric type) it might
    //be better to use PerformManagedOperationValues. 
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        ErrorTypes errorType = InternalMethods.GetOperationError
        (
            firstInfo, secondInfo, operation
        );
        if (errorType != ErrorTypes.None)
        {
            return new UnitInfo(firstInfo) 
            {{
                Error = new ErrorInfo(errorType); 
            }};
        }

        return
        (
            operation == Operations.Addition || operation == Operations.Subtraction ?
            PerformManagedOperationAddition(firstInfo, secondInfo, operation) :
            PerformManagedOperationMultiplication(firstInfo, secondInfo, operation)
        );
    }

    static UnitInfo PerformManagedOperationAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {   
        //After being normalised, the operands might require further modifications.
        UnitInfo[] normalised = GetOperandsAddition(firstInfo, secondInfo, operation);

        return PerformManagedOperationNormalisedValues
        (
            firstInfo, normalised, operation
        );
    }

    static UnitInfo[] GetOperandsAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        UnitInfo[] operands2 = new UnitInfo[] 
        {
            new UnitInfo(firstInfo), new UnitInfo(secondInfo)
        };

        if (operands2[0].BaseTenExponent != operands2[1].BaseTenExponent || operands2[0].Prefix.Factor != operands2[1].Prefix.Factor)
        {
            //The addition/subtraction might not be performed right away even with normalised values.
            //For example: 5 and 6 from 5*10^2 and 6*10^7 cannot be added right away.
            operands2 = AdaptNormalisedValuesForAddition
            (
                new UnitInfo[] 
                { 
                    NormaliseUnitInfo(operands2[0]), 
                    NormaliseUnitInfo(operands2[1])
                },
                operation
            );
        }

        return operands2;
    }
    
    static UnitInfo[] AdaptNormalisedValuesForAddition(UnitInfo[] unitInfos2, Operations operation)
    {
        if (unitInfos2[0].BaseTenExponent == unitInfos2[1].BaseTenExponent)
        {
            //Having the same BaseTenExponent values means that the given operation can be performed right away.
            return unitInfos2;
        }

        int[] bigSmallI = 
        (
            unitInfos2[0].BaseTenExponent > unitInfos2[1].BaseTenExponent ?
            new int[] { 0, 1 } : new int[] { 1, 0 }
        );

        //Only the variable with the bigger value is modified. For example: 5*10^5 & 3*10^3 is converted
        //into 500*10^3 & 3*10^3 in order to allow the addition 500 + 3. 
        UnitInfo big2 = AdaptBiggerAdditionOperand(unitInfos2, bigSmallI, operation);
        if (big2.Error.Type != ErrorTypes.None)
        {
            return TooBigGapAddition(unitInfos2, bigSmallI, operation);
        }

        unitInfos2[bigSmallI[0]].Value = big2.Value;
        unitInfos2[bigSmallI[0]].BaseTenExponent = unitInfos2[bigSmallI[1]].BaseTenExponent;

        return unitInfos2;
    }

    //When adding/subtracting two numbers whose gap is bigger than the maximum double range, there
    //is no need to perform any operation (i.e., no change will be observed because of being outside
    //the maximum supported precision). This method takes care of these cases and returns the expected
    //output (i.e., biggest value).
    static UnitInfo[] TooBigGapAddition(UnitInfo[] unitInfos2, int[] bigSmallI, Operations operation)
    {
        UnitInfo[] outInfos = new UnitInfo[] 
        {
            //First operand (i.e., one whose information defines the operation) together with the
            //numeric information (i.e., just Value and BaseTenExponent because both are normalised)
            //which is associated with the biggest one.
            new UnitInfo(unitInfos2[0])
            {{
                Value = unitInfos2[bigSmallI[0]].Value;
                BaseTenExponent = unitInfos2[bigSmallI[0]].BaseTenExponent;
            }}
        };

        if (operation == Operations.Subtraction && bigSmallI[0] == 1)
        {
            outInfos[0].Value = -1.0 * outInfos[0].Value;
        }

        if (outInfos[0].Unit == Units.Unitless)
        {
            outInfos[0].Unit = unitInfos2[bigSmallI[1]].Unit;
        }

        return outInfos;
    }

    static UnitInfo AdaptBiggerAdditionOperand(UnitInfo[] unitInfos2, Integer[] bigSmallI, Operations operation)
    {
        int gapExponent = unitInfos2[bigSmallI[0]].BaseTenExponent - unitInfos2[bigSmallI[1]].BaseTenExponent;
        if (gapExponent >= 27)
        {
            //The difference between both inputs is bigger than (or, at least, very close to) the maximum double value/precision;
            //what makes this situation calculation unworthy and the first operand to be returned as the result.
            //Note that the error below these lines is just an easy way to tell the calling function about this eventuality.
            return new UnitInfo(unitInfos2[0]) 
            {{ 
                Error = new ErrorInfo(ErrorTypes.InvalidOperation); 
            }};
        }

        //PerformManagedOperationValues is used to make sure that the resulting numeric information is stored
        //in Value (if possible).
        UnitInfo big2 = PerformManagedOperationValues
        (
            RaiseToIntegerExponent(10.0, gapExponent), unitInfos2[bigSmallI[0]].Value, 
            Operations.Multiplication                
        );

        boolean isWrong = 
        (
            big2.Error.Type != ErrorTypes.None || big2.BaseTenExponent != 0 ?
            
            //The value of the bigger input times 10^(gap between BaseTenExponent of inputs) is too big. 
            isWrong = true :
            
            //Overflow-check very unlikely to trigger an error. In fact, with properly normalised variables,
            //triggering an error would be plainly impossible.               
            AreAdditionFinalValuesWrong
            (
                unitInfos2[0].Value, unitInfos2[1].Value, operation
            )
        );

        if (isWrong)
        {
        	UnitInfo temp = new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }};
            
        }
        
        return
        (
            isWrong ?
            //This error is just an easy way to let the calling function know about the fact that no
            //calculation has been performed (too big gap). This isn't a properly-speaking error and
            //that's why it will not be notified to the user.
            new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }} :
            //Returning the new big value. For example: with 5*10^4 & 3*10^2, 500 would be returned.
            new UnitInfo(unitInfos2[bigSmallI[0]])
            {{
                Value = big2.Value;
            }}
        )
    }

    static boolean AreAdditionFinalValuesWrong(double val1, double val2, Operations operation)
    {
        boolean isWrong = false;

        try
        {
            val1 = val1 + val2 *
            (
                operation == Operations.Addition ? 1 : -1
            );
        }
        catch { isWrong = true; }

        return isWrong;
    }

    static UnitInfo PerformManagedOperationMultiplication(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationNormalisedValues
        (
            firstInfo, new UnitInfo[] 
            { 
                NormaliseUnitInfo(firstInfo),
                NormaliseUnitInfo(secondInfo) 
            },
            operation
        );
    }

    public static UnitInfo RaiseToIntegerExponent(double baseValue, int exponent)
    {
        return RaiseToIntegerExponent(new UnitInfo(baseValue), exponent);
    }

    static UnitInfo RaiseToIntegerExponent(UnitInfo baseInfo, int exponent)
    {
        if (exponent <= 1 && exponent >= 0)
        {
            baseInfo.Value = (exponent == 0 ? 1.0 : baseInfo.Value);
            return baseInfo;
        }

        UnitInfo outInfo = new UnitInfo(baseInfo);

        for (int i = 1; i < Math.Abs(exponent); i++)
        {
            outInfo = PerformManagedOperationValues
            (
                outInfo, baseInfo, Operations.Multiplication
            );
            if (outInfo.Error.Type != ErrorTypes.None) return outInfo;
        }

        return
        (
            exponent < 0 ?
            PerformManagedOperationValues(new UnitInfo(1.0), outInfo, Operations.Division) :
            outInfo
        );
    }

    static UnitInfo PerformManagedOperationNormalisedValues(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        outInfo =
        (
            normalisedInfos.Length == 1 ?
            //There is just one operand when the difference between both of them is too big.
            outInfo = normalisedInfos[0] :
            PerformManagedOperationTwoOperands(outInfo, normalisedInfos, operation)
        );

        return outInfo;
    }

    static UnitInfo PerformManagedOperationTwoOperands(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        UnitInfo outInfoNormalised = PerformManagedOperationValues
        (
            normalisedInfos[0], normalisedInfos[1], operation
        );

        if (outInfo.Error.Type != ErrorTypes.None)
        {
            return new UnitInfo(outInfo)
            {
                Error = new ErrorInfo(ErrorTypes.NumericError)
            };
        }

        outInfo.BaseTenExponent = outInfoNormalised.BaseTenExponent;
        outInfo.Value = outInfoNormalised.Value;
        //Normalised means no prefixes.
        outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage); 

        return outInfo;
    }

    static UnitInfo PerformManagedOperationValues(double firstValue, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            new UnitInfo(firstValue), new UnitInfo(secondValue), operation
        );
    }

    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            firstInfo, new UnitInfo(secondValue), operation
        );
    }

    //This method might be used to perform full operations (not just being the last calculation step) instead
    //of the default one (PerformManagedOperationUnits) for simple cases. That is: ones not dealing with the
    //complex numeric reality (Value, Prefix and BaseTenExponent) which makes a pre-analysis required.
    //Note that, unlikely what happens with PerformMangedOperationUnits, the outputs of this method aren't
    //normalised (= primarily stored under Value), what is useful in certain contexts.
    //NOTE: this function assumes that both inputs are normalised, what means that no prefix information is expected.
    //It might also be used with non-normalised inputs, but their prefix information would be plainly ignored.
    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        if (firstInfo.Value == 0.0 || secondInfo.Value == 0.0)
        {
            if (operation == Operations.Multiplication || operation == Operations.Division)
            {
                //Dividing by zero scenarios are taken into account somewhere else.
                return new UnitInfo(firstInfo) { Value = 0.0 };
            }
        }

        UnitInfo outInfo = new UnitInfo(firstInfo);
        UnitInfo firstInfo0 = new UnitInfo(firstInfo);
        UnitInfo secondInfo0 = new UnitInfo(secondInfo);

        boolean isWrong = false;
        try
        {
            if (operation == Operations.Addition)
            {
                outInfo.Value += secondInfo0.Value;
            }
            else if (operation == Operations.Subtraction)
            {
                outInfo.Value -= secondInfo.Value;
            }
            else
            {
                //The reason for checking whether BaseTenExponent is inside/outside the int range before performing 
                //the operation (rather than going ahead and eventually catching the resulting exception) isn't just
                //being quicker, but also the only option in many situations. Note that an addition/subtraction between
                //two int variables whose result is outside the int range might not trigger an exception (+ random 
                //negative value as output).
                if (VaryBaseTenExponent(outInfo, secondInfo0.BaseTenExponent, operation == Operations.Division).Error.Type != ErrorTypes.None)
                {
                    return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
                }

                if (operation == Operations.Multiplication)
                {
                    outInfo.Value *= secondInfo.Value;
                    outInfo.BaseTenExponent += secondInfo.BaseTenExponent;
                }
                else if (operation == Operations.Division)
                {
                    if (secondInfo.Value == 0.0)
                    {
                        return
                        (
                            new UnitInfo(outInfo) 
                            { 
                                Error = new ErrorInfo(ErrorTypes.NumericError) 
                            }
                        );
                    }
                    outInfo.Value /= secondInfo.Value;
                    outInfo.BaseTenExponent -= secondInfo.BaseTenExponent;
                }
            }
        }
        catch { isWrong = true; }

        return
        (
            //An error might not be triggered despite of dealing with numbers outside double precision.
            //For example: 0.00000000000000000001m * 0.0000000000000000000001m can output 0.0 without triggering an error. 
            isWrong || ((operation == Operations.Multiplication || operation == Operations.Division) && outInfo.Value == 0.0.0) ?
            OperationValuesManageError(firstInfo0, secondInfo0, operation) : outInfo
        );
    }

    static UnitInfo OperationValuesManageError(UnitInfo outInfo, UnitInfo secondInfo, Operations operation)
    {
        if (operation != Operations.Multiplication && operation != Operations.Division)
        {
            //This condition should never be true on account of the fact that the pre-modifications performed before
            //adding/subtracting should avoid erroneous situations.
            return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
        }

        UnitInfo secondInfo2 = ConvertValueToBaseTen(secondInfo.Value);
        outInfo = VaryBaseTenExponent(outInfo, secondInfo2.BaseTenExponent, operation == Operations.Division);
        if (Math.Abs(secondInfo2.Value) == 1.0 || outInfo.Error.Type != ErrorTypes.None) return outInfo;
        
        try
        {
            outInfo = PerformManagedOperationUnits
            (
                outInfo, secondInfo2.Value, operation
            );
        }
        catch
        {
            //Very unlikely scenario on account of the fact that Math.Abs(secondInfo2.Value)
            //lies within the 0.1-10.0 range.
            outInfo = OperationValuesManageError
            (
                new UnitInfo(outInfo)
                {
                    Value = secondInfo2.Value,
                    BaseTenExponent = 0
                },
                new UnitInfo()
                {
                    Value = outInfo.Value,
                    BaseTenExponent = outInfo.BaseTenExponent
                },
                operation
            );
        }

        return outInfo;
    }

    static UnitInfo ConvertValueToBaseTen(double value)
    {
        value = Math.Abs(value);
        return FromValueToBaseTenExponent
        (
             new UnitInfo(value), Math.Abs(value), false
        );
    }

    static UnitInfo ConvertBaseTenToValue(UnitInfo unitInfo)
    {
        if (unitInfo.BaseTenExponent == 0) return unitInfo;

        UnitInfo outInfo = new UnitInfo(unitInfo);
        boolean decrease = unitInfo.BaseTenExponent > 0;
        int sign = Math.Sign(outInfo.Value);
        double absValue = Math.Abs(outInfo.Value);

        while (outInfo.BaseTenExponent != 0.0)
        {
            if (decrease)
            {
                if (absValue >= MaxValueDec / 10.0) break;
                absValue *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }
            else
            {
                if (absValue <= MinValueDec * 10.0) break;
                absValue /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
        }

        outInfo.Value = sign * absValue;

        return outInfo;
    }

    static UnitInfo NormaliseUnitInfo(UnitInfo unitInfo)
    {
        if (unitInfo.Value == 0 && unitInfo.Prefix.Factor == 1.0)
        {
            return unitInfo;
        }
        UnitInfo outInfo = new UnitInfo(unitInfo);

        if (outInfo.Prefix.Factor != 1)
        {
            outInfo = FromValueToBaseTenExponent
            (
                outInfo, outInfo.Prefix.Factor, true
            );
            outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage);
        }
        if (outInfo.Value == 0.0) return outInfo;

        outInfo = FromValueToBaseTenExponent
        (
            outInfo, outInfo.Value, false
        );

        return outInfo;
    }

    static UnitInfo FromValueToBaseTenExponent(UnitInfo outInfo, double value, boolean isPrefix)
    {
        if (value == 0.0) return outInfo;

        double valueAbs = Math.Abs(value);
        boolean decrease = (valueAbs > 1.0);
        if (!isPrefix)
        {
            outInfo.Value = outInfo.Value / valueAbs;
        }

        while (valueAbs != 1.0)
        {
            if ((valueAbs < 10.0 && valueAbs > 1.0) || (valueAbs > 0.1.0 && valueAbs < 1.0))
            {
                if (!isPrefix) outInfo.Value = value;
                else
                {
                    outInfo = PerformManagedOperationValues
                    (
                        outInfo, value, Operations.Multiplication
                    );
                }

                return outInfo;
            }

            if (decrease)
            {
                value /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
            else
            {
                value *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }

            valueAbs = Math.Abs(value);
        }

        return outInfo;
    }

    //Method used to vary BaseTenExponent without provoking unhandled exceptions (i.e., bigger than Integer.MAX_VALUE).
    static UnitInfo VaryBaseTenExponent(UnitInfo info, int baseTenIncrease, boolean isDivision = false)
    {
        long val1 = info.BaseTenExponent;
        long val2 = baseTenIncrease;

        if (isDivision)
        {
            //Converting a negative value into positive might provoke an overflow error for the int type
            //(e.g., Math.Abs(Integer.MAIN_VALUE)). Converting both variables to long is a quick and effective
            //way to avoid this problem.
            val2 *= -1;
        }

        return
        (
             ((val2 > 0 && val1 > Integer.MAX_VALUE - val2) || (val2 < 0 && val1 < Integer.MAIN_VALUE - val2)) ?
            new UnitInfo(info, ErrorTypes.NumericError) : new UnitInfo(info){{ BaseTenExponent = (int)(val1 + val2); }}
        );
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 2 2017-05-27 20:04:48.324
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 0 2017-05-27 20:04:48.324
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.core 4 4 2017-05-27 20:04:50.812
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
public class OperationsManaged
{
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, double second, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            firstInfo, new UnitInfo(second), operation
        );
    }

    public static UnitInfo PerformManagedOperationUnits(double first, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            new UnitInfo(first), secondInfo, operation
        );
    }

    //This method should always be used when dealing with random UnitInfo variables because it accounts for all the
    //possible scenarios. On the other hand, with simple operations (e.g., random UnitInfo & numeric type) it might
    //be better to use PerformManagedOperationValues. 
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        ErrorTypes errorType = InternalMethods.GetOperationError
        (
            firstInfo, secondInfo, operation
        );
        if (errorType != ErrorTypes.None)
        {
            return new UnitInfo(firstInfo) 
            {{
                Error = new ErrorInfo(errorType); 
            }};
        }

        return
        (
            operation == Operations.Addition || operation == Operations.Subtraction ?
            PerformManagedOperationAddition(firstInfo, secondInfo, operation) :
            PerformManagedOperationMultiplication(firstInfo, secondInfo, operation)
        );
    }

    static UnitInfo PerformManagedOperationAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {   
        //After being normalised, the operands might require further modifications.
        UnitInfo[] normalised = GetOperandsAddition(firstInfo, secondInfo, operation);

        return PerformManagedOperationNormalisedValues
        (
            firstInfo, normalised, operation
        );
    }

    static UnitInfo[] GetOperandsAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        UnitInfo[] operands2 = new UnitInfo[] 
        {
            new UnitInfo(firstInfo), new UnitInfo(secondInfo)
        };

        if (operands2[0].BaseTenExponent != operands2[1].BaseTenExponent || operands2[0].Prefix.Factor != operands2[1].Prefix.Factor)
        {
            //The addition/subtraction might not be performed right away even with normalised values.
            //For example: 5 and 6 from 5*10^2 and 6*10^7 cannot be added right away.
            operands2 = AdaptNormalisedValuesForAddition
            (
                new UnitInfo[] 
                { 
                    NormaliseUnitInfo(operands2[0]), 
                    NormaliseUnitInfo(operands2[1])
                },
                operation
            );
        }

        return operands2;
    }
    
    static UnitInfo[] AdaptNormalisedValuesForAddition(UnitInfo[] unitInfos2, Operations operation)
    {
        if (unitInfos2[0].BaseTenExponent == unitInfos2[1].BaseTenExponent)
        {
            //Having the same BaseTenExponent values means that the given operation can be performed right away.
            return unitInfos2;
        }

        int[] bigSmallI = 
        (
            unitInfos2[0].BaseTenExponent > unitInfos2[1].BaseTenExponent ?
            new int[] { 0, 1 } : new int[] { 1, 0 }
        );

        //Only the variable with the bigger value is modified. For example: 5*10^5 & 3*10^3 is converted
        //into 500*10^3 & 3*10^3 in order to allow the addition 500 + 3. 
        UnitInfo big2 = AdaptBiggerAdditionOperand(unitInfos2, bigSmallI, operation);
        if (big2.Error.Type != ErrorTypes.None)
        {
            return TooBigGapAddition(unitInfos2, bigSmallI, operation);
        }

        unitInfos2[bigSmallI[0]].Value = big2.Value;
        unitInfos2[bigSmallI[0]].BaseTenExponent = unitInfos2[bigSmallI[1]].BaseTenExponent;

        return unitInfos2;
    }

    //When adding/subtracting two numbers whose gap is bigger than the maximum double range, there
    //is no need to perform any operation (i.e., no change will be observed because of being outside
    //the maximum supported precision). This method takes care of these cases and returns the expected
    //output (i.e., biggest value).
    static UnitInfo[] TooBigGapAddition(UnitInfo[] unitInfos2, int[] bigSmallI, Operations operation)
    {
        UnitInfo[] outInfos = new UnitInfo[] 
        {
            //First operand (i.e., one whose information defines the operation) together with the
            //numeric information (i.e., just Value and BaseTenExponent because both are normalised)
            //which is associated with the biggest one.
            new UnitInfo(unitInfos2[0])
            {{
                Value = unitInfos2[bigSmallI[0]].Value;
                BaseTenExponent = unitInfos2[bigSmallI[0]].BaseTenExponent;
            }}
        };

        if (operation == Operations.Subtraction && bigSmallI[0] == 1)
        {
            outInfos[0].Value = -1.0 * outInfos[0].Value;
        }

        if (outInfos[0].Unit == Units.Unitless)
        {
            outInfos[0].Unit = unitInfos2[bigSmallI[1]].Unit;
        }

        return outInfos;
    }

    static UnitInfo AdaptBiggerAdditionOperand(UnitInfo[] unitInfos2, Integer[] bigSmallI, Operations operation)
    {
        int gapExponent = unitInfos2[bigSmallI[0]].BaseTenExponent - unitInfos2[bigSmallI[1]].BaseTenExponent;
        if (gapExponent >= 27)
        {
            //The difference between both inputs is bigger than (or, at least, very close to) the maximum double value/precision;
            //what makes this situation calculation unworthy and the first operand to be returned as the result.
            //Note that the error below these lines is just an easy way to tell the calling function about this eventuality.
            return new UnitInfo(unitInfos2[0]) 
            {{ 
                Error = new ErrorInfo(ErrorTypes.InvalidOperation); 
            }};
        }

        //PerformManagedOperationValues is used to make sure that the resulting numeric information is stored
        //in Value (if possible).
        UnitInfo big2 = PerformManagedOperationValues
        (
            RaiseToIntegerExponent(10.0, gapExponent), unitInfos2[bigSmallI[0]].Value, 
            Operations.Multiplication                
        );

        boolean isWrong = 
        (
            big2.Error.Type != ErrorTypes.None || big2.BaseTenExponent != 0 ?
            
            //The value of the bigger input times 10^(gap between BaseTenExponent of inputs) is too big. 
            isWrong = true :
            
            //Overflow-check very unlikely to trigger an error. In fact, with properly normalised variables,
            //triggering an error would be plainly impossible.               
            AreAdditionFinalValuesWrong
            (
                unitInfos2[0].Value, unitInfos2[1].Value, operation
            )
        );

        if (isWrong)
        {
        	UnitInfo temp = new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }};
            
            te.
        }
        
        return
        (
            isWrong ?
            //This error is just an easy way to let the calling function know about the fact that no
            //calculation has been performed (too big gap). This isn't a properly-speaking error and
            //that's why it will not be notified to the user.
            new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }} :
            //Returning the new big value. For example: with 5*10^4 & 3*10^2, 500 would be returned.
            new UnitInfo(unitInfos2[bigSmallI[0]])
            {{
                Value = big2.Value;
            }}
        )
    }

    static boolean AreAdditionFinalValuesWrong(double val1, double val2, Operations operation)
    {
        boolean isWrong = false;

        try
        {
            val1 = val1 + val2 *
            (
                operation == Operations.Addition ? 1 : -1
            );
        }
        catch { isWrong = true; }

        return isWrong;
    }

    static UnitInfo PerformManagedOperationMultiplication(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationNormalisedValues
        (
            firstInfo, new UnitInfo[] 
            { 
                NormaliseUnitInfo(firstInfo),
                NormaliseUnitInfo(secondInfo) 
            },
            operation
        );
    }

    public static UnitInfo RaiseToIntegerExponent(double baseValue, int exponent)
    {
        return RaiseToIntegerExponent(new UnitInfo(baseValue), exponent);
    }

    static UnitInfo RaiseToIntegerExponent(UnitInfo baseInfo, int exponent)
    {
        if (exponent <= 1 && exponent >= 0)
        {
            baseInfo.Value = (exponent == 0 ? 1.0 : baseInfo.Value);
            return baseInfo;
        }

        UnitInfo outInfo = new UnitInfo(baseInfo);

        for (int i = 1; i < Math.Abs(exponent); i++)
        {
            outInfo = PerformManagedOperationValues
            (
                outInfo, baseInfo, Operations.Multiplication
            );
            if (outInfo.Error.Type != ErrorTypes.None) return outInfo;
        }

        return
        (
            exponent < 0 ?
            PerformManagedOperationValues(new UnitInfo(1.0), outInfo, Operations.Division) :
            outInfo
        );
    }

    static UnitInfo PerformManagedOperationNormalisedValues(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        outInfo =
        (
            normalisedInfos.Length == 1 ?
            //There is just one operand when the difference between both of them is too big.
            outInfo = normalisedInfos[0] :
            PerformManagedOperationTwoOperands(outInfo, normalisedInfos, operation)
        );

        return outInfo;
    }

    static UnitInfo PerformManagedOperationTwoOperands(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        UnitInfo outInfoNormalised = PerformManagedOperationValues
        (
            normalisedInfos[0], normalisedInfos[1], operation
        );

        if (outInfo.Error.Type != ErrorTypes.None)
        {
            return new UnitInfo(outInfo)
            {
                Error = new ErrorInfo(ErrorTypes.NumericError)
            };
        }

        outInfo.BaseTenExponent = outInfoNormalised.BaseTenExponent;
        outInfo.Value = outInfoNormalised.Value;
        //Normalised means no prefixes.
        outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage); 

        return outInfo;
    }

    static UnitInfo PerformManagedOperationValues(double firstValue, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            new UnitInfo(firstValue), new UnitInfo(secondValue), operation
        );
    }

    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            firstInfo, new UnitInfo(secondValue), operation
        );
    }

    //This method might be used to perform full operations (not just being the last calculation step) instead
    //of the default one (PerformManagedOperationUnits) for simple cases. That is: ones not dealing with the
    //complex numeric reality (Value, Prefix and BaseTenExponent) which makes a pre-analysis required.
    //Note that, unlikely what happens with PerformMangedOperationUnits, the outputs of this method aren't
    //normalised (= primarily stored under Value), what is useful in certain contexts.
    //NOTE: this function assumes that both inputs are normalised, what means that no prefix information is expected.
    //It might also be used with non-normalised inputs, but their prefix information would be plainly ignored.
    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        if (firstInfo.Value == 0.0 || secondInfo.Value == 0.0)
        {
            if (operation == Operations.Multiplication || operation == Operations.Division)
            {
                //Dividing by zero scenarios are taken into account somewhere else.
                return new UnitInfo(firstInfo) { Value = 0.0 };
            }
        }

        UnitInfo outInfo = new UnitInfo(firstInfo);
        UnitInfo firstInfo0 = new UnitInfo(firstInfo);
        UnitInfo secondInfo0 = new UnitInfo(secondInfo);

        boolean isWrong = false;
        try
        {
            if (operation == Operations.Addition)
            {
                outInfo.Value += secondInfo0.Value;
            }
            else if (operation == Operations.Subtraction)
            {
                outInfo.Value -= secondInfo.Value;
            }
            else
            {
                //The reason for checking whether BaseTenExponent is inside/outside the int range before performing 
                //the operation (rather than going ahead and eventually catching the resulting exception) isn't just
                //being quicker, but also the only option in many situations. Note that an addition/subtraction between
                //two int variables whose result is outside the int range might not trigger an exception (+ random 
                //negative value as output).
                if (VaryBaseTenExponent(outInfo, secondInfo0.BaseTenExponent, operation == Operations.Division).Error.Type != ErrorTypes.None)
                {
                    return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
                }

                if (operation == Operations.Multiplication)
                {
                    outInfo.Value *= secondInfo.Value;
                    outInfo.BaseTenExponent += secondInfo.BaseTenExponent;
                }
                else if (operation == Operations.Division)
                {
                    if (secondInfo.Value == 0.0)
                    {
                        return
                        (
                            new UnitInfo(outInfo) 
                            { 
                                Error = new ErrorInfo(ErrorTypes.NumericError) 
                            }
                        );
                    }
                    outInfo.Value /= secondInfo.Value;
                    outInfo.BaseTenExponent -= secondInfo.BaseTenExponent;
                }
            }
        }
        catch { isWrong = true; }

        return
        (
            //An error might not be triggered despite of dealing with numbers outside double precision.
            //For example: 0.00000000000000000001m * 0.0000000000000000000001m can output 0.0 without triggering an error. 
            isWrong || ((operation == Operations.Multiplication || operation == Operations.Division) && outInfo.Value == 0.0.0) ?
            OperationValuesManageError(firstInfo0, secondInfo0, operation) : outInfo
        );
    }

    static UnitInfo OperationValuesManageError(UnitInfo outInfo, UnitInfo secondInfo, Operations operation)
    {
        if (operation != Operations.Multiplication && operation != Operations.Division)
        {
            //This condition should never be true on account of the fact that the pre-modifications performed before
            //adding/subtracting should avoid erroneous situations.
            return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
        }

        UnitInfo secondInfo2 = ConvertValueToBaseTen(secondInfo.Value);
        outInfo = VaryBaseTenExponent(outInfo, secondInfo2.BaseTenExponent, operation == Operations.Division);
        if (Math.Abs(secondInfo2.Value) == 1.0 || outInfo.Error.Type != ErrorTypes.None) return outInfo;
        
        try
        {
            outInfo = PerformManagedOperationUnits
            (
                outInfo, secondInfo2.Value, operation
            );
        }
        catch
        {
            //Very unlikely scenario on account of the fact that Math.Abs(secondInfo2.Value)
            //lies within the 0.1-10.0 range.
            outInfo = OperationValuesManageError
            (
                new UnitInfo(outInfo)
                {
                    Value = secondInfo2.Value,
                    BaseTenExponent = 0
                },
                new UnitInfo()
                {
                    Value = outInfo.Value,
                    BaseTenExponent = outInfo.BaseTenExponent
                },
                operation
            );
        }

        return outInfo;
    }

    static UnitInfo ConvertValueToBaseTen(double value)
    {
        value = Math.Abs(value);
        return FromValueToBaseTenExponent
        (
             new UnitInfo(value), Math.Abs(value), false
        );
    }

    static UnitInfo ConvertBaseTenToValue(UnitInfo unitInfo)
    {
        if (unitInfo.BaseTenExponent == 0) return unitInfo;

        UnitInfo outInfo = new UnitInfo(unitInfo);
        boolean decrease = unitInfo.BaseTenExponent > 0;
        int sign = Math.Sign(outInfo.Value);
        double absValue = Math.Abs(outInfo.Value);

        while (outInfo.BaseTenExponent != 0.0)
        {
            if (decrease)
            {
                if (absValue >= MaxValueDec / 10.0) break;
                absValue *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }
            else
            {
                if (absValue <= MinValueDec * 10.0) break;
                absValue /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
        }

        outInfo.Value = sign * absValue;

        return outInfo;
    }

    static UnitInfo NormaliseUnitInfo(UnitInfo unitInfo)
    {
        if (unitInfo.Value == 0 && unitInfo.Prefix.Factor == 1.0)
        {
            return unitInfo;
        }
        UnitInfo outInfo = new UnitInfo(unitInfo);

        if (outInfo.Prefix.Factor != 1)
        {
            outInfo = FromValueToBaseTenExponent
            (
                outInfo, outInfo.Prefix.Factor, true
            );
            outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage);
        }
        if (outInfo.Value == 0.0) return outInfo;

        outInfo = FromValueToBaseTenExponent
        (
            outInfo, outInfo.Value, false
        );

        return outInfo;
    }

    static UnitInfo FromValueToBaseTenExponent(UnitInfo outInfo, double value, boolean isPrefix)
    {
        if (value == 0.0) return outInfo;

        double valueAbs = Math.Abs(value);
        boolean decrease = (valueAbs > 1.0);
        if (!isPrefix)
        {
            outInfo.Value = outInfo.Value / valueAbs;
        }

        while (valueAbs != 1.0)
        {
            if ((valueAbs < 10.0 && valueAbs > 1.0) || (valueAbs > 0.1.0 && valueAbs < 1.0))
            {
                if (!isPrefix) outInfo.Value = value;
                else
                {
                    outInfo = PerformManagedOperationValues
                    (
                        outInfo, value, Operations.Multiplication
                    );
                }

                return outInfo;
            }

            if (decrease)
            {
                value /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
            else
            {
                value *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }

            valueAbs = Math.Abs(value);
        }

        return outInfo;
    }

    //Method used to vary BaseTenExponent without provoking unhandled exceptions (i.e., bigger than Integer.MAX_VALUE).
    static UnitInfo VaryBaseTenExponent(UnitInfo info, int baseTenIncrease, boolean isDivision = false)
    {
        long val1 = info.BaseTenExponent;
        long val2 = baseTenIncrease;

        if (isDivision)
        {
            //Converting a negative value into positive might provoke an overflow error for the int type
            //(e.g., Math.Abs(Integer.MAIN_VALUE)). Converting both variables to long is a quick and effective
            //way to avoid this problem.
            val2 *= -1;
        }

        return
        (
             ((val2 > 0 && val1 > Integer.MAX_VALUE - val2) || (val2 < 0 && val1 < Integer.MAIN_VALUE - val2)) ?
            new UnitInfo(info, ErrorTypes.NumericError) : new UnitInfo(info){{ BaseTenExponent = (int)(val1 + val2); }}
        );
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2017-05-27 20:04:50.813
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2017-05-27 20:04:50.813
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2017-05-27 20:04:50.845
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
public class OperationsManaged
{
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, double second, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            firstInfo, new UnitInfo(second), operation
        );
    }

    public static UnitInfo PerformManagedOperationUnits(double first, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            new UnitInfo(first), secondInfo, operation
        );
    }

    //This method should always be used when dealing with random UnitInfo variables because it accounts for all the
    //possible scenarios. On the other hand, with simple operations (e.g., random UnitInfo & numeric type) it might
    //be better to use PerformManagedOperationValues. 
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        ErrorTypes errorType = InternalMethods.GetOperationError
        (
            firstInfo, secondInfo, operation
        );
        if (errorType != ErrorTypes.None)
        {
            return new UnitInfo(firstInfo) 
            {{
                Error = new ErrorInfo(errorType); 
            }};
        }

        return
        (
            operation == Operations.Addition || operation == Operations.Subtraction ?
            PerformManagedOperationAddition(firstInfo, secondInfo, operation) :
            PerformManagedOperationMultiplication(firstInfo, secondInfo, operation)
        );
    }

    static UnitInfo PerformManagedOperationAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {   
        //After being normalised, the operands might require further modifications.
        UnitInfo[] normalised = GetOperandsAddition(firstInfo, secondInfo, operation);

        return PerformManagedOperationNormalisedValues
        (
            firstInfo, normalised, operation
        );
    }

    static UnitInfo[] GetOperandsAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        UnitInfo[] operands2 = new UnitInfo[] 
        {
            new UnitInfo(firstInfo), new UnitInfo(secondInfo)
        };

        if (operands2[0].BaseTenExponent != operands2[1].BaseTenExponent || operands2[0].Prefix.Factor != operands2[1].Prefix.Factor)
        {
            //The addition/subtraction might not be performed right away even with normalised values.
            //For example: 5 and 6 from 5*10^2 and 6*10^7 cannot be added right away.
            operands2 = AdaptNormalisedValuesForAddition
            (
                new UnitInfo[] 
                { 
                    NormaliseUnitInfo(operands2[0]), 
                    NormaliseUnitInfo(operands2[1])
                },
                operation
            );
        }

        return operands2;
    }
    
    static UnitInfo[] AdaptNormalisedValuesForAddition(UnitInfo[] unitInfos2, Operations operation)
    {
        if (unitInfos2[0].BaseTenExponent == unitInfos2[1].BaseTenExponent)
        {
            //Having the same BaseTenExponent values means that the given operation can be performed right away.
            return unitInfos2;
        }

        int[] bigSmallI = 
        (
            unitInfos2[0].BaseTenExponent > unitInfos2[1].BaseTenExponent ?
            new int[] { 0, 1 } : new int[] { 1, 0 }
        );

        //Only the variable with the bigger value is modified. For example: 5*10^5 & 3*10^3 is converted
        //into 500*10^3 & 3*10^3 in order to allow the addition 500 + 3. 
        UnitInfo big2 = AdaptBiggerAdditionOperand(unitInfos2, bigSmallI, operation);
        if (big2.Error.Type != ErrorTypes.None)
        {
            return TooBigGapAddition(unitInfos2, bigSmallI, operation);
        }

        unitInfos2[bigSmallI[0]].Value = big2.Value;
        unitInfos2[bigSmallI[0]].BaseTenExponent = unitInfos2[bigSmallI[1]].BaseTenExponent;

        return unitInfos2;
    }

    //When adding/subtracting two numbers whose gap is bigger than the maximum double range, there
    //is no need to perform any operation (i.e., no change will be observed because of being outside
    //the maximum supported precision). This method takes care of these cases and returns the expected
    //output (i.e., biggest value).
    static UnitInfo[] TooBigGapAddition(UnitInfo[] unitInfos2, int[] bigSmallI, Operations operation)
    {
        UnitInfo[] outInfos = new UnitInfo[] 
        {
            //First operand (i.e., one whose information defines the operation) together with the
            //numeric information (i.e., just Value and BaseTenExponent because both are normalised)
            //which is associated with the biggest one.
            new UnitInfo(unitInfos2[0])
            {{
                Value = unitInfos2[bigSmallI[0]].Value;
                BaseTenExponent = unitInfos2[bigSmallI[0]].BaseTenExponent;
            }}
        };

        if (operation == Operations.Subtraction && bigSmallI[0] == 1)
        {
            outInfos[0].Value = -1.0 * outInfos[0].Value;
        }

        if (outInfos[0].Unit == Units.Unitless)
        {
            outInfos[0].Unit = unitInfos2[bigSmallI[1]].Unit;
        }

        return outInfos;
    }

    static UnitInfo AdaptBiggerAdditionOperand(UnitInfo[] unitInfos2, Integer[] bigSmallI, Operations operation)
    {
        int gapExponent = unitInfos2[bigSmallI[0]].BaseTenExponent - unitInfos2[bigSmallI[1]].BaseTenExponent;
        if (gapExponent >= 27)
        {
            //The difference between both inputs is bigger than (or, at least, very close to) the maximum double value/precision;
            //what makes this situation calculation unworthy and the first operand to be returned as the result.
            //Note that the error below these lines is just an easy way to tell the calling function about this eventuality.
            return new UnitInfo(unitInfos2[0]) 
            {{ 
                Error = new ErrorInfo(ErrorTypes.InvalidOperation); 
            }};
        }

        //PerformManagedOperationValues is used to make sure that the resulting numeric information is stored
        //in Value (if possible).
        UnitInfo big2 = PerformManagedOperationValues
        (
            RaiseToIntegerExponent(10.0, gapExponent), unitInfos2[bigSmallI[0]].Value, 
            Operations.Multiplication                
        );

        boolean isWrong = 
        (
            big2.Error.Type != ErrorTypes.None || big2.BaseTenExponent != 0 ?
            
            //The value of the bigger input times 10^(gap between BaseTenExponent of inputs) is too big. 
            isWrong = true :
            
            //Overflow-check very unlikely to trigger an error. In fact, with properly normalised variables,
            //triggering an error would be plainly impossible.               
            AreAdditionFinalValuesWrong
            (
                unitInfos2[0].Value, unitInfos2[1].Value, operation
            )
        );

        if (isWrong)
        {
        	UnitInfo temp = new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }};
            
            te.
        }
        
        return
        (
            isWrong ?
            //This error is just an easy way to let the calling function know about the fact that no
            //calculation has been performed (too big gap). This isn't a properly-speaking error and
            //that's why it will not be notified to the user.
            new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }} :
            //Returning the new big value. For example: with 5*10^4 & 3*10^2, 500 would be returned.
            new UnitInfo(unitInfos2[bigSmallI[0]])
            {{
                Value = big2.Value;
            }}
        )
    }

    static boolean AreAdditionFinalValuesWrong(double val1, double val2, Operations operation)
    {
        boolean isWrong = false;

        try
        {
            val1 = val1 + val2 *
            (
                operation == Operations.Addition ? 1 : -1
            );
        }
        catch { isWrong = true; }

        return isWrong;
    }

    static UnitInfo PerformManagedOperationMultiplication(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationNormalisedValues
        (
            firstInfo, new UnitInfo[] 
            { 
                NormaliseUnitInfo(firstInfo),
                NormaliseUnitInfo(secondInfo) 
            },
            operation
        );
    }

    public static UnitInfo RaiseToIntegerExponent(double baseValue, int exponent)
    {
        return RaiseToIntegerExponent(new UnitInfo(baseValue), exponent);
    }

    static UnitInfo RaiseToIntegerExponent(UnitInfo baseInfo, int exponent)
    {
        if (exponent <= 1 && exponent >= 0)
        {
            baseInfo.Value = (exponent == 0 ? 1.0 : baseInfo.Value);
            return baseInfo;
        }

        UnitInfo outInfo = new UnitInfo(baseInfo);

        for (int i = 1; i < Math.Abs(exponent); i++)
        {
            outInfo = PerformManagedOperationValues
            (
                outInfo, baseInfo, Operations.Multiplication
            );
            if (outInfo.Error.Type != ErrorTypes.None) return outInfo;
        }

        return
        (
            exponent < 0 ?
            PerformManagedOperationValues(new UnitInfo(1.0), outInfo, Operations.Division) :
            outInfo
        );
    }

    static UnitInfo PerformManagedOperationNormalisedValues(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        outInfo =
        (
            normalisedInfos.Length == 1 ?
            //There is just one operand when the difference between both of them is too big.
            outInfo = normalisedInfos[0] :
            PerformManagedOperationTwoOperands(outInfo, normalisedInfos, operation)
        );

        return outInfo;
    }

    static UnitInfo PerformManagedOperationTwoOperands(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        UnitInfo outInfoNormalised = PerformManagedOperationValues
        (
            normalisedInfos[0], normalisedInfos[1], operation
        );

        if (outInfo.Error.Type != ErrorTypes.None)
        {
            return new UnitInfo(outInfo)
            {
                Error = new ErrorInfo(ErrorTypes.NumericError)
            };
        }

        outInfo.BaseTenExponent = outInfoNormalised.BaseTenExponent;
        outInfo.Value = outInfoNormalised.Value;
        //Normalised means no prefixes.
        outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage); 

        return outInfo;
    }

    static UnitInfo PerformManagedOperationValues(double firstValue, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            new UnitInfo(firstValue), new UnitInfo(secondValue), operation
        );
    }

    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            firstInfo, new UnitInfo(secondValue), operation
        );
    }

    //This method might be used to perform full operations (not just being the last calculation step) instead
    //of the default one (PerformManagedOperationUnits) for simple cases. That is: ones not dealing with the
    //complex numeric reality (Value, Prefix and BaseTenExponent) which makes a pre-analysis required.
    //Note that, unlikely what happens with PerformMangedOperationUnits, the outputs of this method aren't
    //normalised (= primarily stored under Value), what is useful in certain contexts.
    //NOTE: this function assumes that both inputs are normalised, what means that no prefix information is expected.
    //It might also be used with non-normalised inputs, but their prefix information would be plainly ignored.
    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        if (firstInfo.Value == 0.0 || secondInfo.Value == 0.0)
        {
            if (operation == Operations.Multiplication || operation == Operations.Division)
            {
                //Dividing by zero scenarios are taken into account somewhere else.
                return new UnitInfo(firstInfo) { Value = 0.0 };
            }
        }

        UnitInfo outInfo = new UnitInfo(firstInfo);
        UnitInfo firstInfo0 = new UnitInfo(firstInfo);
        UnitInfo secondInfo0 = new UnitInfo(secondInfo);

        boolean isWrong = false;
        try
        {
            if (operation == Operations.Addition)
            {
                outInfo.Value += secondInfo0.Value;
            }
            else if (operation == Operations.Subtraction)
            {
                outInfo.Value -= secondInfo.Value;
            }
            else
            {
                //The reason for checking whether BaseTenExponent is inside/outside the int range before performing 
                //the operation (rather than going ahead and eventually catching the resulting exception) isn't just
                //being quicker, but also the only option in many situations. Note that an addition/subtraction between
                //two int variables whose result is outside the int range might not trigger an exception (+ random 
                //negative value as output).
                if (VaryBaseTenExponent(outInfo, secondInfo0.BaseTenExponent, operation == Operations.Division).Error.Type != ErrorTypes.None)
                {
                    return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
                }

                if (operation == Operations.Multiplication)
                {
                    outInfo.Value *= secondInfo.Value;
                    outInfo.BaseTenExponent += secondInfo.BaseTenExponent;
                }
                else if (operation == Operations.Division)
                {
                    if (secondInfo.Value == 0.0)
                    {
                        return
                        (
                            new UnitInfo(outInfo) 
                            { 
                                Error = new ErrorInfo(ErrorTypes.NumericError) 
                            }
                        );
                    }
                    outInfo.Value /= secondInfo.Value;
                    outInfo.BaseTenExponent -= secondInfo.BaseTenExponent;
                }
            }
        }
        catch { isWrong = true; }

        return
        (
            //An error might not be triggered despite of dealing with numbers outside double precision.
            //For example: 0.00000000000000000001m * 0.0000000000000000000001m can output 0.0 without triggering an error. 
            isWrong || ((operation == Operations.Multiplication || operation == Operations.Division) && outInfo.Value == 0.0.0) ?
            OperationValuesManageError(firstInfo0, secondInfo0, operation) : outInfo
        );
    }

    static UnitInfo OperationValuesManageError(UnitInfo outInfo, UnitInfo secondInfo, Operations operation)
    {
        if (operation != Operations.Multiplication && operation != Operations.Division)
        {
            //This condition should never be true on account of the fact that the pre-modifications performed before
            //adding/subtracting should avoid erroneous situations.
            return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
        }

        UnitInfo secondInfo2 = ConvertValueToBaseTen(secondInfo.Value);
        outInfo = VaryBaseTenExponent(outInfo, secondInfo2.BaseTenExponent, operation == Operations.Division);
        if (Math.Abs(secondInfo2.Value) == 1.0 || outInfo.Error.Type != ErrorTypes.None) return outInfo;
        
        try
        {
            outInfo = PerformManagedOperationUnits
            (
                outInfo, secondInfo2.Value, operation
            );
        }
        catch
        {
            //Very unlikely scenario on account of the fact that Math.Abs(secondInfo2.Value)
            //lies within the 0.1-10.0 range.
            outInfo = OperationValuesManageError
            (
                new UnitInfo(outInfo)
                {
                    Value = secondInfo2.Value,
                    BaseTenExponent = 0
                },
                new UnitInfo()
                {
                    Value = outInfo.Value,
                    BaseTenExponent = outInfo.BaseTenExponent
                },
                operation
            );
        }

        return outInfo;
    }

    static UnitInfo ConvertValueToBaseTen(double value)
    {
        value = Math.Abs(value);
        return FromValueToBaseTenExponent
        (
             new UnitInfo(value), Math.Abs(value), false
        );
    }

    static UnitInfo ConvertBaseTenToValue(UnitInfo unitInfo)
    {
        if (unitInfo.BaseTenExponent == 0) return unitInfo;

        UnitInfo outInfo = new UnitInfo(unitInfo);
        boolean decrease = unitInfo.BaseTenExponent > 0;
        int sign = Math.Sign(outInfo.Value);
        double absValue = Math.Abs(outInfo.Value);

        while (outInfo.BaseTenExponent != 0.0)
        {
            if (decrease)
            {
                if (absValue >= MaxValueDec / 10.0) break;
                absValue *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }
            else
            {
                if (absValue <= MinValueDec * 10.0) break;
                absValue /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
        }

        outInfo.Value = sign * absValue;

        return outInfo;
    }

    static UnitInfo NormaliseUnitInfo(UnitInfo unitInfo)
    {
        if (unitInfo.Value == 0 && unitInfo.Prefix.Factor == 1.0)
        {
            return unitInfo;
        }
        UnitInfo outInfo = new UnitInfo(unitInfo);

        if (outInfo.Prefix.Factor != 1)
        {
            outInfo = FromValueToBaseTenExponent
            (
                outInfo, outInfo.Prefix.Factor, true
            );
            outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage);
        }
        if (outInfo.Value == 0.0) return outInfo;

        outInfo = FromValueToBaseTenExponent
        (
            outInfo, outInfo.Value, false
        );

        return outInfo;
    }

    static UnitInfo FromValueToBaseTenExponent(UnitInfo outInfo, double value, boolean isPrefix)
    {
        if (value == 0.0) return outInfo;

        double valueAbs = Math.Abs(value);
        boolean decrease = (valueAbs > 1.0);
        if (!isPrefix)
        {
            outInfo.Value = outInfo.Value / valueAbs;
        }

        while (valueAbs != 1.0)
        {
            if ((valueAbs < 10.0 && valueAbs > 1.0) || (valueAbs > 0.1.0 && valueAbs < 1.0))
            {
                if (!isPrefix) outInfo.Value = value;
                else
                {
                    outInfo = PerformManagedOperationValues
                    (
                        outInfo, value, Operations.Multiplication
                    );
                }

                return outInfo;
            }

            if (decrease)
            {
                value /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
            else
            {
                value *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }

            valueAbs = Math.Abs(value);
        }

        return outInfo;
    }

    //Method used to vary BaseTenExponent without provoking unhandled exceptions (i.e., bigger than Integer.MAX_VALUE).
    static UnitInfo VaryBaseTenExponent(UnitInfo info, int baseTenIncrease, boolean isDivision = false)
    {
        long val1 = info.BaseTenExponent;
        long val2 = baseTenIncrease;

        if (isDivision)
        {
            //Converting a negative value into positive might provoke an overflow error for the int type
            //(e.g., Math.Abs(Integer.MAIN_VALUE)). Converting both variables to long is a quick and effective
            //way to avoid this problem.
            val2 *= -1;
        }

        return
        (
             ((val2 > 0 && val1 > Integer.MAX_VALUE - val2) || (val2 < 0 && val1 < Integer.MAIN_VALUE - val2)) ?
            new UnitInfo(info, ErrorTypes.NumericError) : new UnitInfo(info){{ BaseTenExponent = (int)(val1 + val2); }}
        );
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:476)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 2 2017-05-27 20:04:50.846
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:476)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 0 2017-05-27 20:04:50.847
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:476)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.core 4 4 2017-05-27 20:04:52.875
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
public class OperationsManaged
{
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, double second, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            firstInfo, new UnitInfo(second), operation
        );
    }

    public static UnitInfo PerformManagedOperationUnits(double first, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            new UnitInfo(first), secondInfo, operation
        );
    }

    //This method should always be used when dealing with random UnitInfo variables because it accounts for all the
    //possible scenarios. On the other hand, with simple operations (e.g., random UnitInfo & numeric type) it might
    //be better to use PerformManagedOperationValues. 
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        ErrorTypes errorType = InternalMethods.GetOperationError
        (
            firstInfo, secondInfo, operation
        );
        if (errorType != ErrorTypes.None)
        {
            return new UnitInfo(firstInfo) 
            {{
                Error = new ErrorInfo(errorType); 
            }};
        }

        return
        (
            operation == Operations.Addition || operation == Operations.Subtraction ?
            PerformManagedOperationAddition(firstInfo, secondInfo, operation) :
            PerformManagedOperationMultiplication(firstInfo, secondInfo, operation)
        );
    }

    static UnitInfo PerformManagedOperationAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {   
        //After being normalised, the operands might require further modifications.
        UnitInfo[] normalised = GetOperandsAddition(firstInfo, secondInfo, operation);

        return PerformManagedOperationNormalisedValues
        (
            firstInfo, normalised, operation
        );
    }

    static UnitInfo[] GetOperandsAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        UnitInfo[] operands2 = new UnitInfo[] 
        {
            new UnitInfo(firstInfo), new UnitInfo(secondInfo)
        };

        if (operands2[0].BaseTenExponent != operands2[1].BaseTenExponent || operands2[0].Prefix.Factor != operands2[1].Prefix.Factor)
        {
            //The addition/subtraction might not be performed right away even with normalised values.
            //For example: 5 and 6 from 5*10^2 and 6*10^7 cannot be added right away.
            operands2 = AdaptNormalisedValuesForAddition
            (
                new UnitInfo[] 
                { 
                    NormaliseUnitInfo(operands2[0]), 
                    NormaliseUnitInfo(operands2[1])
                },
                operation
            );
        }

        return operands2;
    }
    
    static UnitInfo[] AdaptNormalisedValuesForAddition(UnitInfo[] unitInfos2, Operations operation)
    {
        if (unitInfos2[0].BaseTenExponent == unitInfos2[1].BaseTenExponent)
        {
            //Having the same BaseTenExponent values means that the given operation can be performed right away.
            return unitInfos2;
        }

        int[] bigSmallI = 
        (
            unitInfos2[0].BaseTenExponent > unitInfos2[1].BaseTenExponent ?
            new int[] { 0, 1 } : new int[] { 1, 0 }
        );

        //Only the variable with the bigger value is modified. For example: 5*10^5 & 3*10^3 is converted
        //into 500*10^3 & 3*10^3 in order to allow the addition 500 + 3. 
        UnitInfo big2 = AdaptBiggerAdditionOperand(unitInfos2, bigSmallI, operation);
        if (big2.Error.Type != ErrorTypes.None)
        {
            return TooBigGapAddition(unitInfos2, bigSmallI, operation);
        }

        unitInfos2[bigSmallI[0]].Value = big2.Value;
        unitInfos2[bigSmallI[0]].BaseTenExponent = unitInfos2[bigSmallI[1]].BaseTenExponent;

        return unitInfos2;
    }

    //When adding/subtracting two numbers whose gap is bigger than the maximum double range, there
    //is no need to perform any operation (i.e., no change will be observed because of being outside
    //the maximum supported precision). This method takes care of these cases and returns the expected
    //output (i.e., biggest value).
    static UnitInfo[] TooBigGapAddition(UnitInfo[] unitInfos2, int[] bigSmallI, Operations operation)
    {
        UnitInfo[] outInfos = new UnitInfo[] 
        {
            //First operand (i.e., one whose information defines the operation) together with the
            //numeric information (i.e., just Value and BaseTenExponent because both are normalised)
            //which is associated with the biggest one.
            new UnitInfo(unitInfos2[0])
            {{
                Value = unitInfos2[bigSmallI[0]].Value;
                BaseTenExponent = unitInfos2[bigSmallI[0]].BaseTenExponent;
            }}
        };

        if (operation == Operations.Subtraction && bigSmallI[0] == 1)
        {
            outInfos[0].Value = -1.0 * outInfos[0].Value;
        }

        if (outInfos[0].Unit == Units.Unitless)
        {
            outInfos[0].Unit = unitInfos2[bigSmallI[1]].Unit;
        }

        return outInfos;
    }

    static UnitInfo AdaptBiggerAdditionOperand(UnitInfo[] unitInfos2, Integer[] bigSmallI, Operations operation)
    {
        int gapExponent = unitInfos2[bigSmallI[0]].BaseTenExponent - unitInfos2[bigSmallI[1]].BaseTenExponent;
        if (gapExponent >= 27)
        {
            //The difference between both inputs is bigger than (or, at least, very close to) the maximum double value/precision;
            //what makes this situation calculation unworthy and the first operand to be returned as the result.
            //Note that the error below these lines is just an easy way to tell the calling function about this eventuality.
            return new UnitInfo(unitInfos2[0]) 
            {{ 
                Error = new ErrorInfo(ErrorTypes.InvalidOperation); 
            }};
        }

        //PerformManagedOperationValues is used to make sure that the resulting numeric information is stored
        //in Value (if possible).
        UnitInfo big2 = PerformManagedOperationValues
        (
            RaiseToIntegerExponent(10.0, gapExponent), unitInfos2[bigSmallI[0]].Value, 
            Operations.Multiplication                
        );

        boolean isWrong = 
        (
            big2.Error.Type != ErrorTypes.None || big2.BaseTenExponent != 0 ?
            
            //The value of the bigger input times 10^(gap between BaseTenExponent of inputs) is too big. 
            isWrong = true :
            
            //Overflow-check very unlikely to trigger an error. In fact, with properly normalised variables,
            //triggering an error would be plainly impossible.               
            AreAdditionFinalValuesWrong
            (
                unitInfos2[0].Value, unitInfos2[1].Value, operation
            )
        );

        if (isWrong)
        {
        	UnitInfo temp = new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }};
            
            temp.
        }
        
        return
        (
            isWrong ?
            //This error is just an easy way to let the calling function know about the fact that no
            //calculation has been performed (too big gap). This isn't a properly-speaking error and
            //that's why it will not be notified to the user.
            new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }} :
            //Returning the new big value. For example: with 5*10^4 & 3*10^2, 500 would be returned.
            new UnitInfo(unitInfos2[bigSmallI[0]])
            {{
                Value = big2.Value;
            }}
        )
    }

    static boolean AreAdditionFinalValuesWrong(double val1, double val2, Operations operation)
    {
        boolean isWrong = false;

        try
        {
            val1 = val1 + val2 *
            (
                operation == Operations.Addition ? 1 : -1
            );
        }
        catch { isWrong = true; }

        return isWrong;
    }

    static UnitInfo PerformManagedOperationMultiplication(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationNormalisedValues
        (
            firstInfo, new UnitInfo[] 
            { 
                NormaliseUnitInfo(firstInfo),
                NormaliseUnitInfo(secondInfo) 
            },
            operation
        );
    }

    public static UnitInfo RaiseToIntegerExponent(double baseValue, int exponent)
    {
        return RaiseToIntegerExponent(new UnitInfo(baseValue), exponent);
    }

    static UnitInfo RaiseToIntegerExponent(UnitInfo baseInfo, int exponent)
    {
        if (exponent <= 1 && exponent >= 0)
        {
            baseInfo.Value = (exponent == 0 ? 1.0 : baseInfo.Value);
            return baseInfo;
        }

        UnitInfo outInfo = new UnitInfo(baseInfo);

        for (int i = 1; i < Math.Abs(exponent); i++)
        {
            outInfo = PerformManagedOperationValues
            (
                outInfo, baseInfo, Operations.Multiplication
            );
            if (outInfo.Error.Type != ErrorTypes.None) return outInfo;
        }

        return
        (
            exponent < 0 ?
            PerformManagedOperationValues(new UnitInfo(1.0), outInfo, Operations.Division) :
            outInfo
        );
    }

    static UnitInfo PerformManagedOperationNormalisedValues(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        outInfo =
        (
            normalisedInfos.Length == 1 ?
            //There is just one operand when the difference between both of them is too big.
            outInfo = normalisedInfos[0] :
            PerformManagedOperationTwoOperands(outInfo, normalisedInfos, operation)
        );

        return outInfo;
    }

    static UnitInfo PerformManagedOperationTwoOperands(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        UnitInfo outInfoNormalised = PerformManagedOperationValues
        (
            normalisedInfos[0], normalisedInfos[1], operation
        );

        if (outInfo.Error.Type != ErrorTypes.None)
        {
            return new UnitInfo(outInfo)
            {
                Error = new ErrorInfo(ErrorTypes.NumericError)
            };
        }

        outInfo.BaseTenExponent = outInfoNormalised.BaseTenExponent;
        outInfo.Value = outInfoNormalised.Value;
        //Normalised means no prefixes.
        outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage); 

        return outInfo;
    }

    static UnitInfo PerformManagedOperationValues(double firstValue, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            new UnitInfo(firstValue), new UnitInfo(secondValue), operation
        );
    }

    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            firstInfo, new UnitInfo(secondValue), operation
        );
    }

    //This method might be used to perform full operations (not just being the last calculation step) instead
    //of the default one (PerformManagedOperationUnits) for simple cases. That is: ones not dealing with the
    //complex numeric reality (Value, Prefix and BaseTenExponent) which makes a pre-analysis required.
    //Note that, unlikely what happens with PerformMangedOperationUnits, the outputs of this method aren't
    //normalised (= primarily stored under Value), what is useful in certain contexts.
    //NOTE: this function assumes that both inputs are normalised, what means that no prefix information is expected.
    //It might also be used with non-normalised inputs, but their prefix information would be plainly ignored.
    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        if (firstInfo.Value == 0.0 || secondInfo.Value == 0.0)
        {
            if (operation == Operations.Multiplication || operation == Operations.Division)
            {
                //Dividing by zero scenarios are taken into account somewhere else.
                return new UnitInfo(firstInfo) { Value = 0.0 };
            }
        }

        UnitInfo outInfo = new UnitInfo(firstInfo);
        UnitInfo firstInfo0 = new UnitInfo(firstInfo);
        UnitInfo secondInfo0 = new UnitInfo(secondInfo);

        boolean isWrong = false;
        try
        {
            if (operation == Operations.Addition)
            {
                outInfo.Value += secondInfo0.Value;
            }
            else if (operation == Operations.Subtraction)
            {
                outInfo.Value -= secondInfo.Value;
            }
            else
            {
                //The reason for checking whether BaseTenExponent is inside/outside the int range before performing 
                //the operation (rather than going ahead and eventually catching the resulting exception) isn't just
                //being quicker, but also the only option in many situations. Note that an addition/subtraction between
                //two int variables whose result is outside the int range might not trigger an exception (+ random 
                //negative value as output).
                if (VaryBaseTenExponent(outInfo, secondInfo0.BaseTenExponent, operation == Operations.Division).Error.Type != ErrorTypes.None)
                {
                    return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
                }

                if (operation == Operations.Multiplication)
                {
                    outInfo.Value *= secondInfo.Value;
                    outInfo.BaseTenExponent += secondInfo.BaseTenExponent;
                }
                else if (operation == Operations.Division)
                {
                    if (secondInfo.Value == 0.0)
                    {
                        return
                        (
                            new UnitInfo(outInfo) 
                            { 
                                Error = new ErrorInfo(ErrorTypes.NumericError) 
                            }
                        );
                    }
                    outInfo.Value /= secondInfo.Value;
                    outInfo.BaseTenExponent -= secondInfo.BaseTenExponent;
                }
            }
        }
        catch { isWrong = true; }

        return
        (
            //An error might not be triggered despite of dealing with numbers outside double precision.
            //For example: 0.00000000000000000001m * 0.0000000000000000000001m can output 0.0 without triggering an error. 
            isWrong || ((operation == Operations.Multiplication || operation == Operations.Division) && outInfo.Value == 0.0.0) ?
            OperationValuesManageError(firstInfo0, secondInfo0, operation) : outInfo
        );
    }

    static UnitInfo OperationValuesManageError(UnitInfo outInfo, UnitInfo secondInfo, Operations operation)
    {
        if (operation != Operations.Multiplication && operation != Operations.Division)
        {
            //This condition should never be true on account of the fact that the pre-modifications performed before
            //adding/subtracting should avoid erroneous situations.
            return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
        }

        UnitInfo secondInfo2 = ConvertValueToBaseTen(secondInfo.Value);
        outInfo = VaryBaseTenExponent(outInfo, secondInfo2.BaseTenExponent, operation == Operations.Division);
        if (Math.Abs(secondInfo2.Value) == 1.0 || outInfo.Error.Type != ErrorTypes.None) return outInfo;
        
        try
        {
            outInfo = PerformManagedOperationUnits
            (
                outInfo, secondInfo2.Value, operation
            );
        }
        catch
        {
            //Very unlikely scenario on account of the fact that Math.Abs(secondInfo2.Value)
            //lies within the 0.1-10.0 range.
            outInfo = OperationValuesManageError
            (
                new UnitInfo(outInfo)
                {
                    Value = secondInfo2.Value,
                    BaseTenExponent = 0
                },
                new UnitInfo()
                {
                    Value = outInfo.Value,
                    BaseTenExponent = outInfo.BaseTenExponent
                },
                operation
            );
        }

        return outInfo;
    }

    static UnitInfo ConvertValueToBaseTen(double value)
    {
        value = Math.Abs(value);
        return FromValueToBaseTenExponent
        (
             new UnitInfo(value), Math.Abs(value), false
        );
    }

    static UnitInfo ConvertBaseTenToValue(UnitInfo unitInfo)
    {
        if (unitInfo.BaseTenExponent == 0) return unitInfo;

        UnitInfo outInfo = new UnitInfo(unitInfo);
        boolean decrease = unitInfo.BaseTenExponent > 0;
        int sign = Math.Sign(outInfo.Value);
        double absValue = Math.Abs(outInfo.Value);

        while (outInfo.BaseTenExponent != 0.0)
        {
            if (decrease)
            {
                if (absValue >= MaxValueDec / 10.0) break;
                absValue *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }
            else
            {
                if (absValue <= MinValueDec * 10.0) break;
                absValue /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
        }

        outInfo.Value = sign * absValue;

        return outInfo;
    }

    static UnitInfo NormaliseUnitInfo(UnitInfo unitInfo)
    {
        if (unitInfo.Value == 0 && unitInfo.Prefix.Factor == 1.0)
        {
            return unitInfo;
        }
        UnitInfo outInfo = new UnitInfo(unitInfo);

        if (outInfo.Prefix.Factor != 1)
        {
            outInfo = FromValueToBaseTenExponent
            (
                outInfo, outInfo.Prefix.Factor, true
            );
            outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage);
        }
        if (outInfo.Value == 0.0) return outInfo;

        outInfo = FromValueToBaseTenExponent
        (
            outInfo, outInfo.Value, false
        );

        return outInfo;
    }

    static UnitInfo FromValueToBaseTenExponent(UnitInfo outInfo, double value, boolean isPrefix)
    {
        if (value == 0.0) return outInfo;

        double valueAbs = Math.Abs(value);
        boolean decrease = (valueAbs > 1.0);
        if (!isPrefix)
        {
            outInfo.Value = outInfo.Value / valueAbs;
        }

        while (valueAbs != 1.0)
        {
            if ((valueAbs < 10.0 && valueAbs > 1.0) || (valueAbs > 0.1.0 && valueAbs < 1.0))
            {
                if (!isPrefix) outInfo.Value = value;
                else
                {
                    outInfo = PerformManagedOperationValues
                    (
                        outInfo, value, Operations.Multiplication
                    );
                }

                return outInfo;
            }

            if (decrease)
            {
                value /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
            else
            {
                value *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }

            valueAbs = Math.Abs(value);
        }

        return outInfo;
    }

    //Method used to vary BaseTenExponent without provoking unhandled exceptions (i.e., bigger than Integer.MAX_VALUE).
    static UnitInfo VaryBaseTenExponent(UnitInfo info, int baseTenIncrease, boolean isDivision = false)
    {
        long val1 = info.BaseTenExponent;
        long val2 = baseTenIncrease;

        if (isDivision)
        {
            //Converting a negative value into positive might provoke an overflow error for the int type
            //(e.g., Math.Abs(Integer.MAIN_VALUE)). Converting both variables to long is a quick and effective
            //way to avoid this problem.
            val2 *= -1;
        }

        return
        (
             ((val2 > 0 && val1 > Integer.MAX_VALUE - val2) || (val2 < 0 && val1 < Integer.MAIN_VALUE - val2)) ?
            new UnitInfo(info, ErrorTypes.NumericError) : new UnitInfo(info){{ BaseTenExponent = (int)(val1 + val2); }}
        );
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2017-05-27 20:04:52.876
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2017-05-27 20:04:52.876
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2017-05-27 20:04:52.905
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
public class OperationsManaged
{
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, double second, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            firstInfo, new UnitInfo(second), operation
        );
    }

    public static UnitInfo PerformManagedOperationUnits(double first, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            new UnitInfo(first), secondInfo, operation
        );
    }

    //This method should always be used when dealing with random UnitInfo variables because it accounts for all the
    //possible scenarios. On the other hand, with simple operations (e.g., random UnitInfo & numeric type) it might
    //be better to use PerformManagedOperationValues. 
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        ErrorTypes errorType = InternalMethods.GetOperationError
        (
            firstInfo, secondInfo, operation
        );
        if (errorType != ErrorTypes.None)
        {
            return new UnitInfo(firstInfo) 
            {{
                Error = new ErrorInfo(errorType); 
            }};
        }

        return
        (
            operation == Operations.Addition || operation == Operations.Subtraction ?
            PerformManagedOperationAddition(firstInfo, secondInfo, operation) :
            PerformManagedOperationMultiplication(firstInfo, secondInfo, operation)
        );
    }

    static UnitInfo PerformManagedOperationAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {   
        //After being normalised, the operands might require further modifications.
        UnitInfo[] normalised = GetOperandsAddition(firstInfo, secondInfo, operation);

        return PerformManagedOperationNormalisedValues
        (
            firstInfo, normalised, operation
        );
    }

    static UnitInfo[] GetOperandsAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        UnitInfo[] operands2 = new UnitInfo[] 
        {
            new UnitInfo(firstInfo), new UnitInfo(secondInfo)
        };

        if (operands2[0].BaseTenExponent != operands2[1].BaseTenExponent || operands2[0].Prefix.Factor != operands2[1].Prefix.Factor)
        {
            //The addition/subtraction might not be performed right away even with normalised values.
            //For example: 5 and 6 from 5*10^2 and 6*10^7 cannot be added right away.
            operands2 = AdaptNormalisedValuesForAddition
            (
                new UnitInfo[] 
                { 
                    NormaliseUnitInfo(operands2[0]), 
                    NormaliseUnitInfo(operands2[1])
                },
                operation
            );
        }

        return operands2;
    }
    
    static UnitInfo[] AdaptNormalisedValuesForAddition(UnitInfo[] unitInfos2, Operations operation)
    {
        if (unitInfos2[0].BaseTenExponent == unitInfos2[1].BaseTenExponent)
        {
            //Having the same BaseTenExponent values means that the given operation can be performed right away.
            return unitInfos2;
        }

        int[] bigSmallI = 
        (
            unitInfos2[0].BaseTenExponent > unitInfos2[1].BaseTenExponent ?
            new int[] { 0, 1 } : new int[] { 1, 0 }
        );

        //Only the variable with the bigger value is modified. For example: 5*10^5 & 3*10^3 is converted
        //into 500*10^3 & 3*10^3 in order to allow the addition 500 + 3. 
        UnitInfo big2 = AdaptBiggerAdditionOperand(unitInfos2, bigSmallI, operation);
        if (big2.Error.Type != ErrorTypes.None)
        {
            return TooBigGapAddition(unitInfos2, bigSmallI, operation);
        }

        unitInfos2[bigSmallI[0]].Value = big2.Value;
        unitInfos2[bigSmallI[0]].BaseTenExponent = unitInfos2[bigSmallI[1]].BaseTenExponent;

        return unitInfos2;
    }

    //When adding/subtracting two numbers whose gap is bigger than the maximum double range, there
    //is no need to perform any operation (i.e., no change will be observed because of being outside
    //the maximum supported precision). This method takes care of these cases and returns the expected
    //output (i.e., biggest value).
    static UnitInfo[] TooBigGapAddition(UnitInfo[] unitInfos2, int[] bigSmallI, Operations operation)
    {
        UnitInfo[] outInfos = new UnitInfo[] 
        {
            //First operand (i.e., one whose information defines the operation) together with the
            //numeric information (i.e., just Value and BaseTenExponent because both are normalised)
            //which is associated with the biggest one.
            new UnitInfo(unitInfos2[0])
            {{
                Value = unitInfos2[bigSmallI[0]].Value;
                BaseTenExponent = unitInfos2[bigSmallI[0]].BaseTenExponent;
            }}
        };

        if (operation == Operations.Subtraction && bigSmallI[0] == 1)
        {
            outInfos[0].Value = -1.0 * outInfos[0].Value;
        }

        if (outInfos[0].Unit == Units.Unitless)
        {
            outInfos[0].Unit = unitInfos2[bigSmallI[1]].Unit;
        }

        return outInfos;
    }

    static UnitInfo AdaptBiggerAdditionOperand(UnitInfo[] unitInfos2, Integer[] bigSmallI, Operations operation)
    {
        int gapExponent = unitInfos2[bigSmallI[0]].BaseTenExponent - unitInfos2[bigSmallI[1]].BaseTenExponent;
        if (gapExponent >= 27)
        {
            //The difference between both inputs is bigger than (or, at least, very close to) the maximum double value/precision;
            //what makes this situation calculation unworthy and the first operand to be returned as the result.
            //Note that the error below these lines is just an easy way to tell the calling function about this eventuality.
            return new UnitInfo(unitInfos2[0]) 
            {{ 
                Error = new ErrorInfo(ErrorTypes.InvalidOperation); 
            }};
        }

        //PerformManagedOperationValues is used to make sure that the resulting numeric information is stored
        //in Value (if possible).
        UnitInfo big2 = PerformManagedOperationValues
        (
            RaiseToIntegerExponent(10.0, gapExponent), unitInfos2[bigSmallI[0]].Value, 
            Operations.Multiplication                
        );

        boolean isWrong = 
        (
            big2.Error.Type != ErrorTypes.None || big2.BaseTenExponent != 0 ?
            
            //The value of the bigger input times 10^(gap between BaseTenExponent of inputs) is too big. 
            isWrong = true :
            
            //Overflow-check very unlikely to trigger an error. In fact, with properly normalised variables,
            //triggering an error would be plainly impossible.               
            AreAdditionFinalValuesWrong
            (
                unitInfos2[0].Value, unitInfos2[1].Value, operation
            )
        );

        if (isWrong)
        {
        	UnitInfo temp = new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }};
            
            temp.
        }
        
        return
        (
            isWrong ?
            //This error is just an easy way to let the calling function know about the fact that no
            //calculation has been performed (too big gap). This isn't a properly-speaking error and
            //that's why it will not be notified to the user.
            new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }} :
            //Returning the new big value. For example: with 5*10^4 & 3*10^2, 500 would be returned.
            new UnitInfo(unitInfos2[bigSmallI[0]])
            {{
                Value = big2.Value;
            }}
        )
    }

    static boolean AreAdditionFinalValuesWrong(double val1, double val2, Operations operation)
    {
        boolean isWrong = false;

        try
        {
            val1 = val1 + val2 *
            (
                operation == Operations.Addition ? 1 : -1
            );
        }
        catch { isWrong = true; }

        return isWrong;
    }

    static UnitInfo PerformManagedOperationMultiplication(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationNormalisedValues
        (
            firstInfo, new UnitInfo[] 
            { 
                NormaliseUnitInfo(firstInfo),
                NormaliseUnitInfo(secondInfo) 
            },
            operation
        );
    }

    public static UnitInfo RaiseToIntegerExponent(double baseValue, int exponent)
    {
        return RaiseToIntegerExponent(new UnitInfo(baseValue), exponent);
    }

    static UnitInfo RaiseToIntegerExponent(UnitInfo baseInfo, int exponent)
    {
        if (exponent <= 1 && exponent >= 0)
        {
            baseInfo.Value = (exponent == 0 ? 1.0 : baseInfo.Value);
            return baseInfo;
        }

        UnitInfo outInfo = new UnitInfo(baseInfo);

        for (int i = 1; i < Math.Abs(exponent); i++)
        {
            outInfo = PerformManagedOperationValues
            (
                outInfo, baseInfo, Operations.Multiplication
            );
            if (outInfo.Error.Type != ErrorTypes.None) return outInfo;
        }

        return
        (
            exponent < 0 ?
            PerformManagedOperationValues(new UnitInfo(1.0), outInfo, Operations.Division) :
            outInfo
        );
    }

    static UnitInfo PerformManagedOperationNormalisedValues(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        outInfo =
        (
            normalisedInfos.Length == 1 ?
            //There is just one operand when the difference between both of them is too big.
            outInfo = normalisedInfos[0] :
            PerformManagedOperationTwoOperands(outInfo, normalisedInfos, operation)
        );

        return outInfo;
    }

    static UnitInfo PerformManagedOperationTwoOperands(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        UnitInfo outInfoNormalised = PerformManagedOperationValues
        (
            normalisedInfos[0], normalisedInfos[1], operation
        );

        if (outInfo.Error.Type != ErrorTypes.None)
        {
            return new UnitInfo(outInfo)
            {
                Error = new ErrorInfo(ErrorTypes.NumericError)
            };
        }

        outInfo.BaseTenExponent = outInfoNormalised.BaseTenExponent;
        outInfo.Value = outInfoNormalised.Value;
        //Normalised means no prefixes.
        outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage); 

        return outInfo;
    }

    static UnitInfo PerformManagedOperationValues(double firstValue, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            new UnitInfo(firstValue), new UnitInfo(secondValue), operation
        );
    }

    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            firstInfo, new UnitInfo(secondValue), operation
        );
    }

    //This method might be used to perform full operations (not just being the last calculation step) instead
    //of the default one (PerformManagedOperationUnits) for simple cases. That is: ones not dealing with the
    //complex numeric reality (Value, Prefix and BaseTenExponent) which makes a pre-analysis required.
    //Note that, unlikely what happens with PerformMangedOperationUnits, the outputs of this method aren't
    //normalised (= primarily stored under Value), what is useful in certain contexts.
    //NOTE: this function assumes that both inputs are normalised, what means that no prefix information is expected.
    //It might also be used with non-normalised inputs, but their prefix information would be plainly ignored.
    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        if (firstInfo.Value == 0.0 || secondInfo.Value == 0.0)
        {
            if (operation == Operations.Multiplication || operation == Operations.Division)
            {
                //Dividing by zero scenarios are taken into account somewhere else.
                return new UnitInfo(firstInfo) { Value = 0.0 };
            }
        }

        UnitInfo outInfo = new UnitInfo(firstInfo);
        UnitInfo firstInfo0 = new UnitInfo(firstInfo);
        UnitInfo secondInfo0 = new UnitInfo(secondInfo);

        boolean isWrong = false;
        try
        {
            if (operation == Operations.Addition)
            {
                outInfo.Value += secondInfo0.Value;
            }
            else if (operation == Operations.Subtraction)
            {
                outInfo.Value -= secondInfo.Value;
            }
            else
            {
                //The reason for checking whether BaseTenExponent is inside/outside the int range before performing 
                //the operation (rather than going ahead and eventually catching the resulting exception) isn't just
                //being quicker, but also the only option in many situations. Note that an addition/subtraction between
                //two int variables whose result is outside the int range might not trigger an exception (+ random 
                //negative value as output).
                if (VaryBaseTenExponent(outInfo, secondInfo0.BaseTenExponent, operation == Operations.Division).Error.Type != ErrorTypes.None)
                {
                    return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
                }

                if (operation == Operations.Multiplication)
                {
                    outInfo.Value *= secondInfo.Value;
                    outInfo.BaseTenExponent += secondInfo.BaseTenExponent;
                }
                else if (operation == Operations.Division)
                {
                    if (secondInfo.Value == 0.0)
                    {
                        return
                        (
                            new UnitInfo(outInfo) 
                            { 
                                Error = new ErrorInfo(ErrorTypes.NumericError) 
                            }
                        );
                    }
                    outInfo.Value /= secondInfo.Value;
                    outInfo.BaseTenExponent -= secondInfo.BaseTenExponent;
                }
            }
        }
        catch { isWrong = true; }

        return
        (
            //An error might not be triggered despite of dealing with numbers outside double precision.
            //For example: 0.00000000000000000001m * 0.0000000000000000000001m can output 0.0 without triggering an error. 
            isWrong || ((operation == Operations.Multiplication || operation == Operations.Division) && outInfo.Value == 0.0.0) ?
            OperationValuesManageError(firstInfo0, secondInfo0, operation) : outInfo
        );
    }

    static UnitInfo OperationValuesManageError(UnitInfo outInfo, UnitInfo secondInfo, Operations operation)
    {
        if (operation != Operations.Multiplication && operation != Operations.Division)
        {
            //This condition should never be true on account of the fact that the pre-modifications performed before
            //adding/subtracting should avoid erroneous situations.
            return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
        }

        UnitInfo secondInfo2 = ConvertValueToBaseTen(secondInfo.Value);
        outInfo = VaryBaseTenExponent(outInfo, secondInfo2.BaseTenExponent, operation == Operations.Division);
        if (Math.Abs(secondInfo2.Value) == 1.0 || outInfo.Error.Type != ErrorTypes.None) return outInfo;
        
        try
        {
            outInfo = PerformManagedOperationUnits
            (
                outInfo, secondInfo2.Value, operation
            );
        }
        catch
        {
            //Very unlikely scenario on account of the fact that Math.Abs(secondInfo2.Value)
            //lies within the 0.1-10.0 range.
            outInfo = OperationValuesManageError
            (
                new UnitInfo(outInfo)
                {
                    Value = secondInfo2.Value,
                    BaseTenExponent = 0
                },
                new UnitInfo()
                {
                    Value = outInfo.Value,
                    BaseTenExponent = outInfo.BaseTenExponent
                },
                operation
            );
        }

        return outInfo;
    }

    static UnitInfo ConvertValueToBaseTen(double value)
    {
        value = Math.Abs(value);
        return FromValueToBaseTenExponent
        (
             new UnitInfo(value), Math.Abs(value), false
        );
    }

    static UnitInfo ConvertBaseTenToValue(UnitInfo unitInfo)
    {
        if (unitInfo.BaseTenExponent == 0) return unitInfo;

        UnitInfo outInfo = new UnitInfo(unitInfo);
        boolean decrease = unitInfo.BaseTenExponent > 0;
        int sign = Math.Sign(outInfo.Value);
        double absValue = Math.Abs(outInfo.Value);

        while (outInfo.BaseTenExponent != 0.0)
        {
            if (decrease)
            {
                if (absValue >= MaxValueDec / 10.0) break;
                absValue *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }
            else
            {
                if (absValue <= MinValueDec * 10.0) break;
                absValue /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
        }

        outInfo.Value = sign * absValue;

        return outInfo;
    }

    static UnitInfo NormaliseUnitInfo(UnitInfo unitInfo)
    {
        if (unitInfo.Value == 0 && unitInfo.Prefix.Factor == 1.0)
        {
            return unitInfo;
        }
        UnitInfo outInfo = new UnitInfo(unitInfo);

        if (outInfo.Prefix.Factor != 1)
        {
            outInfo = FromValueToBaseTenExponent
            (
                outInfo, outInfo.Prefix.Factor, true
            );
            outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage);
        }
        if (outInfo.Value == 0.0) return outInfo;

        outInfo = FromValueToBaseTenExponent
        (
            outInfo, outInfo.Value, false
        );

        return outInfo;
    }

    static UnitInfo FromValueToBaseTenExponent(UnitInfo outInfo, double value, boolean isPrefix)
    {
        if (value == 0.0) return outInfo;

        double valueAbs = Math.Abs(value);
        boolean decrease = (valueAbs > 1.0);
        if (!isPrefix)
        {
            outInfo.Value = outInfo.Value / valueAbs;
        }

        while (valueAbs != 1.0)
        {
            if ((valueAbs < 10.0 && valueAbs > 1.0) || (valueAbs > 0.1.0 && valueAbs < 1.0))
            {
                if (!isPrefix) outInfo.Value = value;
                else
                {
                    outInfo = PerformManagedOperationValues
                    (
                        outInfo, value, Operations.Multiplication
                    );
                }

                return outInfo;
            }

            if (decrease)
            {
                value /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
            else
            {
                value *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }

            valueAbs = Math.Abs(value);
        }

        return outInfo;
    }

    //Method used to vary BaseTenExponent without provoking unhandled exceptions (i.e., bigger than Integer.MAX_VALUE).
    static UnitInfo VaryBaseTenExponent(UnitInfo info, int baseTenIncrease, boolean isDivision = false)
    {
        long val1 = info.BaseTenExponent;
        long val2 = baseTenIncrease;

        if (isDivision)
        {
            //Converting a negative value into positive might provoke an overflow error for the int type
            //(e.g., Math.Abs(Integer.MAIN_VALUE)). Converting both variables to long is a quick and effective
            //way to avoid this problem.
            val2 *= -1;
        }

        return
        (
             ((val2 > 0 && val1 > Integer.MAX_VALUE - val2) || (val2 < 0 && val1 < Integer.MAIN_VALUE - val2)) ?
            new UnitInfo(info, ErrorTypes.NumericError) : new UnitInfo(info){{ BaseTenExponent = (int)(val1 + val2); }}
        );
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 2 2017-05-27 20:04:52.906
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 0 2017-05-27 20:04:52.906
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.core 4 4 2017-05-27 20:04:57.946
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
public class OperationsManaged
{
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, double second, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            firstInfo, new UnitInfo(second), operation
        );
    }

    public static UnitInfo PerformManagedOperationUnits(double first, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            new UnitInfo(first), secondInfo, operation
        );
    }

    //This method should always be used when dealing with random UnitInfo variables because it accounts for all the
    //possible scenarios. On the other hand, with simple operations (e.g., random UnitInfo & numeric type) it might
    //be better to use PerformManagedOperationValues. 
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        ErrorTypes errorType = InternalMethods.GetOperationError
        (
            firstInfo, secondInfo, operation
        );
        if (errorType != ErrorTypes.None)
        {
            return new UnitInfo(firstInfo) 
            {{
                Error = new ErrorInfo(errorType); 
            }};
        }

        return
        (
            operation == Operations.Addition || operation == Operations.Subtraction ?
            PerformManagedOperationAddition(firstInfo, secondInfo, operation) :
            PerformManagedOperationMultiplication(firstInfo, secondInfo, operation)
        );
    }

    static UnitInfo PerformManagedOperationAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {   
        //After being normalised, the operands might require further modifications.
        UnitInfo[] normalised = GetOperandsAddition(firstInfo, secondInfo, operation);

        return PerformManagedOperationNormalisedValues
        (
            firstInfo, normalised, operation
        );
    }

    static UnitInfo[] GetOperandsAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        UnitInfo[] operands2 = new UnitInfo[] 
        {
            new UnitInfo(firstInfo), new UnitInfo(secondInfo)
        };

        if (operands2[0].BaseTenExponent != operands2[1].BaseTenExponent || operands2[0].Prefix.Factor != operands2[1].Prefix.Factor)
        {
            //The addition/subtraction might not be performed right away even with normalised values.
            //For example: 5 and 6 from 5*10^2 and 6*10^7 cannot be added right away.
            operands2 = AdaptNormalisedValuesForAddition
            (
                new UnitInfo[] 
                { 
                    NormaliseUnitInfo(operands2[0]), 
                    NormaliseUnitInfo(operands2[1])
                },
                operation
            );
        }

        return operands2;
    }
    
    static UnitInfo[] AdaptNormalisedValuesForAddition(UnitInfo[] unitInfos2, Operations operation)
    {
        if (unitInfos2[0].BaseTenExponent == unitInfos2[1].BaseTenExponent)
        {
            //Having the same BaseTenExponent values means that the given operation can be performed right away.
            return unitInfos2;
        }

        int[] bigSmallI = 
        (
            unitInfos2[0].BaseTenExponent > unitInfos2[1].BaseTenExponent ?
            new int[] { 0, 1 } : new int[] { 1, 0 }
        );

        //Only the variable with the bigger value is modified. For example: 5*10^5 & 3*10^3 is converted
        //into 500*10^3 & 3*10^3 in order to allow the addition 500 + 3. 
        UnitInfo big2 = AdaptBiggerAdditionOperand(unitInfos2, bigSmallI, operation);
        if (big2.Error.Type != ErrorTypes.None)
        {
            return TooBigGapAddition(unitInfos2, bigSmallI, operation);
        }

        unitInfos2[bigSmallI[0]].Value = big2.Value;
        unitInfos2[bigSmallI[0]].BaseTenExponent = unitInfos2[bigSmallI[1]].BaseTenExponent;

        return unitInfos2;
    }

    //When adding/subtracting two numbers whose gap is bigger than the maximum double range, there
    //is no need to perform any operation (i.e., no change will be observed because of being outside
    //the maximum supported precision). This method takes care of these cases and returns the expected
    //output (i.e., biggest value).
    static UnitInfo[] TooBigGapAddition(UnitInfo[] unitInfos2, int[] bigSmallI, Operations operation)
    {
        UnitInfo[] outInfos = new UnitInfo[] 
        {
            //First operand (i.e., one whose information defines the operation) together with the
            //numeric information (i.e., just Value and BaseTenExponent because both are normalised)
            //which is associated with the biggest one.
            new UnitInfo(unitInfos2[0])
            {{
                Value = unitInfos2[bigSmallI[0]].Value;
                BaseTenExponent = unitInfos2[bigSmallI[0]].BaseTenExponent;
            }}
        };

        if (operation == Operations.Subtraction && bigSmallI[0] == 1)
        {
            outInfos[0].Value = -1.0 * outInfos[0].Value;
        }

        if (outInfos[0].Unit == Units.Unitless)
        {
            outInfos[0].Unit = unitInfos2[bigSmallI[1]].Unit;
        }

        return outInfos;
    }

    static UnitInfo AdaptBiggerAdditionOperand(UnitInfo[] unitInfos2, Integer[] bigSmallI, Operations operation)
    {
        int gapExponent = unitInfos2[bigSmallI[0]].BaseTenExponent - unitInfos2[bigSmallI[1]].BaseTenExponent;
        if (gapExponent >= 27)
        {
            //The difference between both inputs is bigger than (or, at least, very close to) the maximum double value/precision;
            //what makes this situation calculation unworthy and the first operand to be returned as the result.
            //Note that the error below these lines is just an easy way to tell the calling function about this eventuality.
            return new UnitInfo(unitInfos2[0]) 
            {{ 
                Error = new ErrorInfo(ErrorTypes.InvalidOperation); 
            }};
        }

        //PerformManagedOperationValues is used to make sure that the resulting numeric information is stored
        //in Value (if possible).
        UnitInfo big2 = PerformManagedOperationValues
        (
            RaiseToIntegerExponent(10.0, gapExponent), unitInfos2[bigSmallI[0]].Value, 
            Operations.Multiplication                
        );

        boolean isWrong = 
        (
            big2.Error.Type != ErrorTypes.None || big2.BaseTenExponent != 0 ?
            
            //The value of the bigger input times 10^(gap between BaseTenExponent of inputs) is too big. 
            isWrong = true :
            
            //Overflow-check very unlikely to trigger an error. In fact, with properly normalised variables,
            //triggering an error would be plainly impossible.               
            AreAdditionFinalValuesWrong
            (
                unitInfos2[0].Value, unitInfos2[1].Value, operation
            )
        );

        if (isWrong)
        {
        	UnitInfo temp = new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }};
            
            temp.
        }
        
        return
        (
            isWrong ?
            //This error is just an easy way to let the calling function know about the fact that no
            //calculation has been performed (too big gap). This isn't a properly-speaking error and
            //that's why it will not be notified to the user.
            new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }} :
            //Returning the new big value. For example: with 5*10^4 & 3*10^2, 500 would be returned.
            new UnitInfo(unitInfos2[bigSmallI[0]])
            {{
                Value = big2.Value;
            }}
        )
    }

    static boolean AreAdditionFinalValuesWrong(double val1, double val2, Operations operation)
    {
        boolean isWrong = false;

        try
        {
            val1 = val1 + val2 *
            (
                operation == Operations.Addition ? 1 : -1
            );
        }
        catch { isWrong = true; }

        return isWrong;
    }

    static UnitInfo PerformManagedOperationMultiplication(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationNormalisedValues
        (
            firstInfo, new UnitInfo[] 
            { 
                NormaliseUnitInfo(firstInfo),
                NormaliseUnitInfo(secondInfo) 
            },
            operation
        );
    }

    public static UnitInfo RaiseToIntegerExponent(double baseValue, int exponent)
    {
        return RaiseToIntegerExponent(new UnitInfo(baseValue), exponent);
    }

    static UnitInfo RaiseToIntegerExponent(UnitInfo baseInfo, int exponent)
    {
        if (exponent <= 1 && exponent >= 0)
        {
            baseInfo.Value = (exponent == 0 ? 1.0 : baseInfo.Value);
            return baseInfo;
        }

        UnitInfo outInfo = new UnitInfo(baseInfo);

        for (int i = 1; i < Math.Abs(exponent); i++)
        {
            outInfo = PerformManagedOperationValues
            (
                outInfo, baseInfo, Operations.Multiplication
            );
            if (outInfo.Error.Type != ErrorTypes.None) return outInfo;
        }

        return
        (
            exponent < 0 ?
            PerformManagedOperationValues(new UnitInfo(1.0), outInfo, Operations.Division) :
            outInfo
        );
    }

    static UnitInfo PerformManagedOperationNormalisedValues(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        outInfo =
        (
            normalisedInfos.Length == 1 ?
            //There is just one operand when the difference between both of them is too big.
            outInfo = normalisedInfos[0] :
            PerformManagedOperationTwoOperands(outInfo, normalisedInfos, operation)
        );

        return outInfo;
    }

    static UnitInfo PerformManagedOperationTwoOperands(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        UnitInfo outInfoNormalised = PerformManagedOperationValues
        (
            normalisedInfos[0], normalisedInfos[1], operation
        );

        if (outInfo.Error.Type != ErrorTypes.None)
        {
            return new UnitInfo(outInfo)
            {
                Error = new ErrorInfo(ErrorTypes.NumericError)
            };
        }

        outInfo.BaseTenExponent = outInfoNormalised.BaseTenExponent;
        outInfo.Value = outInfoNormalised.Value;
        //Normalised means no prefixes.
        outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage); 

        return outInfo;
    }

    static UnitInfo PerformManagedOperationValues(double firstValue, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            new UnitInfo(firstValue), new UnitInfo(secondValue), operation
        );
    }

    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            firstInfo, new UnitInfo(secondValue), operation
        );
    }

    //This method might be used to perform full operations (not just being the last calculation step) instead
    //of the default one (PerformManagedOperationUnits) for simple cases. That is: ones not dealing with the
    //complex numeric reality (Value, Prefix and BaseTenExponent) which makes a pre-analysis required.
    //Note that, unlikely what happens with PerformMangedOperationUnits, the outputs of this method aren't
    //normalised (= primarily stored under Value), what is useful in certain contexts.
    //NOTE: this function assumes that both inputs are normalised, what means that no prefix information is expected.
    //It might also be used with non-normalised inputs, but their prefix information would be plainly ignored.
    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        if (firstInfo.Value == 0.0 || secondInfo.Value == 0.0)
        {
            if (operation == Operations.Multiplication || operation == Operations.Division)
            {
                //Dividing by zero scenarios are taken into account somewhere else.
                return new UnitInfo(firstInfo) { Value = 0.0 };
            }
        }

        UnitInfo outInfo = new UnitInfo(firstInfo);
        UnitInfo firstInfo0 = new UnitInfo(firstInfo);
        UnitInfo secondInfo0 = new UnitInfo(secondInfo);

        boolean isWrong = false;
        try
        {
            if (operation == Operations.Addition)
            {
                outInfo.Value += secondInfo0.Value;
            }
            else if (operation == Operations.Subtraction)
            {
                outInfo.Value -= secondInfo.Value;
            }
            else
            {
                //The reason for checking whether BaseTenExponent is inside/outside the int range before performing 
                //the operation (rather than going ahead and eventually catching the resulting exception) isn't just
                //being quicker, but also the only option in many situations. Note that an addition/subtraction between
                //two int variables whose result is outside the int range might not trigger an exception (+ random 
                //negative value as output).
                if (VaryBaseTenExponent(outInfo, secondInfo0.BaseTenExponent, operation == Operations.Division).Error.Type != ErrorTypes.None)
                {
                    return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
                }

                if (operation == Operations.Multiplication)
                {
                    outInfo.Value *= secondInfo.Value;
                    outInfo.BaseTenExponent += secondInfo.BaseTenExponent;
                }
                else if (operation == Operations.Division)
                {
                    if (secondInfo.Value == 0.0)
                    {
                        return
                        (
                            new UnitInfo(outInfo) 
                            { 
                                Error = new ErrorInfo(ErrorTypes.NumericError) 
                            }
                        );
                    }
                    outInfo.Value /= secondInfo.Value;
                    outInfo.BaseTenExponent -= secondInfo.BaseTenExponent;
                }
            }
        }
        catch { isWrong = true; }

        return
        (
            //An error might not be triggered despite of dealing with numbers outside double precision.
            //For example: 0.00000000000000000001m * 0.0000000000000000000001m can output 0.0 without triggering an error. 
            isWrong || ((operation == Operations.Multiplication || operation == Operations.Division) && outInfo.Value == 0.0.0) ?
            OperationValuesManageError(firstInfo0, secondInfo0, operation) : outInfo
        );
    }

    static UnitInfo OperationValuesManageError(UnitInfo outInfo, UnitInfo secondInfo, Operations operation)
    {
        if (operation != Operations.Multiplication && operation != Operations.Division)
        {
            //This condition should never be true on account of the fact that the pre-modifications performed before
            //adding/subtracting should avoid erroneous situations.
            return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
        }

        UnitInfo secondInfo2 = ConvertValueToBaseTen(secondInfo.Value);
        outInfo = VaryBaseTenExponent(outInfo, secondInfo2.BaseTenExponent, operation == Operations.Division);
        if (Math.Abs(secondInfo2.Value) == 1.0 || outInfo.Error.Type != ErrorTypes.None) return outInfo;
        
        try
        {
            outInfo = PerformManagedOperationUnits
            (
                outInfo, secondInfo2.Value, operation
            );
        }
        catch
        {
            //Very unlikely scenario on account of the fact that Math.Abs(secondInfo2.Value)
            //lies within the 0.1-10.0 range.
            outInfo = OperationValuesManageError
            (
                new UnitInfo(outInfo)
                {
                    Value = secondInfo2.Value,
                    BaseTenExponent = 0
                },
                new UnitInfo()
                {
                    Value = outInfo.Value,
                    BaseTenExponent = outInfo.BaseTenExponent
                },
                operation
            );
        }

        return outInfo;
    }

    static UnitInfo ConvertValueToBaseTen(double value)
    {
        value = Math.Abs(value);
        return FromValueToBaseTenExponent
        (
             new UnitInfo(value), Math.Abs(value), false
        );
    }

    static UnitInfo ConvertBaseTenToValue(UnitInfo unitInfo)
    {
        if (unitInfo.BaseTenExponent == 0) return unitInfo;

        UnitInfo outInfo = new UnitInfo(unitInfo);
        boolean decrease = unitInfo.BaseTenExponent > 0;
        int sign = Math.Sign(outInfo.Value);
        double absValue = Math.Abs(outInfo.Value);

        while (outInfo.BaseTenExponent != 0.0)
        {
            if (decrease)
            {
                if (absValue >= MaxValueDec / 10.0) break;
                absValue *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }
            else
            {
                if (absValue <= MinValueDec * 10.0) break;
                absValue /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
        }

        outInfo.Value = sign * absValue;

        return outInfo;
    }

    static UnitInfo NormaliseUnitInfo(UnitInfo unitInfo)
    {
        if (unitInfo.Value == 0 && unitInfo.Prefix.Factor == 1.0)
        {
            return unitInfo;
        }
        UnitInfo outInfo = new UnitInfo(unitInfo);

        if (outInfo.Prefix.Factor != 1)
        {
            outInfo = FromValueToBaseTenExponent
            (
                outInfo, outInfo.Prefix.Factor, true
            );
            outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage);
        }
        if (outInfo.Value == 0.0) return outInfo;

        outInfo = FromValueToBaseTenExponent
        (
            outInfo, outInfo.Value, false
        );

        return outInfo;
    }

    static UnitInfo FromValueToBaseTenExponent(UnitInfo outInfo, double value, boolean isPrefix)
    {
        if (value == 0.0) return outInfo;

        double valueAbs = Math.Abs(value);
        boolean decrease = (valueAbs > 1.0);
        if (!isPrefix)
        {
            outInfo.Value = outInfo.Value / valueAbs;
        }

        while (valueAbs != 1.0)
        {
            if ((valueAbs < 10.0 && valueAbs > 1.0) || (valueAbs > 0.1.0 && valueAbs < 1.0))
            {
                if (!isPrefix) outInfo.Value = value;
                else
                {
                    outInfo = PerformManagedOperationValues
                    (
                        outInfo, value, Operations.Multiplication
                    );
                }

                return outInfo;
            }

            if (decrease)
            {
                value /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
            else
            {
                value *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }

            valueAbs = Math.Abs(value);
        }

        return outInfo;
    }

    //Method used to vary BaseTenExponent without provoking unhandled exceptions (i.e., bigger than Integer.MAX_VALUE).
    static UnitInfo VaryBaseTenExponent(UnitInfo info, int baseTenIncrease, boolean isDivision = false)
    {
        long val1 = info.BaseTenExponent;
        long val2 = baseTenIncrease;

        if (isDivision)
        {
            //Converting a negative value into positive might provoke an overflow error for the int type
            //(e.g., Math.Abs(Integer.MAIN_VALUE)). Converting both variables to long is a quick and effective
            //way to avoid this problem.
            val2 *= -1;
        }

        return
        (
             ((val2 > 0 && val1 > Integer.MAX_VALUE - val2) || (val2 < 0 && val1 < Integer.MAIN_VALUE - val2)) ?
            new UnitInfo(info, ErrorTypes.NumericError) : new UnitInfo(info){{ BaseTenExponent = (int)(val1 + val2); }}
        );
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 2 2017-05-27 20:04:57.947
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 0 2017-05-27 20:04:57.947
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.core 4 4 2017-05-27 20:04:58.061
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
public class OperationsManaged
{
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, double second, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            firstInfo, new UnitInfo(second), operation
        );
    }

    public static UnitInfo PerformManagedOperationUnits(double first, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            new UnitInfo(first), secondInfo, operation
        );
    }

    //This method should always be used when dealing with random UnitInfo variables because it accounts for all the
    //possible scenarios. On the other hand, with simple operations (e.g., random UnitInfo & numeric type) it might
    //be better to use PerformManagedOperationValues. 
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        ErrorTypes errorType = InternalMethods.GetOperationError
        (
            firstInfo, secondInfo, operation
        );
        if (errorType != ErrorTypes.None)
        {
            return new UnitInfo(firstInfo) 
            {{
                Error = new ErrorInfo(errorType); 
            }};
        }

        return
        (
            operation == Operations.Addition || operation == Operations.Subtraction ?
            PerformManagedOperationAddition(firstInfo, secondInfo, operation) :
            PerformManagedOperationMultiplication(firstInfo, secondInfo, operation)
        );
    }

    static UnitInfo PerformManagedOperationAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {   
        //After being normalised, the operands might require further modifications.
        UnitInfo[] normalised = GetOperandsAddition(firstInfo, secondInfo, operation);

        return PerformManagedOperationNormalisedValues
        (
            firstInfo, normalised, operation
        );
    }

    static UnitInfo[] GetOperandsAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        UnitInfo[] operands2 = new UnitInfo[] 
        {
            new UnitInfo(firstInfo), new UnitInfo(secondInfo)
        };

        if (operands2[0].BaseTenExponent != operands2[1].BaseTenExponent || operands2[0].Prefix.Factor != operands2[1].Prefix.Factor)
        {
            //The addition/subtraction might not be performed right away even with normalised values.
            //For example: 5 and 6 from 5*10^2 and 6*10^7 cannot be added right away.
            operands2 = AdaptNormalisedValuesForAddition
            (
                new UnitInfo[] 
                { 
                    NormaliseUnitInfo(operands2[0]), 
                    NormaliseUnitInfo(operands2[1])
                },
                operation
            );
        }

        return operands2;
    }
    
    static UnitInfo[] AdaptNormalisedValuesForAddition(UnitInfo[] unitInfos2, Operations operation)
    {
        if (unitInfos2[0].BaseTenExponent == unitInfos2[1].BaseTenExponent)
        {
            //Having the same BaseTenExponent values means that the given operation can be performed right away.
            return unitInfos2;
        }

        int[] bigSmallI = 
        (
            unitInfos2[0].BaseTenExponent > unitInfos2[1].BaseTenExponent ?
            new int[] { 0, 1 } : new int[] { 1, 0 }
        );

        //Only the variable with the bigger value is modified. For example: 5*10^5 & 3*10^3 is converted
        //into 500*10^3 & 3*10^3 in order to allow the addition 500 + 3. 
        UnitInfo big2 = AdaptBiggerAdditionOperand(unitInfos2, bigSmallI, operation);
        if (big2.Error.Type != ErrorTypes.None)
        {
            return TooBigGapAddition(unitInfos2, bigSmallI, operation);
        }

        unitInfos2[bigSmallI[0]].Value = big2.Value;
        unitInfos2[bigSmallI[0]].BaseTenExponent = unitInfos2[bigSmallI[1]].BaseTenExponent;

        return unitInfos2;
    }

    //When adding/subtracting two numbers whose gap is bigger than the maximum double range, there
    //is no need to perform any operation (i.e., no change will be observed because of being outside
    //the maximum supported precision). This method takes care of these cases and returns the expected
    //output (i.e., biggest value).
    static UnitInfo[] TooBigGapAddition(UnitInfo[] unitInfos2, int[] bigSmallI, Operations operation)
    {
        UnitInfo[] outInfos = new UnitInfo[] 
        {
            //First operand (i.e., one whose information defines the operation) together with the
            //numeric information (i.e., just Value and BaseTenExponent because both are normalised)
            //which is associated with the biggest one.
            new UnitInfo(unitInfos2[0])
            {{
                Value = unitInfos2[bigSmallI[0]].Value;
                BaseTenExponent = unitInfos2[bigSmallI[0]].BaseTenExponent;
            }}
        };

        if (operation == Operations.Subtraction && bigSmallI[0] == 1)
        {
            outInfos[0].Value = -1.0 * outInfos[0].Value;
        }

        if (outInfos[0].Unit == Units.Unitless)
        {
            outInfos[0].Unit = unitInfos2[bigSmallI[1]].Unit;
        }

        return outInfos;
    }

    static UnitInfo AdaptBiggerAdditionOperand(UnitInfo[] unitInfos2, Integer[] bigSmallI, Operations operation)
    {
        int gapExponent = unitInfos2[bigSmallI[0]].BaseTenExponent - unitInfos2[bigSmallI[1]].BaseTenExponent;
        if (gapExponent >= 27)
        {
            //The difference between both inputs is bigger than (or, at least, very close to) the maximum double value/precision;
            //what makes this situation calculation unworthy and the first operand to be returned as the result.
            //Note that the error below these lines is just an easy way to tell the calling function about this eventuality.
            return new UnitInfo(unitInfos2[0]) 
            {{ 
                Error = new ErrorInfo(ErrorTypes.InvalidOperation); 
            }};
        }

        //PerformManagedOperationValues is used to make sure that the resulting numeric information is stored
        //in Value (if possible).
        UnitInfo big2 = PerformManagedOperationValues
        (
            RaiseToIntegerExponent(10.0, gapExponent), unitInfos2[bigSmallI[0]].Value, 
            Operations.Multiplication                
        );

        boolean isWrong = 
        (
            big2.Error.Type != ErrorTypes.None || big2.BaseTenExponent != 0 ?
            
            //The value of the bigger input times 10^(gap between BaseTenExponent of inputs) is too big. 
            isWrong = true :
            
            //Overflow-check very unlikely to trigger an error. In fact, with properly normalised variables,
            //triggering an error would be plainly impossible.               
            AreAdditionFinalValuesWrong
            (
                unitInfos2[0].Value, unitInfos2[1].Value, operation
            )
        );

        if (isWrong)
        {
        	UnitInfo temp = new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }};
            
            temp.
        }
        
        return
        (
            isWrong ?
            //This error is just an easy way to let the calling function know about the fact that no
            //calculation has been performed (too big gap). This isn't a properly-speaking error and
            //that's why it will not be notified to the user.
            new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }} :
            //Returning the new big value. For example: with 5*10^4 & 3*10^2, 500 would be returned.
            new UnitInfo(unitInfos2[bigSmallI[0]])
            {{
                Value = big2.Value;
            }}
        )
    }

    static boolean AreAdditionFinalValuesWrong(double val1, double val2, Operations operation)
    {
        boolean isWrong = false;

        try
        {
            val1 = val1 + val2 *
            (
                operation == Operations.Addition ? 1 : -1
            );
        }
        catch { isWrong = true; }

        return isWrong;
    }

    static UnitInfo PerformManagedOperationMultiplication(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationNormalisedValues
        (
            firstInfo, new UnitInfo[] 
            { 
                NormaliseUnitInfo(firstInfo),
                NormaliseUnitInfo(secondInfo) 
            },
            operation
        );
    }

    public static UnitInfo RaiseToIntegerExponent(double baseValue, int exponent)
    {
        return RaiseToIntegerExponent(new UnitInfo(baseValue), exponent);
    }

    static UnitInfo RaiseToIntegerExponent(UnitInfo baseInfo, int exponent)
    {
        if (exponent <= 1 && exponent >= 0)
        {
            baseInfo.Value = (exponent == 0 ? 1.0 : baseInfo.Value);
            return baseInfo;
        }

        UnitInfo outInfo = new UnitInfo(baseInfo);

        for (int i = 1; i < Math.Abs(exponent); i++)
        {
            outInfo = PerformManagedOperationValues
            (
                outInfo, baseInfo, Operations.Multiplication
            );
            if (outInfo.Error.Type != ErrorTypes.None) return outInfo;
        }

        return
        (
            exponent < 0 ?
            PerformManagedOperationValues(new UnitInfo(1.0), outInfo, Operations.Division) :
            outInfo
        );
    }

    static UnitInfo PerformManagedOperationNormalisedValues(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        outInfo =
        (
            normalisedInfos.Length == 1 ?
            //There is just one operand when the difference between both of them is too big.
            outInfo = normalisedInfos[0] :
            PerformManagedOperationTwoOperands(outInfo, normalisedInfos, operation)
        );

        return outInfo;
    }

    static UnitInfo PerformManagedOperationTwoOperands(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        UnitInfo outInfoNormalised = PerformManagedOperationValues
        (
            normalisedInfos[0], normalisedInfos[1], operation
        );

        if (outInfo.Error.Type != ErrorTypes.None)
        {
            return new UnitInfo(outInfo)
            {
                Error = new ErrorInfo(ErrorTypes.NumericError)
            };
        }

        outInfo.BaseTenExponent = outInfoNormalised.BaseTenExponent;
        outInfo.Value = outInfoNormalised.Value;
        //Normalised means no prefixes.
        outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage); 

        return outInfo;
    }

    static UnitInfo PerformManagedOperationValues(double firstValue, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            new UnitInfo(firstValue), new UnitInfo(secondValue), operation
        );
    }

    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            firstInfo, new UnitInfo(secondValue), operation
        );
    }

    //This method might be used to perform full operations (not just being the last calculation step) instead
    //of the default one (PerformManagedOperationUnits) for simple cases. That is: ones not dealing with the
    //complex numeric reality (Value, Prefix and BaseTenExponent) which makes a pre-analysis required.
    //Note that, unlikely what happens with PerformMangedOperationUnits, the outputs of this method aren't
    //normalised (= primarily stored under Value), what is useful in certain contexts.
    //NOTE: this function assumes that both inputs are normalised, what means that no prefix information is expected.
    //It might also be used with non-normalised inputs, but their prefix information would be plainly ignored.
    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        if (firstInfo.Value == 0.0 || secondInfo.Value == 0.0)
        {
            if (operation == Operations.Multiplication || operation == Operations.Division)
            {
                //Dividing by zero scenarios are taken into account somewhere else.
                return new UnitInfo(firstInfo) { Value = 0.0 };
            }
        }

        UnitInfo outInfo = new UnitInfo(firstInfo);
        UnitInfo firstInfo0 = new UnitInfo(firstInfo);
        UnitInfo secondInfo0 = new UnitInfo(secondInfo);

        boolean isWrong = false;
        try
        {
            if (operation == Operations.Addition)
            {
                outInfo.Value += secondInfo0.Value;
            }
            else if (operation == Operations.Subtraction)
            {
                outInfo.Value -= secondInfo.Value;
            }
            else
            {
                //The reason for checking whether BaseTenExponent is inside/outside the int range before performing 
                //the operation (rather than going ahead and eventually catching the resulting exception) isn't just
                //being quicker, but also the only option in many situations. Note that an addition/subtraction between
                //two int variables whose result is outside the int range might not trigger an exception (+ random 
                //negative value as output).
                if (VaryBaseTenExponent(outInfo, secondInfo0.BaseTenExponent, operation == Operations.Division).Error.Type != ErrorTypes.None)
                {
                    return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
                }

                if (operation == Operations.Multiplication)
                {
                    outInfo.Value *= secondInfo.Value;
                    outInfo.BaseTenExponent += secondInfo.BaseTenExponent;
                }
                else if (operation == Operations.Division)
                {
                    if (secondInfo.Value == 0.0)
                    {
                        return
                        (
                            new UnitInfo(outInfo) 
                            { 
                                Error = new ErrorInfo(ErrorTypes.NumericError) 
                            }
                        );
                    }
                    outInfo.Value /= secondInfo.Value;
                    outInfo.BaseTenExponent -= secondInfo.BaseTenExponent;
                }
            }
        }
        catch { isWrong = true; }

        return
        (
            //An error might not be triggered despite of dealing with numbers outside double precision.
            //For example: 0.00000000000000000001m * 0.0000000000000000000001m can output 0.0 without triggering an error. 
            isWrong || ((operation == Operations.Multiplication || operation == Operations.Division) && outInfo.Value == 0.0.0) ?
            OperationValuesManageError(firstInfo0, secondInfo0, operation) : outInfo
        );
    }

    static UnitInfo OperationValuesManageError(UnitInfo outInfo, UnitInfo secondInfo, Operations operation)
    {
        if (operation != Operations.Multiplication && operation != Operations.Division)
        {
            //This condition should never be true on account of the fact that the pre-modifications performed before
            //adding/subtracting should avoid erroneous situations.
            return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
        }

        UnitInfo secondInfo2 = ConvertValueToBaseTen(secondInfo.Value);
        outInfo = VaryBaseTenExponent(outInfo, secondInfo2.BaseTenExponent, operation == Operations.Division);
        if (Math.Abs(secondInfo2.Value) == 1.0 || outInfo.Error.Type != ErrorTypes.None) return outInfo;
        
        try
        {
            outInfo = PerformManagedOperationUnits
            (
                outInfo, secondInfo2.Value, operation
            );
        }
        catch
        {
            //Very unlikely scenario on account of the fact that Math.Abs(secondInfo2.Value)
            //lies within the 0.1-10.0 range.
            outInfo = OperationValuesManageError
            (
                new UnitInfo(outInfo)
                {
                    Value = secondInfo2.Value,
                    BaseTenExponent = 0
                },
                new UnitInfo()
                {
                    Value = outInfo.Value,
                    BaseTenExponent = outInfo.BaseTenExponent
                },
                operation
            );
        }

        return outInfo;
    }

    static UnitInfo ConvertValueToBaseTen(double value)
    {
        value = Math.Abs(value);
        return FromValueToBaseTenExponent
        (
             new UnitInfo(value), Math.Abs(value), false
        );
    }

    static UnitInfo ConvertBaseTenToValue(UnitInfo unitInfo)
    {
        if (unitInfo.BaseTenExponent == 0) return unitInfo;

        UnitInfo outInfo = new UnitInfo(unitInfo);
        boolean decrease = unitInfo.BaseTenExponent > 0;
        int sign = Math.Sign(outInfo.Value);
        double absValue = Math.Abs(outInfo.Value);

        while (outInfo.BaseTenExponent != 0.0)
        {
            if (decrease)
            {
                if (absValue >= MaxValueDec / 10.0) break;
                absValue *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }
            else
            {
                if (absValue <= MinValueDec * 10.0) break;
                absValue /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
        }

        outInfo.Value = sign * absValue;

        return outInfo;
    }

    static UnitInfo NormaliseUnitInfo(UnitInfo unitInfo)
    {
        if (unitInfo.Value == 0 && unitInfo.Prefix.Factor == 1.0)
        {
            return unitInfo;
        }
        UnitInfo outInfo = new UnitInfo(unitInfo);

        if (outInfo.Prefix.Factor != 1)
        {
            outInfo = FromValueToBaseTenExponent
            (
                outInfo, outInfo.Prefix.Factor, true
            );
            outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage);
        }
        if (outInfo.Value == 0.0) return outInfo;

        outInfo = FromValueToBaseTenExponent
        (
            outInfo, outInfo.Value, false
        );

        return outInfo;
    }

    static UnitInfo FromValueToBaseTenExponent(UnitInfo outInfo, double value, boolean isPrefix)
    {
        if (value == 0.0) return outInfo;

        double valueAbs = Math.Abs(value);
        boolean decrease = (valueAbs > 1.0);
        if (!isPrefix)
        {
            outInfo.Value = outInfo.Value / valueAbs;
        }

        while (valueAbs != 1.0)
        {
            if ((valueAbs < 10.0 && valueAbs > 1.0) || (valueAbs > 0.1.0 && valueAbs < 1.0))
            {
                if (!isPrefix) outInfo.Value = value;
                else
                {
                    outInfo = PerformManagedOperationValues
                    (
                        outInfo, value, Operations.Multiplication
                    );
                }

                return outInfo;
            }

            if (decrease)
            {
                value /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
            else
            {
                value *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }

            valueAbs = Math.Abs(value);
        }

        return outInfo;
    }

    //Method used to vary BaseTenExponent without provoking unhandled exceptions (i.e., bigger than Integer.MAX_VALUE).
    static UnitInfo VaryBaseTenExponent(UnitInfo info, int baseTenIncrease, boolean isDivision = false)
    {
        long val1 = info.BaseTenExponent;
        long val2 = baseTenIncrease;

        if (isDivision)
        {
            //Converting a negative value into positive might provoke an overflow error for the int type
            //(e.g., Math.Abs(Integer.MAIN_VALUE)). Converting both variables to long is a quick and effective
            //way to avoid this problem.
            val2 *= -1;
        }

        return
        (
             ((val2 > 0 && val1 > Integer.MAX_VALUE - val2) || (val2 < 0 && val1 < Integer.MAIN_VALUE - val2)) ?
            new UnitInfo(info, ErrorTypes.NumericError) : new UnitInfo(info){{ BaseTenExponent = (int)(val1 + val2); }}
        );
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.recommenders.rcp.utils.JdtUtils.findAstNodeFromEditorSelection(JdtUtils.java:669)
	at org.eclipse.recommenders.internal.rcp.JavaElementSelectionService.handleSelectionInEditor(JavaElementSelectionService.java:110)
	at org.eclipse.recommenders.internal.rcp.JavaElementSelectionService.access$1(JavaElementSelectionService.java:105)
	at org.eclipse.recommenders.internal.rcp.JavaElementSelectionService$1.run(JavaElementSelectionService.java:82)
	at java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source)
	at java.util.concurrent.FutureTask.run(Unknown Source)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(Unknown Source)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(Unknown Source)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source)
	at java.lang.Thread.run(Unknown Source)

!ENTRY org.eclipse.jdt.ui 4 2 2017-05-27 20:04:58.063
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.recommenders.rcp.utils.JdtUtils.findAstNodeFromEditorSelection(JdtUtils.java:669)
	at org.eclipse.recommenders.internal.rcp.JavaElementSelectionService.handleSelectionInEditor(JavaElementSelectionService.java:110)
	at org.eclipse.recommenders.internal.rcp.JavaElementSelectionService.access$1(JavaElementSelectionService.java:105)
	at org.eclipse.recommenders.internal.rcp.JavaElementSelectionService$1.run(JavaElementSelectionService.java:82)
	at java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source)
	at java.util.concurrent.FutureTask.run(Unknown Source)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(Unknown Source)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(Unknown Source)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source)
	at java.lang.Thread.run(Unknown Source)

!ENTRY org.eclipse.jdt.ui 4 0 2017-05-27 20:04:58.063
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.recommenders.rcp.utils.JdtUtils.findAstNodeFromEditorSelection(JdtUtils.java:669)
	at org.eclipse.recommenders.internal.rcp.JavaElementSelectionService.handleSelectionInEditor(JavaElementSelectionService.java:110)
	at org.eclipse.recommenders.internal.rcp.JavaElementSelectionService.access$1(JavaElementSelectionService.java:105)
	at org.eclipse.recommenders.internal.rcp.JavaElementSelectionService$1.run(JavaElementSelectionService.java:82)
	at java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source)
	at java.util.concurrent.FutureTask.run(Unknown Source)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(Unknown Source)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(Unknown Source)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source)
	at java.lang.Thread.run(Unknown Source)

!ENTRY org.eclipse.jdt.core 4 4 2017-05-27 20:04:58.547
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
public class OperationsManaged
{
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, double second, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            firstInfo, new UnitInfo(second), operation
        );
    }

    public static UnitInfo PerformManagedOperationUnits(double first, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            new UnitInfo(first), secondInfo, operation
        );
    }

    //This method should always be used when dealing with random UnitInfo variables because it accounts for all the
    //possible scenarios. On the other hand, with simple operations (e.g., random UnitInfo & numeric type) it might
    //be better to use PerformManagedOperationValues. 
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        ErrorTypes errorType = InternalMethods.GetOperationError
        (
            firstInfo, secondInfo, operation
        );
        if (errorType != ErrorTypes.None)
        {
            return new UnitInfo(firstInfo) 
            {{
                Error = new ErrorInfo(errorType); 
            }};
        }

        return
        (
            operation == Operations.Addition || operation == Operations.Subtraction ?
            PerformManagedOperationAddition(firstInfo, secondInfo, operation) :
            PerformManagedOperationMultiplication(firstInfo, secondInfo, operation)
        );
    }

    static UnitInfo PerformManagedOperationAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {   
        //After being normalised, the operands might require further modifications.
        UnitInfo[] normalised = GetOperandsAddition(firstInfo, secondInfo, operation);

        return PerformManagedOperationNormalisedValues
        (
            firstInfo, normalised, operation
        );
    }

    static UnitInfo[] GetOperandsAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        UnitInfo[] operands2 = new UnitInfo[] 
        {
            new UnitInfo(firstInfo), new UnitInfo(secondInfo)
        };

        if (operands2[0].BaseTenExponent != operands2[1].BaseTenExponent || operands2[0].Prefix.Factor != operands2[1].Prefix.Factor)
        {
            //The addition/subtraction might not be performed right away even with normalised values.
            //For example: 5 and 6 from 5*10^2 and 6*10^7 cannot be added right away.
            operands2 = AdaptNormalisedValuesForAddition
            (
                new UnitInfo[] 
                { 
                    NormaliseUnitInfo(operands2[0]), 
                    NormaliseUnitInfo(operands2[1])
                },
                operation
            );
        }

        return operands2;
    }
    
    static UnitInfo[] AdaptNormalisedValuesForAddition(UnitInfo[] unitInfos2, Operations operation)
    {
        if (unitInfos2[0].BaseTenExponent == unitInfos2[1].BaseTenExponent)
        {
            //Having the same BaseTenExponent values means that the given operation can be performed right away.
            return unitInfos2;
        }

        int[] bigSmallI = 
        (
            unitInfos2[0].BaseTenExponent > unitInfos2[1].BaseTenExponent ?
            new int[] { 0, 1 } : new int[] { 1, 0 }
        );

        //Only the variable with the bigger value is modified. For example: 5*10^5 & 3*10^3 is converted
        //into 500*10^3 & 3*10^3 in order to allow the addition 500 + 3. 
        UnitInfo big2 = AdaptBiggerAdditionOperand(unitInfos2, bigSmallI, operation);
        if (big2.Error.Type != ErrorTypes.None)
        {
            return TooBigGapAddition(unitInfos2, bigSmallI, operation);
        }

        unitInfos2[bigSmallI[0]].Value = big2.Value;
        unitInfos2[bigSmallI[0]].BaseTenExponent = unitInfos2[bigSmallI[1]].BaseTenExponent;

        return unitInfos2;
    }

    //When adding/subtracting two numbers whose gap is bigger than the maximum double range, there
    //is no need to perform any operation (i.e., no change will be observed because of being outside
    //the maximum supported precision). This method takes care of these cases and returns the expected
    //output (i.e., biggest value).
    static UnitInfo[] TooBigGapAddition(UnitInfo[] unitInfos2, int[] bigSmallI, Operations operation)
    {
        UnitInfo[] outInfos = new UnitInfo[] 
        {
            //First operand (i.e., one whose information defines the operation) together with the
            //numeric information (i.e., just Value and BaseTenExponent because both are normalised)
            //which is associated with the biggest one.
            new UnitInfo(unitInfos2[0])
            {{
                Value = unitInfos2[bigSmallI[0]].Value;
                BaseTenExponent = unitInfos2[bigSmallI[0]].BaseTenExponent;
            }}
        };

        if (operation == Operations.Subtraction && bigSmallI[0] == 1)
        {
            outInfos[0].Value = -1.0 * outInfos[0].Value;
        }

        if (outInfos[0].Unit == Units.Unitless)
        {
            outInfos[0].Unit = unitInfos2[bigSmallI[1]].Unit;
        }

        return outInfos;
    }

    static UnitInfo AdaptBiggerAdditionOperand(UnitInfo[] unitInfos2, Integer[] bigSmallI, Operations operation)
    {
        int gapExponent = unitInfos2[bigSmallI[0]].BaseTenExponent - unitInfos2[bigSmallI[1]].BaseTenExponent;
        if (gapExponent >= 27)
        {
            //The difference between both inputs is bigger than (or, at least, very close to) the maximum double value/precision;
            //what makes this situation calculation unworthy and the first operand to be returned as the result.
            //Note that the error below these lines is just an easy way to tell the calling function about this eventuality.
            return new UnitInfo(unitInfos2[0]) 
            {{ 
                Error = new ErrorInfo(ErrorTypes.InvalidOperation); 
            }};
        }

        //PerformManagedOperationValues is used to make sure that the resulting numeric information is stored
        //in Value (if possible).
        UnitInfo big2 = PerformManagedOperationValues
        (
            RaiseToIntegerExponent(10.0, gapExponent), unitInfos2[bigSmallI[0]].Value, 
            Operations.Multiplication                
        );

        boolean isWrong = 
        (
            big2.Error.Type != ErrorTypes.None || big2.BaseTenExponent != 0 ?
            
            //The value of the bigger input times 10^(gap between BaseTenExponent of inputs) is too big. 
            isWrong = true :
            
            //Overflow-check very unlikely to trigger an error. In fact, with properly normalised variables,
            //triggering an error would be plainly impossible.               
            AreAdditionFinalValuesWrong
            (
                unitInfos2[0].Value, unitInfos2[1].Value, operation
            )
        );

        if (isWrong)
        {
        	UnitInfo temp = new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }};
            
            temp.
        }
        
        return
        (
            isWrong ?
            //This error is just an easy way to let the calling function know about the fact that no
            //calculation has been performed (too big gap). This isn't a properly-speaking error and
            //that's why it will not be notified to the user.
            new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }} :
            //Returning the new big value. For example: with 5*10^4 & 3*10^2, 500 would be returned.
            new UnitInfo(unitInfos2[bigSmallI[0]])
            {{
                Value = big2.Value;
            }}
        )
    }

    static boolean AreAdditionFinalValuesWrong(double val1, double val2, Operations operation)
    {
        boolean isWrong = false;

        try
        {
            val1 = val1 + val2 *
            (
                operation == Operations.Addition ? 1 : -1
            );
        }
        catch { isWrong = true; }

        return isWrong;
    }

    static UnitInfo PerformManagedOperationMultiplication(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationNormalisedValues
        (
            firstInfo, new UnitInfo[] 
            { 
                NormaliseUnitInfo(firstInfo),
                NormaliseUnitInfo(secondInfo) 
            },
            operation
        );
    }

    public static UnitInfo RaiseToIntegerExponent(double baseValue, int exponent)
    {
        return RaiseToIntegerExponent(new UnitInfo(baseValue), exponent);
    }

    static UnitInfo RaiseToIntegerExponent(UnitInfo baseInfo, int exponent)
    {
        if (exponent <= 1 && exponent >= 0)
        {
            baseInfo.Value = (exponent == 0 ? 1.0 : baseInfo.Value);
            return baseInfo;
        }

        UnitInfo outInfo = new UnitInfo(baseInfo);

        for (int i = 1; i < Math.Abs(exponent); i++)
        {
            outInfo = PerformManagedOperationValues
            (
                outInfo, baseInfo, Operations.Multiplication
            );
            if (outInfo.Error.Type != ErrorTypes.None) return outInfo;
        }

        return
        (
            exponent < 0 ?
            PerformManagedOperationValues(new UnitInfo(1.0), outInfo, Operations.Division) :
            outInfo
        );
    }

    static UnitInfo PerformManagedOperationNormalisedValues(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        outInfo =
        (
            normalisedInfos.Length == 1 ?
            //There is just one operand when the difference between both of them is too big.
            outInfo = normalisedInfos[0] :
            PerformManagedOperationTwoOperands(outInfo, normalisedInfos, operation)
        );

        return outInfo;
    }

    static UnitInfo PerformManagedOperationTwoOperands(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        UnitInfo outInfoNormalised = PerformManagedOperationValues
        (
            normalisedInfos[0], normalisedInfos[1], operation
        );

        if (outInfo.Error.Type != ErrorTypes.None)
        {
            return new UnitInfo(outInfo)
            {
                Error = new ErrorInfo(ErrorTypes.NumericError)
            };
        }

        outInfo.BaseTenExponent = outInfoNormalised.BaseTenExponent;
        outInfo.Value = outInfoNormalised.Value;
        //Normalised means no prefixes.
        outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage); 

        return outInfo;
    }

    static UnitInfo PerformManagedOperationValues(double firstValue, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            new UnitInfo(firstValue), new UnitInfo(secondValue), operation
        );
    }

    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            firstInfo, new UnitInfo(secondValue), operation
        );
    }

    //This method might be used to perform full operations (not just being the last calculation step) instead
    //of the default one (PerformManagedOperationUnits) for simple cases. That is: ones not dealing with the
    //complex numeric reality (Value, Prefix and BaseTenExponent) which makes a pre-analysis required.
    //Note that, unlikely what happens with PerformMangedOperationUnits, the outputs of this method aren't
    //normalised (= primarily stored under Value), what is useful in certain contexts.
    //NOTE: this function assumes that both inputs are normalised, what means that no prefix information is expected.
    //It might also be used with non-normalised inputs, but their prefix information would be plainly ignored.
    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        if (firstInfo.Value == 0.0 || secondInfo.Value == 0.0)
        {
            if (operation == Operations.Multiplication || operation == Operations.Division)
            {
                //Dividing by zero scenarios are taken into account somewhere else.
                return new UnitInfo(firstInfo) { Value = 0.0 };
            }
        }

        UnitInfo outInfo = new UnitInfo(firstInfo);
        UnitInfo firstInfo0 = new UnitInfo(firstInfo);
        UnitInfo secondInfo0 = new UnitInfo(secondInfo);

        boolean isWrong = false;
        try
        {
            if (operation == Operations.Addition)
            {
                outInfo.Value += secondInfo0.Value;
            }
            else if (operation == Operations.Subtraction)
            {
                outInfo.Value -= secondInfo.Value;
            }
            else
            {
                //The reason for checking whether BaseTenExponent is inside/outside the int range before performing 
                //the operation (rather than going ahead and eventually catching the resulting exception) isn't just
                //being quicker, but also the only option in many situations. Note that an addition/subtraction between
                //two int variables whose result is outside the int range might not trigger an exception (+ random 
                //negative value as output).
                if (VaryBaseTenExponent(outInfo, secondInfo0.BaseTenExponent, operation == Operations.Division).Error.Type != ErrorTypes.None)
                {
                    return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
                }

                if (operation == Operations.Multiplication)
                {
                    outInfo.Value *= secondInfo.Value;
                    outInfo.BaseTenExponent += secondInfo.BaseTenExponent;
                }
                else if (operation == Operations.Division)
                {
                    if (secondInfo.Value == 0.0)
                    {
                        return
                        (
                            new UnitInfo(outInfo) 
                            { 
                                Error = new ErrorInfo(ErrorTypes.NumericError) 
                            }
                        );
                    }
                    outInfo.Value /= secondInfo.Value;
                    outInfo.BaseTenExponent -= secondInfo.BaseTenExponent;
                }
            }
        }
        catch { isWrong = true; }

        return
        (
            //An error might not be triggered despite of dealing with numbers outside double precision.
            //For example: 0.00000000000000000001m * 0.0000000000000000000001m can output 0.0 without triggering an error. 
            isWrong || ((operation == Operations.Multiplication || operation == Operations.Division) && outInfo.Value == 0.0.0) ?
            OperationValuesManageError(firstInfo0, secondInfo0, operation) : outInfo
        );
    }

    static UnitInfo OperationValuesManageError(UnitInfo outInfo, UnitInfo secondInfo, Operations operation)
    {
        if (operation != Operations.Multiplication && operation != Operations.Division)
        {
            //This condition should never be true on account of the fact that the pre-modifications performed before
            //adding/subtracting should avoid erroneous situations.
            return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
        }

        UnitInfo secondInfo2 = ConvertValueToBaseTen(secondInfo.Value);
        outInfo = VaryBaseTenExponent(outInfo, secondInfo2.BaseTenExponent, operation == Operations.Division);
        if (Math.Abs(secondInfo2.Value) == 1.0 || outInfo.Error.Type != ErrorTypes.None) return outInfo;
        
        try
        {
            outInfo = PerformManagedOperationUnits
            (
                outInfo, secondInfo2.Value, operation
            );
        }
        catch
        {
            //Very unlikely scenario on account of the fact that Math.Abs(secondInfo2.Value)
            //lies within the 0.1-10.0 range.
            outInfo = OperationValuesManageError
            (
                new UnitInfo(outInfo)
                {
                    Value = secondInfo2.Value,
                    BaseTenExponent = 0
                },
                new UnitInfo()
                {
                    Value = outInfo.Value,
                    BaseTenExponent = outInfo.BaseTenExponent
                },
                operation
            );
        }

        return outInfo;
    }

    static UnitInfo ConvertValueToBaseTen(double value)
    {
        value = Math.Abs(value);
        return FromValueToBaseTenExponent
        (
             new UnitInfo(value), Math.Abs(value), false
        );
    }

    static UnitInfo ConvertBaseTenToValue(UnitInfo unitInfo)
    {
        if (unitInfo.BaseTenExponent == 0) return unitInfo;

        UnitInfo outInfo = new UnitInfo(unitInfo);
        boolean decrease = unitInfo.BaseTenExponent > 0;
        int sign = Math.Sign(outInfo.Value);
        double absValue = Math.Abs(outInfo.Value);

        while (outInfo.BaseTenExponent != 0.0)
        {
            if (decrease)
            {
                if (absValue >= MaxValueDec / 10.0) break;
                absValue *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }
            else
            {
                if (absValue <= MinValueDec * 10.0) break;
                absValue /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
        }

        outInfo.Value = sign * absValue;

        return outInfo;
    }

    static UnitInfo NormaliseUnitInfo(UnitInfo unitInfo)
    {
        if (unitInfo.Value == 0 && unitInfo.Prefix.Factor == 1.0)
        {
            return unitInfo;
        }
        UnitInfo outInfo = new UnitInfo(unitInfo);

        if (outInfo.Prefix.Factor != 1)
        {
            outInfo = FromValueToBaseTenExponent
            (
                outInfo, outInfo.Prefix.Factor, true
            );
            outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage);
        }
        if (outInfo.Value == 0.0) return outInfo;

        outInfo = FromValueToBaseTenExponent
        (
            outInfo, outInfo.Value, false
        );

        return outInfo;
    }

    static UnitInfo FromValueToBaseTenExponent(UnitInfo outInfo, double value, boolean isPrefix)
    {
        if (value == 0.0) return outInfo;

        double valueAbs = Math.Abs(value);
        boolean decrease = (valueAbs > 1.0);
        if (!isPrefix)
        {
            outInfo.Value = outInfo.Value / valueAbs;
        }

        while (valueAbs != 1.0)
        {
            if ((valueAbs < 10.0 && valueAbs > 1.0) || (valueAbs > 0.1.0 && valueAbs < 1.0))
            {
                if (!isPrefix) outInfo.Value = value;
                else
                {
                    outInfo = PerformManagedOperationValues
                    (
                        outInfo, value, Operations.Multiplication
                    );
                }

                return outInfo;
            }

            if (decrease)
            {
                value /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
            else
            {
                value *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }

            valueAbs = Math.Abs(value);
        }

        return outInfo;
    }

    //Method used to vary BaseTenExponent without provoking unhandled exceptions (i.e., bigger than Integer.MAX_VALUE).
    static UnitInfo VaryBaseTenExponent(UnitInfo info, int baseTenIncrease, boolean isDivision = false)
    {
        long val1 = info.BaseTenExponent;
        long val2 = baseTenIncrease;

        if (isDivision)
        {
            //Converting a negative value into positive might provoke an overflow error for the int type
            //(e.g., Math.Abs(Integer.MAIN_VALUE)). Converting both variables to long is a quick and effective
            //way to avoid this problem.
            val2 *= -1;
        }

        return
        (
             ((val2 > 0 && val1 > Integer.MAX_VALUE - val2) || (val2 < 0 && val1 < Integer.MAIN_VALUE - val2)) ?
            new UnitInfo(info, ErrorTypes.NumericError) : new UnitInfo(info){{ BaseTenExponent = (int)(val1 + val2); }}
        );
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData(ClipboardOperationAction.java:430)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImportsOperation(ClipboardOperationAction.java:357)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperation(ClipboardOperationAction.java:317)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction$1.run(ClipboardOperationAction.java:265)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:70)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run(ClipboardOperationAction.java:262)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:473)
	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:118)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:90)
	at sun.reflect.GeneratedMethodAccessor44.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:55)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:282)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:264)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:132)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:152)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:494)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:488)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:210)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:286)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:507)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:558)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:378)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.access$0(KeyBindingDispatcher.java:324)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:86)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1270)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1078)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1103)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1088)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1130)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1126)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1547)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4918)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:364)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4799)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:359)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5110)
	at org.eclipse.swt.internal.win32.OS.DispatchMessageW(Native Method)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(OS.java:2552)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3822)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:1121)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1022)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:150)
	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:693)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:610)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:148)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:138)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:388)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:243)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:673)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:610)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1519)

!ENTRY org.eclipse.jdt.ui 4 2 2017-05-27 20:04:58.549
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData(ClipboardOperationAction.java:430)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImportsOperation(ClipboardOperationAction.java:357)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperation(ClipboardOperationAction.java:317)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction$1.run(ClipboardOperationAction.java:265)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:70)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run(ClipboardOperationAction.java:262)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:473)
	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:118)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:90)
	at sun.reflect.GeneratedMethodAccessor44.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:55)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:282)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:264)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:132)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:152)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:494)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:488)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:210)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:286)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:507)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:558)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:378)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.access$0(KeyBindingDispatcher.java:324)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:86)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1270)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1078)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1103)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1088)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1130)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1126)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1547)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4918)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:364)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4799)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:359)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5110)
	at org.eclipse.swt.internal.win32.OS.DispatchMessageW(Native Method)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(OS.java:2552)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3822)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:1121)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1022)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:150)
	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:693)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:610)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:148)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:138)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:388)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:243)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:673)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:610)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1519)

!ENTRY org.eclipse.jdt.ui 4 0 2017-05-27 20:04:58.549
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData(ClipboardOperationAction.java:430)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImportsOperation(ClipboardOperationAction.java:357)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperation(ClipboardOperationAction.java:317)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction$1.run(ClipboardOperationAction.java:265)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:70)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run(ClipboardOperationAction.java:262)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:473)
	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:118)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:90)
	at sun.reflect.GeneratedMethodAccessor44.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:55)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:282)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:264)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:132)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:152)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:494)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:488)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:210)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:286)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:507)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:558)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:378)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.access$0(KeyBindingDispatcher.java:324)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:86)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1270)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1078)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1103)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1088)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1130)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1126)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1547)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4918)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:364)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4799)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:359)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5110)
	at org.eclipse.swt.internal.win32.OS.DispatchMessageW(Native Method)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(OS.java:2552)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3822)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:1121)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1022)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:150)
	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:693)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:610)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:148)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:138)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:388)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:243)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:673)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:610)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1519)

!ENTRY org.eclipse.jdt.core 4 4 2017-05-27 20:05:00.412
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
public class OperationsManaged
{
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, double second, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            firstInfo, new UnitInfo(second), operation
        );
    }

    public static UnitInfo PerformManagedOperationUnits(double first, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            new UnitInfo(first), secondInfo, operation
        );
    }

    //This method should always be used when dealing with random UnitInfo variables because it accounts for all the
    //possible scenarios. On the other hand, with simple operations (e.g., random UnitInfo & numeric type) it might
    //be better to use PerformManagedOperationValues. 
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        ErrorTypes errorType = InternalMethods.GetOperationError
        (
            firstInfo, secondInfo, operation
        );
        if (errorType != ErrorTypes.None)
        {
            return new UnitInfo(firstInfo) 
            {{
                Error = new ErrorInfo(errorType); 
            }};
        }

        return
        (
            operation == Operations.Addition || operation == Operations.Subtraction ?
            PerformManagedOperationAddition(firstInfo, secondInfo, operation) :
            PerformManagedOperationMultiplication(firstInfo, secondInfo, operation)
        );
    }

    static UnitInfo PerformManagedOperationAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {   
        //After being normalised, the operands might require further modifications.
        UnitInfo[] normalised = GetOperandsAddition(firstInfo, secondInfo, operation);

        return PerformManagedOperationNormalisedValues
        (
            firstInfo, normalised, operation
        );
    }

    static UnitInfo[] GetOperandsAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        UnitInfo[] operands2 = new UnitInfo[] 
        {
            new UnitInfo(firstInfo), new UnitInfo(secondInfo)
        };

        if (operands2[0].BaseTenExponent != operands2[1].BaseTenExponent || operands2[0].Prefix.Factor != operands2[1].Prefix.Factor)
        {
            //The addition/subtraction might not be performed right away even with normalised values.
            //For example: 5 and 6 from 5*10^2 and 6*10^7 cannot be added right away.
            operands2 = AdaptNormalisedValuesForAddition
            (
                new UnitInfo[] 
                { 
                    NormaliseUnitInfo(operands2[0]), 
                    NormaliseUnitInfo(operands2[1])
                },
                operation
            );
        }

        return operands2;
    }
    
    static UnitInfo[] AdaptNormalisedValuesForAddition(UnitInfo[] unitInfos2, Operations operation)
    {
        if (unitInfos2[0].BaseTenExponent == unitInfos2[1].BaseTenExponent)
        {
            //Having the same BaseTenExponent values means that the given operation can be performed right away.
            return unitInfos2;
        }

        int[] bigSmallI = 
        (
            unitInfos2[0].BaseTenExponent > unitInfos2[1].BaseTenExponent ?
            new int[] { 0, 1 } : new int[] { 1, 0 }
        );

        //Only the variable with the bigger value is modified. For example: 5*10^5 & 3*10^3 is converted
        //into 500*10^3 & 3*10^3 in order to allow the addition 500 + 3. 
        UnitInfo big2 = AdaptBiggerAdditionOperand(unitInfos2, bigSmallI, operation);
        if (big2.Error.Type != ErrorTypes.None)
        {
            return TooBigGapAddition(unitInfos2, bigSmallI, operation);
        }

        unitInfos2[bigSmallI[0]].Value = big2.Value;
        unitInfos2[bigSmallI[0]].BaseTenExponent = unitInfos2[bigSmallI[1]].BaseTenExponent;

        return unitInfos2;
    }

    //When adding/subtracting two numbers whose gap is bigger than the maximum double range, there
    //is no need to perform any operation (i.e., no change will be observed because of being outside
    //the maximum supported precision). This method takes care of these cases and returns the expected
    //output (i.e., biggest value).
    static UnitInfo[] TooBigGapAddition(UnitInfo[] unitInfos2, int[] bigSmallI, Operations operation)
    {
        UnitInfo[] outInfos = new UnitInfo[] 
        {
            //First operand (i.e., one whose information defines the operation) together with the
            //numeric information (i.e., just Value and BaseTenExponent because both are normalised)
            //which is associated with the biggest one.
            new UnitInfo(unitInfos2[0])
            {{
                Value = unitInfos2[bigSmallI[0]].Value;
                BaseTenExponent = unitInfos2[bigSmallI[0]].BaseTenExponent;
            }}
        };

        if (operation == Operations.Subtraction && bigSmallI[0] == 1)
        {
            outInfos[0].Value = -1.0 * outInfos[0].Value;
        }

        if (outInfos[0].Unit == Units.Unitless)
        {
            outInfos[0].Unit = unitInfos2[bigSmallI[1]].Unit;
        }

        return outInfos;
    }

    static UnitInfo AdaptBiggerAdditionOperand(UnitInfo[] unitInfos2, Integer[] bigSmallI, Operations operation)
    {
        int gapExponent = unitInfos2[bigSmallI[0]].BaseTenExponent - unitInfos2[bigSmallI[1]].BaseTenExponent;
        if (gapExponent >= 27)
        {
            //The difference between both inputs is bigger than (or, at least, very close to) the maximum double value/precision;
            //what makes this situation calculation unworthy and the first operand to be returned as the result.
            //Note that the error below these lines is just an easy way to tell the calling function about this eventuality.
            return new UnitInfo(unitInfos2[0]) 
            {{ 
                Error = new ErrorInfo(ErrorTypes.InvalidOperation); 
            }};
        }

        //PerformManagedOperationValues is used to make sure that the resulting numeric information is stored
        //in Value (if possible).
        UnitInfo big2 = PerformManagedOperationValues
        (
            RaiseToIntegerExponent(10.0, gapExponent), unitInfos2[bigSmallI[0]].Value, 
            Operations.Multiplication                
        );

        boolean isWrong = 
        (
            big2.Error.Type != ErrorTypes.None || big2.BaseTenExponent != 0 ?
            
            //The value of the bigger input times 10^(gap between BaseTenExponent of inputs) is too big. 
            isWrong = true :
            
            //Overflow-check very unlikely to trigger an error. In fact, with properly normalised variables,
            //triggering an error would be plainly impossible.               
            AreAdditionFinalValuesWrong
            (
                unitInfos2[0].Value, unitInfos2[1].Value, operation
            )
        );

        if (isWrong)
        {
        	UnitInfo temp = new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }};
            
            temp.Error = new ErrorInfo(ErrorTypes.InvalidOperation);
        }
        
        return
        (
            isWrong ?
            //This error is just an easy way to let the calling function know about the fact that no
            //calculation has been performed (too big gap). This isn't a properly-speaking error and
            //that's why it will not be notified to the user.
            new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }} :
            //Returning the new big value. For example: with 5*10^4 & 3*10^2, 500 would be returned.
            new UnitInfo(unitInfos2[bigSmallI[0]])
            {{
                Value = big2.Value;
            }}
        )
    }

    static boolean AreAdditionFinalValuesWrong(double val1, double val2, Operations operation)
    {
        boolean isWrong = false;

        try
        {
            val1 = val1 + val2 *
            (
                operation == Operations.Addition ? 1 : -1
            );
        }
        catch { isWrong = true; }

        return isWrong;
    }

    static UnitInfo PerformManagedOperationMultiplication(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationNormalisedValues
        (
            firstInfo, new UnitInfo[] 
            { 
                NormaliseUnitInfo(firstInfo),
                NormaliseUnitInfo(secondInfo) 
            },
            operation
        );
    }

    public static UnitInfo RaiseToIntegerExponent(double baseValue, int exponent)
    {
        return RaiseToIntegerExponent(new UnitInfo(baseValue), exponent);
    }

    static UnitInfo RaiseToIntegerExponent(UnitInfo baseInfo, int exponent)
    {
        if (exponent <= 1 && exponent >= 0)
        {
            baseInfo.Value = (exponent == 0 ? 1.0 : baseInfo.Value);
            return baseInfo;
        }

        UnitInfo outInfo = new UnitInfo(baseInfo);

        for (int i = 1; i < Math.Abs(exponent); i++)
        {
            outInfo = PerformManagedOperationValues
            (
                outInfo, baseInfo, Operations.Multiplication
            );
            if (outInfo.Error.Type != ErrorTypes.None) return outInfo;
        }

        return
        (
            exponent < 0 ?
            PerformManagedOperationValues(new UnitInfo(1.0), outInfo, Operations.Division) :
            outInfo
        );
    }

    static UnitInfo PerformManagedOperationNormalisedValues(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        outInfo =
        (
            normalisedInfos.Length == 1 ?
            //There is just one operand when the difference between both of them is too big.
            outInfo = normalisedInfos[0] :
            PerformManagedOperationTwoOperands(outInfo, normalisedInfos, operation)
        );

        return outInfo;
    }

    static UnitInfo PerformManagedOperationTwoOperands(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        UnitInfo outInfoNormalised = PerformManagedOperationValues
        (
            normalisedInfos[0], normalisedInfos[1], operation
        );

        if (outInfo.Error.Type != ErrorTypes.None)
        {
            return new UnitInfo(outInfo)
            {
                Error = new ErrorInfo(ErrorTypes.NumericError)
            };
        }

        outInfo.BaseTenExponent = outInfoNormalised.BaseTenExponent;
        outInfo.Value = outInfoNormalised.Value;
        //Normalised means no prefixes.
        outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage); 

        return outInfo;
    }

    static UnitInfo PerformManagedOperationValues(double firstValue, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            new UnitInfo(firstValue), new UnitInfo(secondValue), operation
        );
    }

    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            firstInfo, new UnitInfo(secondValue), operation
        );
    }

    //This method might be used to perform full operations (not just being the last calculation step) instead
    //of the default one (PerformManagedOperationUnits) for simple cases. That is: ones not dealing with the
    //complex numeric reality (Value, Prefix and BaseTenExponent) which makes a pre-analysis required.
    //Note that, unlikely what happens with PerformMangedOperationUnits, the outputs of this method aren't
    //normalised (= primarily stored under Value), what is useful in certain contexts.
    //NOTE: this function assumes that both inputs are normalised, what means that no prefix information is expected.
    //It might also be used with non-normalised inputs, but their prefix information would be plainly ignored.
    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        if (firstInfo.Value == 0.0 || secondInfo.Value == 0.0)
        {
            if (operation == Operations.Multiplication || operation == Operations.Division)
            {
                //Dividing by zero scenarios are taken into account somewhere else.
                return new UnitInfo(firstInfo) { Value = 0.0 };
            }
        }

        UnitInfo outInfo = new UnitInfo(firstInfo);
        UnitInfo firstInfo0 = new UnitInfo(firstInfo);
        UnitInfo secondInfo0 = new UnitInfo(secondInfo);

        boolean isWrong = false;
        try
        {
            if (operation == Operations.Addition)
            {
                outInfo.Value += secondInfo0.Value;
            }
            else if (operation == Operations.Subtraction)
            {
                outInfo.Value -= secondInfo.Value;
            }
            else
            {
                //The reason for checking whether BaseTenExponent is inside/outside the int range before performing 
                //the operation (rather than going ahead and eventually catching the resulting exception) isn't just
                //being quicker, but also the only option in many situations. Note that an addition/subtraction between
                //two int variables whose result is outside the int range might not trigger an exception (+ random 
                //negative value as output).
                if (VaryBaseTenExponent(outInfo, secondInfo0.BaseTenExponent, operation == Operations.Division).Error.Type != ErrorTypes.None)
                {
                    return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
                }

                if (operation == Operations.Multiplication)
                {
                    outInfo.Value *= secondInfo.Value;
                    outInfo.BaseTenExponent += secondInfo.BaseTenExponent;
                }
                else if (operation == Operations.Division)
                {
                    if (secondInfo.Value == 0.0)
                    {
                        return
                        (
                            new UnitInfo(outInfo) 
                            { 
                                Error = new ErrorInfo(ErrorTypes.NumericError) 
                            }
                        );
                    }
                    outInfo.Value /= secondInfo.Value;
                    outInfo.BaseTenExponent -= secondInfo.BaseTenExponent;
                }
            }
        }
        catch { isWrong = true; }

        return
        (
            //An error might not be triggered despite of dealing with numbers outside double precision.
            //For example: 0.00000000000000000001m * 0.0000000000000000000001m can output 0.0 without triggering an error. 
            isWrong || ((operation == Operations.Multiplication || operation == Operations.Division) && outInfo.Value == 0.0.0) ?
            OperationValuesManageError(firstInfo0, secondInfo0, operation) : outInfo
        );
    }

    static UnitInfo OperationValuesManageError(UnitInfo outInfo, UnitInfo secondInfo, Operations operation)
    {
        if (operation != Operations.Multiplication && operation != Operations.Division)
        {
            //This condition should never be true on account of the fact that the pre-modifications performed before
            //adding/subtracting should avoid erroneous situations.
            return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
        }

        UnitInfo secondInfo2 = ConvertValueToBaseTen(secondInfo.Value);
        outInfo = VaryBaseTenExponent(outInfo, secondInfo2.BaseTenExponent, operation == Operations.Division);
        if (Math.Abs(secondInfo2.Value) == 1.0 || outInfo.Error.Type != ErrorTypes.None) return outInfo;
        
        try
        {
            outInfo = PerformManagedOperationUnits
            (
                outInfo, secondInfo2.Value, operation
            );
        }
        catch
        {
            //Very unlikely scenario on account of the fact that Math.Abs(secondInfo2.Value)
            //lies within the 0.1-10.0 range.
            outInfo = OperationValuesManageError
            (
                new UnitInfo(outInfo)
                {
                    Value = secondInfo2.Value,
                    BaseTenExponent = 0
                },
                new UnitInfo()
                {
                    Value = outInfo.Value,
                    BaseTenExponent = outInfo.BaseTenExponent
                },
                operation
            );
        }

        return outInfo;
    }

    static UnitInfo ConvertValueToBaseTen(double value)
    {
        value = Math.Abs(value);
        return FromValueToBaseTenExponent
        (
             new UnitInfo(value), Math.Abs(value), false
        );
    }

    static UnitInfo ConvertBaseTenToValue(UnitInfo unitInfo)
    {
        if (unitInfo.BaseTenExponent == 0) return unitInfo;

        UnitInfo outInfo = new UnitInfo(unitInfo);
        boolean decrease = unitInfo.BaseTenExponent > 0;
        int sign = Math.Sign(outInfo.Value);
        double absValue = Math.Abs(outInfo.Value);

        while (outInfo.BaseTenExponent != 0.0)
        {
            if (decrease)
            {
                if (absValue >= MaxValueDec / 10.0) break;
                absValue *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }
            else
            {
                if (absValue <= MinValueDec * 10.0) break;
                absValue /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
        }

        outInfo.Value = sign * absValue;

        return outInfo;
    }

    static UnitInfo NormaliseUnitInfo(UnitInfo unitInfo)
    {
        if (unitInfo.Value == 0 && unitInfo.Prefix.Factor == 1.0)
        {
            return unitInfo;
        }
        UnitInfo outInfo = new UnitInfo(unitInfo);

        if (outInfo.Prefix.Factor != 1)
        {
            outInfo = FromValueToBaseTenExponent
            (
                outInfo, outInfo.Prefix.Factor, true
            );
            outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage);
        }
        if (outInfo.Value == 0.0) return outInfo;

        outInfo = FromValueToBaseTenExponent
        (
            outInfo, outInfo.Value, false
        );

        return outInfo;
    }

    static UnitInfo FromValueToBaseTenExponent(UnitInfo outInfo, double value, boolean isPrefix)
    {
        if (value == 0.0) return outInfo;

        double valueAbs = Math.Abs(value);
        boolean decrease = (valueAbs > 1.0);
        if (!isPrefix)
        {
            outInfo.Value = outInfo.Value / valueAbs;
        }

        while (valueAbs != 1.0)
        {
            if ((valueAbs < 10.0 && valueAbs > 1.0) || (valueAbs > 0.1.0 && valueAbs < 1.0))
            {
                if (!isPrefix) outInfo.Value = value;
                else
                {
                    outInfo = PerformManagedOperationValues
                    (
                        outInfo, value, Operations.Multiplication
                    );
                }

                return outInfo;
            }

            if (decrease)
            {
                value /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
            else
            {
                value *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }

            valueAbs = Math.Abs(value);
        }

        return outInfo;
    }

    //Method used to vary BaseTenExponent without provoking unhandled exceptions (i.e., bigger than Integer.MAX_VALUE).
    static UnitInfo VaryBaseTenExponent(UnitInfo info, int baseTenIncrease, boolean isDivision = false)
    {
        long val1 = info.BaseTenExponent;
        long val2 = baseTenIncrease;

        if (isDivision)
        {
            //Converting a negative value into positive might provoke an overflow error for the int type
            //(e.g., Math.Abs(Integer.MAIN_VALUE)). Converting both variables to long is a quick and effective
            //way to avoid this problem.
            val2 *= -1;
        }

        return
        (
             ((val2 > 0 && val1 > Integer.MAX_VALUE - val2) || (val2 < 0 && val1 < Integer.MAIN_VALUE - val2)) ?
            new UnitInfo(info, ErrorTypes.NumericError) : new UnitInfo(info){{ BaseTenExponent = (int)(val1 + val2); }}
        );
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2017-05-27 20:05:00.413
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2017-05-27 20:05:00.413
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2017-05-27 20:05:00.461
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
public class OperationsManaged
{
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, double second, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            firstInfo, new UnitInfo(second), operation
        );
    }

    public static UnitInfo PerformManagedOperationUnits(double first, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            new UnitInfo(first), secondInfo, operation
        );
    }

    //This method should always be used when dealing with random UnitInfo variables because it accounts for all the
    //possible scenarios. On the other hand, with simple operations (e.g., random UnitInfo & numeric type) it might
    //be better to use PerformManagedOperationValues. 
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        ErrorTypes errorType = InternalMethods.GetOperationError
        (
            firstInfo, secondInfo, operation
        );
        if (errorType != ErrorTypes.None)
        {
            return new UnitInfo(firstInfo) 
            {{
                Error = new ErrorInfo(errorType); 
            }};
        }

        return
        (
            operation == Operations.Addition || operation == Operations.Subtraction ?
            PerformManagedOperationAddition(firstInfo, secondInfo, operation) :
            PerformManagedOperationMultiplication(firstInfo, secondInfo, operation)
        );
    }

    static UnitInfo PerformManagedOperationAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {   
        //After being normalised, the operands might require further modifications.
        UnitInfo[] normalised = GetOperandsAddition(firstInfo, secondInfo, operation);

        return PerformManagedOperationNormalisedValues
        (
            firstInfo, normalised, operation
        );
    }

    static UnitInfo[] GetOperandsAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        UnitInfo[] operands2 = new UnitInfo[] 
        {
            new UnitInfo(firstInfo), new UnitInfo(secondInfo)
        };

        if (operands2[0].BaseTenExponent != operands2[1].BaseTenExponent || operands2[0].Prefix.Factor != operands2[1].Prefix.Factor)
        {
            //The addition/subtraction might not be performed right away even with normalised values.
            //For example: 5 and 6 from 5*10^2 and 6*10^7 cannot be added right away.
            operands2 = AdaptNormalisedValuesForAddition
            (
                new UnitInfo[] 
                { 
                    NormaliseUnitInfo(operands2[0]), 
                    NormaliseUnitInfo(operands2[1])
                },
                operation
            );
        }

        return operands2;
    }
    
    static UnitInfo[] AdaptNormalisedValuesForAddition(UnitInfo[] unitInfos2, Operations operation)
    {
        if (unitInfos2[0].BaseTenExponent == unitInfos2[1].BaseTenExponent)
        {
            //Having the same BaseTenExponent values means that the given operation can be performed right away.
            return unitInfos2;
        }

        int[] bigSmallI = 
        (
            unitInfos2[0].BaseTenExponent > unitInfos2[1].BaseTenExponent ?
            new int[] { 0, 1 } : new int[] { 1, 0 }
        );

        //Only the variable with the bigger value is modified. For example: 5*10^5 & 3*10^3 is converted
        //into 500*10^3 & 3*10^3 in order to allow the addition 500 + 3. 
        UnitInfo big2 = AdaptBiggerAdditionOperand(unitInfos2, bigSmallI, operation);
        if (big2.Error.Type != ErrorTypes.None)
        {
            return TooBigGapAddition(unitInfos2, bigSmallI, operation);
        }

        unitInfos2[bigSmallI[0]].Value = big2.Value;
        unitInfos2[bigSmallI[0]].BaseTenExponent = unitInfos2[bigSmallI[1]].BaseTenExponent;

        return unitInfos2;
    }

    //When adding/subtracting two numbers whose gap is bigger than the maximum double range, there
    //is no need to perform any operation (i.e., no change will be observed because of being outside
    //the maximum supported precision). This method takes care of these cases and returns the expected
    //output (i.e., biggest value).
    static UnitInfo[] TooBigGapAddition(UnitInfo[] unitInfos2, int[] bigSmallI, Operations operation)
    {
        UnitInfo[] outInfos = new UnitInfo[] 
        {
            //First operand (i.e., one whose information defines the operation) together with the
            //numeric information (i.e., just Value and BaseTenExponent because both are normalised)
            //which is associated with the biggest one.
            new UnitInfo(unitInfos2[0])
            {{
                Value = unitInfos2[bigSmallI[0]].Value;
                BaseTenExponent = unitInfos2[bigSmallI[0]].BaseTenExponent;
            }}
        };

        if (operation == Operations.Subtraction && bigSmallI[0] == 1)
        {
            outInfos[0].Value = -1.0 * outInfos[0].Value;
        }

        if (outInfos[0].Unit == Units.Unitless)
        {
            outInfos[0].Unit = unitInfos2[bigSmallI[1]].Unit;
        }

        return outInfos;
    }

    static UnitInfo AdaptBiggerAdditionOperand(UnitInfo[] unitInfos2, Integer[] bigSmallI, Operations operation)
    {
        int gapExponent = unitInfos2[bigSmallI[0]].BaseTenExponent - unitInfos2[bigSmallI[1]].BaseTenExponent;
        if (gapExponent >= 27)
        {
            //The difference between both inputs is bigger than (or, at least, very close to) the maximum double value/precision;
            //what makes this situation calculation unworthy and the first operand to be returned as the result.
            //Note that the error below these lines is just an easy way to tell the calling function about this eventuality.
            return new UnitInfo(unitInfos2[0]) 
            {{ 
                Error = new ErrorInfo(ErrorTypes.InvalidOperation); 
            }};
        }

        //PerformManagedOperationValues is used to make sure that the resulting numeric information is stored
        //in Value (if possible).
        UnitInfo big2 = PerformManagedOperationValues
        (
            RaiseToIntegerExponent(10.0, gapExponent), unitInfos2[bigSmallI[0]].Value, 
            Operations.Multiplication                
        );

        boolean isWrong = 
        (
            big2.Error.Type != ErrorTypes.None || big2.BaseTenExponent != 0 ?
            
            //The value of the bigger input times 10^(gap between BaseTenExponent of inputs) is too big. 
            isWrong = true :
            
            //Overflow-check very unlikely to trigger an error. In fact, with properly normalised variables,
            //triggering an error would be plainly impossible.               
            AreAdditionFinalValuesWrong
            (
                unitInfos2[0].Value, unitInfos2[1].Value, operation
            )
        );

        if (isWrong)
        {
        	UnitInfo temp = new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }};
            
            temp.Error = new ErrorInfo(ErrorTypes.InvalidOperation);
        }
        
        return
        (
            isWrong ?
            //This error is just an easy way to let the calling function know about the fact that no
            //calculation has been performed (too big gap). This isn't a properly-speaking error and
            //that's why it will not be notified to the user.
            new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }} :
            //Returning the new big value. For example: with 5*10^4 & 3*10^2, 500 would be returned.
            new UnitInfo(unitInfos2[bigSmallI[0]])
            {{
                Value = big2.Value;
            }}
        )
    }

    static boolean AreAdditionFinalValuesWrong(double val1, double val2, Operations operation)
    {
        boolean isWrong = false;

        try
        {
            val1 = val1 + val2 *
            (
                operation == Operations.Addition ? 1 : -1
            );
        }
        catch { isWrong = true; }

        return isWrong;
    }

    static UnitInfo PerformManagedOperationMultiplication(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationNormalisedValues
        (
            firstInfo, new UnitInfo[] 
            { 
                NormaliseUnitInfo(firstInfo),
                NormaliseUnitInfo(secondInfo) 
            },
            operation
        );
    }

    public static UnitInfo RaiseToIntegerExponent(double baseValue, int exponent)
    {
        return RaiseToIntegerExponent(new UnitInfo(baseValue), exponent);
    }

    static UnitInfo RaiseToIntegerExponent(UnitInfo baseInfo, int exponent)
    {
        if (exponent <= 1 && exponent >= 0)
        {
            baseInfo.Value = (exponent == 0 ? 1.0 : baseInfo.Value);
            return baseInfo;
        }

        UnitInfo outInfo = new UnitInfo(baseInfo);

        for (int i = 1; i < Math.Abs(exponent); i++)
        {
            outInfo = PerformManagedOperationValues
            (
                outInfo, baseInfo, Operations.Multiplication
            );
            if (outInfo.Error.Type != ErrorTypes.None) return outInfo;
        }

        return
        (
            exponent < 0 ?
            PerformManagedOperationValues(new UnitInfo(1.0), outInfo, Operations.Division) :
            outInfo
        );
    }

    static UnitInfo PerformManagedOperationNormalisedValues(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        outInfo =
        (
            normalisedInfos.Length == 1 ?
            //There is just one operand when the difference between both of them is too big.
            outInfo = normalisedInfos[0] :
            PerformManagedOperationTwoOperands(outInfo, normalisedInfos, operation)
        );

        return outInfo;
    }

    static UnitInfo PerformManagedOperationTwoOperands(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        UnitInfo outInfoNormalised = PerformManagedOperationValues
        (
            normalisedInfos[0], normalisedInfos[1], operation
        );

        if (outInfo.Error.Type != ErrorTypes.None)
        {
            return new UnitInfo(outInfo)
            {
                Error = new ErrorInfo(ErrorTypes.NumericError)
            };
        }

        outInfo.BaseTenExponent = outInfoNormalised.BaseTenExponent;
        outInfo.Value = outInfoNormalised.Value;
        //Normalised means no prefixes.
        outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage); 

        return outInfo;
    }

    static UnitInfo PerformManagedOperationValues(double firstValue, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            new UnitInfo(firstValue), new UnitInfo(secondValue), operation
        );
    }

    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            firstInfo, new UnitInfo(secondValue), operation
        );
    }

    //This method might be used to perform full operations (not just being the last calculation step) instead
    //of the default one (PerformManagedOperationUnits) for simple cases. That is: ones not dealing with the
    //complex numeric reality (Value, Prefix and BaseTenExponent) which makes a pre-analysis required.
    //Note that, unlikely what happens with PerformMangedOperationUnits, the outputs of this method aren't
    //normalised (= primarily stored under Value), what is useful in certain contexts.
    //NOTE: this function assumes that both inputs are normalised, what means that no prefix information is expected.
    //It might also be used with non-normalised inputs, but their prefix information would be plainly ignored.
    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        if (firstInfo.Value == 0.0 || secondInfo.Value == 0.0)
        {
            if (operation == Operations.Multiplication || operation == Operations.Division)
            {
                //Dividing by zero scenarios are taken into account somewhere else.
                return new UnitInfo(firstInfo) { Value = 0.0 };
            }
        }

        UnitInfo outInfo = new UnitInfo(firstInfo);
        UnitInfo firstInfo0 = new UnitInfo(firstInfo);
        UnitInfo secondInfo0 = new UnitInfo(secondInfo);

        boolean isWrong = false;
        try
        {
            if (operation == Operations.Addition)
            {
                outInfo.Value += secondInfo0.Value;
            }
            else if (operation == Operations.Subtraction)
            {
                outInfo.Value -= secondInfo.Value;
            }
            else
            {
                //The reason for checking whether BaseTenExponent is inside/outside the int range before performing 
                //the operation (rather than going ahead and eventually catching the resulting exception) isn't just
                //being quicker, but also the only option in many situations. Note that an addition/subtraction between
                //two int variables whose result is outside the int range might not trigger an exception (+ random 
                //negative value as output).
                if (VaryBaseTenExponent(outInfo, secondInfo0.BaseTenExponent, operation == Operations.Division).Error.Type != ErrorTypes.None)
                {
                    return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
                }

                if (operation == Operations.Multiplication)
                {
                    outInfo.Value *= secondInfo.Value;
                    outInfo.BaseTenExponent += secondInfo.BaseTenExponent;
                }
                else if (operation == Operations.Division)
                {
                    if (secondInfo.Value == 0.0)
                    {
                        return
                        (
                            new UnitInfo(outInfo) 
                            { 
                                Error = new ErrorInfo(ErrorTypes.NumericError) 
                            }
                        );
                    }
                    outInfo.Value /= secondInfo.Value;
                    outInfo.BaseTenExponent -= secondInfo.BaseTenExponent;
                }
            }
        }
        catch { isWrong = true; }

        return
        (
            //An error might not be triggered despite of dealing with numbers outside double precision.
            //For example: 0.00000000000000000001m * 0.0000000000000000000001m can output 0.0 without triggering an error. 
            isWrong || ((operation == Operations.Multiplication || operation == Operations.Division) && outInfo.Value == 0.0.0) ?
            OperationValuesManageError(firstInfo0, secondInfo0, operation) : outInfo
        );
    }

    static UnitInfo OperationValuesManageError(UnitInfo outInfo, UnitInfo secondInfo, Operations operation)
    {
        if (operation != Operations.Multiplication && operation != Operations.Division)
        {
            //This condition should never be true on account of the fact that the pre-modifications performed before
            //adding/subtracting should avoid erroneous situations.
            return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
        }

        UnitInfo secondInfo2 = ConvertValueToBaseTen(secondInfo.Value);
        outInfo = VaryBaseTenExponent(outInfo, secondInfo2.BaseTenExponent, operation == Operations.Division);
        if (Math.Abs(secondInfo2.Value) == 1.0 || outInfo.Error.Type != ErrorTypes.None) return outInfo;
        
        try
        {
            outInfo = PerformManagedOperationUnits
            (
                outInfo, secondInfo2.Value, operation
            );
        }
        catch
        {
            //Very unlikely scenario on account of the fact that Math.Abs(secondInfo2.Value)
            //lies within the 0.1-10.0 range.
            outInfo = OperationValuesManageError
            (
                new UnitInfo(outInfo)
                {
                    Value = secondInfo2.Value,
                    BaseTenExponent = 0
                },
                new UnitInfo()
                {
                    Value = outInfo.Value,
                    BaseTenExponent = outInfo.BaseTenExponent
                },
                operation
            );
        }

        return outInfo;
    }

    static UnitInfo ConvertValueToBaseTen(double value)
    {
        value = Math.Abs(value);
        return FromValueToBaseTenExponent
        (
             new UnitInfo(value), Math.Abs(value), false
        );
    }

    static UnitInfo ConvertBaseTenToValue(UnitInfo unitInfo)
    {
        if (unitInfo.BaseTenExponent == 0) return unitInfo;

        UnitInfo outInfo = new UnitInfo(unitInfo);
        boolean decrease = unitInfo.BaseTenExponent > 0;
        int sign = Math.Sign(outInfo.Value);
        double absValue = Math.Abs(outInfo.Value);

        while (outInfo.BaseTenExponent != 0.0)
        {
            if (decrease)
            {
                if (absValue >= MaxValueDec / 10.0) break;
                absValue *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }
            else
            {
                if (absValue <= MinValueDec * 10.0) break;
                absValue /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
        }

        outInfo.Value = sign * absValue;

        return outInfo;
    }

    static UnitInfo NormaliseUnitInfo(UnitInfo unitInfo)
    {
        if (unitInfo.Value == 0 && unitInfo.Prefix.Factor == 1.0)
        {
            return unitInfo;
        }
        UnitInfo outInfo = new UnitInfo(unitInfo);

        if (outInfo.Prefix.Factor != 1)
        {
            outInfo = FromValueToBaseTenExponent
            (
                outInfo, outInfo.Prefix.Factor, true
            );
            outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage);
        }
        if (outInfo.Value == 0.0) return outInfo;

        outInfo = FromValueToBaseTenExponent
        (
            outInfo, outInfo.Value, false
        );

        return outInfo;
    }

    static UnitInfo FromValueToBaseTenExponent(UnitInfo outInfo, double value, boolean isPrefix)
    {
        if (value == 0.0) return outInfo;

        double valueAbs = Math.Abs(value);
        boolean decrease = (valueAbs > 1.0);
        if (!isPrefix)
        {
            outInfo.Value = outInfo.Value / valueAbs;
        }

        while (valueAbs != 1.0)
        {
            if ((valueAbs < 10.0 && valueAbs > 1.0) || (valueAbs > 0.1.0 && valueAbs < 1.0))
            {
                if (!isPrefix) outInfo.Value = value;
                else
                {
                    outInfo = PerformManagedOperationValues
                    (
                        outInfo, value, Operations.Multiplication
                    );
                }

                return outInfo;
            }

            if (decrease)
            {
                value /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
            else
            {
                value *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }

            valueAbs = Math.Abs(value);
        }

        return outInfo;
    }

    //Method used to vary BaseTenExponent without provoking unhandled exceptions (i.e., bigger than Integer.MAX_VALUE).
    static UnitInfo VaryBaseTenExponent(UnitInfo info, int baseTenIncrease, boolean isDivision = false)
    {
        long val1 = info.BaseTenExponent;
        long val2 = baseTenIncrease;

        if (isDivision)
        {
            //Converting a negative value into positive might provoke an overflow error for the int type
            //(e.g., Math.Abs(Integer.MAIN_VALUE)). Converting both variables to long is a quick and effective
            //way to avoid this problem.
            val2 *= -1;
        }

        return
        (
             ((val2 > 0 && val1 > Integer.MAX_VALUE - val2) || (val2 < 0 && val1 < Integer.MAIN_VALUE - val2)) ?
            new UnitInfo(info, ErrorTypes.NumericError) : new UnitInfo(info){{ BaseTenExponent = (int)(val1 + val2); }}
        );
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 2 2017-05-27 20:05:00.462
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 0 2017-05-27 20:05:00.462
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.core 4 4 2017-05-27 20:05:02.535
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
public class OperationsManaged
{
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, double second, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            firstInfo, new UnitInfo(second), operation
        );
    }

    public static UnitInfo PerformManagedOperationUnits(double first, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            new UnitInfo(first), secondInfo, operation
        );
    }

    //This method should always be used when dealing with random UnitInfo variables because it accounts for all the
    //possible scenarios. On the other hand, with simple operations (e.g., random UnitInfo & numeric type) it might
    //be better to use PerformManagedOperationValues. 
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        ErrorTypes errorType = InternalMethods.GetOperationError
        (
            firstInfo, secondInfo, operation
        );
        if (errorType != ErrorTypes.None)
        {
            return new UnitInfo(firstInfo) 
            {{
                Error = new ErrorInfo(errorType); 
            }};
        }

        return
        (
            operation == Operations.Addition || operation == Operations.Subtraction ?
            PerformManagedOperationAddition(firstInfo, secondInfo, operation) :
            PerformManagedOperationMultiplication(firstInfo, secondInfo, operation)
        );
    }

    static UnitInfo PerformManagedOperationAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {   
        //After being normalised, the operands might require further modifications.
        UnitInfo[] normalised = GetOperandsAddition(firstInfo, secondInfo, operation);

        return PerformManagedOperationNormalisedValues
        (
            firstInfo, normalised, operation
        );
    }

    static UnitInfo[] GetOperandsAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        UnitInfo[] operands2 = new UnitInfo[] 
        {
            new UnitInfo(firstInfo), new UnitInfo(secondInfo)
        };

        if (operands2[0].BaseTenExponent != operands2[1].BaseTenExponent || operands2[0].Prefix.Factor != operands2[1].Prefix.Factor)
        {
            //The addition/subtraction might not be performed right away even with normalised values.
            //For example: 5 and 6 from 5*10^2 and 6*10^7 cannot be added right away.
            operands2 = AdaptNormalisedValuesForAddition
            (
                new UnitInfo[] 
                { 
                    NormaliseUnitInfo(operands2[0]), 
                    NormaliseUnitInfo(operands2[1])
                },
                operation
            );
        }

        return operands2;
    }
    
    static UnitInfo[] AdaptNormalisedValuesForAddition(UnitInfo[] unitInfos2, Operations operation)
    {
        if (unitInfos2[0].BaseTenExponent == unitInfos2[1].BaseTenExponent)
        {
            //Having the same BaseTenExponent values means that the given operation can be performed right away.
            return unitInfos2;
        }

        int[] bigSmallI = 
        (
            unitInfos2[0].BaseTenExponent > unitInfos2[1].BaseTenExponent ?
            new int[] { 0, 1 } : new int[] { 1, 0 }
        );

        //Only the variable with the bigger value is modified. For example: 5*10^5 & 3*10^3 is converted
        //into 500*10^3 & 3*10^3 in order to allow the addition 500 + 3. 
        UnitInfo big2 = AdaptBiggerAdditionOperand(unitInfos2, bigSmallI, operation);
        if (big2.Error.Type != ErrorTypes.None)
        {
            return TooBigGapAddition(unitInfos2, bigSmallI, operation);
        }

        unitInfos2[bigSmallI[0]].Value = big2.Value;
        unitInfos2[bigSmallI[0]].BaseTenExponent = unitInfos2[bigSmallI[1]].BaseTenExponent;

        return unitInfos2;
    }

    //When adding/subtracting two numbers whose gap is bigger than the maximum double range, there
    //is no need to perform any operation (i.e., no change will be observed because of being outside
    //the maximum supported precision). This method takes care of these cases and returns the expected
    //output (i.e., biggest value).
    static UnitInfo[] TooBigGapAddition(UnitInfo[] unitInfos2, int[] bigSmallI, Operations operation)
    {
        UnitInfo[] outInfos = new UnitInfo[] 
        {
            //First operand (i.e., one whose information defines the operation) together with the
            //numeric information (i.e., just Value and BaseTenExponent because both are normalised)
            //which is associated with the biggest one.
            new UnitInfo(unitInfos2[0])
            {{
                Value = unitInfos2[bigSmallI[0]].Value;
                BaseTenExponent = unitInfos2[bigSmallI[0]].BaseTenExponent;
            }}
        };

        if (operation == Operations.Subtraction && bigSmallI[0] == 1)
        {
            outInfos[0].Value = -1.0 * outInfos[0].Value;
        }

        if (outInfos[0].Unit == Units.Unitless)
        {
            outInfos[0].Unit = unitInfos2[bigSmallI[1]].Unit;
        }

        return outInfos;
    }

    static UnitInfo AdaptBiggerAdditionOperand(UnitInfo[] unitInfos2, Integer[] bigSmallI, Operations operation)
    {
        int gapExponent = unitInfos2[bigSmallI[0]].BaseTenExponent - unitInfos2[bigSmallI[1]].BaseTenExponent;
        if (gapExponent >= 27)
        {
            //The difference between both inputs is bigger than (or, at least, very close to) the maximum double value/precision;
            //what makes this situation calculation unworthy and the first operand to be returned as the result.
            //Note that the error below these lines is just an easy way to tell the calling function about this eventuality.
            return new UnitInfo(unitInfos2[0]) 
            {{ 
                Error = new ErrorInfo(ErrorTypes.InvalidOperation); 
            }};
        }

        //PerformManagedOperationValues is used to make sure that the resulting numeric information is stored
        //in Value (if possible).
        UnitInfo big2 = PerformManagedOperationValues
        (
            RaiseToIntegerExponent(10.0, gapExponent), unitInfos2[bigSmallI[0]].Value, 
            Operations.Multiplication                
        );

        boolean isWrong = 
        (
            big2.Error.Type != ErrorTypes.None || big2.BaseTenExponent != 0 ?
            
            //The value of the bigger input times 10^(gap between BaseTenExponent of inputs) is too big. 
            isWrong = true :
            
            //Overflow-check very unlikely to trigger an error. In fact, with properly normalised variables,
            //triggering an error would be plainly impossible.               
            AreAdditionFinalValuesWrong
            (
                unitInfos2[0].Value, unitInfos2[1].Value, operation
            )
        );

        if (isWrong)
        {
        	UnitInfo temp = new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }};
            
            temp.Error = new ErrorInfo(ErrorTypes.InvalidOperation);
        }
        
        return
        (
            isWrong ?
            //This error is just an easy way to let the calling function know about the fact that no
            //calculation has been performed (too big gap). This isn't a properly-speaking error and
            //that's why it will not be notified to the user.
            new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }} :
            //Returning the new big value. For example: with 5*10^4 & 3*10^2, 500 would be returned.
            new UnitInfo(unitInfos2[bigSmallI[0]])
            {{
                Value = big2.Value;
            }}
        )
    }

    static boolean AreAdditionFinalValuesWrong(double val1, double val2, Operations operation)
    {
        boolean isWrong = false;

        try
        {
            val1 = val1 + val2 *
            (
                operation == Operations.Addition ? 1 : -1
            );
        }
        catch { isWrong = true; }

        return isWrong;
    }

    static UnitInfo PerformManagedOperationMultiplication(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationNormalisedValues
        (
            firstInfo, new UnitInfo[] 
            { 
                NormaliseUnitInfo(firstInfo),
                NormaliseUnitInfo(secondInfo) 
            },
            operation
        );
    }

    public static UnitInfo RaiseToIntegerExponent(double baseValue, int exponent)
    {
        return RaiseToIntegerExponent(new UnitInfo(baseValue), exponent);
    }

    static UnitInfo RaiseToIntegerExponent(UnitInfo baseInfo, int exponent)
    {
        if (exponent <= 1 && exponent >= 0)
        {
            baseInfo.Value = (exponent == 0 ? 1.0 : baseInfo.Value);
            return baseInfo;
        }

        UnitInfo outInfo = new UnitInfo(baseInfo);

        for (int i = 1; i < Math.Abs(exponent); i++)
        {
            outInfo = PerformManagedOperationValues
            (
                outInfo, baseInfo, Operations.Multiplication
            );
            if (outInfo.Error.Type != ErrorTypes.None) return outInfo;
        }

        return
        (
            exponent < 0 ?
            PerformManagedOperationValues(new UnitInfo(1.0), outInfo, Operations.Division) :
            outInfo
        );
    }

    static UnitInfo PerformManagedOperationNormalisedValues(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        outInfo =
        (
            normalisedInfos.Length == 1 ?
            //There is just one operand when the difference between both of them is too big.
            outInfo = normalisedInfos[0] :
            PerformManagedOperationTwoOperands(outInfo, normalisedInfos, operation)
        );

        return outInfo;
    }

    static UnitInfo PerformManagedOperationTwoOperands(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        UnitInfo outInfoNormalised = PerformManagedOperationValues
        (
            normalisedInfos[0], normalisedInfos[1], operation
        );

        if (outInfo.Error.Type != ErrorTypes.None)
        {
            return new UnitInfo(outInfo)
            {
                Error = new ErrorInfo(ErrorTypes.NumericError)
            };
        }

        outInfo.BaseTenExponent = outInfoNormalised.BaseTenExponent;
        outInfo.Value = outInfoNormalised.Value;
        //Normalised means no prefixes.
        outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage); 

        return outInfo;
    }

    static UnitInfo PerformManagedOperationValues(double firstValue, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            new UnitInfo(firstValue), new UnitInfo(secondValue), operation
        );
    }

    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            firstInfo, new UnitInfo(secondValue), operation
        );
    }

    //This method might be used to perform full operations (not just being the last calculation step) instead
    //of the default one (PerformManagedOperationUnits) for simple cases. That is: ones not dealing with the
    //complex numeric reality (Value, Prefix and BaseTenExponent) which makes a pre-analysis required.
    //Note that, unlikely what happens with PerformMangedOperationUnits, the outputs of this method aren't
    //normalised (= primarily stored under Value), what is useful in certain contexts.
    //NOTE: this function assumes that both inputs are normalised, what means that no prefix information is expected.
    //It might also be used with non-normalised inputs, but their prefix information would be plainly ignored.
    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        if (firstInfo.Value == 0.0 || secondInfo.Value == 0.0)
        {
            if (operation == Operations.Multiplication || operation == Operations.Division)
            {
                //Dividing by zero scenarios are taken into account somewhere else.
                return new UnitInfo(firstInfo) { Value = 0.0 };
            }
        }

        UnitInfo outInfo = new UnitInfo(firstInfo);
        UnitInfo firstInfo0 = new UnitInfo(firstInfo);
        UnitInfo secondInfo0 = new UnitInfo(secondInfo);

        boolean isWrong = false;
        try
        {
            if (operation == Operations.Addition)
            {
                outInfo.Value += secondInfo0.Value;
            }
            else if (operation == Operations.Subtraction)
            {
                outInfo.Value -= secondInfo.Value;
            }
            else
            {
                //The reason for checking whether BaseTenExponent is inside/outside the int range before performing 
                //the operation (rather than going ahead and eventually catching the resulting exception) isn't just
                //being quicker, but also the only option in many situations. Note that an addition/subtraction between
                //two int variables whose result is outside the int range might not trigger an exception (+ random 
                //negative value as output).
                if (VaryBaseTenExponent(outInfo, secondInfo0.BaseTenExponent, operation == Operations.Division).Error.Type != ErrorTypes.None)
                {
                    return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
                }

                if (operation == Operations.Multiplication)
                {
                    outInfo.Value *= secondInfo.Value;
                    outInfo.BaseTenExponent += secondInfo.BaseTenExponent;
                }
                else if (operation == Operations.Division)
                {
                    if (secondInfo.Value == 0.0)
                    {
                        return
                        (
                            new UnitInfo(outInfo) 
                            { 
                                Error = new ErrorInfo(ErrorTypes.NumericError) 
                            }
                        );
                    }
                    outInfo.Value /= secondInfo.Value;
                    outInfo.BaseTenExponent -= secondInfo.BaseTenExponent;
                }
            }
        }
        catch { isWrong = true; }

        return
        (
            //An error might not be triggered despite of dealing with numbers outside double precision.
            //For example: 0.00000000000000000001m * 0.0000000000000000000001m can output 0.0 without triggering an error. 
            isWrong || ((operation == Operations.Multiplication || operation == Operations.Division) && outInfo.Value == 0.0.0) ?
            OperationValuesManageError(firstInfo0, secondInfo0, operation) : outInfo
        );
    }

    static UnitInfo OperationValuesManageError(UnitInfo outInfo, UnitInfo secondInfo, Operations operation)
    {
        if (operation != Operations.Multiplication && operation != Operations.Division)
        {
            //This condition should never be true on account of the fact that the pre-modifications performed before
            //adding/subtracting should avoid erroneous situations.
            return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
        }

        UnitInfo secondInfo2 = ConvertValueToBaseTen(secondInfo.Value);
        outInfo = VaryBaseTenExponent(outInfo, secondInfo2.BaseTenExponent, operation == Operations.Division);
        if (Math.Abs(secondInfo2.Value) == 1.0 || outInfo.Error.Type != ErrorTypes.None) return outInfo;
        
        try
        {
            outInfo = PerformManagedOperationUnits
            (
                outInfo, secondInfo2.Value, operation
            );
        }
        catch
        {
            //Very unlikely scenario on account of the fact that Math.Abs(secondInfo2.Value)
            //lies within the 0.1-10.0 range.
            outInfo = OperationValuesManageError
            (
                new UnitInfo(outInfo)
                {
                    Value = secondInfo2.Value,
                    BaseTenExponent = 0
                },
                new UnitInfo()
                {
                    Value = outInfo.Value,
                    BaseTenExponent = outInfo.BaseTenExponent
                },
                operation
            );
        }

        return outInfo;
    }

    static UnitInfo ConvertValueToBaseTen(double value)
    {
        value = Math.Abs(value);
        return FromValueToBaseTenExponent
        (
             new UnitInfo(value), Math.Abs(value), false
        );
    }

    static UnitInfo ConvertBaseTenToValue(UnitInfo unitInfo)
    {
        if (unitInfo.BaseTenExponent == 0) return unitInfo;

        UnitInfo outInfo = new UnitInfo(unitInfo);
        boolean decrease = unitInfo.BaseTenExponent > 0;
        int sign = Math.Sign(outInfo.Value);
        double absValue = Math.Abs(outInfo.Value);

        while (outInfo.BaseTenExponent != 0.0)
        {
            if (decrease)
            {
                if (absValue >= MaxValueDec / 10.0) break;
                absValue *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }
            else
            {
                if (absValue <= MinValueDec * 10.0) break;
                absValue /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
        }

        outInfo.Value = sign * absValue;

        return outInfo;
    }

    static UnitInfo NormaliseUnitInfo(UnitInfo unitInfo)
    {
        if (unitInfo.Value == 0 && unitInfo.Prefix.Factor == 1.0)
        {
            return unitInfo;
        }
        UnitInfo outInfo = new UnitInfo(unitInfo);

        if (outInfo.Prefix.Factor != 1)
        {
            outInfo = FromValueToBaseTenExponent
            (
                outInfo, outInfo.Prefix.Factor, true
            );
            outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage);
        }
        if (outInfo.Value == 0.0) return outInfo;

        outInfo = FromValueToBaseTenExponent
        (
            outInfo, outInfo.Value, false
        );

        return outInfo;
    }

    static UnitInfo FromValueToBaseTenExponent(UnitInfo outInfo, double value, boolean isPrefix)
    {
        if (value == 0.0) return outInfo;

        double valueAbs = Math.Abs(value);
        boolean decrease = (valueAbs > 1.0);
        if (!isPrefix)
        {
            outInfo.Value = outInfo.Value / valueAbs;
        }

        while (valueAbs != 1.0)
        {
            if ((valueAbs < 10.0 && valueAbs > 1.0) || (valueAbs > 0.1.0 && valueAbs < 1.0))
            {
                if (!isPrefix) outInfo.Value = value;
                else
                {
                    outInfo = PerformManagedOperationValues
                    (
                        outInfo, value, Operations.Multiplication
                    );
                }

                return outInfo;
            }

            if (decrease)
            {
                value /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
            else
            {
                value *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }

            valueAbs = Math.Abs(value);
        }

        return outInfo;
    }

    //Method used to vary BaseTenExponent without provoking unhandled exceptions (i.e., bigger than Integer.MAX_VALUE).
    static UnitInfo VaryBaseTenExponent(UnitInfo info, int baseTenIncrease, boolean isDivision = false)
    {
        long val1 = info.BaseTenExponent;
        long val2 = baseTenIncrease;

        if (isDivision)
        {
            //Converting a negative value into positive might provoke an overflow error for the int type
            //(e.g., Math.Abs(Integer.MAIN_VALUE)). Converting both variables to long is a quick and effective
            //way to avoid this problem.
            val2 *= -1;
        }

        return
        (
             ((val2 > 0 && val1 > Integer.MAX_VALUE - val2) || (val2 < 0 && val1 < Integer.MAIN_VALUE - val2)) ?
            new UnitInfo(info, ErrorTypes.NumericError) : new UnitInfo(info){{ BaseTenExponent = (int)(val1 + val2); }}
        );
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 2 2017-05-27 20:05:02.536
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 0 2017-05-27 20:05:02.536
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.core 4 4 2017-05-27 20:05:03.945
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
public class OperationsManaged
{
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, double second, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            firstInfo, new UnitInfo(second), operation
        );
    }

    public static UnitInfo PerformManagedOperationUnits(double first, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            new UnitInfo(first), secondInfo, operation
        );
    }

    //This method should always be used when dealing with random UnitInfo variables because it accounts for all the
    //possible scenarios. On the other hand, with simple operations (e.g., random UnitInfo & numeric type) it might
    //be better to use PerformManagedOperationValues. 
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        ErrorTypes errorType = InternalMethods.GetOperationError
        (
            firstInfo, secondInfo, operation
        );
        if (errorType != ErrorTypes.None)
        {
            return new UnitInfo(firstInfo) 
            {{
                Error = new ErrorInfo(errorType); 
            }};
        }

        return
        (
            operation == Operations.Addition || operation == Operations.Subtraction ?
            PerformManagedOperationAddition(firstInfo, secondInfo, operation) :
            PerformManagedOperationMultiplication(firstInfo, secondInfo, operation)
        );
    }

    static UnitInfo PerformManagedOperationAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {   
        //After being normalised, the operands might require further modifications.
        UnitInfo[] normalised = GetOperandsAddition(firstInfo, secondInfo, operation);

        return PerformManagedOperationNormalisedValues
        (
            firstInfo, normalised, operation
        );
    }

    static UnitInfo[] GetOperandsAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        UnitInfo[] operands2 = new UnitInfo[] 
        {
            new UnitInfo(firstInfo), new UnitInfo(secondInfo)
        };

        if (operands2[0].BaseTenExponent != operands2[1].BaseTenExponent || operands2[0].Prefix.Factor != operands2[1].Prefix.Factor)
        {
            //The addition/subtraction might not be performed right away even with normalised values.
            //For example: 5 and 6 from 5*10^2 and 6*10^7 cannot be added right away.
            operands2 = AdaptNormalisedValuesForAddition
            (
                new UnitInfo[] 
                { 
                    NormaliseUnitInfo(operands2[0]), 
                    NormaliseUnitInfo(operands2[1])
                },
                operation
            );
        }

        return operands2;
    }
    
    static UnitInfo[] AdaptNormalisedValuesForAddition(UnitInfo[] unitInfos2, Operations operation)
    {
        if (unitInfos2[0].BaseTenExponent == unitInfos2[1].BaseTenExponent)
        {
            //Having the same BaseTenExponent values means that the given operation can be performed right away.
            return unitInfos2;
        }

        int[] bigSmallI = 
        (
            unitInfos2[0].BaseTenExponent > unitInfos2[1].BaseTenExponent ?
            new int[] { 0, 1 } : new int[] { 1, 0 }
        );

        //Only the variable with the bigger value is modified. For example: 5*10^5 & 3*10^3 is converted
        //into 500*10^3 & 3*10^3 in order to allow the addition 500 + 3. 
        UnitInfo big2 = AdaptBiggerAdditionOperand(unitInfos2, bigSmallI, operation);
        if (big2.Error.Type != ErrorTypes.None)
        {
            return TooBigGapAddition(unitInfos2, bigSmallI, operation);
        }

        unitInfos2[bigSmallI[0]].Value = big2.Value;
        unitInfos2[bigSmallI[0]].BaseTenExponent = unitInfos2[bigSmallI[1]].BaseTenExponent;

        return unitInfos2;
    }

    //When adding/subtracting two numbers whose gap is bigger than the maximum double range, there
    //is no need to perform any operation (i.e., no change will be observed because of being outside
    //the maximum supported precision). This method takes care of these cases and returns the expected
    //output (i.e., biggest value).
    static UnitInfo[] TooBigGapAddition(UnitInfo[] unitInfos2, int[] bigSmallI, Operations operation)
    {
        UnitInfo[] outInfos = new UnitInfo[] 
        {
            //First operand (i.e., one whose information defines the operation) together with the
            //numeric information (i.e., just Value and BaseTenExponent because both are normalised)
            //which is associated with the biggest one.
            new UnitInfo(unitInfos2[0])
            {{
                Value = unitInfos2[bigSmallI[0]].Value;
                BaseTenExponent = unitInfos2[bigSmallI[0]].BaseTenExponent;
            }}
        };

        if (operation == Operations.Subtraction && bigSmallI[0] == 1)
        {
            outInfos[0].Value = -1.0 * outInfos[0].Value;
        }

        if (outInfos[0].Unit == Units.Unitless)
        {
            outInfos[0].Unit = unitInfos2[bigSmallI[1]].Unit;
        }

        return outInfos;
    }

    static UnitInfo AdaptBiggerAdditionOperand(UnitInfo[] unitInfos2, Integer[] bigSmallI, Operations operation)
    {
        int gapExponent = unitInfos2[bigSmallI[0]].BaseTenExponent - unitInfos2[bigSmallI[1]].BaseTenExponent;
        if (gapExponent >= 27)
        {
            //The difference between both inputs is bigger than (or, at least, very close to) the maximum double value/precision;
            //what makes this situation calculation unworthy and the first operand to be returned as the result.
            //Note that the error below these lines is just an easy way to tell the calling function about this eventuality.
            return new UnitInfo(unitInfos2[0]) 
            {{ 
                Error = new ErrorInfo(ErrorTypes.InvalidOperation); 
            }};
        }

        //PerformManagedOperationValues is used to make sure that the resulting numeric information is stored
        //in Value (if possible).
        UnitInfo big2 = PerformManagedOperationValues
        (
            RaiseToIntegerExponent(10.0, gapExponent), unitInfos2[bigSmallI[0]].Value, 
            Operations.Multiplication                
        );

        boolean isWrong = 
        (
            big2.Error.Type != ErrorTypes.None || big2.BaseTenExponent != 0 ?
            
            //The value of the bigger input times 10^(gap between BaseTenExponent of inputs) is too big. 
            isWrong = true :
            
            //Overflow-check very unlikely to trigger an error. In fact, with properly normalised variables,
            //triggering an error would be plainly impossible.               
            AreAdditionFinalValuesWrong
            (
                unitInfos2[0].Value, unitInfos2[1].Value, operation
            )
        );

        if (isWrong)
        {
        	UnitInfo temp = new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }};
            
            temp.Error = new ErrorInfo(ErrorTypes.InvalidOperation);
        }
        
        
        
        return
        (
            isWrong ?
            //This error is just an easy way to let the calling function know about the fact that no
            //calculation has been performed (too big gap). This isn't a properly-speaking error and
            //that's why it will not be notified to the user.
            new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }} :
            //Returning the new big value. For example: with 5*10^4 & 3*10^2, 500 would be returned.
            new UnitInfo(unitInfos2[bigSmallI[0]])
            {{
                Value = big2.Value;
            }}
        )
    }

    static boolean AreAdditionFinalValuesWrong(double val1, double val2, Operations operation)
    {
        boolean isWrong = false;

        try
        {
            val1 = val1 + val2 *
            (
                operation == Operations.Addition ? 1 : -1
            );
        }
        catch { isWrong = true; }

        return isWrong;
    }

    static UnitInfo PerformManagedOperationMultiplication(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationNormalisedValues
        (
            firstInfo, new UnitInfo[] 
            { 
                NormaliseUnitInfo(firstInfo),
                NormaliseUnitInfo(secondInfo) 
            },
            operation
        );
    }

    public static UnitInfo RaiseToIntegerExponent(double baseValue, int exponent)
    {
        return RaiseToIntegerExponent(new UnitInfo(baseValue), exponent);
    }

    static UnitInfo RaiseToIntegerExponent(UnitInfo baseInfo, int exponent)
    {
        if (exponent <= 1 && exponent >= 0)
        {
            baseInfo.Value = (exponent == 0 ? 1.0 : baseInfo.Value);
            return baseInfo;
        }

        UnitInfo outInfo = new UnitInfo(baseInfo);

        for (int i = 1; i < Math.Abs(exponent); i++)
        {
            outInfo = PerformManagedOperationValues
            (
                outInfo, baseInfo, Operations.Multiplication
            );
            if (outInfo.Error.Type != ErrorTypes.None) return outInfo;
        }

        return
        (
            exponent < 0 ?
            PerformManagedOperationValues(new UnitInfo(1.0), outInfo, Operations.Division) :
            outInfo
        );
    }

    static UnitInfo PerformManagedOperationNormalisedValues(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        outInfo =
        (
            normalisedInfos.Length == 1 ?
            //There is just one operand when the difference between both of them is too big.
            outInfo = normalisedInfos[0] :
            PerformManagedOperationTwoOperands(outInfo, normalisedInfos, operation)
        );

        return outInfo;
    }

    static UnitInfo PerformManagedOperationTwoOperands(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        UnitInfo outInfoNormalised = PerformManagedOperationValues
        (
            normalisedInfos[0], normalisedInfos[1], operation
        );

        if (outInfo.Error.Type != ErrorTypes.None)
        {
            return new UnitInfo(outInfo)
            {
                Error = new ErrorInfo(ErrorTypes.NumericError)
            };
        }

        outInfo.BaseTenExponent = outInfoNormalised.BaseTenExponent;
        outInfo.Value = outInfoNormalised.Value;
        //Normalised means no prefixes.
        outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage); 

        return outInfo;
    }

    static UnitInfo PerformManagedOperationValues(double firstValue, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            new UnitInfo(firstValue), new UnitInfo(secondValue), operation
        );
    }

    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            firstInfo, new UnitInfo(secondValue), operation
        );
    }

    //This method might be used to perform full operations (not just being the last calculation step) instead
    //of the default one (PerformManagedOperationUnits) for simple cases. That is: ones not dealing with the
    //complex numeric reality (Value, Prefix and BaseTenExponent) which makes a pre-analysis required.
    //Note that, unlikely what happens with PerformMangedOperationUnits, the outputs of this method aren't
    //normalised (= primarily stored under Value), what is useful in certain contexts.
    //NOTE: this function assumes that both inputs are normalised, what means that no prefix information is expected.
    //It might also be used with non-normalised inputs, but their prefix information would be plainly ignored.
    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        if (firstInfo.Value == 0.0 || secondInfo.Value == 0.0)
        {
            if (operation == Operations.Multiplication || operation == Operations.Division)
            {
                //Dividing by zero scenarios are taken into account somewhere else.
                return new UnitInfo(firstInfo) { Value = 0.0 };
            }
        }

        UnitInfo outInfo = new UnitInfo(firstInfo);
        UnitInfo firstInfo0 = new UnitInfo(firstInfo);
        UnitInfo secondInfo0 = new UnitInfo(secondInfo);

        boolean isWrong = false;
        try
        {
            if (operation == Operations.Addition)
            {
                outInfo.Value += secondInfo0.Value;
            }
            else if (operation == Operations.Subtraction)
            {
                outInfo.Value -= secondInfo.Value;
            }
            else
            {
                //The reason for checking whether BaseTenExponent is inside/outside the int range before performing 
                //the operation (rather than going ahead and eventually catching the resulting exception) isn't just
                //being quicker, but also the only option in many situations. Note that an addition/subtraction between
                //two int variables whose result is outside the int range might not trigger an exception (+ random 
                //negative value as output).
                if (VaryBaseTenExponent(outInfo, secondInfo0.BaseTenExponent, operation == Operations.Division).Error.Type != ErrorTypes.None)
                {
                    return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
                }

                if (operation == Operations.Multiplication)
                {
                    outInfo.Value *= secondInfo.Value;
                    outInfo.BaseTenExponent += secondInfo.BaseTenExponent;
                }
                else if (operation == Operations.Division)
                {
                    if (secondInfo.Value == 0.0)
                    {
                        return
                        (
                            new UnitInfo(outInfo) 
                            { 
                                Error = new ErrorInfo(ErrorTypes.NumericError) 
                            }
                        );
                    }
                    outInfo.Value /= secondInfo.Value;
                    outInfo.BaseTenExponent -= secondInfo.BaseTenExponent;
                }
            }
        }
        catch { isWrong = true; }

        return
        (
            //An error might not be triggered despite of dealing with numbers outside double precision.
            //For example: 0.00000000000000000001m * 0.0000000000000000000001m can output 0.0 without triggering an error. 
            isWrong || ((operation == Operations.Multiplication || operation == Operations.Division) && outInfo.Value == 0.0.0) ?
            OperationValuesManageError(firstInfo0, secondInfo0, operation) : outInfo
        );
    }

    static UnitInfo OperationValuesManageError(UnitInfo outInfo, UnitInfo secondInfo, Operations operation)
    {
        if (operation != Operations.Multiplication && operation != Operations.Division)
        {
            //This condition should never be true on account of the fact that the pre-modifications performed before
            //adding/subtracting should avoid erroneous situations.
            return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
        }

        UnitInfo secondInfo2 = ConvertValueToBaseTen(secondInfo.Value);
        outInfo = VaryBaseTenExponent(outInfo, secondInfo2.BaseTenExponent, operation == Operations.Division);
        if (Math.Abs(secondInfo2.Value) == 1.0 || outInfo.Error.Type != ErrorTypes.None) return outInfo;
        
        try
        {
            outInfo = PerformManagedOperationUnits
            (
                outInfo, secondInfo2.Value, operation
            );
        }
        catch
        {
            //Very unlikely scenario on account of the fact that Math.Abs(secondInfo2.Value)
            //lies within the 0.1-10.0 range.
            outInfo = OperationValuesManageError
            (
                new UnitInfo(outInfo)
                {
                    Value = secondInfo2.Value,
                    BaseTenExponent = 0
                },
                new UnitInfo()
                {
                    Value = outInfo.Value,
                    BaseTenExponent = outInfo.BaseTenExponent
                },
                operation
            );
        }

        return outInfo;
    }

    static UnitInfo ConvertValueToBaseTen(double value)
    {
        value = Math.Abs(value);
        return FromValueToBaseTenExponent
        (
             new UnitInfo(value), Math.Abs(value), false
        );
    }

    static UnitInfo ConvertBaseTenToValue(UnitInfo unitInfo)
    {
        if (unitInfo.BaseTenExponent == 0) return unitInfo;

        UnitInfo outInfo = new UnitInfo(unitInfo);
        boolean decrease = unitInfo.BaseTenExponent > 0;
        int sign = Math.Sign(outInfo.Value);
        double absValue = Math.Abs(outInfo.Value);

        while (outInfo.BaseTenExponent != 0.0)
        {
            if (decrease)
            {
                if (absValue >= MaxValueDec / 10.0) break;
                absValue *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }
            else
            {
                if (absValue <= MinValueDec * 10.0) break;
                absValue /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
        }

        outInfo.Value = sign * absValue;

        return outInfo;
    }

    static UnitInfo NormaliseUnitInfo(UnitInfo unitInfo)
    {
        if (unitInfo.Value == 0 && unitInfo.Prefix.Factor == 1.0)
        {
            return unitInfo;
        }
        UnitInfo outInfo = new UnitInfo(unitInfo);

        if (outInfo.Prefix.Factor != 1)
        {
            outInfo = FromValueToBaseTenExponent
            (
                outInfo, outInfo.Prefix.Factor, true
            );
            outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage);
        }
        if (outInfo.Value == 0.0) return outInfo;

        outInfo = FromValueToBaseTenExponent
        (
            outInfo, outInfo.Value, false
        );

        return outInfo;
    }

    static UnitInfo FromValueToBaseTenExponent(UnitInfo outInfo, double value, boolean isPrefix)
    {
        if (value == 0.0) return outInfo;

        double valueAbs = Math.Abs(value);
        boolean decrease = (valueAbs > 1.0);
        if (!isPrefix)
        {
            outInfo.Value = outInfo.Value / valueAbs;
        }

        while (valueAbs != 1.0)
        {
            if ((valueAbs < 10.0 && valueAbs > 1.0) || (valueAbs > 0.1.0 && valueAbs < 1.0))
            {
                if (!isPrefix) outInfo.Value = value;
                else
                {
                    outInfo = PerformManagedOperationValues
                    (
                        outInfo, value, Operations.Multiplication
                    );
                }

                return outInfo;
            }

            if (decrease)
            {
                value /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
            else
            {
                value *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }

            valueAbs = Math.Abs(value);
        }

        return outInfo;
    }

    //Method used to vary BaseTenExponent without provoking unhandled exceptions (i.e., bigger than Integer.MAX_VALUE).
    static UnitInfo VaryBaseTenExponent(UnitInfo info, int baseTenIncrease, boolean isDivision = false)
    {
        long val1 = info.BaseTenExponent;
        long val2 = baseTenIncrease;

        if (isDivision)
        {
            //Converting a negative value into positive might provoke an overflow error for the int type
            //(e.g., Math.Abs(Integer.MAIN_VALUE)). Converting both variables to long is a quick and effective
            //way to avoid this problem.
            val2 *= -1;
        }

        return
        (
             ((val2 > 0 && val1 > Integer.MAX_VALUE - val2) || (val2 < 0 && val1 < Integer.MAIN_VALUE - val2)) ?
            new UnitInfo(info, ErrorTypes.NumericError) : new UnitInfo(info){{ BaseTenExponent = (int)(val1 + val2); }}
        );
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2017-05-27 20:05:03.946
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2017-05-27 20:05:03.947
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2017-05-27 20:05:04.142
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
public class OperationsManaged
{
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, double second, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            firstInfo, new UnitInfo(second), operation
        );
    }

    public static UnitInfo PerformManagedOperationUnits(double first, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            new UnitInfo(first), secondInfo, operation
        );
    }

    //This method should always be used when dealing with random UnitInfo variables because it accounts for all the
    //possible scenarios. On the other hand, with simple operations (e.g., random UnitInfo & numeric type) it might
    //be better to use PerformManagedOperationValues. 
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        ErrorTypes errorType = InternalMethods.GetOperationError
        (
            firstInfo, secondInfo, operation
        );
        if (errorType != ErrorTypes.None)
        {
            return new UnitInfo(firstInfo) 
            {{
                Error = new ErrorInfo(errorType); 
            }};
        }

        return
        (
            operation == Operations.Addition || operation == Operations.Subtraction ?
            PerformManagedOperationAddition(firstInfo, secondInfo, operation) :
            PerformManagedOperationMultiplication(firstInfo, secondInfo, operation)
        );
    }

    static UnitInfo PerformManagedOperationAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {   
        //After being normalised, the operands might require further modifications.
        UnitInfo[] normalised = GetOperandsAddition(firstInfo, secondInfo, operation);

        return PerformManagedOperationNormalisedValues
        (
            firstInfo, normalised, operation
        );
    }

    static UnitInfo[] GetOperandsAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        UnitInfo[] operands2 = new UnitInfo[] 
        {
            new UnitInfo(firstInfo), new UnitInfo(secondInfo)
        };

        if (operands2[0].BaseTenExponent != operands2[1].BaseTenExponent || operands2[0].Prefix.Factor != operands2[1].Prefix.Factor)
        {
            //The addition/subtraction might not be performed right away even with normalised values.
            //For example: 5 and 6 from 5*10^2 and 6*10^7 cannot be added right away.
            operands2 = AdaptNormalisedValuesForAddition
            (
                new UnitInfo[] 
                { 
                    NormaliseUnitInfo(operands2[0]), 
                    NormaliseUnitInfo(operands2[1])
                },
                operation
            );
        }

        return operands2;
    }
    
    static UnitInfo[] AdaptNormalisedValuesForAddition(UnitInfo[] unitInfos2, Operations operation)
    {
        if (unitInfos2[0].BaseTenExponent == unitInfos2[1].BaseTenExponent)
        {
            //Having the same BaseTenExponent values means that the given operation can be performed right away.
            return unitInfos2;
        }

        int[] bigSmallI = 
        (
            unitInfos2[0].BaseTenExponent > unitInfos2[1].BaseTenExponent ?
            new int[] { 0, 1 } : new int[] { 1, 0 }
        );

        //Only the variable with the bigger value is modified. For example: 5*10^5 & 3*10^3 is converted
        //into 500*10^3 & 3*10^3 in order to allow the addition 500 + 3. 
        UnitInfo big2 = AdaptBiggerAdditionOperand(unitInfos2, bigSmallI, operation);
        if (big2.Error.Type != ErrorTypes.None)
        {
            return TooBigGapAddition(unitInfos2, bigSmallI, operation);
        }

        unitInfos2[bigSmallI[0]].Value = big2.Value;
        unitInfos2[bigSmallI[0]].BaseTenExponent = unitInfos2[bigSmallI[1]].BaseTenExponent;

        return unitInfos2;
    }

    //When adding/subtracting two numbers whose gap is bigger than the maximum double range, there
    //is no need to perform any operation (i.e., no change will be observed because of being outside
    //the maximum supported precision). This method takes care of these cases and returns the expected
    //output (i.e., biggest value).
    static UnitInfo[] TooBigGapAddition(UnitInfo[] unitInfos2, int[] bigSmallI, Operations operation)
    {
        UnitInfo[] outInfos = new UnitInfo[] 
        {
            //First operand (i.e., one whose information defines the operation) together with the
            //numeric information (i.e., just Value and BaseTenExponent because both are normalised)
            //which is associated with the biggest one.
            new UnitInfo(unitInfos2[0])
            {{
                Value = unitInfos2[bigSmallI[0]].Value;
                BaseTenExponent = unitInfos2[bigSmallI[0]].BaseTenExponent;
            }}
        };

        if (operation == Operations.Subtraction && bigSmallI[0] == 1)
        {
            outInfos[0].Value = -1.0 * outInfos[0].Value;
        }

        if (outInfos[0].Unit == Units.Unitless)
        {
            outInfos[0].Unit = unitInfos2[bigSmallI[1]].Unit;
        }

        return outInfos;
    }

    static UnitInfo AdaptBiggerAdditionOperand(UnitInfo[] unitInfos2, Integer[] bigSmallI, Operations operation)
    {
        int gapExponent = unitInfos2[bigSmallI[0]].BaseTenExponent - unitInfos2[bigSmallI[1]].BaseTenExponent;
        if (gapExponent >= 27)
        {
            //The difference between both inputs is bigger than (or, at least, very close to) the maximum double value/precision;
            //what makes this situation calculation unworthy and the first operand to be returned as the result.
            //Note that the error below these lines is just an easy way to tell the calling function about this eventuality.
            return new UnitInfo(unitInfos2[0]) 
            {{ 
                Error = new ErrorInfo(ErrorTypes.InvalidOperation); 
            }};
        }

        //PerformManagedOperationValues is used to make sure that the resulting numeric information is stored
        //in Value (if possible).
        UnitInfo big2 = PerformManagedOperationValues
        (
            RaiseToIntegerExponent(10.0, gapExponent), unitInfos2[bigSmallI[0]].Value, 
            Operations.Multiplication                
        );

        boolean isWrong = 
        (
            big2.Error.Type != ErrorTypes.None || big2.BaseTenExponent != 0 ?
            
            //The value of the bigger input times 10^(gap between BaseTenExponent of inputs) is too big. 
            isWrong = true :
            
            //Overflow-check very unlikely to trigger an error. In fact, with properly normalised variables,
            //triggering an error would be plainly impossible.               
            AreAdditionFinalValuesWrong
            (
                unitInfos2[0].Value, unitInfos2[1].Value, operation
            )
        );

        if (isWrong)
        {
        	UnitInfo temp = new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }};
            
            temp.Error = new ErrorInfo(ErrorTypes.InvalidOperation);
        }
        
        
        
        return
        (
            isWrong ?
            //This error is just an easy way to let the calling function know about the fact that no
            //calculation has been performed (too big gap). This isn't a properly-speaking error and
            //that's why it will not be notified to the user.
            new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }} :
            //Returning the new big value. For example: with 5*10^4 & 3*10^2, 500 would be returned.
            new UnitInfo(unitInfos2[bigSmallI[0]])
            {{
                Value = big2.Value;
            }}
        )
    }

    static boolean AreAdditionFinalValuesWrong(double val1, double val2, Operations operation)
    {
        boolean isWrong = false;

        try
        {
            val1 = val1 + val2 *
            (
                operation == Operations.Addition ? 1 : -1
            );
        }
        catch { isWrong = true; }

        return isWrong;
    }

    static UnitInfo PerformManagedOperationMultiplication(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationNormalisedValues
        (
            firstInfo, new UnitInfo[] 
            { 
                NormaliseUnitInfo(firstInfo),
                NormaliseUnitInfo(secondInfo) 
            },
            operation
        );
    }

    public static UnitInfo RaiseToIntegerExponent(double baseValue, int exponent)
    {
        return RaiseToIntegerExponent(new UnitInfo(baseValue), exponent);
    }

    static UnitInfo RaiseToIntegerExponent(UnitInfo baseInfo, int exponent)
    {
        if (exponent <= 1 && exponent >= 0)
        {
            baseInfo.Value = (exponent == 0 ? 1.0 : baseInfo.Value);
            return baseInfo;
        }

        UnitInfo outInfo = new UnitInfo(baseInfo);

        for (int i = 1; i < Math.Abs(exponent); i++)
        {
            outInfo = PerformManagedOperationValues
            (
                outInfo, baseInfo, Operations.Multiplication
            );
            if (outInfo.Error.Type != ErrorTypes.None) return outInfo;
        }

        return
        (
            exponent < 0 ?
            PerformManagedOperationValues(new UnitInfo(1.0), outInfo, Operations.Division) :
            outInfo
        );
    }

    static UnitInfo PerformManagedOperationNormalisedValues(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        outInfo =
        (
            normalisedInfos.Length == 1 ?
            //There is just one operand when the difference between both of them is too big.
            outInfo = normalisedInfos[0] :
            PerformManagedOperationTwoOperands(outInfo, normalisedInfos, operation)
        );

        return outInfo;
    }

    static UnitInfo PerformManagedOperationTwoOperands(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        UnitInfo outInfoNormalised = PerformManagedOperationValues
        (
            normalisedInfos[0], normalisedInfos[1], operation
        );

        if (outInfo.Error.Type != ErrorTypes.None)
        {
            return new UnitInfo(outInfo)
            {
                Error = new ErrorInfo(ErrorTypes.NumericError)
            };
        }

        outInfo.BaseTenExponent = outInfoNormalised.BaseTenExponent;
        outInfo.Value = outInfoNormalised.Value;
        //Normalised means no prefixes.
        outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage); 

        return outInfo;
    }

    static UnitInfo PerformManagedOperationValues(double firstValue, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            new UnitInfo(firstValue), new UnitInfo(secondValue), operation
        );
    }

    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            firstInfo, new UnitInfo(secondValue), operation
        );
    }

    //This method might be used to perform full operations (not just being the last calculation step) instead
    //of the default one (PerformManagedOperationUnits) for simple cases. That is: ones not dealing with the
    //complex numeric reality (Value, Prefix and BaseTenExponent) which makes a pre-analysis required.
    //Note that, unlikely what happens with PerformMangedOperationUnits, the outputs of this method aren't
    //normalised (= primarily stored under Value), what is useful in certain contexts.
    //NOTE: this function assumes that both inputs are normalised, what means that no prefix information is expected.
    //It might also be used with non-normalised inputs, but their prefix information would be plainly ignored.
    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        if (firstInfo.Value == 0.0 || secondInfo.Value == 0.0)
        {
            if (operation == Operations.Multiplication || operation == Operations.Division)
            {
                //Dividing by zero scenarios are taken into account somewhere else.
                return new UnitInfo(firstInfo) { Value = 0.0 };
            }
        }

        UnitInfo outInfo = new UnitInfo(firstInfo);
        UnitInfo firstInfo0 = new UnitInfo(firstInfo);
        UnitInfo secondInfo0 = new UnitInfo(secondInfo);

        boolean isWrong = false;
        try
        {
            if (operation == Operations.Addition)
            {
                outInfo.Value += secondInfo0.Value;
            }
            else if (operation == Operations.Subtraction)
            {
                outInfo.Value -= secondInfo.Value;
            }
            else
            {
                //The reason for checking whether BaseTenExponent is inside/outside the int range before performing 
                //the operation (rather than going ahead and eventually catching the resulting exception) isn't just
                //being quicker, but also the only option in many situations. Note that an addition/subtraction between
                //two int variables whose result is outside the int range might not trigger an exception (+ random 
                //negative value as output).
                if (VaryBaseTenExponent(outInfo, secondInfo0.BaseTenExponent, operation == Operations.Division).Error.Type != ErrorTypes.None)
                {
                    return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
                }

                if (operation == Operations.Multiplication)
                {
                    outInfo.Value *= secondInfo.Value;
                    outInfo.BaseTenExponent += secondInfo.BaseTenExponent;
                }
                else if (operation == Operations.Division)
                {
                    if (secondInfo.Value == 0.0)
                    {
                        return
                        (
                            new UnitInfo(outInfo) 
                            { 
                                Error = new ErrorInfo(ErrorTypes.NumericError) 
                            }
                        );
                    }
                    outInfo.Value /= secondInfo.Value;
                    outInfo.BaseTenExponent -= secondInfo.BaseTenExponent;
                }
            }
        }
        catch { isWrong = true; }

        return
        (
            //An error might not be triggered despite of dealing with numbers outside double precision.
            //For example: 0.00000000000000000001m * 0.0000000000000000000001m can output 0.0 without triggering an error. 
            isWrong || ((operation == Operations.Multiplication || operation == Operations.Division) && outInfo.Value == 0.0.0) ?
            OperationValuesManageError(firstInfo0, secondInfo0, operation) : outInfo
        );
    }

    static UnitInfo OperationValuesManageError(UnitInfo outInfo, UnitInfo secondInfo, Operations operation)
    {
        if (operation != Operations.Multiplication && operation != Operations.Division)
        {
            //This condition should never be true on account of the fact that the pre-modifications performed before
            //adding/subtracting should avoid erroneous situations.
            return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
        }

        UnitInfo secondInfo2 = ConvertValueToBaseTen(secondInfo.Value);
        outInfo = VaryBaseTenExponent(outInfo, secondInfo2.BaseTenExponent, operation == Operations.Division);
        if (Math.Abs(secondInfo2.Value) == 1.0 || outInfo.Error.Type != ErrorTypes.None) return outInfo;
        
        try
        {
            outInfo = PerformManagedOperationUnits
            (
                outInfo, secondInfo2.Value, operation
            );
        }
        catch
        {
            //Very unlikely scenario on account of the fact that Math.Abs(secondInfo2.Value)
            //lies within the 0.1-10.0 range.
            outInfo = OperationValuesManageError
            (
                new UnitInfo(outInfo)
                {
                    Value = secondInfo2.Value,
                    BaseTenExponent = 0
                },
                new UnitInfo()
                {
                    Value = outInfo.Value,
                    BaseTenExponent = outInfo.BaseTenExponent
                },
                operation
            );
        }

        return outInfo;
    }

    static UnitInfo ConvertValueToBaseTen(double value)
    {
        value = Math.Abs(value);
        return FromValueToBaseTenExponent
        (
             new UnitInfo(value), Math.Abs(value), false
        );
    }

    static UnitInfo ConvertBaseTenToValue(UnitInfo unitInfo)
    {
        if (unitInfo.BaseTenExponent == 0) return unitInfo;

        UnitInfo outInfo = new UnitInfo(unitInfo);
        boolean decrease = unitInfo.BaseTenExponent > 0;
        int sign = Math.Sign(outInfo.Value);
        double absValue = Math.Abs(outInfo.Value);

        while (outInfo.BaseTenExponent != 0.0)
        {
            if (decrease)
            {
                if (absValue >= MaxValueDec / 10.0) break;
                absValue *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }
            else
            {
                if (absValue <= MinValueDec * 10.0) break;
                absValue /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
        }

        outInfo.Value = sign * absValue;

        return outInfo;
    }

    static UnitInfo NormaliseUnitInfo(UnitInfo unitInfo)
    {
        if (unitInfo.Value == 0 && unitInfo.Prefix.Factor == 1.0)
        {
            return unitInfo;
        }
        UnitInfo outInfo = new UnitInfo(unitInfo);

        if (outInfo.Prefix.Factor != 1)
        {
            outInfo = FromValueToBaseTenExponent
            (
                outInfo, outInfo.Prefix.Factor, true
            );
            outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage);
        }
        if (outInfo.Value == 0.0) return outInfo;

        outInfo = FromValueToBaseTenExponent
        (
            outInfo, outInfo.Value, false
        );

        return outInfo;
    }

    static UnitInfo FromValueToBaseTenExponent(UnitInfo outInfo, double value, boolean isPrefix)
    {
        if (value == 0.0) return outInfo;

        double valueAbs = Math.Abs(value);
        boolean decrease = (valueAbs > 1.0);
        if (!isPrefix)
        {
            outInfo.Value = outInfo.Value / valueAbs;
        }

        while (valueAbs != 1.0)
        {
            if ((valueAbs < 10.0 && valueAbs > 1.0) || (valueAbs > 0.1.0 && valueAbs < 1.0))
            {
                if (!isPrefix) outInfo.Value = value;
                else
                {
                    outInfo = PerformManagedOperationValues
                    (
                        outInfo, value, Operations.Multiplication
                    );
                }

                return outInfo;
            }

            if (decrease)
            {
                value /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
            else
            {
                value *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }

            valueAbs = Math.Abs(value);
        }

        return outInfo;
    }

    //Method used to vary BaseTenExponent without provoking unhandled exceptions (i.e., bigger than Integer.MAX_VALUE).
    static UnitInfo VaryBaseTenExponent(UnitInfo info, int baseTenIncrease, boolean isDivision = false)
    {
        long val1 = info.BaseTenExponent;
        long val2 = baseTenIncrease;

        if (isDivision)
        {
            //Converting a negative value into positive might provoke an overflow error for the int type
            //(e.g., Math.Abs(Integer.MAIN_VALUE)). Converting both variables to long is a quick and effective
            //way to avoid this problem.
            val2 *= -1;
        }

        return
        (
             ((val2 > 0 && val1 > Integer.MAX_VALUE - val2) || (val2 < 0 && val1 < Integer.MAIN_VALUE - val2)) ?
            new UnitInfo(info, ErrorTypes.NumericError) : new UnitInfo(info){{ BaseTenExponent = (int)(val1 + val2); }}
        );
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 2 2017-05-27 20:05:04.143
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 0 2017-05-27 20:05:04.144
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.core 4 4 2017-05-27 20:05:05.983
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
public class OperationsManaged
{
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, double second, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            firstInfo, new UnitInfo(second), operation
        );
    }

    public static UnitInfo PerformManagedOperationUnits(double first, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            new UnitInfo(first), secondInfo, operation
        );
    }

    //This method should always be used when dealing with random UnitInfo variables because it accounts for all the
    //possible scenarios. On the other hand, with simple operations (e.g., random UnitInfo & numeric type) it might
    //be better to use PerformManagedOperationValues. 
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        ErrorTypes errorType = InternalMethods.GetOperationError
        (
            firstInfo, secondInfo, operation
        );
        if (errorType != ErrorTypes.None)
        {
            return new UnitInfo(firstInfo) 
            {{
                Error = new ErrorInfo(errorType); 
            }};
        }

        return
        (
            operation == Operations.Addition || operation == Operations.Subtraction ?
            PerformManagedOperationAddition(firstInfo, secondInfo, operation) :
            PerformManagedOperationMultiplication(firstInfo, secondInfo, operation)
        );
    }

    static UnitInfo PerformManagedOperationAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {   
        //After being normalised, the operands might require further modifications.
        UnitInfo[] normalised = GetOperandsAddition(firstInfo, secondInfo, operation);

        return PerformManagedOperationNormalisedValues
        (
            firstInfo, normalised, operation
        );
    }

    static UnitInfo[] GetOperandsAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        UnitInfo[] operands2 = new UnitInfo[] 
        {
            new UnitInfo(firstInfo), new UnitInfo(secondInfo)
        };

        if (operands2[0].BaseTenExponent != operands2[1].BaseTenExponent || operands2[0].Prefix.Factor != operands2[1].Prefix.Factor)
        {
            //The addition/subtraction might not be performed right away even with normalised values.
            //For example: 5 and 6 from 5*10^2 and 6*10^7 cannot be added right away.
            operands2 = AdaptNormalisedValuesForAddition
            (
                new UnitInfo[] 
                { 
                    NormaliseUnitInfo(operands2[0]), 
                    NormaliseUnitInfo(operands2[1])
                },
                operation
            );
        }

        return operands2;
    }
    
    static UnitInfo[] AdaptNormalisedValuesForAddition(UnitInfo[] unitInfos2, Operations operation)
    {
        if (unitInfos2[0].BaseTenExponent == unitInfos2[1].BaseTenExponent)
        {
            //Having the same BaseTenExponent values means that the given operation can be performed right away.
            return unitInfos2;
        }

        int[] bigSmallI = 
        (
            unitInfos2[0].BaseTenExponent > unitInfos2[1].BaseTenExponent ?
            new int[] { 0, 1 } : new int[] { 1, 0 }
        );

        //Only the variable with the bigger value is modified. For example: 5*10^5 & 3*10^3 is converted
        //into 500*10^3 & 3*10^3 in order to allow the addition 500 + 3. 
        UnitInfo big2 = AdaptBiggerAdditionOperand(unitInfos2, bigSmallI, operation);
        if (big2.Error.Type != ErrorTypes.None)
        {
            return TooBigGapAddition(unitInfos2, bigSmallI, operation);
        }

        unitInfos2[bigSmallI[0]].Value = big2.Value;
        unitInfos2[bigSmallI[0]].BaseTenExponent = unitInfos2[bigSmallI[1]].BaseTenExponent;

        return unitInfos2;
    }

    //When adding/subtracting two numbers whose gap is bigger than the maximum double range, there
    //is no need to perform any operation (i.e., no change will be observed because of being outside
    //the maximum supported precision). This method takes care of these cases and returns the expected
    //output (i.e., biggest value).
    static UnitInfo[] TooBigGapAddition(UnitInfo[] unitInfos2, int[] bigSmallI, Operations operation)
    {
        UnitInfo[] outInfos = new UnitInfo[] 
        {
            //First operand (i.e., one whose information defines the operation) together with the
            //numeric information (i.e., just Value and BaseTenExponent because both are normalised)
            //which is associated with the biggest one.
            new UnitInfo(unitInfos2[0])
            {{
                Value = unitInfos2[bigSmallI[0]].Value;
                BaseTenExponent = unitInfos2[bigSmallI[0]].BaseTenExponent;
            }}
        };

        if (operation == Operations.Subtraction && bigSmallI[0] == 1)
        {
            outInfos[0].Value = -1.0 * outInfos[0].Value;
        }

        if (outInfos[0].Unit == Units.Unitless)
        {
            outInfos[0].Unit = unitInfos2[bigSmallI[1]].Unit;
        }

        return outInfos;
    }

    static UnitInfo AdaptBiggerAdditionOperand(UnitInfo[] unitInfos2, Integer[] bigSmallI, Operations operation)
    {
        int gapExponent = unitInfos2[bigSmallI[0]].BaseTenExponent - unitInfos2[bigSmallI[1]].BaseTenExponent;
        if (gapExponent >= 27)
        {
            //The difference between both inputs is bigger than (or, at least, very close to) the maximum double value/precision;
            //what makes this situation calculation unworthy and the first operand to be returned as the result.
            //Note that the error below these lines is just an easy way to tell the calling function about this eventuality.
            return new UnitInfo(unitInfos2[0]) 
            {{ 
                Error = new ErrorInfo(ErrorTypes.InvalidOperation); 
            }};
        }

        //PerformManagedOperationValues is used to make sure that the resulting numeric information is stored
        //in Value (if possible).
        UnitInfo big2 = PerformManagedOperationValues
        (
            RaiseToIntegerExponent(10.0, gapExponent), unitInfos2[bigSmallI[0]].Value, 
            Operations.Multiplication                
        );

        boolean isWrong = 
        (
            big2.Error.Type != ErrorTypes.None || big2.BaseTenExponent != 0 ?
            
            //The value of the bigger input times 10^(gap between BaseTenExponent of inputs) is too big. 
            isWrong = true :
            
            //Overflow-check very unlikely to trigger an error. In fact, with properly normalised variables,
            //triggering an error would be plainly impossible.               
            AreAdditionFinalValuesWrong
            (
                unitInfos2[0].Value, unitInfos2[1].Value, operation
            )
        );

        if (isWrong)
        {
        	UnitInfo temp = new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }};
            
            temp.Error = new ErrorInfo(ErrorTypes.InvalidOperation);
        }
        
        
        
        return
        (
            isWrong ?
            //This error is just an easy way to let the calling function know about the fact that no
            //calculation has been performed (too big gap). This isn't a properly-speaking error and
            //that's why it will not be notified to the user.
            new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }} :
            //Returning the new big value. For example: with 5*10^4 & 3*10^2, 500 would be returned.
            new UnitInfo(unitInfos2[bigSmallI[0]])
            {{
                Value = big2.Value;
            }}
        )
    }

    static boolean AreAdditionFinalValuesWrong(double val1, double val2, Operations operation)
    {
        boolean isWrong = false;

        try
        {
            val1 = val1 + val2 *
            (
                operation == Operations.Addition ? 1 : -1
            );
        }
        catch { isWrong = true; }

        return isWrong;
    }

    static UnitInfo PerformManagedOperationMultiplication(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationNormalisedValues
        (
            firstInfo, new UnitInfo[] 
            { 
                NormaliseUnitInfo(firstInfo),
                NormaliseUnitInfo(secondInfo) 
            },
            operation
        );
    }

    public static UnitInfo RaiseToIntegerExponent(double baseValue, int exponent)
    {
        return RaiseToIntegerExponent(new UnitInfo(baseValue), exponent);
    }

    static UnitInfo RaiseToIntegerExponent(UnitInfo baseInfo, int exponent)
    {
        if (exponent <= 1 && exponent >= 0)
        {
            baseInfo.Value = (exponent == 0 ? 1.0 : baseInfo.Value);
            return baseInfo;
        }

        UnitInfo outInfo = new UnitInfo(baseInfo);

        for (int i = 1; i < Math.Abs(exponent); i++)
        {
            outInfo = PerformManagedOperationValues
            (
                outInfo, baseInfo, Operations.Multiplication
            );
            if (outInfo.Error.Type != ErrorTypes.None) return outInfo;
        }

        return
        (
            exponent < 0 ?
            PerformManagedOperationValues(new UnitInfo(1.0), outInfo, Operations.Division) :
            outInfo
        );
    }

    static UnitInfo PerformManagedOperationNormalisedValues(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        outInfo =
        (
            normalisedInfos.Length == 1 ?
            //There is just one operand when the difference between both of them is too big.
            outInfo = normalisedInfos[0] :
            PerformManagedOperationTwoOperands(outInfo, normalisedInfos, operation)
        );

        return outInfo;
    }

    static UnitInfo PerformManagedOperationTwoOperands(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        UnitInfo outInfoNormalised = PerformManagedOperationValues
        (
            normalisedInfos[0], normalisedInfos[1], operation
        );

        if (outInfo.Error.Type != ErrorTypes.None)
        {
            return new UnitInfo(outInfo)
            {
                Error = new ErrorInfo(ErrorTypes.NumericError)
            };
        }

        outInfo.BaseTenExponent = outInfoNormalised.BaseTenExponent;
        outInfo.Value = outInfoNormalised.Value;
        //Normalised means no prefixes.
        outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage); 

        return outInfo;
    }

    static UnitInfo PerformManagedOperationValues(double firstValue, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            new UnitInfo(firstValue), new UnitInfo(secondValue), operation
        );
    }

    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            firstInfo, new UnitInfo(secondValue), operation
        );
    }

    //This method might be used to perform full operations (not just being the last calculation step) instead
    //of the default one (PerformManagedOperationUnits) for simple cases. That is: ones not dealing with the
    //complex numeric reality (Value, Prefix and BaseTenExponent) which makes a pre-analysis required.
    //Note that, unlikely what happens with PerformMangedOperationUnits, the outputs of this method aren't
    //normalised (= primarily stored under Value), what is useful in certain contexts.
    //NOTE: this function assumes that both inputs are normalised, what means that no prefix information is expected.
    //It might also be used with non-normalised inputs, but their prefix information would be plainly ignored.
    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        if (firstInfo.Value == 0.0 || secondInfo.Value == 0.0)
        {
            if (operation == Operations.Multiplication || operation == Operations.Division)
            {
                //Dividing by zero scenarios are taken into account somewhere else.
                return new UnitInfo(firstInfo) { Value = 0.0 };
            }
        }

        UnitInfo outInfo = new UnitInfo(firstInfo);
        UnitInfo firstInfo0 = new UnitInfo(firstInfo);
        UnitInfo secondInfo0 = new UnitInfo(secondInfo);

        boolean isWrong = false;
        try
        {
            if (operation == Operations.Addition)
            {
                outInfo.Value += secondInfo0.Value;
            }
            else if (operation == Operations.Subtraction)
            {
                outInfo.Value -= secondInfo.Value;
            }
            else
            {
                //The reason for checking whether BaseTenExponent is inside/outside the int range before performing 
                //the operation (rather than going ahead and eventually catching the resulting exception) isn't just
                //being quicker, but also the only option in many situations. Note that an addition/subtraction between
                //two int variables whose result is outside the int range might not trigger an exception (+ random 
                //negative value as output).
                if (VaryBaseTenExponent(outInfo, secondInfo0.BaseTenExponent, operation == Operations.Division).Error.Type != ErrorTypes.None)
                {
                    return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
                }

                if (operation == Operations.Multiplication)
                {
                    outInfo.Value *= secondInfo.Value;
                    outInfo.BaseTenExponent += secondInfo.BaseTenExponent;
                }
                else if (operation == Operations.Division)
                {
                    if (secondInfo.Value == 0.0)
                    {
                        return
                        (
                            new UnitInfo(outInfo) 
                            { 
                                Error = new ErrorInfo(ErrorTypes.NumericError) 
                            }
                        );
                    }
                    outInfo.Value /= secondInfo.Value;
                    outInfo.BaseTenExponent -= secondInfo.BaseTenExponent;
                }
            }
        }
        catch { isWrong = true; }

        return
        (
            //An error might not be triggered despite of dealing with numbers outside double precision.
            //For example: 0.00000000000000000001m * 0.0000000000000000000001m can output 0.0 without triggering an error. 
            isWrong || ((operation == Operations.Multiplication || operation == Operations.Division) && outInfo.Value == 0.0.0) ?
            OperationValuesManageError(firstInfo0, secondInfo0, operation) : outInfo
        );
    }

    static UnitInfo OperationValuesManageError(UnitInfo outInfo, UnitInfo secondInfo, Operations operation)
    {
        if (operation != Operations.Multiplication && operation != Operations.Division)
        {
            //This condition should never be true on account of the fact that the pre-modifications performed before
            //adding/subtracting should avoid erroneous situations.
            return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
        }

        UnitInfo secondInfo2 = ConvertValueToBaseTen(secondInfo.Value);
        outInfo = VaryBaseTenExponent(outInfo, secondInfo2.BaseTenExponent, operation == Operations.Division);
        if (Math.Abs(secondInfo2.Value) == 1.0 || outInfo.Error.Type != ErrorTypes.None) return outInfo;
        
        try
        {
            outInfo = PerformManagedOperationUnits
            (
                outInfo, secondInfo2.Value, operation
            );
        }
        catch
        {
            //Very unlikely scenario on account of the fact that Math.Abs(secondInfo2.Value)
            //lies within the 0.1-10.0 range.
            outInfo = OperationValuesManageError
            (
                new UnitInfo(outInfo)
                {
                    Value = secondInfo2.Value,
                    BaseTenExponent = 0
                },
                new UnitInfo()
                {
                    Value = outInfo.Value,
                    BaseTenExponent = outInfo.BaseTenExponent
                },
                operation
            );
        }

        return outInfo;
    }

    static UnitInfo ConvertValueToBaseTen(double value)
    {
        value = Math.Abs(value);
        return FromValueToBaseTenExponent
        (
             new UnitInfo(value), Math.Abs(value), false
        );
    }

    static UnitInfo ConvertBaseTenToValue(UnitInfo unitInfo)
    {
        if (unitInfo.BaseTenExponent == 0) return unitInfo;

        UnitInfo outInfo = new UnitInfo(unitInfo);
        boolean decrease = unitInfo.BaseTenExponent > 0;
        int sign = Math.Sign(outInfo.Value);
        double absValue = Math.Abs(outInfo.Value);

        while (outInfo.BaseTenExponent != 0.0)
        {
            if (decrease)
            {
                if (absValue >= MaxValueDec / 10.0) break;
                absValue *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }
            else
            {
                if (absValue <= MinValueDec * 10.0) break;
                absValue /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
        }

        outInfo.Value = sign * absValue;

        return outInfo;
    }

    static UnitInfo NormaliseUnitInfo(UnitInfo unitInfo)
    {
        if (unitInfo.Value == 0 && unitInfo.Prefix.Factor == 1.0)
        {
            return unitInfo;
        }
        UnitInfo outInfo = new UnitInfo(unitInfo);

        if (outInfo.Prefix.Factor != 1)
        {
            outInfo = FromValueToBaseTenExponent
            (
                outInfo, outInfo.Prefix.Factor, true
            );
            outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage);
        }
        if (outInfo.Value == 0.0) return outInfo;

        outInfo = FromValueToBaseTenExponent
        (
            outInfo, outInfo.Value, false
        );

        return outInfo;
    }

    static UnitInfo FromValueToBaseTenExponent(UnitInfo outInfo, double value, boolean isPrefix)
    {
        if (value == 0.0) return outInfo;

        double valueAbs = Math.Abs(value);
        boolean decrease = (valueAbs > 1.0);
        if (!isPrefix)
        {
            outInfo.Value = outInfo.Value / valueAbs;
        }

        while (valueAbs != 1.0)
        {
            if ((valueAbs < 10.0 && valueAbs > 1.0) || (valueAbs > 0.1.0 && valueAbs < 1.0))
            {
                if (!isPrefix) outInfo.Value = value;
                else
                {
                    outInfo = PerformManagedOperationValues
                    (
                        outInfo, value, Operations.Multiplication
                    );
                }

                return outInfo;
            }

            if (decrease)
            {
                value /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
            else
            {
                value *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }

            valueAbs = Math.Abs(value);
        }

        return outInfo;
    }

    //Method used to vary BaseTenExponent without provoking unhandled exceptions (i.e., bigger than Integer.MAX_VALUE).
    static UnitInfo VaryBaseTenExponent(UnitInfo info, int baseTenIncrease, boolean isDivision = false)
    {
        long val1 = info.BaseTenExponent;
        long val2 = baseTenIncrease;

        if (isDivision)
        {
            //Converting a negative value into positive might provoke an overflow error for the int type
            //(e.g., Math.Abs(Integer.MAIN_VALUE)). Converting both variables to long is a quick and effective
            //way to avoid this problem.
            val2 *= -1;
        }

        return
        (
             ((val2 > 0 && val1 > Integer.MAX_VALUE - val2) || (val2 < 0 && val1 < Integer.MAIN_VALUE - val2)) ?
            new UnitInfo(info, ErrorTypes.NumericError) : new UnitInfo(info){{ BaseTenExponent = (int)(val1 + val2); }}
        );
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 2 2017-05-27 20:05:05.984
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 0 2017-05-27 20:05:05.985
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.core 4 4 2017-05-27 20:05:06.976
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
public class OperationsManaged
{
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, double second, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            firstInfo, new UnitInfo(second), operation
        );
    }

    public static UnitInfo PerformManagedOperationUnits(double first, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            new UnitInfo(first), secondInfo, operation
        );
    }

    //This method should always be used when dealing with random UnitInfo variables because it accounts for all the
    //possible scenarios. On the other hand, with simple operations (e.g., random UnitInfo & numeric type) it might
    //be better to use PerformManagedOperationValues. 
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        ErrorTypes errorType = InternalMethods.GetOperationError
        (
            firstInfo, secondInfo, operation
        );
        if (errorType != ErrorTypes.None)
        {
            return new UnitInfo(firstInfo) 
            {{
                Error = new ErrorInfo(errorType); 
            }};
        }

        return
        (
            operation == Operations.Addition || operation == Operations.Subtraction ?
            PerformManagedOperationAddition(firstInfo, secondInfo, operation) :
            PerformManagedOperationMultiplication(firstInfo, secondInfo, operation)
        );
    }

    static UnitInfo PerformManagedOperationAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {   
        //After being normalised, the operands might require further modifications.
        UnitInfo[] normalised = GetOperandsAddition(firstInfo, secondInfo, operation);

        return PerformManagedOperationNormalisedValues
        (
            firstInfo, normalised, operation
        );
    }

    static UnitInfo[] GetOperandsAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        UnitInfo[] operands2 = new UnitInfo[] 
        {
            new UnitInfo(firstInfo), new UnitInfo(secondInfo)
        };

        if (operands2[0].BaseTenExponent != operands2[1].BaseTenExponent || operands2[0].Prefix.Factor != operands2[1].Prefix.Factor)
        {
            //The addition/subtraction might not be performed right away even with normalised values.
            //For example: 5 and 6 from 5*10^2 and 6*10^7 cannot be added right away.
            operands2 = AdaptNormalisedValuesForAddition
            (
                new UnitInfo[] 
                { 
                    NormaliseUnitInfo(operands2[0]), 
                    NormaliseUnitInfo(operands2[1])
                },
                operation
            );
        }

        return operands2;
    }
    
    static UnitInfo[] AdaptNormalisedValuesForAddition(UnitInfo[] unitInfos2, Operations operation)
    {
        if (unitInfos2[0].BaseTenExponent == unitInfos2[1].BaseTenExponent)
        {
            //Having the same BaseTenExponent values means that the given operation can be performed right away.
            return unitInfos2;
        }

        int[] bigSmallI = 
        (
            unitInfos2[0].BaseTenExponent > unitInfos2[1].BaseTenExponent ?
            new int[] { 0, 1 } : new int[] { 1, 0 }
        );

        //Only the variable with the bigger value is modified. For example: 5*10^5 & 3*10^3 is converted
        //into 500*10^3 & 3*10^3 in order to allow the addition 500 + 3. 
        UnitInfo big2 = AdaptBiggerAdditionOperand(unitInfos2, bigSmallI, operation);
        if (big2.Error.Type != ErrorTypes.None)
        {
            return TooBigGapAddition(unitInfos2, bigSmallI, operation);
        }

        unitInfos2[bigSmallI[0]].Value = big2.Value;
        unitInfos2[bigSmallI[0]].BaseTenExponent = unitInfos2[bigSmallI[1]].BaseTenExponent;

        return unitInfos2;
    }

    //When adding/subtracting two numbers whose gap is bigger than the maximum double range, there
    //is no need to perform any operation (i.e., no change will be observed because of being outside
    //the maximum supported precision). This method takes care of these cases and returns the expected
    //output (i.e., biggest value).
    static UnitInfo[] TooBigGapAddition(UnitInfo[] unitInfos2, int[] bigSmallI, Operations operation)
    {
        UnitInfo[] outInfos = new UnitInfo[] 
        {
            //First operand (i.e., one whose information defines the operation) together with the
            //numeric information (i.e., just Value and BaseTenExponent because both are normalised)
            //which is associated with the biggest one.
            new UnitInfo(unitInfos2[0])
            {{
                Value = unitInfos2[bigSmallI[0]].Value;
                BaseTenExponent = unitInfos2[bigSmallI[0]].BaseTenExponent;
            }}
        };

        if (operation == Operations.Subtraction && bigSmallI[0] == 1)
        {
            outInfos[0].Value = -1.0 * outInfos[0].Value;
        }

        if (outInfos[0].Unit == Units.Unitless)
        {
            outInfos[0].Unit = unitInfos2[bigSmallI[1]].Unit;
        }

        return outInfos;
    }

    static UnitInfo AdaptBiggerAdditionOperand(UnitInfo[] unitInfos2, Integer[] bigSmallI, Operations operation)
    {
        int gapExponent = unitInfos2[bigSmallI[0]].BaseTenExponent - unitInfos2[bigSmallI[1]].BaseTenExponent;
        if (gapExponent >= 27)
        {
            //The difference between both inputs is bigger than (or, at least, very close to) the maximum double value/precision;
            //what makes this situation calculation unworthy and the first operand to be returned as the result.
            //Note that the error below these lines is just an easy way to tell the calling function about this eventuality.
            return new UnitInfo(unitInfos2[0]) 
            {{ 
                Error = new ErrorInfo(ErrorTypes.InvalidOperation); 
            }};
        }

        //PerformManagedOperationValues is used to make sure that the resulting numeric information is stored
        //in Value (if possible).
        UnitInfo big2 = PerformManagedOperationValues
        (
            RaiseToIntegerExponent(10.0, gapExponent), unitInfos2[bigSmallI[0]].Value, 
            Operations.Multiplication                
        );

        boolean isWrong = 
        (
            big2.Error.Type != ErrorTypes.None || big2.BaseTenExponent != 0 ?
            
            //The value of the bigger input times 10^(gap between BaseTenExponent of inputs) is too big. 
            isWrong = true :
            
            //Overflow-check very unlikely to trigger an error. In fact, with properly normalised variables,
            //triggering an error would be plainly impossible.               
            AreAdditionFinalValuesWrong
            (
                unitInfos2[0].Value, unitInfos2[1].Value, operation
            )
        );

        if (isWrong)
        {
        	UnitInfo temp = new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }};
            
            temp.Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            
        }
        
        
        
        return
        (
            isWrong ?
            //This error is just an easy way to let the calling function know about the fact that no
            //calculation has been performed (too big gap). This isn't a properly-speaking error and
            //that's why it will not be notified to the user.
            new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }} :
            //Returning the new big value. For example: with 5*10^4 & 3*10^2, 500 would be returned.
            new UnitInfo(unitInfos2[bigSmallI[0]])
            {{
                Value = big2.Value;
            }}
        )
    }

    static boolean AreAdditionFinalValuesWrong(double val1, double val2, Operations operation)
    {
        boolean isWrong = false;

        try
        {
            val1 = val1 + val2 *
            (
                operation == Operations.Addition ? 1 : -1
            );
        }
        catch { isWrong = true; }

        return isWrong;
    }

    static UnitInfo PerformManagedOperationMultiplication(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationNormalisedValues
        (
            firstInfo, new UnitInfo[] 
            { 
                NormaliseUnitInfo(firstInfo),
                NormaliseUnitInfo(secondInfo) 
            },
            operation
        );
    }

    public static UnitInfo RaiseToIntegerExponent(double baseValue, int exponent)
    {
        return RaiseToIntegerExponent(new UnitInfo(baseValue), exponent);
    }

    static UnitInfo RaiseToIntegerExponent(UnitInfo baseInfo, int exponent)
    {
        if (exponent <= 1 && exponent >= 0)
        {
            baseInfo.Value = (exponent == 0 ? 1.0 : baseInfo.Value);
            return baseInfo;
        }

        UnitInfo outInfo = new UnitInfo(baseInfo);

        for (int i = 1; i < Math.Abs(exponent); i++)
        {
            outInfo = PerformManagedOperationValues
            (
                outInfo, baseInfo, Operations.Multiplication
            );
            if (outInfo.Error.Type != ErrorTypes.None) return outInfo;
        }

        return
        (
            exponent < 0 ?
            PerformManagedOperationValues(new UnitInfo(1.0), outInfo, Operations.Division) :
            outInfo
        );
    }

    static UnitInfo PerformManagedOperationNormalisedValues(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        outInfo =
        (
            normalisedInfos.Length == 1 ?
            //There is just one operand when the difference between both of them is too big.
            outInfo = normalisedInfos[0] :
            PerformManagedOperationTwoOperands(outInfo, normalisedInfos, operation)
        );

        return outInfo;
    }

    static UnitInfo PerformManagedOperationTwoOperands(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        UnitInfo outInfoNormalised = PerformManagedOperationValues
        (
            normalisedInfos[0], normalisedInfos[1], operation
        );

        if (outInfo.Error.Type != ErrorTypes.None)
        {
            return new UnitInfo(outInfo)
            {
                Error = new ErrorInfo(ErrorTypes.NumericError)
            };
        }

        outInfo.BaseTenExponent = outInfoNormalised.BaseTenExponent;
        outInfo.Value = outInfoNormalised.Value;
        //Normalised means no prefixes.
        outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage); 

        return outInfo;
    }

    static UnitInfo PerformManagedOperationValues(double firstValue, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            new UnitInfo(firstValue), new UnitInfo(secondValue), operation
        );
    }

    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            firstInfo, new UnitInfo(secondValue), operation
        );
    }

    //This method might be used to perform full operations (not just being the last calculation step) instead
    //of the default one (PerformManagedOperationUnits) for simple cases. That is: ones not dealing with the
    //complex numeric reality (Value, Prefix and BaseTenExponent) which makes a pre-analysis required.
    //Note that, unlikely what happens with PerformMangedOperationUnits, the outputs of this method aren't
    //normalised (= primarily stored under Value), what is useful in certain contexts.
    //NOTE: this function assumes that both inputs are normalised, what means that no prefix information is expected.
    //It might also be used with non-normalised inputs, but their prefix information would be plainly ignored.
    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        if (firstInfo.Value == 0.0 || secondInfo.Value == 0.0)
        {
            if (operation == Operations.Multiplication || operation == Operations.Division)
            {
                //Dividing by zero scenarios are taken into account somewhere else.
                return new UnitInfo(firstInfo) { Value = 0.0 };
            }
        }

        UnitInfo outInfo = new UnitInfo(firstInfo);
        UnitInfo firstInfo0 = new UnitInfo(firstInfo);
        UnitInfo secondInfo0 = new UnitInfo(secondInfo);

        boolean isWrong = false;
        try
        {
            if (operation == Operations.Addition)
            {
                outInfo.Value += secondInfo0.Value;
            }
            else if (operation == Operations.Subtraction)
            {
                outInfo.Value -= secondInfo.Value;
            }
            else
            {
                //The reason for checking whether BaseTenExponent is inside/outside the int range before performing 
                //the operation (rather than going ahead and eventually catching the resulting exception) isn't just
                //being quicker, but also the only option in many situations. Note that an addition/subtraction between
                //two int variables whose result is outside the int range might not trigger an exception (+ random 
                //negative value as output).
                if (VaryBaseTenExponent(outInfo, secondInfo0.BaseTenExponent, operation == Operations.Division).Error.Type != ErrorTypes.None)
                {
                    return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
                }

                if (operation == Operations.Multiplication)
                {
                    outInfo.Value *= secondInfo.Value;
                    outInfo.BaseTenExponent += secondInfo.BaseTenExponent;
                }
                else if (operation == Operations.Division)
                {
                    if (secondInfo.Value == 0.0)
                    {
                        return
                        (
                            new UnitInfo(outInfo) 
                            { 
                                Error = new ErrorInfo(ErrorTypes.NumericError) 
                            }
                        );
                    }
                    outInfo.Value /= secondInfo.Value;
                    outInfo.BaseTenExponent -= secondInfo.BaseTenExponent;
                }
            }
        }
        catch { isWrong = true; }

        return
        (
            //An error might not be triggered despite of dealing with numbers outside double precision.
            //For example: 0.00000000000000000001m * 0.0000000000000000000001m can output 0.0 without triggering an error. 
            isWrong || ((operation == Operations.Multiplication || operation == Operations.Division) && outInfo.Value == 0.0.0) ?
            OperationValuesManageError(firstInfo0, secondInfo0, operation) : outInfo
        );
    }

    static UnitInfo OperationValuesManageError(UnitInfo outInfo, UnitInfo secondInfo, Operations operation)
    {
        if (operation != Operations.Multiplication && operation != Operations.Division)
        {
            //This condition should never be true on account of the fact that the pre-modifications performed before
            //adding/subtracting should avoid erroneous situations.
            return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
        }

        UnitInfo secondInfo2 = ConvertValueToBaseTen(secondInfo.Value);
        outInfo = VaryBaseTenExponent(outInfo, secondInfo2.BaseTenExponent, operation == Operations.Division);
        if (Math.Abs(secondInfo2.Value) == 1.0 || outInfo.Error.Type != ErrorTypes.None) return outInfo;
        
        try
        {
            outInfo = PerformManagedOperationUnits
            (
                outInfo, secondInfo2.Value, operation
            );
        }
        catch
        {
            //Very unlikely scenario on account of the fact that Math.Abs(secondInfo2.Value)
            //lies within the 0.1-10.0 range.
            outInfo = OperationValuesManageError
            (
                new UnitInfo(outInfo)
                {
                    Value = secondInfo2.Value,
                    BaseTenExponent = 0
                },
                new UnitInfo()
                {
                    Value = outInfo.Value,
                    BaseTenExponent = outInfo.BaseTenExponent
                },
                operation
            );
        }

        return outInfo;
    }

    static UnitInfo ConvertValueToBaseTen(double value)
    {
        value = Math.Abs(value);
        return FromValueToBaseTenExponent
        (
             new UnitInfo(value), Math.Abs(value), false
        );
    }

    static UnitInfo ConvertBaseTenToValue(UnitInfo unitInfo)
    {
        if (unitInfo.BaseTenExponent == 0) return unitInfo;

        UnitInfo outInfo = new UnitInfo(unitInfo);
        boolean decrease = unitInfo.BaseTenExponent > 0;
        int sign = Math.Sign(outInfo.Value);
        double absValue = Math.Abs(outInfo.Value);

        while (outInfo.BaseTenExponent != 0.0)
        {
            if (decrease)
            {
                if (absValue >= MaxValueDec / 10.0) break;
                absValue *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }
            else
            {
                if (absValue <= MinValueDec * 10.0) break;
                absValue /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
        }

        outInfo.Value = sign * absValue;

        return outInfo;
    }

    static UnitInfo NormaliseUnitInfo(UnitInfo unitInfo)
    {
        if (unitInfo.Value == 0 && unitInfo.Prefix.Factor == 1.0)
        {
            return unitInfo;
        }
        UnitInfo outInfo = new UnitInfo(unitInfo);

        if (outInfo.Prefix.Factor != 1)
        {
            outInfo = FromValueToBaseTenExponent
            (
                outInfo, outInfo.Prefix.Factor, true
            );
            outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage);
        }
        if (outInfo.Value == 0.0) return outInfo;

        outInfo = FromValueToBaseTenExponent
        (
            outInfo, outInfo.Value, false
        );

        return outInfo;
    }

    static UnitInfo FromValueToBaseTenExponent(UnitInfo outInfo, double value, boolean isPrefix)
    {
        if (value == 0.0) return outInfo;

        double valueAbs = Math.Abs(value);
        boolean decrease = (valueAbs > 1.0);
        if (!isPrefix)
        {
            outInfo.Value = outInfo.Value / valueAbs;
        }

        while (valueAbs != 1.0)
        {
            if ((valueAbs < 10.0 && valueAbs > 1.0) || (valueAbs > 0.1.0 && valueAbs < 1.0))
            {
                if (!isPrefix) outInfo.Value = value;
                else
                {
                    outInfo = PerformManagedOperationValues
                    (
                        outInfo, value, Operations.Multiplication
                    );
                }

                return outInfo;
            }

            if (decrease)
            {
                value /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
            else
            {
                value *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }

            valueAbs = Math.Abs(value);
        }

        return outInfo;
    }

    //Method used to vary BaseTenExponent without provoking unhandled exceptions (i.e., bigger than Integer.MAX_VALUE).
    static UnitInfo VaryBaseTenExponent(UnitInfo info, int baseTenIncrease, boolean isDivision = false)
    {
        long val1 = info.BaseTenExponent;
        long val2 = baseTenIncrease;

        if (isDivision)
        {
            //Converting a negative value into positive might provoke an overflow error for the int type
            //(e.g., Math.Abs(Integer.MAIN_VALUE)). Converting both variables to long is a quick and effective
            //way to avoid this problem.
            val2 *= -1;
        }

        return
        (
             ((val2 > 0 && val1 > Integer.MAX_VALUE - val2) || (val2 < 0 && val1 < Integer.MAIN_VALUE - val2)) ?
            new UnitInfo(info, ErrorTypes.NumericError) : new UnitInfo(info){{ BaseTenExponent = (int)(val1 + val2); }}
        );
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2017-05-27 20:05:06.977
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2017-05-27 20:05:06.977
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2017-05-27 20:05:06.997
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
public class OperationsManaged
{
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, double second, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            firstInfo, new UnitInfo(second), operation
        );
    }

    public static UnitInfo PerformManagedOperationUnits(double first, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            new UnitInfo(first), secondInfo, operation
        );
    }

    //This method should always be used when dealing with random UnitInfo variables because it accounts for all the
    //possible scenarios. On the other hand, with simple operations (e.g., random UnitInfo & numeric type) it might
    //be better to use PerformManagedOperationValues. 
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        ErrorTypes errorType = InternalMethods.GetOperationError
        (
            firstInfo, secondInfo, operation
        );
        if (errorType != ErrorTypes.None)
        {
            return new UnitInfo(firstInfo) 
            {{
                Error = new ErrorInfo(errorType); 
            }};
        }

        return
        (
            operation == Operations.Addition || operation == Operations.Subtraction ?
            PerformManagedOperationAddition(firstInfo, secondInfo, operation) :
            PerformManagedOperationMultiplication(firstInfo, secondInfo, operation)
        );
    }

    static UnitInfo PerformManagedOperationAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {   
        //After being normalised, the operands might require further modifications.
        UnitInfo[] normalised = GetOperandsAddition(firstInfo, secondInfo, operation);

        return PerformManagedOperationNormalisedValues
        (
            firstInfo, normalised, operation
        );
    }

    static UnitInfo[] GetOperandsAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        UnitInfo[] operands2 = new UnitInfo[] 
        {
            new UnitInfo(firstInfo), new UnitInfo(secondInfo)
        };

        if (operands2[0].BaseTenExponent != operands2[1].BaseTenExponent || operands2[0].Prefix.Factor != operands2[1].Prefix.Factor)
        {
            //The addition/subtraction might not be performed right away even with normalised values.
            //For example: 5 and 6 from 5*10^2 and 6*10^7 cannot be added right away.
            operands2 = AdaptNormalisedValuesForAddition
            (
                new UnitInfo[] 
                { 
                    NormaliseUnitInfo(operands2[0]), 
                    NormaliseUnitInfo(operands2[1])
                },
                operation
            );
        }

        return operands2;
    }
    
    static UnitInfo[] AdaptNormalisedValuesForAddition(UnitInfo[] unitInfos2, Operations operation)
    {
        if (unitInfos2[0].BaseTenExponent == unitInfos2[1].BaseTenExponent)
        {
            //Having the same BaseTenExponent values means that the given operation can be performed right away.
            return unitInfos2;
        }

        int[] bigSmallI = 
        (
            unitInfos2[0].BaseTenExponent > unitInfos2[1].BaseTenExponent ?
            new int[] { 0, 1 } : new int[] { 1, 0 }
        );

        //Only the variable with the bigger value is modified. For example: 5*10^5 & 3*10^3 is converted
        //into 500*10^3 & 3*10^3 in order to allow the addition 500 + 3. 
        UnitInfo big2 = AdaptBiggerAdditionOperand(unitInfos2, bigSmallI, operation);
        if (big2.Error.Type != ErrorTypes.None)
        {
            return TooBigGapAddition(unitInfos2, bigSmallI, operation);
        }

        unitInfos2[bigSmallI[0]].Value = big2.Value;
        unitInfos2[bigSmallI[0]].BaseTenExponent = unitInfos2[bigSmallI[1]].BaseTenExponent;

        return unitInfos2;
    }

    //When adding/subtracting two numbers whose gap is bigger than the maximum double range, there
    //is no need to perform any operation (i.e., no change will be observed because of being outside
    //the maximum supported precision). This method takes care of these cases and returns the expected
    //output (i.e., biggest value).
    static UnitInfo[] TooBigGapAddition(UnitInfo[] unitInfos2, int[] bigSmallI, Operations operation)
    {
        UnitInfo[] outInfos = new UnitInfo[] 
        {
            //First operand (i.e., one whose information defines the operation) together with the
            //numeric information (i.e., just Value and BaseTenExponent because both are normalised)
            //which is associated with the biggest one.
            new UnitInfo(unitInfos2[0])
            {{
                Value = unitInfos2[bigSmallI[0]].Value;
                BaseTenExponent = unitInfos2[bigSmallI[0]].BaseTenExponent;
            }}
        };

        if (operation == Operations.Subtraction && bigSmallI[0] == 1)
        {
            outInfos[0].Value = -1.0 * outInfos[0].Value;
        }

        if (outInfos[0].Unit == Units.Unitless)
        {
            outInfos[0].Unit = unitInfos2[bigSmallI[1]].Unit;
        }

        return outInfos;
    }

    static UnitInfo AdaptBiggerAdditionOperand(UnitInfo[] unitInfos2, Integer[] bigSmallI, Operations operation)
    {
        int gapExponent = unitInfos2[bigSmallI[0]].BaseTenExponent - unitInfos2[bigSmallI[1]].BaseTenExponent;
        if (gapExponent >= 27)
        {
            //The difference between both inputs is bigger than (or, at least, very close to) the maximum double value/precision;
            //what makes this situation calculation unworthy and the first operand to be returned as the result.
            //Note that the error below these lines is just an easy way to tell the calling function about this eventuality.
            return new UnitInfo(unitInfos2[0]) 
            {{ 
                Error = new ErrorInfo(ErrorTypes.InvalidOperation); 
            }};
        }

        //PerformManagedOperationValues is used to make sure that the resulting numeric information is stored
        //in Value (if possible).
        UnitInfo big2 = PerformManagedOperationValues
        (
            RaiseToIntegerExponent(10.0, gapExponent), unitInfos2[bigSmallI[0]].Value, 
            Operations.Multiplication                
        );

        boolean isWrong = 
        (
            big2.Error.Type != ErrorTypes.None || big2.BaseTenExponent != 0 ?
            
            //The value of the bigger input times 10^(gap between BaseTenExponent of inputs) is too big. 
            isWrong = true :
            
            //Overflow-check very unlikely to trigger an error. In fact, with properly normalised variables,
            //triggering an error would be plainly impossible.               
            AreAdditionFinalValuesWrong
            (
                unitInfos2[0].Value, unitInfos2[1].Value, operation
            )
        );

        if (isWrong)
        {
        	UnitInfo temp = new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }};
            
            temp.Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            
        }
        
        
        
        return
        (
            isWrong ?
            //This error is just an easy way to let the calling function know about the fact that no
            //calculation has been performed (too big gap). This isn't a properly-speaking error and
            //that's why it will not be notified to the user.
            new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }} :
            //Returning the new big value. For example: with 5*10^4 & 3*10^2, 500 would be returned.
            new UnitInfo(unitInfos2[bigSmallI[0]])
            {{
                Value = big2.Value;
            }}
        )
    }

    static boolean AreAdditionFinalValuesWrong(double val1, double val2, Operations operation)
    {
        boolean isWrong = false;

        try
        {
            val1 = val1 + val2 *
            (
                operation == Operations.Addition ? 1 : -1
            );
        }
        catch { isWrong = true; }

        return isWrong;
    }

    static UnitInfo PerformManagedOperationMultiplication(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationNormalisedValues
        (
            firstInfo, new UnitInfo[] 
            { 
                NormaliseUnitInfo(firstInfo),
                NormaliseUnitInfo(secondInfo) 
            },
            operation
        );
    }

    public static UnitInfo RaiseToIntegerExponent(double baseValue, int exponent)
    {
        return RaiseToIntegerExponent(new UnitInfo(baseValue), exponent);
    }

    static UnitInfo RaiseToIntegerExponent(UnitInfo baseInfo, int exponent)
    {
        if (exponent <= 1 && exponent >= 0)
        {
            baseInfo.Value = (exponent == 0 ? 1.0 : baseInfo.Value);
            return baseInfo;
        }

        UnitInfo outInfo = new UnitInfo(baseInfo);

        for (int i = 1; i < Math.Abs(exponent); i++)
        {
            outInfo = PerformManagedOperationValues
            (
                outInfo, baseInfo, Operations.Multiplication
            );
            if (outInfo.Error.Type != ErrorTypes.None) return outInfo;
        }

        return
        (
            exponent < 0 ?
            PerformManagedOperationValues(new UnitInfo(1.0), outInfo, Operations.Division) :
            outInfo
        );
    }

    static UnitInfo PerformManagedOperationNormalisedValues(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        outInfo =
        (
            normalisedInfos.Length == 1 ?
            //There is just one operand when the difference between both of them is too big.
            outInfo = normalisedInfos[0] :
            PerformManagedOperationTwoOperands(outInfo, normalisedInfos, operation)
        );

        return outInfo;
    }

    static UnitInfo PerformManagedOperationTwoOperands(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        UnitInfo outInfoNormalised = PerformManagedOperationValues
        (
            normalisedInfos[0], normalisedInfos[1], operation
        );

        if (outInfo.Error.Type != ErrorTypes.None)
        {
            return new UnitInfo(outInfo)
            {
                Error = new ErrorInfo(ErrorTypes.NumericError)
            };
        }

        outInfo.BaseTenExponent = outInfoNormalised.BaseTenExponent;
        outInfo.Value = outInfoNormalised.Value;
        //Normalised means no prefixes.
        outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage); 

        return outInfo;
    }

    static UnitInfo PerformManagedOperationValues(double firstValue, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            new UnitInfo(firstValue), new UnitInfo(secondValue), operation
        );
    }

    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            firstInfo, new UnitInfo(secondValue), operation
        );
    }

    //This method might be used to perform full operations (not just being the last calculation step) instead
    //of the default one (PerformManagedOperationUnits) for simple cases. That is: ones not dealing with the
    //complex numeric reality (Value, Prefix and BaseTenExponent) which makes a pre-analysis required.
    //Note that, unlikely what happens with PerformMangedOperationUnits, the outputs of this method aren't
    //normalised (= primarily stored under Value), what is useful in certain contexts.
    //NOTE: this function assumes that both inputs are normalised, what means that no prefix information is expected.
    //It might also be used with non-normalised inputs, but their prefix information would be plainly ignored.
    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        if (firstInfo.Value == 0.0 || secondInfo.Value == 0.0)
        {
            if (operation == Operations.Multiplication || operation == Operations.Division)
            {
                //Dividing by zero scenarios are taken into account somewhere else.
                return new UnitInfo(firstInfo) { Value = 0.0 };
            }
        }

        UnitInfo outInfo = new UnitInfo(firstInfo);
        UnitInfo firstInfo0 = new UnitInfo(firstInfo);
        UnitInfo secondInfo0 = new UnitInfo(secondInfo);

        boolean isWrong = false;
        try
        {
            if (operation == Operations.Addition)
            {
                outInfo.Value += secondInfo0.Value;
            }
            else if (operation == Operations.Subtraction)
            {
                outInfo.Value -= secondInfo.Value;
            }
            else
            {
                //The reason for checking whether BaseTenExponent is inside/outside the int range before performing 
                //the operation (rather than going ahead and eventually catching the resulting exception) isn't just
                //being quicker, but also the only option in many situations. Note that an addition/subtraction between
                //two int variables whose result is outside the int range might not trigger an exception (+ random 
                //negative value as output).
                if (VaryBaseTenExponent(outInfo, secondInfo0.BaseTenExponent, operation == Operations.Division).Error.Type != ErrorTypes.None)
                {
                    return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
                }

                if (operation == Operations.Multiplication)
                {
                    outInfo.Value *= secondInfo.Value;
                    outInfo.BaseTenExponent += secondInfo.BaseTenExponent;
                }
                else if (operation == Operations.Division)
                {
                    if (secondInfo.Value == 0.0)
                    {
                        return
                        (
                            new UnitInfo(outInfo) 
                            { 
                                Error = new ErrorInfo(ErrorTypes.NumericError) 
                            }
                        );
                    }
                    outInfo.Value /= secondInfo.Value;
                    outInfo.BaseTenExponent -= secondInfo.BaseTenExponent;
                }
            }
        }
        catch { isWrong = true; }

        return
        (
            //An error might not be triggered despite of dealing with numbers outside double precision.
            //For example: 0.00000000000000000001m * 0.0000000000000000000001m can output 0.0 without triggering an error. 
            isWrong || ((operation == Operations.Multiplication || operation == Operations.Division) && outInfo.Value == 0.0.0) ?
            OperationValuesManageError(firstInfo0, secondInfo0, operation) : outInfo
        );
    }

    static UnitInfo OperationValuesManageError(UnitInfo outInfo, UnitInfo secondInfo, Operations operation)
    {
        if (operation != Operations.Multiplication && operation != Operations.Division)
        {
            //This condition should never be true on account of the fact that the pre-modifications performed before
            //adding/subtracting should avoid erroneous situations.
            return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
        }

        UnitInfo secondInfo2 = ConvertValueToBaseTen(secondInfo.Value);
        outInfo = VaryBaseTenExponent(outInfo, secondInfo2.BaseTenExponent, operation == Operations.Division);
        if (Math.Abs(secondInfo2.Value) == 1.0 || outInfo.Error.Type != ErrorTypes.None) return outInfo;
        
        try
        {
            outInfo = PerformManagedOperationUnits
            (
                outInfo, secondInfo2.Value, operation
            );
        }
        catch
        {
            //Very unlikely scenario on account of the fact that Math.Abs(secondInfo2.Value)
            //lies within the 0.1-10.0 range.
            outInfo = OperationValuesManageError
            (
                new UnitInfo(outInfo)
                {
                    Value = secondInfo2.Value,
                    BaseTenExponent = 0
                },
                new UnitInfo()
                {
                    Value = outInfo.Value,
                    BaseTenExponent = outInfo.BaseTenExponent
                },
                operation
            );
        }

        return outInfo;
    }

    static UnitInfo ConvertValueToBaseTen(double value)
    {
        value = Math.Abs(value);
        return FromValueToBaseTenExponent
        (
             new UnitInfo(value), Math.Abs(value), false
        );
    }

    static UnitInfo ConvertBaseTenToValue(UnitInfo unitInfo)
    {
        if (unitInfo.BaseTenExponent == 0) return unitInfo;

        UnitInfo outInfo = new UnitInfo(unitInfo);
        boolean decrease = unitInfo.BaseTenExponent > 0;
        int sign = Math.Sign(outInfo.Value);
        double absValue = Math.Abs(outInfo.Value);

        while (outInfo.BaseTenExponent != 0.0)
        {
            if (decrease)
            {
                if (absValue >= MaxValueDec / 10.0) break;
                absValue *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }
            else
            {
                if (absValue <= MinValueDec * 10.0) break;
                absValue /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
        }

        outInfo.Value = sign * absValue;

        return outInfo;
    }

    static UnitInfo NormaliseUnitInfo(UnitInfo unitInfo)
    {
        if (unitInfo.Value == 0 && unitInfo.Prefix.Factor == 1.0)
        {
            return unitInfo;
        }
        UnitInfo outInfo = new UnitInfo(unitInfo);

        if (outInfo.Prefix.Factor != 1)
        {
            outInfo = FromValueToBaseTenExponent
            (
                outInfo, outInfo.Prefix.Factor, true
            );
            outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage);
        }
        if (outInfo.Value == 0.0) return outInfo;

        outInfo = FromValueToBaseTenExponent
        (
            outInfo, outInfo.Value, false
        );

        return outInfo;
    }

    static UnitInfo FromValueToBaseTenExponent(UnitInfo outInfo, double value, boolean isPrefix)
    {
        if (value == 0.0) return outInfo;

        double valueAbs = Math.Abs(value);
        boolean decrease = (valueAbs > 1.0);
        if (!isPrefix)
        {
            outInfo.Value = outInfo.Value / valueAbs;
        }

        while (valueAbs != 1.0)
        {
            if ((valueAbs < 10.0 && valueAbs > 1.0) || (valueAbs > 0.1.0 && valueAbs < 1.0))
            {
                if (!isPrefix) outInfo.Value = value;
                else
                {
                    outInfo = PerformManagedOperationValues
                    (
                        outInfo, value, Operations.Multiplication
                    );
                }

                return outInfo;
            }

            if (decrease)
            {
                value /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
            else
            {
                value *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }

            valueAbs = Math.Abs(value);
        }

        return outInfo;
    }

    //Method used to vary BaseTenExponent without provoking unhandled exceptions (i.e., bigger than Integer.MAX_VALUE).
    static UnitInfo VaryBaseTenExponent(UnitInfo info, int baseTenIncrease, boolean isDivision = false)
    {
        long val1 = info.BaseTenExponent;
        long val2 = baseTenIncrease;

        if (isDivision)
        {
            //Converting a negative value into positive might provoke an overflow error for the int type
            //(e.g., Math.Abs(Integer.MAIN_VALUE)). Converting both variables to long is a quick and effective
            //way to avoid this problem.
            val2 *= -1;
        }

        return
        (
             ((val2 > 0 && val1 > Integer.MAX_VALUE - val2) || (val2 < 0 && val1 < Integer.MAIN_VALUE - val2)) ?
            new UnitInfo(info, ErrorTypes.NumericError) : new UnitInfo(info){{ BaseTenExponent = (int)(val1 + val2); }}
        );
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:476)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 2 2017-05-27 20:05:06.999
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:476)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 0 2017-05-27 20:05:06.999
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:476)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.core 4 4 2017-05-27 20:05:11.545
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
public class OperationsManaged
{
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, double second, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            firstInfo, new UnitInfo(second), operation
        );
    }

    public static UnitInfo PerformManagedOperationUnits(double first, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            new UnitInfo(first), secondInfo, operation
        );
    }

    //This method should always be used when dealing with random UnitInfo variables because it accounts for all the
    //possible scenarios. On the other hand, with simple operations (e.g., random UnitInfo & numeric type) it might
    //be better to use PerformManagedOperationValues. 
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        ErrorTypes errorType = InternalMethods.GetOperationError
        (
            firstInfo, secondInfo, operation
        );
        if (errorType != ErrorTypes.None)
        {
            return new UnitInfo(firstInfo) 
            {{
                Error = new ErrorInfo(errorType); 
            }};
        }

        return
        (
            operation == Operations.Addition || operation == Operations.Subtraction ?
            PerformManagedOperationAddition(firstInfo, secondInfo, operation) :
            PerformManagedOperationMultiplication(firstInfo, secondInfo, operation)
        );
    }

    static UnitInfo PerformManagedOperationAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {   
        //After being normalised, the operands might require further modifications.
        UnitInfo[] normalised = GetOperandsAddition(firstInfo, secondInfo, operation);

        return PerformManagedOperationNormalisedValues
        (
            firstInfo, normalised, operation
        );
    }

    static UnitInfo[] GetOperandsAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        UnitInfo[] operands2 = new UnitInfo[] 
        {
            new UnitInfo(firstInfo), new UnitInfo(secondInfo)
        };

        if (operands2[0].BaseTenExponent != operands2[1].BaseTenExponent || operands2[0].Prefix.Factor != operands2[1].Prefix.Factor)
        {
            //The addition/subtraction might not be performed right away even with normalised values.
            //For example: 5 and 6 from 5*10^2 and 6*10^7 cannot be added right away.
            operands2 = AdaptNormalisedValuesForAddition
            (
                new UnitInfo[] 
                { 
                    NormaliseUnitInfo(operands2[0]), 
                    NormaliseUnitInfo(operands2[1])
                },
                operation
            );
        }

        return operands2;
    }
    
    static UnitInfo[] AdaptNormalisedValuesForAddition(UnitInfo[] unitInfos2, Operations operation)
    {
        if (unitInfos2[0].BaseTenExponent == unitInfos2[1].BaseTenExponent)
        {
            //Having the same BaseTenExponent values means that the given operation can be performed right away.
            return unitInfos2;
        }

        int[] bigSmallI = 
        (
            unitInfos2[0].BaseTenExponent > unitInfos2[1].BaseTenExponent ?
            new int[] { 0, 1 } : new int[] { 1, 0 }
        );

        //Only the variable with the bigger value is modified. For example: 5*10^5 & 3*10^3 is converted
        //into 500*10^3 & 3*10^3 in order to allow the addition 500 + 3. 
        UnitInfo big2 = AdaptBiggerAdditionOperand(unitInfos2, bigSmallI, operation);
        if (big2.Error.Type != ErrorTypes.None)
        {
            return TooBigGapAddition(unitInfos2, bigSmallI, operation);
        }

        unitInfos2[bigSmallI[0]].Value = big2.Value;
        unitInfos2[bigSmallI[0]].BaseTenExponent = unitInfos2[bigSmallI[1]].BaseTenExponent;

        return unitInfos2;
    }

    //When adding/subtracting two numbers whose gap is bigger than the maximum double range, there
    //is no need to perform any operation (i.e., no change will be observed because of being outside
    //the maximum supported precision). This method takes care of these cases and returns the expected
    //output (i.e., biggest value).
    static UnitInfo[] TooBigGapAddition(UnitInfo[] unitInfos2, int[] bigSmallI, Operations operation)
    {
        UnitInfo[] outInfos = new UnitInfo[] 
        {
            //First operand (i.e., one whose information defines the operation) together with the
            //numeric information (i.e., just Value and BaseTenExponent because both are normalised)
            //which is associated with the biggest one.
            new UnitInfo(unitInfos2[0])
            {{
                Value = unitInfos2[bigSmallI[0]].Value;
                BaseTenExponent = unitInfos2[bigSmallI[0]].BaseTenExponent;
            }}
        };

        if (operation == Operations.Subtraction && bigSmallI[0] == 1)
        {
            outInfos[0].Value = -1.0 * outInfos[0].Value;
        }

        if (outInfos[0].Unit == Units.Unitless)
        {
            outInfos[0].Unit = unitInfos2[bigSmallI[1]].Unit;
        }

        return outInfos;
    }

    static UnitInfo AdaptBiggerAdditionOperand(UnitInfo[] unitInfos2, Integer[] bigSmallI, Operations operation)
    {
        int gapExponent = unitInfos2[bigSmallI[0]].BaseTenExponent - unitInfos2[bigSmallI[1]].BaseTenExponent;
        if (gapExponent >= 27)
        {
            //The difference between both inputs is bigger than (or, at least, very close to) the maximum double value/precision;
            //what makes this situation calculation unworthy and the first operand to be returned as the result.
            //Note that the error below these lines is just an easy way to tell the calling function about this eventuality.
            return new UnitInfo(unitInfos2[0]) 
            {{ 
                Error = new ErrorInfo(ErrorTypes.InvalidOperation); 
            }};
        }

        //PerformManagedOperationValues is used to make sure that the resulting numeric information is stored
        //in Value (if possible).
        UnitInfo big2 = PerformManagedOperationValues
        (
            RaiseToIntegerExponent(10.0, gapExponent), unitInfos2[bigSmallI[0]].Value, 
            Operations.Multiplication                
        );

        boolean isWrong = 
        (
            big2.Error.Type != ErrorTypes.None || big2.BaseTenExponent != 0 ?
            
            //The value of the bigger input times 10^(gap between BaseTenExponent of inputs) is too big. 
            isWrong = true :
            
            //Overflow-check very unlikely to trigger an error. In fact, with properly normalised variables,
            //triggering an error would be plainly impossible.               
            AreAdditionFinalValuesWrong
            (
                unitInfos2[0].Value, unitInfos2[1].Value, operation
            )
        );

        if (isWrong)
        {
        	UnitInfo temp = new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }};
            
            temp.Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            
        }
        
        
        return temp;
        
        
        return
        (
            isWrong ?
            //This error is just an easy way to let the calling function know about the fact that no
            //calculation has been performed (too big gap). This isn't a properly-speaking error and
            //that's why it will not be notified to the user.
            new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }} :
            //Returning the new big value. For example: with 5*10^4 & 3*10^2, 500 would be returned.
            new UnitInfo(unitInfos2[bigSmallI[0]])
            {{
                Value = big2.Value;
            }}
        )
    }

    static boolean AreAdditionFinalValuesWrong(double val1, double val2, Operations operation)
    {
        boolean isWrong = false;

        try
        {
            val1 = val1 + val2 *
            (
                operation == Operations.Addition ? 1 : -1
            );
        }
        catch { isWrong = true; }

        return isWrong;
    }

    static UnitInfo PerformManagedOperationMultiplication(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationNormalisedValues
        (
            firstInfo, new UnitInfo[] 
            { 
                NormaliseUnitInfo(firstInfo),
                NormaliseUnitInfo(secondInfo) 
            },
            operation
        );
    }

    public static UnitInfo RaiseToIntegerExponent(double baseValue, int exponent)
    {
        return RaiseToIntegerExponent(new UnitInfo(baseValue), exponent);
    }

    static UnitInfo RaiseToIntegerExponent(UnitInfo baseInfo, int exponent)
    {
        if (exponent <= 1 && exponent >= 0)
        {
            baseInfo.Value = (exponent == 0 ? 1.0 : baseInfo.Value);
            return baseInfo;
        }

        UnitInfo outInfo = new UnitInfo(baseInfo);

        for (int i = 1; i < Math.Abs(exponent); i++)
        {
            outInfo = PerformManagedOperationValues
            (
                outInfo, baseInfo, Operations.Multiplication
            );
            if (outInfo.Error.Type != ErrorTypes.None) return outInfo;
        }

        return
        (
            exponent < 0 ?
            PerformManagedOperationValues(new UnitInfo(1.0), outInfo, Operations.Division) :
            outInfo
        );
    }

    static UnitInfo PerformManagedOperationNormalisedValues(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        outInfo =
        (
            normalisedInfos.Length == 1 ?
            //There is just one operand when the difference between both of them is too big.
            outInfo = normalisedInfos[0] :
            PerformManagedOperationTwoOperands(outInfo, normalisedInfos, operation)
        );

        return outInfo;
    }

    static UnitInfo PerformManagedOperationTwoOperands(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        UnitInfo outInfoNormalised = PerformManagedOperationValues
        (
            normalisedInfos[0], normalisedInfos[1], operation
        );

        if (outInfo.Error.Type != ErrorTypes.None)
        {
            return new UnitInfo(outInfo)
            {
                Error = new ErrorInfo(ErrorTypes.NumericError)
            };
        }

        outInfo.BaseTenExponent = outInfoNormalised.BaseTenExponent;
        outInfo.Value = outInfoNormalised.Value;
        //Normalised means no prefixes.
        outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage); 

        return outInfo;
    }

    static UnitInfo PerformManagedOperationValues(double firstValue, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            new UnitInfo(firstValue), new UnitInfo(secondValue), operation
        );
    }

    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            firstInfo, new UnitInfo(secondValue), operation
        );
    }

    //This method might be used to perform full operations (not just being the last calculation step) instead
    //of the default one (PerformManagedOperationUnits) for simple cases. That is: ones not dealing with the
    //complex numeric reality (Value, Prefix and BaseTenExponent) which makes a pre-analysis required.
    //Note that, unlikely what happens with PerformMangedOperationUnits, the outputs of this method aren't
    //normalised (= primarily stored under Value), what is useful in certain contexts.
    //NOTE: this function assumes that both inputs are normalised, what means that no prefix information is expected.
    //It might also be used with non-normalised inputs, but their prefix information would be plainly ignored.
    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        if (firstInfo.Value == 0.0 || secondInfo.Value == 0.0)
        {
            if (operation == Operations.Multiplication || operation == Operations.Division)
            {
                //Dividing by zero scenarios are taken into account somewhere else.
                return new UnitInfo(firstInfo) { Value = 0.0 };
            }
        }

        UnitInfo outInfo = new UnitInfo(firstInfo);
        UnitInfo firstInfo0 = new UnitInfo(firstInfo);
        UnitInfo secondInfo0 = new UnitInfo(secondInfo);

        boolean isWrong = false;
        try
        {
            if (operation == Operations.Addition)
            {
                outInfo.Value += secondInfo0.Value;
            }
            else if (operation == Operations.Subtraction)
            {
                outInfo.Value -= secondInfo.Value;
            }
            else
            {
                //The reason for checking whether BaseTenExponent is inside/outside the int range before performing 
                //the operation (rather than going ahead and eventually catching the resulting exception) isn't just
                //being quicker, but also the only option in many situations. Note that an addition/subtraction between
                //two int variables whose result is outside the int range might not trigger an exception (+ random 
                //negative value as output).
                if (VaryBaseTenExponent(outInfo, secondInfo0.BaseTenExponent, operation == Operations.Division).Error.Type != ErrorTypes.None)
                {
                    return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
                }

                if (operation == Operations.Multiplication)
                {
                    outInfo.Value *= secondInfo.Value;
                    outInfo.BaseTenExponent += secondInfo.BaseTenExponent;
                }
                else if (operation == Operations.Division)
                {
                    if (secondInfo.Value == 0.0)
                    {
                        return
                        (
                            new UnitInfo(outInfo) 
                            { 
                                Error = new ErrorInfo(ErrorTypes.NumericError) 
                            }
                        );
                    }
                    outInfo.Value /= secondInfo.Value;
                    outInfo.BaseTenExponent -= secondInfo.BaseTenExponent;
                }
            }
        }
        catch { isWrong = true; }

        return
        (
            //An error might not be triggered despite of dealing with numbers outside double precision.
            //For example: 0.00000000000000000001m * 0.0000000000000000000001m can output 0.0 without triggering an error. 
            isWrong || ((operation == Operations.Multiplication || operation == Operations.Division) && outInfo.Value == 0.0.0) ?
            OperationValuesManageError(firstInfo0, secondInfo0, operation) : outInfo
        );
    }

    static UnitInfo OperationValuesManageError(UnitInfo outInfo, UnitInfo secondInfo, Operations operation)
    {
        if (operation != Operations.Multiplication && operation != Operations.Division)
        {
            //This condition should never be true on account of the fact that the pre-modifications performed before
            //adding/subtracting should avoid erroneous situations.
            return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
        }

        UnitInfo secondInfo2 = ConvertValueToBaseTen(secondInfo.Value);
        outInfo = VaryBaseTenExponent(outInfo, secondInfo2.BaseTenExponent, operation == Operations.Division);
        if (Math.Abs(secondInfo2.Value) == 1.0 || outInfo.Error.Type != ErrorTypes.None) return outInfo;
        
        try
        {
            outInfo = PerformManagedOperationUnits
            (
                outInfo, secondInfo2.Value, operation
            );
        }
        catch
        {
            //Very unlikely scenario on account of the fact that Math.Abs(secondInfo2.Value)
            //lies within the 0.1-10.0 range.
            outInfo = OperationValuesManageError
            (
                new UnitInfo(outInfo)
                {
                    Value = secondInfo2.Value,
                    BaseTenExponent = 0
                },
                new UnitInfo()
                {
                    Value = outInfo.Value,
                    BaseTenExponent = outInfo.BaseTenExponent
                },
                operation
            );
        }

        return outInfo;
    }

    static UnitInfo ConvertValueToBaseTen(double value)
    {
        value = Math.Abs(value);
        return FromValueToBaseTenExponent
        (
             new UnitInfo(value), Math.Abs(value), false
        );
    }

    static UnitInfo ConvertBaseTenToValue(UnitInfo unitInfo)
    {
        if (unitInfo.BaseTenExponent == 0) return unitInfo;

        UnitInfo outInfo = new UnitInfo(unitInfo);
        boolean decrease = unitInfo.BaseTenExponent > 0;
        int sign = Math.Sign(outInfo.Value);
        double absValue = Math.Abs(outInfo.Value);

        while (outInfo.BaseTenExponent != 0.0)
        {
            if (decrease)
            {
                if (absValue >= MaxValueDec / 10.0) break;
                absValue *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }
            else
            {
                if (absValue <= MinValueDec * 10.0) break;
                absValue /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
        }

        outInfo.Value = sign * absValue;

        return outInfo;
    }

    static UnitInfo NormaliseUnitInfo(UnitInfo unitInfo)
    {
        if (unitInfo.Value == 0 && unitInfo.Prefix.Factor == 1.0)
        {
            return unitInfo;
        }
        UnitInfo outInfo = new UnitInfo(unitInfo);

        if (outInfo.Prefix.Factor != 1)
        {
            outInfo = FromValueToBaseTenExponent
            (
                outInfo, outInfo.Prefix.Factor, true
            );
            outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage);
        }
        if (outInfo.Value == 0.0) return outInfo;

        outInfo = FromValueToBaseTenExponent
        (
            outInfo, outInfo.Value, false
        );

        return outInfo;
    }

    static UnitInfo FromValueToBaseTenExponent(UnitInfo outInfo, double value, boolean isPrefix)
    {
        if (value == 0.0) return outInfo;

        double valueAbs = Math.Abs(value);
        boolean decrease = (valueAbs > 1.0);
        if (!isPrefix)
        {
            outInfo.Value = outInfo.Value / valueAbs;
        }

        while (valueAbs != 1.0)
        {
            if ((valueAbs < 10.0 && valueAbs > 1.0) || (valueAbs > 0.1.0 && valueAbs < 1.0))
            {
                if (!isPrefix) outInfo.Value = value;
                else
                {
                    outInfo = PerformManagedOperationValues
                    (
                        outInfo, value, Operations.Multiplication
                    );
                }

                return outInfo;
            }

            if (decrease)
            {
                value /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
            else
            {
                value *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }

            valueAbs = Math.Abs(value);
        }

        return outInfo;
    }

    //Method used to vary BaseTenExponent without provoking unhandled exceptions (i.e., bigger than Integer.MAX_VALUE).
    static UnitInfo VaryBaseTenExponent(UnitInfo info, int baseTenIncrease, boolean isDivision = false)
    {
        long val1 = info.BaseTenExponent;
        long val2 = baseTenIncrease;

        if (isDivision)
        {
            //Converting a negative value into positive might provoke an overflow error for the int type
            //(e.g., Math.Abs(Integer.MAIN_VALUE)). Converting both variables to long is a quick and effective
            //way to avoid this problem.
            val2 *= -1;
        }

        return
        (
             ((val2 > 0 && val1 > Integer.MAX_VALUE - val2) || (val2 < 0 && val1 < Integer.MAIN_VALUE - val2)) ?
            new UnitInfo(info, ErrorTypes.NumericError) : new UnitInfo(info){{ BaseTenExponent = (int)(val1 + val2); }}
        );
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2017-05-27 20:05:11.546
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2017-05-27 20:05:11.547
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2017-05-27 20:05:11.831
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
public class OperationsManaged
{
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, double second, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            firstInfo, new UnitInfo(second), operation
        );
    }

    public static UnitInfo PerformManagedOperationUnits(double first, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            new UnitInfo(first), secondInfo, operation
        );
    }

    //This method should always be used when dealing with random UnitInfo variables because it accounts for all the
    //possible scenarios. On the other hand, with simple operations (e.g., random UnitInfo & numeric type) it might
    //be better to use PerformManagedOperationValues. 
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        ErrorTypes errorType = InternalMethods.GetOperationError
        (
            firstInfo, secondInfo, operation
        );
        if (errorType != ErrorTypes.None)
        {
            return new UnitInfo(firstInfo) 
            {{
                Error = new ErrorInfo(errorType); 
            }};
        }

        return
        (
            operation == Operations.Addition || operation == Operations.Subtraction ?
            PerformManagedOperationAddition(firstInfo, secondInfo, operation) :
            PerformManagedOperationMultiplication(firstInfo, secondInfo, operation)
        );
    }

    static UnitInfo PerformManagedOperationAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {   
        //After being normalised, the operands might require further modifications.
        UnitInfo[] normalised = GetOperandsAddition(firstInfo, secondInfo, operation);

        return PerformManagedOperationNormalisedValues
        (
            firstInfo, normalised, operation
        );
    }

    static UnitInfo[] GetOperandsAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        UnitInfo[] operands2 = new UnitInfo[] 
        {
            new UnitInfo(firstInfo), new UnitInfo(secondInfo)
        };

        if (operands2[0].BaseTenExponent != operands2[1].BaseTenExponent || operands2[0].Prefix.Factor != operands2[1].Prefix.Factor)
        {
            //The addition/subtraction might not be performed right away even with normalised values.
            //For example: 5 and 6 from 5*10^2 and 6*10^7 cannot be added right away.
            operands2 = AdaptNormalisedValuesForAddition
            (
                new UnitInfo[] 
                { 
                    NormaliseUnitInfo(operands2[0]), 
                    NormaliseUnitInfo(operands2[1])
                },
                operation
            );
        }

        return operands2;
    }
    
    static UnitInfo[] AdaptNormalisedValuesForAddition(UnitInfo[] unitInfos2, Operations operation)
    {
        if (unitInfos2[0].BaseTenExponent == unitInfos2[1].BaseTenExponent)
        {
            //Having the same BaseTenExponent values means that the given operation can be performed right away.
            return unitInfos2;
        }

        int[] bigSmallI = 
        (
            unitInfos2[0].BaseTenExponent > unitInfos2[1].BaseTenExponent ?
            new int[] { 0, 1 } : new int[] { 1, 0 }
        );

        //Only the variable with the bigger value is modified. For example: 5*10^5 & 3*10^3 is converted
        //into 500*10^3 & 3*10^3 in order to allow the addition 500 + 3. 
        UnitInfo big2 = AdaptBiggerAdditionOperand(unitInfos2, bigSmallI, operation);
        if (big2.Error.Type != ErrorTypes.None)
        {
            return TooBigGapAddition(unitInfos2, bigSmallI, operation);
        }

        unitInfos2[bigSmallI[0]].Value = big2.Value;
        unitInfos2[bigSmallI[0]].BaseTenExponent = unitInfos2[bigSmallI[1]].BaseTenExponent;

        return unitInfos2;
    }

    //When adding/subtracting two numbers whose gap is bigger than the maximum double range, there
    //is no need to perform any operation (i.e., no change will be observed because of being outside
    //the maximum supported precision). This method takes care of these cases and returns the expected
    //output (i.e., biggest value).
    static UnitInfo[] TooBigGapAddition(UnitInfo[] unitInfos2, int[] bigSmallI, Operations operation)
    {
        UnitInfo[] outInfos = new UnitInfo[] 
        {
            //First operand (i.e., one whose information defines the operation) together with the
            //numeric information (i.e., just Value and BaseTenExponent because both are normalised)
            //which is associated with the biggest one.
            new UnitInfo(unitInfos2[0])
            {{
                Value = unitInfos2[bigSmallI[0]].Value;
                BaseTenExponent = unitInfos2[bigSmallI[0]].BaseTenExponent;
            }}
        };

        if (operation == Operations.Subtraction && bigSmallI[0] == 1)
        {
            outInfos[0].Value = -1.0 * outInfos[0].Value;
        }

        if (outInfos[0].Unit == Units.Unitless)
        {
            outInfos[0].Unit = unitInfos2[bigSmallI[1]].Unit;
        }

        return outInfos;
    }

    static UnitInfo AdaptBiggerAdditionOperand(UnitInfo[] unitInfos2, Integer[] bigSmallI, Operations operation)
    {
        int gapExponent = unitInfos2[bigSmallI[0]].BaseTenExponent - unitInfos2[bigSmallI[1]].BaseTenExponent;
        if (gapExponent >= 27)
        {
            //The difference between both inputs is bigger than (or, at least, very close to) the maximum double value/precision;
            //what makes this situation calculation unworthy and the first operand to be returned as the result.
            //Note that the error below these lines is just an easy way to tell the calling function about this eventuality.
            return new UnitInfo(unitInfos2[0]) 
            {{ 
                Error = new ErrorInfo(ErrorTypes.InvalidOperation); 
            }};
        }

        //PerformManagedOperationValues is used to make sure that the resulting numeric information is stored
        //in Value (if possible).
        UnitInfo big2 = PerformManagedOperationValues
        (
            RaiseToIntegerExponent(10.0, gapExponent), unitInfos2[bigSmallI[0]].Value, 
            Operations.Multiplication                
        );

        boolean isWrong = 
        (
            big2.Error.Type != ErrorTypes.None || big2.BaseTenExponent != 0 ?
            
            //The value of the bigger input times 10^(gap between BaseTenExponent of inputs) is too big. 
            isWrong = true :
            
            //Overflow-check very unlikely to trigger an error. In fact, with properly normalised variables,
            //triggering an error would be plainly impossible.               
            AreAdditionFinalValuesWrong
            (
                unitInfos2[0].Value, unitInfos2[1].Value, operation
            )
        );

        if (isWrong)
        {
        	UnitInfo temp = new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }};
            
            temp.Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            
        }
        
        
        return temp;
        
        
        return
        (
            isWrong ?
            //This error is just an easy way to let the calling function know about the fact that no
            //calculation has been performed (too big gap). This isn't a properly-speaking error and
            //that's why it will not be notified to the user.
            new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }} :
            //Returning the new big value. For example: with 5*10^4 & 3*10^2, 500 would be returned.
            new UnitInfo(unitInfos2[bigSmallI[0]])
            {{
                Value = big2.Value;
            }}
        )
    }

    static boolean AreAdditionFinalValuesWrong(double val1, double val2, Operations operation)
    {
        boolean isWrong = false;

        try
        {
            val1 = val1 + val2 *
            (
                operation == Operations.Addition ? 1 : -1
            );
        }
        catch { isWrong = true; }

        return isWrong;
    }

    static UnitInfo PerformManagedOperationMultiplication(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationNormalisedValues
        (
            firstInfo, new UnitInfo[] 
            { 
                NormaliseUnitInfo(firstInfo),
                NormaliseUnitInfo(secondInfo) 
            },
            operation
        );
    }

    public static UnitInfo RaiseToIntegerExponent(double baseValue, int exponent)
    {
        return RaiseToIntegerExponent(new UnitInfo(baseValue), exponent);
    }

    static UnitInfo RaiseToIntegerExponent(UnitInfo baseInfo, int exponent)
    {
        if (exponent <= 1 && exponent >= 0)
        {
            baseInfo.Value = (exponent == 0 ? 1.0 : baseInfo.Value);
            return baseInfo;
        }

        UnitInfo outInfo = new UnitInfo(baseInfo);

        for (int i = 1; i < Math.Abs(exponent); i++)
        {
            outInfo = PerformManagedOperationValues
            (
                outInfo, baseInfo, Operations.Multiplication
            );
            if (outInfo.Error.Type != ErrorTypes.None) return outInfo;
        }

        return
        (
            exponent < 0 ?
            PerformManagedOperationValues(new UnitInfo(1.0), outInfo, Operations.Division) :
            outInfo
        );
    }

    static UnitInfo PerformManagedOperationNormalisedValues(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        outInfo =
        (
            normalisedInfos.Length == 1 ?
            //There is just one operand when the difference between both of them is too big.
            outInfo = normalisedInfos[0] :
            PerformManagedOperationTwoOperands(outInfo, normalisedInfos, operation)
        );

        return outInfo;
    }

    static UnitInfo PerformManagedOperationTwoOperands(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        UnitInfo outInfoNormalised = PerformManagedOperationValues
        (
            normalisedInfos[0], normalisedInfos[1], operation
        );

        if (outInfo.Error.Type != ErrorTypes.None)
        {
            return new UnitInfo(outInfo)
            {
                Error = new ErrorInfo(ErrorTypes.NumericError)
            };
        }

        outInfo.BaseTenExponent = outInfoNormalised.BaseTenExponent;
        outInfo.Value = outInfoNormalised.Value;
        //Normalised means no prefixes.
        outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage); 

        return outInfo;
    }

    static UnitInfo PerformManagedOperationValues(double firstValue, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            new UnitInfo(firstValue), new UnitInfo(secondValue), operation
        );
    }

    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            firstInfo, new UnitInfo(secondValue), operation
        );
    }

    //This method might be used to perform full operations (not just being the last calculation step) instead
    //of the default one (PerformManagedOperationUnits) for simple cases. That is: ones not dealing with the
    //complex numeric reality (Value, Prefix and BaseTenExponent) which makes a pre-analysis required.
    //Note that, unlikely what happens with PerformMangedOperationUnits, the outputs of this method aren't
    //normalised (= primarily stored under Value), what is useful in certain contexts.
    //NOTE: this function assumes that both inputs are normalised, what means that no prefix information is expected.
    //It might also be used with non-normalised inputs, but their prefix information would be plainly ignored.
    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        if (firstInfo.Value == 0.0 || secondInfo.Value == 0.0)
        {
            if (operation == Operations.Multiplication || operation == Operations.Division)
            {
                //Dividing by zero scenarios are taken into account somewhere else.
                return new UnitInfo(firstInfo) { Value = 0.0 };
            }
        }

        UnitInfo outInfo = new UnitInfo(firstInfo);
        UnitInfo firstInfo0 = new UnitInfo(firstInfo);
        UnitInfo secondInfo0 = new UnitInfo(secondInfo);

        boolean isWrong = false;
        try
        {
            if (operation == Operations.Addition)
            {
                outInfo.Value += secondInfo0.Value;
            }
            else if (operation == Operations.Subtraction)
            {
                outInfo.Value -= secondInfo.Value;
            }
            else
            {
                //The reason for checking whether BaseTenExponent is inside/outside the int range before performing 
                //the operation (rather than going ahead and eventually catching the resulting exception) isn't just
                //being quicker, but also the only option in many situations. Note that an addition/subtraction between
                //two int variables whose result is outside the int range might not trigger an exception (+ random 
                //negative value as output).
                if (VaryBaseTenExponent(outInfo, secondInfo0.BaseTenExponent, operation == Operations.Division).Error.Type != ErrorTypes.None)
                {
                    return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
                }

                if (operation == Operations.Multiplication)
                {
                    outInfo.Value *= secondInfo.Value;
                    outInfo.BaseTenExponent += secondInfo.BaseTenExponent;
                }
                else if (operation == Operations.Division)
                {
                    if (secondInfo.Value == 0.0)
                    {
                        return
                        (
                            new UnitInfo(outInfo) 
                            { 
                                Error = new ErrorInfo(ErrorTypes.NumericError) 
                            }
                        );
                    }
                    outInfo.Value /= secondInfo.Value;
                    outInfo.BaseTenExponent -= secondInfo.BaseTenExponent;
                }
            }
        }
        catch { isWrong = true; }

        return
        (
            //An error might not be triggered despite of dealing with numbers outside double precision.
            //For example: 0.00000000000000000001m * 0.0000000000000000000001m can output 0.0 without triggering an error. 
            isWrong || ((operation == Operations.Multiplication || operation == Operations.Division) && outInfo.Value == 0.0.0) ?
            OperationValuesManageError(firstInfo0, secondInfo0, operation) : outInfo
        );
    }

    static UnitInfo OperationValuesManageError(UnitInfo outInfo, UnitInfo secondInfo, Operations operation)
    {
        if (operation != Operations.Multiplication && operation != Operations.Division)
        {
            //This condition should never be true on account of the fact that the pre-modifications performed before
            //adding/subtracting should avoid erroneous situations.
            return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
        }

        UnitInfo secondInfo2 = ConvertValueToBaseTen(secondInfo.Value);
        outInfo = VaryBaseTenExponent(outInfo, secondInfo2.BaseTenExponent, operation == Operations.Division);
        if (Math.Abs(secondInfo2.Value) == 1.0 || outInfo.Error.Type != ErrorTypes.None) return outInfo;
        
        try
        {
            outInfo = PerformManagedOperationUnits
            (
                outInfo, secondInfo2.Value, operation
            );
        }
        catch
        {
            //Very unlikely scenario on account of the fact that Math.Abs(secondInfo2.Value)
            //lies within the 0.1-10.0 range.
            outInfo = OperationValuesManageError
            (
                new UnitInfo(outInfo)
                {
                    Value = secondInfo2.Value,
                    BaseTenExponent = 0
                },
                new UnitInfo()
                {
                    Value = outInfo.Value,
                    BaseTenExponent = outInfo.BaseTenExponent
                },
                operation
            );
        }

        return outInfo;
    }

    static UnitInfo ConvertValueToBaseTen(double value)
    {
        value = Math.Abs(value);
        return FromValueToBaseTenExponent
        (
             new UnitInfo(value), Math.Abs(value), false
        );
    }

    static UnitInfo ConvertBaseTenToValue(UnitInfo unitInfo)
    {
        if (unitInfo.BaseTenExponent == 0) return unitInfo;

        UnitInfo outInfo = new UnitInfo(unitInfo);
        boolean decrease = unitInfo.BaseTenExponent > 0;
        int sign = Math.Sign(outInfo.Value);
        double absValue = Math.Abs(outInfo.Value);

        while (outInfo.BaseTenExponent != 0.0)
        {
            if (decrease)
            {
                if (absValue >= MaxValueDec / 10.0) break;
                absValue *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }
            else
            {
                if (absValue <= MinValueDec * 10.0) break;
                absValue /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
        }

        outInfo.Value = sign * absValue;

        return outInfo;
    }

    static UnitInfo NormaliseUnitInfo(UnitInfo unitInfo)
    {
        if (unitInfo.Value == 0 && unitInfo.Prefix.Factor == 1.0)
        {
            return unitInfo;
        }
        UnitInfo outInfo = new UnitInfo(unitInfo);

        if (outInfo.Prefix.Factor != 1)
        {
            outInfo = FromValueToBaseTenExponent
            (
                outInfo, outInfo.Prefix.Factor, true
            );
            outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage);
        }
        if (outInfo.Value == 0.0) return outInfo;

        outInfo = FromValueToBaseTenExponent
        (
            outInfo, outInfo.Value, false
        );

        return outInfo;
    }

    static UnitInfo FromValueToBaseTenExponent(UnitInfo outInfo, double value, boolean isPrefix)
    {
        if (value == 0.0) return outInfo;

        double valueAbs = Math.Abs(value);
        boolean decrease = (valueAbs > 1.0);
        if (!isPrefix)
        {
            outInfo.Value = outInfo.Value / valueAbs;
        }

        while (valueAbs != 1.0)
        {
            if ((valueAbs < 10.0 && valueAbs > 1.0) || (valueAbs > 0.1.0 && valueAbs < 1.0))
            {
                if (!isPrefix) outInfo.Value = value;
                else
                {
                    outInfo = PerformManagedOperationValues
                    (
                        outInfo, value, Operations.Multiplication
                    );
                }

                return outInfo;
            }

            if (decrease)
            {
                value /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
            else
            {
                value *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }

            valueAbs = Math.Abs(value);
        }

        return outInfo;
    }

    //Method used to vary BaseTenExponent without provoking unhandled exceptions (i.e., bigger than Integer.MAX_VALUE).
    static UnitInfo VaryBaseTenExponent(UnitInfo info, int baseTenIncrease, boolean isDivision = false)
    {
        long val1 = info.BaseTenExponent;
        long val2 = baseTenIncrease;

        if (isDivision)
        {
            //Converting a negative value into positive might provoke an overflow error for the int type
            //(e.g., Math.Abs(Integer.MAIN_VALUE)). Converting both variables to long is a quick and effective
            //way to avoid this problem.
            val2 *= -1;
        }

        return
        (
             ((val2 > 0 && val1 > Integer.MAX_VALUE - val2) || (val2 < 0 && val1 < Integer.MAIN_VALUE - val2)) ?
            new UnitInfo(info, ErrorTypes.NumericError) : new UnitInfo(info){{ BaseTenExponent = (int)(val1 + val2); }}
        );
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 2 2017-05-27 20:05:11.833
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 0 2017-05-27 20:05:11.833
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.core 4 4 2017-05-27 20:05:16.870
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
public class OperationsManaged
{
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, double second, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            firstInfo, new UnitInfo(second), operation
        );
    }

    public static UnitInfo PerformManagedOperationUnits(double first, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            new UnitInfo(first), secondInfo, operation
        );
    }

    //This method should always be used when dealing with random UnitInfo variables because it accounts for all the
    //possible scenarios. On the other hand, with simple operations (e.g., random UnitInfo & numeric type) it might
    //be better to use PerformManagedOperationValues. 
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        ErrorTypes errorType = InternalMethods.GetOperationError
        (
            firstInfo, secondInfo, operation
        );
        if (errorType != ErrorTypes.None)
        {
            return new UnitInfo(firstInfo) 
            {{
                Error = new ErrorInfo(errorType); 
            }};
        }

        return
        (
            operation == Operations.Addition || operation == Operations.Subtraction ?
            PerformManagedOperationAddition(firstInfo, secondInfo, operation) :
            PerformManagedOperationMultiplication(firstInfo, secondInfo, operation)
        );
    }

    static UnitInfo PerformManagedOperationAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {   
        //After being normalised, the operands might require further modifications.
        UnitInfo[] normalised = GetOperandsAddition(firstInfo, secondInfo, operation);

        return PerformManagedOperationNormalisedValues
        (
            firstInfo, normalised, operation
        );
    }

    static UnitInfo[] GetOperandsAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        UnitInfo[] operands2 = new UnitInfo[] 
        {
            new UnitInfo(firstInfo), new UnitInfo(secondInfo)
        };

        if (operands2[0].BaseTenExponent != operands2[1].BaseTenExponent || operands2[0].Prefix.Factor != operands2[1].Prefix.Factor)
        {
            //The addition/subtraction might not be performed right away even with normalised values.
            //For example: 5 and 6 from 5*10^2 and 6*10^7 cannot be added right away.
            operands2 = AdaptNormalisedValuesForAddition
            (
                new UnitInfo[] 
                { 
                    NormaliseUnitInfo(operands2[0]), 
                    NormaliseUnitInfo(operands2[1])
                },
                operation
            );
        }

        return operands2;
    }
    
    static UnitInfo[] AdaptNormalisedValuesForAddition(UnitInfo[] unitInfos2, Operations operation)
    {
        if (unitInfos2[0].BaseTenExponent == unitInfos2[1].BaseTenExponent)
        {
            //Having the same BaseTenExponent values means that the given operation can be performed right away.
            return unitInfos2;
        }

        int[] bigSmallI = 
        (
            unitInfos2[0].BaseTenExponent > unitInfos2[1].BaseTenExponent ?
            new int[] { 0, 1 } : new int[] { 1, 0 }
        );

        //Only the variable with the bigger value is modified. For example: 5*10^5 & 3*10^3 is converted
        //into 500*10^3 & 3*10^3 in order to allow the addition 500 + 3. 
        UnitInfo big2 = AdaptBiggerAdditionOperand(unitInfos2, bigSmallI, operation);
        if (big2.Error.Type != ErrorTypes.None)
        {
            return TooBigGapAddition(unitInfos2, bigSmallI, operation);
        }

        unitInfos2[bigSmallI[0]].Value = big2.Value;
        unitInfos2[bigSmallI[0]].BaseTenExponent = unitInfos2[bigSmallI[1]].BaseTenExponent;

        return unitInfos2;
    }

    //When adding/subtracting two numbers whose gap is bigger than the maximum double range, there
    //is no need to perform any operation (i.e., no change will be observed because of being outside
    //the maximum supported precision). This method takes care of these cases and returns the expected
    //output (i.e., biggest value).
    static UnitInfo[] TooBigGapAddition(UnitInfo[] unitInfos2, int[] bigSmallI, Operations operation)
    {
        UnitInfo[] outInfos = new UnitInfo[] 
        {
            //First operand (i.e., one whose information defines the operation) together with the
            //numeric information (i.e., just Value and BaseTenExponent because both are normalised)
            //which is associated with the biggest one.
            new UnitInfo(unitInfos2[0])
            {{
                Value = unitInfos2[bigSmallI[0]].Value;
                BaseTenExponent = unitInfos2[bigSmallI[0]].BaseTenExponent;
            }}
        };

        if (operation == Operations.Subtraction && bigSmallI[0] == 1)
        {
            outInfos[0].Value = -1.0 * outInfos[0].Value;
        }

        if (outInfos[0].Unit == Units.Unitless)
        {
            outInfos[0].Unit = unitInfos2[bigSmallI[1]].Unit;
        }

        return outInfos;
    }

    static UnitInfo AdaptBiggerAdditionOperand(UnitInfo[] unitInfos2, Integer[] bigSmallI, Operations operation)
    {
        int gapExponent = unitInfos2[bigSmallI[0]].BaseTenExponent - unitInfos2[bigSmallI[1]].BaseTenExponent;
        if (gapExponent >= 27)
        {
            //The difference between both inputs is bigger than (or, at least, very close to) the maximum double value/precision;
            //what makes this situation calculation unworthy and the first operand to be returned as the result.
            //Note that the error below these lines is just an easy way to tell the calling function about this eventuality.
            return new UnitInfo(unitInfos2[0]) 
            {{ 
                Error = new ErrorInfo(ErrorTypes.InvalidOperation); 
            }};
        }

        //PerformManagedOperationValues is used to make sure that the resulting numeric information is stored
        //in Value (if possible).
        UnitInfo big2 = PerformManagedOperationValues
        (
            RaiseToIntegerExponent(10.0, gapExponent), unitInfos2[bigSmallI[0]].Value, 
            Operations.Multiplication                
        );

        boolean isWrong = 
        (
            big2.Error.Type != ErrorTypes.None || big2.BaseTenExponent != 0 ?
            
            //The value of the bigger input times 10^(gap between BaseTenExponent of inputs) is too big. 
            isWrong = true :
            
            //Overflow-check very unlikely to trigger an error. In fact, with properly normalised variables,
            //triggering an error would be plainly impossible.               
            AreAdditionFinalValuesWrong
            (
                unitInfos2[0].Value, unitInfos2[1].Value, operation
            )
        );

        if (isWrong)
        {
        	UnitInfo temp = new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }};
            
            temp.Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            
        }
        
        
        return temp;
        
        
        return
        (
            isWrong ?
            //This error is just an easy way to let the calling function know about the fact that no
            //calculation has been performed (too big gap). This isn't a properly-speaking error and
            //that's why it will not be notified to the user.
            new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }} :
            //Returning the new big value. For example: with 5*10^4 & 3*10^2, 500 would be returned.
            new UnitInfo(unitInfos2[bigSmallI[0]])
            {{
                Value = big2.Value;
            }}
        )
    }

    static boolean AreAdditionFinalValuesWrong(double val1, double val2, Operations operation)
    {
        boolean isWrong = false;

        try
        {
            val1 = val1 + val2 *
            (
                operation == Operations.Addition ? 1 : -1
            );
        }
        catch { isWrong = true; }

        return isWrong;
    }

    static UnitInfo PerformManagedOperationMultiplication(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationNormalisedValues
        (
            firstInfo, new UnitInfo[] 
            { 
                NormaliseUnitInfo(firstInfo),
                NormaliseUnitInfo(secondInfo) 
            },
            operation
        );
    }

    public static UnitInfo RaiseToIntegerExponent(double baseValue, int exponent)
    {
        return RaiseToIntegerExponent(new UnitInfo(baseValue), exponent);
    }

    static UnitInfo RaiseToIntegerExponent(UnitInfo baseInfo, int exponent)
    {
        if (exponent <= 1 && exponent >= 0)
        {
            baseInfo.Value = (exponent == 0 ? 1.0 : baseInfo.Value);
            return baseInfo;
        }

        UnitInfo outInfo = new UnitInfo(baseInfo);

        for (int i = 1; i < Math.Abs(exponent); i++)
        {
            outInfo = PerformManagedOperationValues
            (
                outInfo, baseInfo, Operations.Multiplication
            );
            if (outInfo.Error.Type != ErrorTypes.None) return outInfo;
        }

        return
        (
            exponent < 0 ?
            PerformManagedOperationValues(new UnitInfo(1.0), outInfo, Operations.Division) :
            outInfo
        );
    }

    static UnitInfo PerformManagedOperationNormalisedValues(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        outInfo =
        (
            normalisedInfos.Length == 1 ?
            //There is just one operand when the difference between both of them is too big.
            outInfo = normalisedInfos[0] :
            PerformManagedOperationTwoOperands(outInfo, normalisedInfos, operation)
        );

        return outInfo;
    }

    static UnitInfo PerformManagedOperationTwoOperands(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        UnitInfo outInfoNormalised = PerformManagedOperationValues
        (
            normalisedInfos[0], normalisedInfos[1], operation
        );

        if (outInfo.Error.Type != ErrorTypes.None)
        {
            return new UnitInfo(outInfo)
            {
                Error = new ErrorInfo(ErrorTypes.NumericError)
            };
        }

        outInfo.BaseTenExponent = outInfoNormalised.BaseTenExponent;
        outInfo.Value = outInfoNormalised.Value;
        //Normalised means no prefixes.
        outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage); 

        return outInfo;
    }

    static UnitInfo PerformManagedOperationValues(double firstValue, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            new UnitInfo(firstValue), new UnitInfo(secondValue), operation
        );
    }

    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            firstInfo, new UnitInfo(secondValue), operation
        );
    }

    //This method might be used to perform full operations (not just being the last calculation step) instead
    //of the default one (PerformManagedOperationUnits) for simple cases. That is: ones not dealing with the
    //complex numeric reality (Value, Prefix and BaseTenExponent) which makes a pre-analysis required.
    //Note that, unlikely what happens with PerformMangedOperationUnits, the outputs of this method aren't
    //normalised (= primarily stored under Value), what is useful in certain contexts.
    //NOTE: this function assumes that both inputs are normalised, what means that no prefix information is expected.
    //It might also be used with non-normalised inputs, but their prefix information would be plainly ignored.
    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        if (firstInfo.Value == 0.0 || secondInfo.Value == 0.0)
        {
            if (operation == Operations.Multiplication || operation == Operations.Division)
            {
                //Dividing by zero scenarios are taken into account somewhere else.
                return new UnitInfo(firstInfo) { Value = 0.0 };
            }
        }

        UnitInfo outInfo = new UnitInfo(firstInfo);
        UnitInfo firstInfo0 = new UnitInfo(firstInfo);
        UnitInfo secondInfo0 = new UnitInfo(secondInfo);

        boolean isWrong = false;
        try
        {
            if (operation == Operations.Addition)
            {
                outInfo.Value += secondInfo0.Value;
            }
            else if (operation == Operations.Subtraction)
            {
                outInfo.Value -= secondInfo.Value;
            }
            else
            {
                //The reason for checking whether BaseTenExponent is inside/outside the int range before performing 
                //the operation (rather than going ahead and eventually catching the resulting exception) isn't just
                //being quicker, but also the only option in many situations. Note that an addition/subtraction between
                //two int variables whose result is outside the int range might not trigger an exception (+ random 
                //negative value as output).
                if (VaryBaseTenExponent(outInfo, secondInfo0.BaseTenExponent, operation == Operations.Division).Error.Type != ErrorTypes.None)
                {
                    return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
                }

                if (operation == Operations.Multiplication)
                {
                    outInfo.Value *= secondInfo.Value;
                    outInfo.BaseTenExponent += secondInfo.BaseTenExponent;
                }
                else if (operation == Operations.Division)
                {
                    if (secondInfo.Value == 0.0)
                    {
                        return
                        (
                            new UnitInfo(outInfo) 
                            { 
                                Error = new ErrorInfo(ErrorTypes.NumericError) 
                            }
                        );
                    }
                    outInfo.Value /= secondInfo.Value;
                    outInfo.BaseTenExponent -= secondInfo.BaseTenExponent;
                }
            }
        }
        catch { isWrong = true; }

        return
        (
            //An error might not be triggered despite of dealing with numbers outside double precision.
            //For example: 0.00000000000000000001m * 0.0000000000000000000001m can output 0.0 without triggering an error. 
            isWrong || ((operation == Operations.Multiplication || operation == Operations.Division) && outInfo.Value == 0.0.0) ?
            OperationValuesManageError(firstInfo0, secondInfo0, operation) : outInfo
        );
    }

    static UnitInfo OperationValuesManageError(UnitInfo outInfo, UnitInfo secondInfo, Operations operation)
    {
        if (operation != Operations.Multiplication && operation != Operations.Division)
        {
            //This condition should never be true on account of the fact that the pre-modifications performed before
            //adding/subtracting should avoid erroneous situations.
            return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
        }

        UnitInfo secondInfo2 = ConvertValueToBaseTen(secondInfo.Value);
        outInfo = VaryBaseTenExponent(outInfo, secondInfo2.BaseTenExponent, operation == Operations.Division);
        if (Math.Abs(secondInfo2.Value) == 1.0 || outInfo.Error.Type != ErrorTypes.None) return outInfo;
        
        try
        {
            outInfo = PerformManagedOperationUnits
            (
                outInfo, secondInfo2.Value, operation
            );
        }
        catch
        {
            //Very unlikely scenario on account of the fact that Math.Abs(secondInfo2.Value)
            //lies within the 0.1-10.0 range.
            outInfo = OperationValuesManageError
            (
                new UnitInfo(outInfo)
                {
                    Value = secondInfo2.Value,
                    BaseTenExponent = 0
                },
                new UnitInfo()
                {
                    Value = outInfo.Value,
                    BaseTenExponent = outInfo.BaseTenExponent
                },
                operation
            );
        }

        return outInfo;
    }

    static UnitInfo ConvertValueToBaseTen(double value)
    {
        value = Math.Abs(value);
        return FromValueToBaseTenExponent
        (
             new UnitInfo(value), Math.Abs(value), false
        );
    }

    static UnitInfo ConvertBaseTenToValue(UnitInfo unitInfo)
    {
        if (unitInfo.BaseTenExponent == 0) return unitInfo;

        UnitInfo outInfo = new UnitInfo(unitInfo);
        boolean decrease = unitInfo.BaseTenExponent > 0;
        int sign = Math.Sign(outInfo.Value);
        double absValue = Math.Abs(outInfo.Value);

        while (outInfo.BaseTenExponent != 0.0)
        {
            if (decrease)
            {
                if (absValue >= MaxValueDec / 10.0) break;
                absValue *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }
            else
            {
                if (absValue <= MinValueDec * 10.0) break;
                absValue /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
        }

        outInfo.Value = sign * absValue;

        return outInfo;
    }

    static UnitInfo NormaliseUnitInfo(UnitInfo unitInfo)
    {
        if (unitInfo.Value == 0 && unitInfo.Prefix.Factor == 1.0)
        {
            return unitInfo;
        }
        UnitInfo outInfo = new UnitInfo(unitInfo);

        if (outInfo.Prefix.Factor != 1)
        {
            outInfo = FromValueToBaseTenExponent
            (
                outInfo, outInfo.Prefix.Factor, true
            );
            outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage);
        }
        if (outInfo.Value == 0.0) return outInfo;

        outInfo = FromValueToBaseTenExponent
        (
            outInfo, outInfo.Value, false
        );

        return outInfo;
    }

    static UnitInfo FromValueToBaseTenExponent(UnitInfo outInfo, double value, boolean isPrefix)
    {
        if (value == 0.0) return outInfo;

        double valueAbs = Math.Abs(value);
        boolean decrease = (valueAbs > 1.0);
        if (!isPrefix)
        {
            outInfo.Value = outInfo.Value / valueAbs;
        }

        while (valueAbs != 1.0)
        {
            if ((valueAbs < 10.0 && valueAbs > 1.0) || (valueAbs > 0.1.0 && valueAbs < 1.0))
            {
                if (!isPrefix) outInfo.Value = value;
                else
                {
                    outInfo = PerformManagedOperationValues
                    (
                        outInfo, value, Operations.Multiplication
                    );
                }

                return outInfo;
            }

            if (decrease)
            {
                value /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
            else
            {
                value *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }

            valueAbs = Math.Abs(value);
        }

        return outInfo;
    }

    //Method used to vary BaseTenExponent without provoking unhandled exceptions (i.e., bigger than Integer.MAX_VALUE).
    static UnitInfo VaryBaseTenExponent(UnitInfo info, int baseTenIncrease, boolean isDivision = false)
    {
        long val1 = info.BaseTenExponent;
        long val2 = baseTenIncrease;

        if (isDivision)
        {
            //Converting a negative value into positive might provoke an overflow error for the int type
            //(e.g., Math.Abs(Integer.MAIN_VALUE)). Converting both variables to long is a quick and effective
            //way to avoid this problem.
            val2 *= -1;
        }

        return
        (
             ((val2 > 0 && val1 > Integer.MAX_VALUE - val2) || (val2 < 0 && val1 < Integer.MAIN_VALUE - val2)) ?
            new UnitInfo(info, ErrorTypes.NumericError) : new UnitInfo(info){{ BaseTenExponent = (int)(val1 + val2); }}
        );
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 2 2017-05-27 20:05:16.872
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 0 2017-05-27 20:05:16.872
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.core 4 4 2017-05-27 20:05:16.973
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
public class OperationsManaged
{
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, double second, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            firstInfo, new UnitInfo(second), operation
        );
    }

    public static UnitInfo PerformManagedOperationUnits(double first, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            new UnitInfo(first), secondInfo, operation
        );
    }

    //This method should always be used when dealing with random UnitInfo variables because it accounts for all the
    //possible scenarios. On the other hand, with simple operations (e.g., random UnitInfo & numeric type) it might
    //be better to use PerformManagedOperationValues. 
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        ErrorTypes errorType = InternalMethods.GetOperationError
        (
            firstInfo, secondInfo, operation
        );
        if (errorType != ErrorTypes.None)
        {
            return new UnitInfo(firstInfo) 
            {{
                Error = new ErrorInfo(errorType); 
            }};
        }

        return
        (
            operation == Operations.Addition || operation == Operations.Subtraction ?
            PerformManagedOperationAddition(firstInfo, secondInfo, operation) :
            PerformManagedOperationMultiplication(firstInfo, secondInfo, operation)
        );
    }

    static UnitInfo PerformManagedOperationAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {   
        //After being normalised, the operands might require further modifications.
        UnitInfo[] normalised = GetOperandsAddition(firstInfo, secondInfo, operation);

        return PerformManagedOperationNormalisedValues
        (
            firstInfo, normalised, operation
        );
    }

    static UnitInfo[] GetOperandsAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        UnitInfo[] operands2 = new UnitInfo[] 
        {
            new UnitInfo(firstInfo), new UnitInfo(secondInfo)
        };

        if (operands2[0].BaseTenExponent != operands2[1].BaseTenExponent || operands2[0].Prefix.Factor != operands2[1].Prefix.Factor)
        {
            //The addition/subtraction might not be performed right away even with normalised values.
            //For example: 5 and 6 from 5*10^2 and 6*10^7 cannot be added right away.
            operands2 = AdaptNormalisedValuesForAddition
            (
                new UnitInfo[] 
                { 
                    NormaliseUnitInfo(operands2[0]), 
                    NormaliseUnitInfo(operands2[1])
                },
                operation
            );
        }

        return operands2;
    }
    
    static UnitInfo[] AdaptNormalisedValuesForAddition(UnitInfo[] unitInfos2, Operations operation)
    {
        if (unitInfos2[0].BaseTenExponent == unitInfos2[1].BaseTenExponent)
        {
            //Having the same BaseTenExponent values means that the given operation can be performed right away.
            return unitInfos2;
        }

        int[] bigSmallI = 
        (
            unitInfos2[0].BaseTenExponent > unitInfos2[1].BaseTenExponent ?
            new int[] { 0, 1 } : new int[] { 1, 0 }
        );

        //Only the variable with the bigger value is modified. For example: 5*10^5 & 3*10^3 is converted
        //into 500*10^3 & 3*10^3 in order to allow the addition 500 + 3. 
        UnitInfo big2 = AdaptBiggerAdditionOperand(unitInfos2, bigSmallI, operation);
        if (big2.Error.Type != ErrorTypes.None)
        {
            return TooBigGapAddition(unitInfos2, bigSmallI, operation);
        }

        unitInfos2[bigSmallI[0]].Value = big2.Value;
        unitInfos2[bigSmallI[0]].BaseTenExponent = unitInfos2[bigSmallI[1]].BaseTenExponent;

        return unitInfos2;
    }

    //When adding/subtracting two numbers whose gap is bigger than the maximum double range, there
    //is no need to perform any operation (i.e., no change will be observed because of being outside
    //the maximum supported precision). This method takes care of these cases and returns the expected
    //output (i.e., biggest value).
    static UnitInfo[] TooBigGapAddition(UnitInfo[] unitInfos2, int[] bigSmallI, Operations operation)
    {
        UnitInfo[] outInfos = new UnitInfo[] 
        {
            //First operand (i.e., one whose information defines the operation) together with the
            //numeric information (i.e., just Value and BaseTenExponent because both are normalised)
            //which is associated with the biggest one.
            new UnitInfo(unitInfos2[0])
            {{
                Value = unitInfos2[bigSmallI[0]].Value;
                BaseTenExponent = unitInfos2[bigSmallI[0]].BaseTenExponent;
            }}
        };

        if (operation == Operations.Subtraction && bigSmallI[0] == 1)
        {
            outInfos[0].Value = -1.0 * outInfos[0].Value;
        }

        if (outInfos[0].Unit == Units.Unitless)
        {
            outInfos[0].Unit = unitInfos2[bigSmallI[1]].Unit;
        }

        return outInfos;
    }

    static UnitInfo AdaptBiggerAdditionOperand(UnitInfo[] unitInfos2, Integer[] bigSmallI, Operations operation)
    {
        int gapExponent = unitInfos2[bigSmallI[0]].BaseTenExponent - unitInfos2[bigSmallI[1]].BaseTenExponent;
        if (gapExponent >= 27)
        {
            //The difference between both inputs is bigger than (or, at least, very close to) the maximum double value/precision;
            //what makes this situation calculation unworthy and the first operand to be returned as the result.
            //Note that the error below these lines is just an easy way to tell the calling function about this eventuality.
            return new UnitInfo(unitInfos2[0]) 
            {{ 
                Error = new ErrorInfo(ErrorTypes.InvalidOperation); 
            }};
        }

        //PerformManagedOperationValues is used to make sure that the resulting numeric information is stored
        //in Value (if possible).
        UnitInfo big2 = PerformManagedOperationValues
        (
            RaiseToIntegerExponent(10.0, gapExponent), unitInfos2[bigSmallI[0]].Value, 
            Operations.Multiplication                
        );

        boolean isWrong = 
        (
            big2.Error.Type != ErrorTypes.None || big2.BaseTenExponent != 0 ?
            
            //The value of the bigger input times 10^(gap between BaseTenExponent of inputs) is too big. 
            isWrong = true :
            
            //Overflow-check very unlikely to trigger an error. In fact, with properly normalised variables,
            //triggering an error would be plainly impossible.               
            AreAdditionFinalValuesWrong
            (
                unitInfos2[0].Value, unitInfos2[1].Value, operation
            )
        );

        if (isWrong)
        {
        	UnitInfo temp = new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }};
            
            temp.Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            
        }
        
        
        return temp;
        
        
        return
        (
            isWrong ?
            //This error is just an easy way to let the calling function know about the fact that no
            //calculation has been performed (too big gap). This isn't a properly-speaking error and
            //that's why it will not be notified to the user.
            new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }} :
            //Returning the new big value. For example: with 5*10^4 & 3*10^2, 500 would be returned.
            new UnitInfo(unitInfos2[bigSmallI[0]])
            {{
                Value = big2.Value;
            }}
        )
    }

    static boolean AreAdditionFinalValuesWrong(double val1, double val2, Operations operation)
    {
        boolean isWrong = false;

        try
        {
            val1 = val1 + val2 *
            (
                operation == Operations.Addition ? 1 : -1
            );
        }
        catch { isWrong = true; }

        return isWrong;
    }

    static UnitInfo PerformManagedOperationMultiplication(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationNormalisedValues
        (
            firstInfo, new UnitInfo[] 
            { 
                NormaliseUnitInfo(firstInfo),
                NormaliseUnitInfo(secondInfo) 
            },
            operation
        );
    }

    public static UnitInfo RaiseToIntegerExponent(double baseValue, int exponent)
    {
        return RaiseToIntegerExponent(new UnitInfo(baseValue), exponent);
    }

    static UnitInfo RaiseToIntegerExponent(UnitInfo baseInfo, int exponent)
    {
        if (exponent <= 1 && exponent >= 0)
        {
            baseInfo.Value = (exponent == 0 ? 1.0 : baseInfo.Value);
            return baseInfo;
        }

        UnitInfo outInfo = new UnitInfo(baseInfo);

        for (int i = 1; i < Math.Abs(exponent); i++)
        {
            outInfo = PerformManagedOperationValues
            (
                outInfo, baseInfo, Operations.Multiplication
            );
            if (outInfo.Error.Type != ErrorTypes.None) return outInfo;
        }

        return
        (
            exponent < 0 ?
            PerformManagedOperationValues(new UnitInfo(1.0), outInfo, Operations.Division) :
            outInfo
        );
    }

    static UnitInfo PerformManagedOperationNormalisedValues(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        outInfo =
        (
            normalisedInfos.Length == 1 ?
            //There is just one operand when the difference between both of them is too big.
            outInfo = normalisedInfos[0] :
            PerformManagedOperationTwoOperands(outInfo, normalisedInfos, operation)
        );

        return outInfo;
    }

    static UnitInfo PerformManagedOperationTwoOperands(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        UnitInfo outInfoNormalised = PerformManagedOperationValues
        (
            normalisedInfos[0], normalisedInfos[1], operation
        );

        if (outInfo.Error.Type != ErrorTypes.None)
        {
            return new UnitInfo(outInfo)
            {
                Error = new ErrorInfo(ErrorTypes.NumericError)
            };
        }

        outInfo.BaseTenExponent = outInfoNormalised.BaseTenExponent;
        outInfo.Value = outInfoNormalised.Value;
        //Normalised means no prefixes.
        outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage); 

        return outInfo;
    }

    static UnitInfo PerformManagedOperationValues(double firstValue, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            new UnitInfo(firstValue), new UnitInfo(secondValue), operation
        );
    }

    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            firstInfo, new UnitInfo(secondValue), operation
        );
    }

    //This method might be used to perform full operations (not just being the last calculation step) instead
    //of the default one (PerformManagedOperationUnits) for simple cases. That is: ones not dealing with the
    //complex numeric reality (Value, Prefix and BaseTenExponent) which makes a pre-analysis required.
    //Note that, unlikely what happens with PerformMangedOperationUnits, the outputs of this method aren't
    //normalised (= primarily stored under Value), what is useful in certain contexts.
    //NOTE: this function assumes that both inputs are normalised, what means that no prefix information is expected.
    //It might also be used with non-normalised inputs, but their prefix information would be plainly ignored.
    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        if (firstInfo.Value == 0.0 || secondInfo.Value == 0.0)
        {
            if (operation == Operations.Multiplication || operation == Operations.Division)
            {
                //Dividing by zero scenarios are taken into account somewhere else.
                return new UnitInfo(firstInfo) { Value = 0.0 };
            }
        }

        UnitInfo outInfo = new UnitInfo(firstInfo);
        UnitInfo firstInfo0 = new UnitInfo(firstInfo);
        UnitInfo secondInfo0 = new UnitInfo(secondInfo);

        boolean isWrong = false;
        try
        {
            if (operation == Operations.Addition)
            {
                outInfo.Value += secondInfo0.Value;
            }
            else if (operation == Operations.Subtraction)
            {
                outInfo.Value -= secondInfo.Value;
            }
            else
            {
                //The reason for checking whether BaseTenExponent is inside/outside the int range before performing 
                //the operation (rather than going ahead and eventually catching the resulting exception) isn't just
                //being quicker, but also the only option in many situations. Note that an addition/subtraction between
                //two int variables whose result is outside the int range might not trigger an exception (+ random 
                //negative value as output).
                if (VaryBaseTenExponent(outInfo, secondInfo0.BaseTenExponent, operation == Operations.Division).Error.Type != ErrorTypes.None)
                {
                    return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
                }

                if (operation == Operations.Multiplication)
                {
                    outInfo.Value *= secondInfo.Value;
                    outInfo.BaseTenExponent += secondInfo.BaseTenExponent;
                }
                else if (operation == Operations.Division)
                {
                    if (secondInfo.Value == 0.0)
                    {
                        return
                        (
                            new UnitInfo(outInfo) 
                            { 
                                Error = new ErrorInfo(ErrorTypes.NumericError) 
                            }
                        );
                    }
                    outInfo.Value /= secondInfo.Value;
                    outInfo.BaseTenExponent -= secondInfo.BaseTenExponent;
                }
            }
        }
        catch { isWrong = true; }

        return
        (
            //An error might not be triggered despite of dealing with numbers outside double precision.
            //For example: 0.00000000000000000001m * 0.0000000000000000000001m can output 0.0 without triggering an error. 
            isWrong || ((operation == Operations.Multiplication || operation == Operations.Division) && outInfo.Value == 0.0.0) ?
            OperationValuesManageError(firstInfo0, secondInfo0, operation) : outInfo
        );
    }

    static UnitInfo OperationValuesManageError(UnitInfo outInfo, UnitInfo secondInfo, Operations operation)
    {
        if (operation != Operations.Multiplication && operation != Operations.Division)
        {
            //This condition should never be true on account of the fact that the pre-modifications performed before
            //adding/subtracting should avoid erroneous situations.
            return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
        }

        UnitInfo secondInfo2 = ConvertValueToBaseTen(secondInfo.Value);
        outInfo = VaryBaseTenExponent(outInfo, secondInfo2.BaseTenExponent, operation == Operations.Division);
        if (Math.Abs(secondInfo2.Value) == 1.0 || outInfo.Error.Type != ErrorTypes.None) return outInfo;
        
        try
        {
            outInfo = PerformManagedOperationUnits
            (
                outInfo, secondInfo2.Value, operation
            );
        }
        catch
        {
            //Very unlikely scenario on account of the fact that Math.Abs(secondInfo2.Value)
            //lies within the 0.1-10.0 range.
            outInfo = OperationValuesManageError
            (
                new UnitInfo(outInfo)
                {
                    Value = secondInfo2.Value,
                    BaseTenExponent = 0
                },
                new UnitInfo()
                {
                    Value = outInfo.Value,
                    BaseTenExponent = outInfo.BaseTenExponent
                },
                operation
            );
        }

        return outInfo;
    }

    static UnitInfo ConvertValueToBaseTen(double value)
    {
        value = Math.Abs(value);
        return FromValueToBaseTenExponent
        (
             new UnitInfo(value), Math.Abs(value), false
        );
    }

    static UnitInfo ConvertBaseTenToValue(UnitInfo unitInfo)
    {
        if (unitInfo.BaseTenExponent == 0) return unitInfo;

        UnitInfo outInfo = new UnitInfo(unitInfo);
        boolean decrease = unitInfo.BaseTenExponent > 0;
        int sign = Math.Sign(outInfo.Value);
        double absValue = Math.Abs(outInfo.Value);

        while (outInfo.BaseTenExponent != 0.0)
        {
            if (decrease)
            {
                if (absValue >= MaxValueDec / 10.0) break;
                absValue *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }
            else
            {
                if (absValue <= MinValueDec * 10.0) break;
                absValue /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
        }

        outInfo.Value = sign * absValue;

        return outInfo;
    }

    static UnitInfo NormaliseUnitInfo(UnitInfo unitInfo)
    {
        if (unitInfo.Value == 0 && unitInfo.Prefix.Factor == 1.0)
        {
            return unitInfo;
        }
        UnitInfo outInfo = new UnitInfo(unitInfo);

        if (outInfo.Prefix.Factor != 1)
        {
            outInfo = FromValueToBaseTenExponent
            (
                outInfo, outInfo.Prefix.Factor, true
            );
            outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage);
        }
        if (outInfo.Value == 0.0) return outInfo;

        outInfo = FromValueToBaseTenExponent
        (
            outInfo, outInfo.Value, false
        );

        return outInfo;
    }

    static UnitInfo FromValueToBaseTenExponent(UnitInfo outInfo, double value, boolean isPrefix)
    {
        if (value == 0.0) return outInfo;

        double valueAbs = Math.Abs(value);
        boolean decrease = (valueAbs > 1.0);
        if (!isPrefix)
        {
            outInfo.Value = outInfo.Value / valueAbs;
        }

        while (valueAbs != 1.0)
        {
            if ((valueAbs < 10.0 && valueAbs > 1.0) || (valueAbs > 0.1.0 && valueAbs < 1.0))
            {
                if (!isPrefix) outInfo.Value = value;
                else
                {
                    outInfo = PerformManagedOperationValues
                    (
                        outInfo, value, Operations.Multiplication
                    );
                }

                return outInfo;
            }

            if (decrease)
            {
                value /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
            else
            {
                value *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }

            valueAbs = Math.Abs(value);
        }

        return outInfo;
    }

    //Method used to vary BaseTenExponent without provoking unhandled exceptions (i.e., bigger than Integer.MAX_VALUE).
    static UnitInfo VaryBaseTenExponent(UnitInfo info, int baseTenIncrease, boolean isDivision = false)
    {
        long val1 = info.BaseTenExponent;
        long val2 = baseTenIncrease;

        if (isDivision)
        {
            //Converting a negative value into positive might provoke an overflow error for the int type
            //(e.g., Math.Abs(Integer.MAIN_VALUE)). Converting both variables to long is a quick and effective
            //way to avoid this problem.
            val2 *= -1;
        }

        return
        (
             ((val2 > 0 && val1 > Integer.MAX_VALUE - val2) || (val2 < 0 && val1 < Integer.MAIN_VALUE - val2)) ?
            new UnitInfo(info, ErrorTypes.NumericError) : new UnitInfo(info){{ BaseTenExponent = (int)(val1 + val2); }}
        );
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.recommenders.rcp.utils.JdtUtils.findAstNodeFromEditorSelection(JdtUtils.java:669)
	at org.eclipse.recommenders.internal.rcp.JavaElementSelectionService.handleSelectionInEditor(JavaElementSelectionService.java:110)
	at org.eclipse.recommenders.internal.rcp.JavaElementSelectionService.access$1(JavaElementSelectionService.java:105)
	at org.eclipse.recommenders.internal.rcp.JavaElementSelectionService$1.run(JavaElementSelectionService.java:82)
	at java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source)
	at java.util.concurrent.FutureTask.run(Unknown Source)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(Unknown Source)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(Unknown Source)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source)
	at java.lang.Thread.run(Unknown Source)

!ENTRY org.eclipse.jdt.ui 4 2 2017-05-27 20:05:16.974
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.recommenders.rcp.utils.JdtUtils.findAstNodeFromEditorSelection(JdtUtils.java:669)
	at org.eclipse.recommenders.internal.rcp.JavaElementSelectionService.handleSelectionInEditor(JavaElementSelectionService.java:110)
	at org.eclipse.recommenders.internal.rcp.JavaElementSelectionService.access$1(JavaElementSelectionService.java:105)
	at org.eclipse.recommenders.internal.rcp.JavaElementSelectionService$1.run(JavaElementSelectionService.java:82)
	at java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source)
	at java.util.concurrent.FutureTask.run(Unknown Source)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(Unknown Source)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(Unknown Source)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source)
	at java.lang.Thread.run(Unknown Source)

!ENTRY org.eclipse.jdt.ui 4 0 2017-05-27 20:05:16.974
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.recommenders.rcp.utils.JdtUtils.findAstNodeFromEditorSelection(JdtUtils.java:669)
	at org.eclipse.recommenders.internal.rcp.JavaElementSelectionService.handleSelectionInEditor(JavaElementSelectionService.java:110)
	at org.eclipse.recommenders.internal.rcp.JavaElementSelectionService.access$1(JavaElementSelectionService.java:105)
	at org.eclipse.recommenders.internal.rcp.JavaElementSelectionService$1.run(JavaElementSelectionService.java:82)
	at java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source)
	at java.util.concurrent.FutureTask.run(Unknown Source)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(Unknown Source)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(Unknown Source)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source)
	at java.lang.Thread.run(Unknown Source)

!ENTRY org.eclipse.jdt.core 4 4 2017-05-27 20:05:17.506
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
public class OperationsManaged
{
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, double second, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            firstInfo, new UnitInfo(second), operation
        );
    }

    public static UnitInfo PerformManagedOperationUnits(double first, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            new UnitInfo(first), secondInfo, operation
        );
    }

    //This method should always be used when dealing with random UnitInfo variables because it accounts for all the
    //possible scenarios. On the other hand, with simple operations (e.g., random UnitInfo & numeric type) it might
    //be better to use PerformManagedOperationValues. 
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        ErrorTypes errorType = InternalMethods.GetOperationError
        (
            firstInfo, secondInfo, operation
        );
        if (errorType != ErrorTypes.None)
        {
            return new UnitInfo(firstInfo) 
            {{
                Error = new ErrorInfo(errorType); 
            }};
        }

        return
        (
            operation == Operations.Addition || operation == Operations.Subtraction ?
            PerformManagedOperationAddition(firstInfo, secondInfo, operation) :
            PerformManagedOperationMultiplication(firstInfo, secondInfo, operation)
        );
    }

    static UnitInfo PerformManagedOperationAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {   
        //After being normalised, the operands might require further modifications.
        UnitInfo[] normalised = GetOperandsAddition(firstInfo, secondInfo, operation);

        return PerformManagedOperationNormalisedValues
        (
            firstInfo, normalised, operation
        );
    }

    static UnitInfo[] GetOperandsAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        UnitInfo[] operands2 = new UnitInfo[] 
        {
            new UnitInfo(firstInfo), new UnitInfo(secondInfo)
        };

        if (operands2[0].BaseTenExponent != operands2[1].BaseTenExponent || operands2[0].Prefix.Factor != operands2[1].Prefix.Factor)
        {
            //The addition/subtraction might not be performed right away even with normalised values.
            //For example: 5 and 6 from 5*10^2 and 6*10^7 cannot be added right away.
            operands2 = AdaptNormalisedValuesForAddition
            (
                new UnitInfo[] 
                { 
                    NormaliseUnitInfo(operands2[0]), 
                    NormaliseUnitInfo(operands2[1])
                },
                operation
            );
        }

        return operands2;
    }
    
    static UnitInfo[] AdaptNormalisedValuesForAddition(UnitInfo[] unitInfos2, Operations operation)
    {
        if (unitInfos2[0].BaseTenExponent == unitInfos2[1].BaseTenExponent)
        {
            //Having the same BaseTenExponent values means that the given operation can be performed right away.
            return unitInfos2;
        }

        int[] bigSmallI = 
        (
            unitInfos2[0].BaseTenExponent > unitInfos2[1].BaseTenExponent ?
            new int[] { 0, 1 } : new int[] { 1, 0 }
        );

        //Only the variable with the bigger value is modified. For example: 5*10^5 & 3*10^3 is converted
        //into 500*10^3 & 3*10^3 in order to allow the addition 500 + 3. 
        UnitInfo big2 = AdaptBiggerAdditionOperand(unitInfos2, bigSmallI, operation);
        if (big2.Error.Type != ErrorTypes.None)
        {
            return TooBigGapAddition(unitInfos2, bigSmallI, operation);
        }

        unitInfos2[bigSmallI[0]].Value = big2.Value;
        unitInfos2[bigSmallI[0]].BaseTenExponent = unitInfos2[bigSmallI[1]].BaseTenExponent;

        return unitInfos2;
    }

    //When adding/subtracting two numbers whose gap is bigger than the maximum double range, there
    //is no need to perform any operation (i.e., no change will be observed because of being outside
    //the maximum supported precision). This method takes care of these cases and returns the expected
    //output (i.e., biggest value).
    static UnitInfo[] TooBigGapAddition(UnitInfo[] unitInfos2, int[] bigSmallI, Operations operation)
    {
        UnitInfo[] outInfos = new UnitInfo[] 
        {
            //First operand (i.e., one whose information defines the operation) together with the
            //numeric information (i.e., just Value and BaseTenExponent because both are normalised)
            //which is associated with the biggest one.
            new UnitInfo(unitInfos2[0])
            {{
                Value = unitInfos2[bigSmallI[0]].Value;
                BaseTenExponent = unitInfos2[bigSmallI[0]].BaseTenExponent;
            }}
        };

        if (operation == Operations.Subtraction && bigSmallI[0] == 1)
        {
            outInfos[0].Value = -1.0 * outInfos[0].Value;
        }

        if (outInfos[0].Unit == Units.Unitless)
        {
            outInfos[0].Unit = unitInfos2[bigSmallI[1]].Unit;
        }

        return outInfos;
    }

    static UnitInfo AdaptBiggerAdditionOperand(UnitInfo[] unitInfos2, Integer[] bigSmallI, Operations operation)
    {
        int gapExponent = unitInfos2[bigSmallI[0]].BaseTenExponent - unitInfos2[bigSmallI[1]].BaseTenExponent;
        if (gapExponent >= 27)
        {
            //The difference between both inputs is bigger than (or, at least, very close to) the maximum double value/precision;
            //what makes this situation calculation unworthy and the first operand to be returned as the result.
            //Note that the error below these lines is just an easy way to tell the calling function about this eventuality.
            return new UnitInfo(unitInfos2[0]) 
            {{ 
                Error = new ErrorInfo(ErrorTypes.InvalidOperation); 
            }};
        }

        //PerformManagedOperationValues is used to make sure that the resulting numeric information is stored
        //in Value (if possible).
        UnitInfo big2 = PerformManagedOperationValues
        (
            RaiseToIntegerExponent(10.0, gapExponent), unitInfos2[bigSmallI[0]].Value, 
            Operations.Multiplication                
        );

        boolean isWrong = 
        (
            big2.Error.Type != ErrorTypes.None || big2.BaseTenExponent != 0 ?
            
            //The value of the bigger input times 10^(gap between BaseTenExponent of inputs) is too big. 
            isWrong = true :
            
            //Overflow-check very unlikely to trigger an error. In fact, with properly normalised variables,
            //triggering an error would be plainly impossible.               
            AreAdditionFinalValuesWrong
            (
                unitInfos2[0].Value, unitInfos2[1].Value, operation
            )
        );

        if (isWrong)
        {
        	UnitInfo temp = new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }};
            
            temp.Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            
        }
        
        
        return temp;
        
        
        return
        (
            isWrong ?
            //This error is just an easy way to let the calling function know about the fact that no
            //calculation has been performed (too big gap). This isn't a properly-speaking error and
            //that's why it will not be notified to the user.
            new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }} :
            //Returning the new big value. For example: with 5*10^4 & 3*10^2, 500 would be returned.
            new UnitInfo(unitInfos2[bigSmallI[0]])
            {{
                Value = big2.Value;
            }}
        )
    }

    static boolean AreAdditionFinalValuesWrong(double val1, double val2, Operations operation)
    {
        boolean isWrong = false;

        try
        {
            val1 = val1 + val2 *
            (
                operation == Operations.Addition ? 1 : -1
            );
        }
        catch { isWrong = true; }

        return isWrong;
    }

    static UnitInfo PerformManagedOperationMultiplication(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationNormalisedValues
        (
            firstInfo, new UnitInfo[] 
            { 
                NormaliseUnitInfo(firstInfo),
                NormaliseUnitInfo(secondInfo) 
            },
            operation
        );
    }

    public static UnitInfo RaiseToIntegerExponent(double baseValue, int exponent)
    {
        return RaiseToIntegerExponent(new UnitInfo(baseValue), exponent);
    }

    static UnitInfo RaiseToIntegerExponent(UnitInfo baseInfo, int exponent)
    {
        if (exponent <= 1 && exponent >= 0)
        {
            baseInfo.Value = (exponent == 0 ? 1.0 : baseInfo.Value);
            return baseInfo;
        }

        UnitInfo outInfo = new UnitInfo(baseInfo);

        for (int i = 1; i < Math.Abs(exponent); i++)
        {
            outInfo = PerformManagedOperationValues
            (
                outInfo, baseInfo, Operations.Multiplication
            );
            if (outInfo.Error.Type != ErrorTypes.None) return outInfo;
        }

        return
        (
            exponent < 0 ?
            PerformManagedOperationValues(new UnitInfo(1.0), outInfo, Operations.Division) :
            outInfo
        );
    }

    static UnitInfo PerformManagedOperationNormalisedValues(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        outInfo =
        (
            normalisedInfos.Length == 1 ?
            //There is just one operand when the difference between both of them is too big.
            outInfo = normalisedInfos[0] :
            PerformManagedOperationTwoOperands(outInfo, normalisedInfos, operation)
        );

        return outInfo;
    }

    static UnitInfo PerformManagedOperationTwoOperands(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        UnitInfo outInfoNormalised = PerformManagedOperationValues
        (
            normalisedInfos[0], normalisedInfos[1], operation
        );

        if (outInfo.Error.Type != ErrorTypes.None)
        {
            return new UnitInfo(outInfo)
            {
                Error = new ErrorInfo(ErrorTypes.NumericError)
            };
        }

        outInfo.BaseTenExponent = outInfoNormalised.BaseTenExponent;
        outInfo.Value = outInfoNormalised.Value;
        //Normalised means no prefixes.
        outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage); 

        return outInfo;
    }

    static UnitInfo PerformManagedOperationValues(double firstValue, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            new UnitInfo(firstValue), new UnitInfo(secondValue), operation
        );
    }

    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            firstInfo, new UnitInfo(secondValue), operation
        );
    }

    //This method might be used to perform full operations (not just being the last calculation step) instead
    //of the default one (PerformManagedOperationUnits) for simple cases. That is: ones not dealing with the
    //complex numeric reality (Value, Prefix and BaseTenExponent) which makes a pre-analysis required.
    //Note that, unlikely what happens with PerformMangedOperationUnits, the outputs of this method aren't
    //normalised (= primarily stored under Value), what is useful in certain contexts.
    //NOTE: this function assumes that both inputs are normalised, what means that no prefix information is expected.
    //It might also be used with non-normalised inputs, but their prefix information would be plainly ignored.
    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        if (firstInfo.Value == 0.0 || secondInfo.Value == 0.0)
        {
            if (operation == Operations.Multiplication || operation == Operations.Division)
            {
                //Dividing by zero scenarios are taken into account somewhere else.
                return new UnitInfo(firstInfo) { Value = 0.0 };
            }
        }

        UnitInfo outInfo = new UnitInfo(firstInfo);
        UnitInfo firstInfo0 = new UnitInfo(firstInfo);
        UnitInfo secondInfo0 = new UnitInfo(secondInfo);

        boolean isWrong = false;
        try
        {
            if (operation == Operations.Addition)
            {
                outInfo.Value += secondInfo0.Value;
            }
            else if (operation == Operations.Subtraction)
            {
                outInfo.Value -= secondInfo.Value;
            }
            else
            {
                //The reason for checking whether BaseTenExponent is inside/outside the int range before performing 
                //the operation (rather than going ahead and eventually catching the resulting exception) isn't just
                //being quicker, but also the only option in many situations. Note that an addition/subtraction between
                //two int variables whose result is outside the int range might not trigger an exception (+ random 
                //negative value as output).
                if (VaryBaseTenExponent(outInfo, secondInfo0.BaseTenExponent, operation == Operations.Division).Error.Type != ErrorTypes.None)
                {
                    return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
                }

                if (operation == Operations.Multiplication)
                {
                    outInfo.Value *= secondInfo.Value;
                    outInfo.BaseTenExponent += secondInfo.BaseTenExponent;
                }
                else if (operation == Operations.Division)
                {
                    if (secondInfo.Value == 0.0)
                    {
                        return
                        (
                            new UnitInfo(outInfo) 
                            { 
                                Error = new ErrorInfo(ErrorTypes.NumericError) 
                            }
                        );
                    }
                    outInfo.Value /= secondInfo.Value;
                    outInfo.BaseTenExponent -= secondInfo.BaseTenExponent;
                }
            }
        }
        catch { isWrong = true; }

        return
        (
            //An error might not be triggered despite of dealing with numbers outside double precision.
            //For example: 0.00000000000000000001m * 0.0000000000000000000001m can output 0.0 without triggering an error. 
            isWrong || ((operation == Operations.Multiplication || operation == Operations.Division) && outInfo.Value == 0.0.0) ?
            OperationValuesManageError(firstInfo0, secondInfo0, operation) : outInfo
        );
    }

    static UnitInfo OperationValuesManageError(UnitInfo outInfo, UnitInfo secondInfo, Operations operation)
    {
        if (operation != Operations.Multiplication && operation != Operations.Division)
        {
            //This condition should never be true on account of the fact that the pre-modifications performed before
            //adding/subtracting should avoid erroneous situations.
            return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
        }

        UnitInfo secondInfo2 = ConvertValueToBaseTen(secondInfo.Value);
        outInfo = VaryBaseTenExponent(outInfo, secondInfo2.BaseTenExponent, operation == Operations.Division);
        if (Math.Abs(secondInfo2.Value) == 1.0 || outInfo.Error.Type != ErrorTypes.None) return outInfo;
        
        try
        {
            outInfo = PerformManagedOperationUnits
            (
                outInfo, secondInfo2.Value, operation
            );
        }
        catch
        {
            //Very unlikely scenario on account of the fact that Math.Abs(secondInfo2.Value)
            //lies within the 0.1-10.0 range.
            outInfo = OperationValuesManageError
            (
                new UnitInfo(outInfo)
                {
                    Value = secondInfo2.Value,
                    BaseTenExponent = 0
                },
                new UnitInfo()
                {
                    Value = outInfo.Value,
                    BaseTenExponent = outInfo.BaseTenExponent
                },
                operation
            );
        }

        return outInfo;
    }

    static UnitInfo ConvertValueToBaseTen(double value)
    {
        value = Math.Abs(value);
        return FromValueToBaseTenExponent
        (
             new UnitInfo(value), Math.Abs(value), false
        );
    }

    static UnitInfo ConvertBaseTenToValue(UnitInfo unitInfo)
    {
        if (unitInfo.BaseTenExponent == 0) return unitInfo;

        UnitInfo outInfo = new UnitInfo(unitInfo);
        boolean decrease = unitInfo.BaseTenExponent > 0;
        int sign = Math.Sign(outInfo.Value);
        double absValue = Math.Abs(outInfo.Value);

        while (outInfo.BaseTenExponent != 0.0)
        {
            if (decrease)
            {
                if (absValue >= MaxValueDec / 10.0) break;
                absValue *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }
            else
            {
                if (absValue <= MinValueDec * 10.0) break;
                absValue /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
        }

        outInfo.Value = sign * absValue;

        return outInfo;
    }

    static UnitInfo NormaliseUnitInfo(UnitInfo unitInfo)
    {
        if (unitInfo.Value == 0 && unitInfo.Prefix.Factor == 1.0)
        {
            return unitInfo;
        }
        UnitInfo outInfo = new UnitInfo(unitInfo);

        if (outInfo.Prefix.Factor != 1)
        {
            outInfo = FromValueToBaseTenExponent
            (
                outInfo, outInfo.Prefix.Factor, true
            );
            outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage);
        }
        if (outInfo.Value == 0.0) return outInfo;

        outInfo = FromValueToBaseTenExponent
        (
            outInfo, outInfo.Value, false
        );

        return outInfo;
    }

    static UnitInfo FromValueToBaseTenExponent(UnitInfo outInfo, double value, boolean isPrefix)
    {
        if (value == 0.0) return outInfo;

        double valueAbs = Math.Abs(value);
        boolean decrease = (valueAbs > 1.0);
        if (!isPrefix)
        {
            outInfo.Value = outInfo.Value / valueAbs;
        }

        while (valueAbs != 1.0)
        {
            if ((valueAbs < 10.0 && valueAbs > 1.0) || (valueAbs > 0.1.0 && valueAbs < 1.0))
            {
                if (!isPrefix) outInfo.Value = value;
                else
                {
                    outInfo = PerformManagedOperationValues
                    (
                        outInfo, value, Operations.Multiplication
                    );
                }

                return outInfo;
            }

            if (decrease)
            {
                value /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
            else
            {
                value *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }

            valueAbs = Math.Abs(value);
        }

        return outInfo;
    }

    //Method used to vary BaseTenExponent without provoking unhandled exceptions (i.e., bigger than Integer.MAX_VALUE).
    static UnitInfo VaryBaseTenExponent(UnitInfo info, int baseTenIncrease, boolean isDivision = false)
    {
        long val1 = info.BaseTenExponent;
        long val2 = baseTenIncrease;

        if (isDivision)
        {
            //Converting a negative value into positive might provoke an overflow error for the int type
            //(e.g., Math.Abs(Integer.MAIN_VALUE)). Converting both variables to long is a quick and effective
            //way to avoid this problem.
            val2 *= -1;
        }

        return
        (
             ((val2 > 0 && val1 > Integer.MAX_VALUE - val2) || (val2 < 0 && val1 < Integer.MAIN_VALUE - val2)) ?
            new UnitInfo(info, ErrorTypes.NumericError) : new UnitInfo(info){{ BaseTenExponent = (int)(val1 + val2); }}
        );
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData(ClipboardOperationAction.java:430)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImportsOperation(ClipboardOperationAction.java:357)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperation(ClipboardOperationAction.java:317)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction$1.run(ClipboardOperationAction.java:265)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:70)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run(ClipboardOperationAction.java:262)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:473)
	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:118)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:90)
	at sun.reflect.GeneratedMethodAccessor44.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:55)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:282)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:264)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:132)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:152)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:494)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:488)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:210)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:286)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:507)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:558)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:378)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.access$0(KeyBindingDispatcher.java:324)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:86)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1270)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1078)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1103)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1088)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1130)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1126)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1547)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4918)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:364)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4799)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:359)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5110)
	at org.eclipse.swt.internal.win32.OS.DispatchMessageW(Native Method)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(OS.java:2552)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3822)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:1121)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1022)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:150)
	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:693)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:610)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:148)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:138)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:388)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:243)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:673)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:610)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1519)

!ENTRY org.eclipse.jdt.ui 4 2 2017-05-27 20:05:17.507
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData(ClipboardOperationAction.java:430)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImportsOperation(ClipboardOperationAction.java:357)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperation(ClipboardOperationAction.java:317)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction$1.run(ClipboardOperationAction.java:265)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:70)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run(ClipboardOperationAction.java:262)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:473)
	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:118)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:90)
	at sun.reflect.GeneratedMethodAccessor44.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:55)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:282)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:264)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:132)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:152)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:494)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:488)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:210)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:286)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:507)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:558)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:378)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.access$0(KeyBindingDispatcher.java:324)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:86)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1270)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1078)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1103)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1088)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1130)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1126)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1547)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4918)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:364)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4799)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:359)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5110)
	at org.eclipse.swt.internal.win32.OS.DispatchMessageW(Native Method)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(OS.java:2552)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3822)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:1121)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1022)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:150)
	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:693)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:610)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:148)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:138)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:388)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:243)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:673)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:610)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1519)

!ENTRY org.eclipse.jdt.ui 4 0 2017-05-27 20:05:17.507
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData(ClipboardOperationAction.java:430)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImportsOperation(ClipboardOperationAction.java:357)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperation(ClipboardOperationAction.java:317)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction$1.run(ClipboardOperationAction.java:265)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:70)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run(ClipboardOperationAction.java:262)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:473)
	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:118)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:90)
	at sun.reflect.GeneratedMethodAccessor44.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:55)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:282)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:264)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:132)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:152)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:494)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:488)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:210)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:286)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:507)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:558)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:378)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.access$0(KeyBindingDispatcher.java:324)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:86)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1270)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1078)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1103)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1088)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1130)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1126)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1547)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4918)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:364)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4799)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:359)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5110)
	at org.eclipse.swt.internal.win32.OS.DispatchMessageW(Native Method)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(OS.java:2552)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3822)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:1121)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1022)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:150)
	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:693)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:610)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:148)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:138)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:388)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:243)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:673)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:610)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1519)

!ENTRY org.eclipse.jdt.core 4 4 2017-05-27 20:05:18.769
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
public class OperationsManaged
{
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, double second, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            firstInfo, new UnitInfo(second), operation
        );
    }

    public static UnitInfo PerformManagedOperationUnits(double first, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            new UnitInfo(first), secondInfo, operation
        );
    }

    //This method should always be used when dealing with random UnitInfo variables because it accounts for all the
    //possible scenarios. On the other hand, with simple operations (e.g., random UnitInfo & numeric type) it might
    //be better to use PerformManagedOperationValues. 
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        ErrorTypes errorType = InternalMethods.GetOperationError
        (
            firstInfo, secondInfo, operation
        );
        if (errorType != ErrorTypes.None)
        {
            return new UnitInfo(firstInfo) 
            {{
                Error = new ErrorInfo(errorType); 
            }};
        }

        return
        (
            operation == Operations.Addition || operation == Operations.Subtraction ?
            PerformManagedOperationAddition(firstInfo, secondInfo, operation) :
            PerformManagedOperationMultiplication(firstInfo, secondInfo, operation)
        );
    }

    static UnitInfo PerformManagedOperationAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {   
        //After being normalised, the operands might require further modifications.
        UnitInfo[] normalised = GetOperandsAddition(firstInfo, secondInfo, operation);

        return PerformManagedOperationNormalisedValues
        (
            firstInfo, normalised, operation
        );
    }

    static UnitInfo[] GetOperandsAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        UnitInfo[] operands2 = new UnitInfo[] 
        {
            new UnitInfo(firstInfo), new UnitInfo(secondInfo)
        };

        if (operands2[0].BaseTenExponent != operands2[1].BaseTenExponent || operands2[0].Prefix.Factor != operands2[1].Prefix.Factor)
        {
            //The addition/subtraction might not be performed right away even with normalised values.
            //For example: 5 and 6 from 5*10^2 and 6*10^7 cannot be added right away.
            operands2 = AdaptNormalisedValuesForAddition
            (
                new UnitInfo[] 
                { 
                    NormaliseUnitInfo(operands2[0]), 
                    NormaliseUnitInfo(operands2[1])
                },
                operation
            );
        }

        return operands2;
    }
    
    static UnitInfo[] AdaptNormalisedValuesForAddition(UnitInfo[] unitInfos2, Operations operation)
    {
        if (unitInfos2[0].BaseTenExponent == unitInfos2[1].BaseTenExponent)
        {
            //Having the same BaseTenExponent values means that the given operation can be performed right away.
            return unitInfos2;
        }

        int[] bigSmallI = 
        (
            unitInfos2[0].BaseTenExponent > unitInfos2[1].BaseTenExponent ?
            new int[] { 0, 1 } : new int[] { 1, 0 }
        );

        //Only the variable with the bigger value is modified. For example: 5*10^5 & 3*10^3 is converted
        //into 500*10^3 & 3*10^3 in order to allow the addition 500 + 3. 
        UnitInfo big2 = AdaptBiggerAdditionOperand(unitInfos2, bigSmallI, operation);
        if (big2.Error.Type != ErrorTypes.None)
        {
            return TooBigGapAddition(unitInfos2, bigSmallI, operation);
        }

        unitInfos2[bigSmallI[0]].Value = big2.Value;
        unitInfos2[bigSmallI[0]].BaseTenExponent = unitInfos2[bigSmallI[1]].BaseTenExponent;

        return unitInfos2;
    }

    //When adding/subtracting two numbers whose gap is bigger than the maximum double range, there
    //is no need to perform any operation (i.e., no change will be observed because of being outside
    //the maximum supported precision). This method takes care of these cases and returns the expected
    //output (i.e., biggest value).
    static UnitInfo[] TooBigGapAddition(UnitInfo[] unitInfos2, int[] bigSmallI, Operations operation)
    {
        UnitInfo[] outInfos = new UnitInfo[] 
        {
            //First operand (i.e., one whose information defines the operation) together with the
            //numeric information (i.e., just Value and BaseTenExponent because both are normalised)
            //which is associated with the biggest one.
            new UnitInfo(unitInfos2[0])
            {{
                Value = unitInfos2[bigSmallI[0]].Value;
                BaseTenExponent = unitInfos2[bigSmallI[0]].BaseTenExponent;
            }}
        };

        if (operation == Operations.Subtraction && bigSmallI[0] == 1)
        {
            outInfos[0].Value = -1.0 * outInfos[0].Value;
        }

        if (outInfos[0].Unit == Units.Unitless)
        {
            outInfos[0].Unit = unitInfos2[bigSmallI[1]].Unit;
        }

        return outInfos;
    }

    static UnitInfo AdaptBiggerAdditionOperand(UnitInfo[] unitInfos2, Integer[] bigSmallI, Operations operation)
    {
        int gapExponent = unitInfos2[bigSmallI[0]].BaseTenExponent - unitInfos2[bigSmallI[1]].BaseTenExponent;
        if (gapExponent >= 27)
        {
            //The difference between both inputs is bigger than (or, at least, very close to) the maximum double value/precision;
            //what makes this situation calculation unworthy and the first operand to be returned as the result.
            //Note that the error below these lines is just an easy way to tell the calling function about this eventuality.
            return new UnitInfo(unitInfos2[0]) 
            {{ 
                Error = new ErrorInfo(ErrorTypes.InvalidOperation); 
            }};
        }

        //PerformManagedOperationValues is used to make sure that the resulting numeric information is stored
        //in Value (if possible).
        UnitInfo big2 = PerformManagedOperationValues
        (
            RaiseToIntegerExponent(10.0, gapExponent), unitInfos2[bigSmallI[0]].Value, 
            Operations.Multiplication                
        );

        boolean isWrong = 
        (
            big2.Error.Type != ErrorTypes.None || big2.BaseTenExponent != 0 ?
            
            //The value of the bigger input times 10^(gap between BaseTenExponent of inputs) is too big. 
            isWrong = true :
            
            //Overflow-check very unlikely to trigger an error. In fact, with properly normalised variables,
            //triggering an error would be plainly impossible.               
            AreAdditionFinalValuesWrong
            (
                unitInfos2[0].Value, unitInfos2[1].Value, operation
            )
        );

        if (isWrong)
        {
        	UnitInfo temp = new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }};
            
            temp.Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            
        }
        
        
        return temp;
        
        
        return
        (
            isWrong ?
            //This error is just an easy way to let the calling function know about the fact that no
            //calculation has been performed (too big gap). This isn't a properly-speaking error and
            //that's why it will not be notified to the user.
            new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }} :
            //Returning the new big value. For example: with 5*10^4 & 3*10^2, 500 would be returned.
            new UnitInfo(unitInfos2[bigSmallI[0]])
            {{
                Value = big2.Value;
            }}
        )
    }

    static boolean AreAdditionFinalValuesWrong(double val1, double val2, Operations operation)
    {
        boolean isWrong = false;

        try
        {
            val1 = val1 + val2 *
            (
                operation == Operations.Addition ? 1 : -1
            );
        }
        catch { isWrong = true; }

        return isWrong;
    }

    static UnitInfo PerformManagedOperationMultiplication(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationNormalisedValues
        (
            firstInfo, new UnitInfo[] 
            { 
                NormaliseUnitInfo(firstInfo),
                NormaliseUnitInfo(secondInfo) 
            },
            operation
        );
    }

    public static UnitInfo RaiseToIntegerExponent(double baseValue, int exponent)
    {
        return RaiseToIntegerExponent(new UnitInfo(baseValue), exponent);
    }

    static UnitInfo RaiseToIntegerExponent(UnitInfo baseInfo, int exponent)
    {
        if (exponent <= 1 && exponent >= 0)
        {
            baseInfo.Value = (exponent == 0 ? 1.0 : baseInfo.Value);
            return baseInfo;
        }

        UnitInfo outInfo = new UnitInfo(baseInfo);

        for (int i = 1; i < Math.Abs(exponent); i++)
        {
            outInfo = PerformManagedOperationValues
            (
                outInfo, baseInfo, Operations.Multiplication
            );
            if (outInfo.Error.Type != ErrorTypes.None) return outInfo;
        }

        return
        (
            exponent < 0 ?
            PerformManagedOperationValues(new UnitInfo(1.0), outInfo, Operations.Division) :
            outInfo
        );
    }

    static UnitInfo PerformManagedOperationNormalisedValues(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        outInfo =
        (
            normalisedInfos.Length == 1 ?
            //There is just one operand when the difference between both of them is too big.
            outInfo = normalisedInfos[0] :
            PerformManagedOperationTwoOperands(outInfo, normalisedInfos, operation)
        );

        return outInfo;
    }

    static UnitInfo PerformManagedOperationTwoOperands(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        UnitInfo outInfoNormalised = PerformManagedOperationValues
        (
            normalisedInfos[0], normalisedInfos[1], operation
        );

        if (outInfo.Error.Type != ErrorTypes.None)
        {
            return new UnitInfo(outInfo)
            {
                Error = new ErrorInfo(ErrorTypes.NumericError)
            };
        }

        outInfo.BaseTenExponent = outInfoNormalised.BaseTenExponent;
        outInfo.Value = outInfoNormalised.Value;
        //Normalised means no prefixes.
        outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage); 

        return outInfo;
    }

    static UnitInfo PerformManagedOperationValues(double firstValue, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            new UnitInfo(firstValue), new UnitInfo(secondValue), operation
        );
    }

    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            firstInfo, new UnitInfo(secondValue), operation
        );
    }

    //This method might be used to perform full operations (not just being the last calculation step) instead
    //of the default one (PerformManagedOperationUnits) for simple cases. That is: ones not dealing with the
    //complex numeric reality (Value, Prefix and BaseTenExponent) which makes a pre-analysis required.
    //Note that, unlikely what happens with PerformMangedOperationUnits, the outputs of this method aren't
    //normalised (= primarily stored under Value), what is useful in certain contexts.
    //NOTE: this function assumes that both inputs are normalised, what means that no prefix information is expected.
    //It might also be used with non-normalised inputs, but their prefix information would be plainly ignored.
    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        if (firstInfo.Value == 0.0 || secondInfo.Value == 0.0)
        {
            if (operation == Operations.Multiplication || operation == Operations.Division)
            {
                //Dividing by zero scenarios are taken into account somewhere else.
                return new UnitInfo(firstInfo) { Value = 0.0 };
            }
        }

        UnitInfo outInfo = new UnitInfo(firstInfo);
        UnitInfo firstInfo0 = new UnitInfo(firstInfo);
        UnitInfo secondInfo0 = new UnitInfo(secondInfo);

        boolean isWrong = false;
        try
        {
            if (operation == Operations.Addition)
            {
                outInfo.Value += secondInfo0.Value;
            }
            else if (operation == Operations.Subtraction)
            {
                outInfo.Value -= secondInfo.Value;
            }
            else
            {
                //The reason for checking whether BaseTenExponent is inside/outside the int range before performing 
                //the operation (rather than going ahead and eventually catching the resulting exception) isn't just
                //being quicker, but also the only option in many situations. Note that an addition/subtraction between
                //two int variables whose result is outside the int range might not trigger an exception (+ random 
                //negative value as output).
                if (VaryBaseTenExponent(outInfo, secondInfo0.BaseTenExponent, operation == Operations.Division).Error.Type != ErrorTypes.None)
                {
                    return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
                }

                if (operation == Operations.Multiplication)
                {
                    outInfo.Value *= secondInfo.Value;
                    outInfo.BaseTenExponent += secondInfo.BaseTenExponent;
                }
                else if (operation == Operations.Division)
                {
                    if (secondInfo.Value == 0.0)
                    {
                        return
                        (
                            new UnitInfo(outInfo) 
                            { 
                                Error = new ErrorInfo(ErrorTypes.NumericError) 
                            }
                        );
                    }
                    outInfo.Value /= secondInfo.Value;
                    outInfo.BaseTenExponent -= secondInfo.BaseTenExponent;
                }
            }
        }
        catch { isWrong = true; }

        return
        (
            //An error might not be triggered despite of dealing with numbers outside double precision.
            //For example: 0.00000000000000000001m * 0.0000000000000000000001m can output 0.0 without triggering an error. 
            isWrong || ((operation == Operations.Multiplication || operation == Operations.Division) && outInfo.Value == 0.0.0) ?
            OperationValuesManageError(firstInfo0, secondInfo0, operation) : outInfo
        );
    }

    static UnitInfo OperationValuesManageError(UnitInfo outInfo, UnitInfo secondInfo, Operations operation)
    {
        if (operation != Operations.Multiplication && operation != Operations.Division)
        {
            //This condition should never be true on account of the fact that the pre-modifications performed before
            //adding/subtracting should avoid erroneous situations.
            return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
        }

        UnitInfo secondInfo2 = ConvertValueToBaseTen(secondInfo.Value);
        outInfo = VaryBaseTenExponent(outInfo, secondInfo2.BaseTenExponent, operation == Operations.Division);
        if (Math.Abs(secondInfo2.Value) == 1.0 || outInfo.Error.Type != ErrorTypes.None) return outInfo;
        
        try
        {
            outInfo = PerformManagedOperationUnits
            (
                outInfo, secondInfo2.Value, operation
            );
        }
        catch
        {
            //Very unlikely scenario on account of the fact that Math.Abs(secondInfo2.Value)
            //lies within the 0.1-10.0 range.
            outInfo = OperationValuesManageError
            (
                new UnitInfo(outInfo)
                {
                    Value = secondInfo2.Value,
                    BaseTenExponent = 0
                },
                new UnitInfo()
                {
                    Value = outInfo.Value,
                    BaseTenExponent = outInfo.BaseTenExponent
                },
                operation
            );
        }

        return outInfo;
    }

    static UnitInfo ConvertValueToBaseTen(double value)
    {
        value = Math.Abs(value);
        return FromValueToBaseTenExponent
        (
             new UnitInfo(value), Math.Abs(value), false
        );
    }

    static UnitInfo ConvertBaseTenToValue(UnitInfo unitInfo)
    {
        if (unitInfo.BaseTenExponent == 0) return unitInfo;

        UnitInfo outInfo = new UnitInfo(unitInfo);
        boolean decrease = unitInfo.BaseTenExponent > 0;
        int sign = Math.Sign(outInfo.Value);
        double absValue = Math.Abs(outInfo.Value);

        while (outInfo.BaseTenExponent != 0.0)
        {
            if (decrease)
            {
                if (absValue >= MaxValueDec / 10.0) break;
                absValue *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }
            else
            {
                if (absValue <= MinValueDec * 10.0) break;
                absValue /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
        }

        outInfo.Value = sign * absValue;

        return outInfo;
    }

    static UnitInfo NormaliseUnitInfo(UnitInfo unitInfo)
    {
        if (unitInfo.Value == 0 && unitInfo.Prefix.Factor == 1.0)
        {
            return unitInfo;
        }
        UnitInfo outInfo = new UnitInfo(unitInfo);

        if (outInfo.Prefix.Factor != 1)
        {
            outInfo = FromValueToBaseTenExponent
            (
                outInfo, outInfo.Prefix.Factor, true
            );
            outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage);
        }
        if (outInfo.Value == 0.0) return outInfo;

        outInfo = FromValueToBaseTenExponent
        (
            outInfo, outInfo.Value, false
        );

        return outInfo;
    }

    static UnitInfo FromValueToBaseTenExponent(UnitInfo outInfo, double value, boolean isPrefix)
    {
        if (value == 0.0) return outInfo;

        double valueAbs = Math.Abs(value);
        boolean decrease = (valueAbs > 1.0);
        if (!isPrefix)
        {
            outInfo.Value = outInfo.Value / valueAbs;
        }

        while (valueAbs != 1.0)
        {
            if ((valueAbs < 10.0 && valueAbs > 1.0) || (valueAbs > 0.1.0 && valueAbs < 1.0))
            {
                if (!isPrefix) outInfo.Value = value;
                else
                {
                    outInfo = PerformManagedOperationValues
                    (
                        outInfo, value, Operations.Multiplication
                    );
                }

                return outInfo;
            }

            if (decrease)
            {
                value /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
            else
            {
                value *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }

            valueAbs = Math.Abs(value);
        }

        return outInfo;
    }

    //Method used to vary BaseTenExponent without provoking unhandled exceptions (i.e., bigger than Integer.MAX_VALUE).
    static UnitInfo VaryBaseTenExponent(UnitInfo info, int baseTenIncrease, boolean isDivision = false)
    {
        long val1 = info.BaseTenExponent;
        long val2 = baseTenIncrease;

        if (isDivision)
        {
            //Converting a negative value into positive might provoke an overflow error for the int type
            //(e.g., Math.Abs(Integer.MAIN_VALUE)). Converting both variables to long is a quick and effective
            //way to avoid this problem.
            val2 *= -1;
        }

        return
        (
             ((val2 > 0 && val1 > Integer.MAX_VALUE - val2) || (val2 < 0 && val1 < Integer.MAIN_VALUE - val2)) ?
            new UnitInfo(info, ErrorTypes.NumericError) : new UnitInfo(info){{ BaseTenExponent = (int)(val1 + val2); }}
        );
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 2 2017-05-27 20:05:18.770
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 0 2017-05-27 20:05:18.770
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.core 4 4 2017-05-27 20:05:24.619
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
public class OperationsManaged
{
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, double second, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            firstInfo, new UnitInfo(second), operation
        );
    }

    public static UnitInfo PerformManagedOperationUnits(double first, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            new UnitInfo(first), secondInfo, operation
        );
    }

    //This method should always be used when dealing with random UnitInfo variables because it accounts for all the
    //possible scenarios. On the other hand, with simple operations (e.g., random UnitInfo & numeric type) it might
    //be better to use PerformManagedOperationValues. 
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        ErrorTypes errorType = InternalMethods.GetOperationError
        (
            firstInfo, secondInfo, operation
        );
        if (errorType != ErrorTypes.None)
        {
            return new UnitInfo(firstInfo) 
            {{
                Error = new ErrorInfo(errorType); 
            }};
        }

        return
        (
            operation == Operations.Addition || operation == Operations.Subtraction ?
            PerformManagedOperationAddition(firstInfo, secondInfo, operation) :
            PerformManagedOperationMultiplication(firstInfo, secondInfo, operation)
        );
    }

    static UnitInfo PerformManagedOperationAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {   
        //After being normalised, the operands might require further modifications.
        UnitInfo[] normalised = GetOperandsAddition(firstInfo, secondInfo, operation);

        return PerformManagedOperationNormalisedValues
        (
            firstInfo, normalised, operation
        );
    }

    static UnitInfo[] GetOperandsAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        UnitInfo[] operands2 = new UnitInfo[] 
        {
            new UnitInfo(firstInfo), new UnitInfo(secondInfo)
        };

        if (operands2[0].BaseTenExponent != operands2[1].BaseTenExponent || operands2[0].Prefix.Factor != operands2[1].Prefix.Factor)
        {
            //The addition/subtraction might not be performed right away even with normalised values.
            //For example: 5 and 6 from 5*10^2 and 6*10^7 cannot be added right away.
            operands2 = AdaptNormalisedValuesForAddition
            (
                new UnitInfo[] 
                { 
                    NormaliseUnitInfo(operands2[0]), 
                    NormaliseUnitInfo(operands2[1])
                },
                operation
            );
        }

        return operands2;
    }
    
    static UnitInfo[] AdaptNormalisedValuesForAddition(UnitInfo[] unitInfos2, Operations operation)
    {
        if (unitInfos2[0].BaseTenExponent == unitInfos2[1].BaseTenExponent)
        {
            //Having the same BaseTenExponent values means that the given operation can be performed right away.
            return unitInfos2;
        }

        int[] bigSmallI = 
        (
            unitInfos2[0].BaseTenExponent > unitInfos2[1].BaseTenExponent ?
            new int[] { 0, 1 } : new int[] { 1, 0 }
        );

        //Only the variable with the bigger value is modified. For example: 5*10^5 & 3*10^3 is converted
        //into 500*10^3 & 3*10^3 in order to allow the addition 500 + 3. 
        UnitInfo big2 = AdaptBiggerAdditionOperand(unitInfos2, bigSmallI, operation);
        if (big2.Error.Type != ErrorTypes.None)
        {
            return TooBigGapAddition(unitInfos2, bigSmallI, operation);
        }

        unitInfos2[bigSmallI[0]].Value = big2.Value;
        unitInfos2[bigSmallI[0]].BaseTenExponent = unitInfos2[bigSmallI[1]].BaseTenExponent;

        return unitInfos2;
    }

    //When adding/subtracting two numbers whose gap is bigger than the maximum double range, there
    //is no need to perform any operation (i.e., no change will be observed because of being outside
    //the maximum supported precision). This method takes care of these cases and returns the expected
    //output (i.e., biggest value).
    static UnitInfo[] TooBigGapAddition(UnitInfo[] unitInfos2, int[] bigSmallI, Operations operation)
    {
        UnitInfo[] outInfos = new UnitInfo[] 
        {
            //First operand (i.e., one whose information defines the operation) together with the
            //numeric information (i.e., just Value and BaseTenExponent because both are normalised)
            //which is associated with the biggest one.
            new UnitInfo(unitInfos2[0])
            {{
                Value = unitInfos2[bigSmallI[0]].Value;
                BaseTenExponent = unitInfos2[bigSmallI[0]].BaseTenExponent;
            }}
        };

        if (operation == Operations.Subtraction && bigSmallI[0] == 1)
        {
            outInfos[0].Value = -1.0 * outInfos[0].Value;
        }

        if (outInfos[0].Unit == Units.Unitless)
        {
            outInfos[0].Unit = unitInfos2[bigSmallI[1]].Unit;
        }

        return outInfos;
    }

    static UnitInfo AdaptBiggerAdditionOperand(UnitInfo[] unitInfos2, Integer[] bigSmallI, Operations operation)
    {
        int gapExponent = unitInfos2[bigSmallI[0]].BaseTenExponent - unitInfos2[bigSmallI[1]].BaseTenExponent;
        if (gapExponent >= 27)
        {
            //The difference between both inputs is bigger than (or, at least, very close to) the maximum double value/precision;
            //what makes this situation calculation unworthy and the first operand to be returned as the result.
            //Note that the error below these lines is just an easy way to tell the calling function about this eventuality.
            return new UnitInfo(unitInfos2[0]) 
            {{ 
                Error = new ErrorInfo(ErrorTypes.InvalidOperation); 
            }};
        }

        //PerformManagedOperationValues is used to make sure that the resulting numeric information is stored
        //in Value (if possible).
        UnitInfo big2 = PerformManagedOperationValues
        (
            RaiseToIntegerExponent(10.0, gapExponent), unitInfos2[bigSmallI[0]].Value, 
            Operations.Multiplication                
        );

        boolean isWrong = 
        (
            big2.Error.Type != ErrorTypes.None || big2.BaseTenExponent != 0 ?
            
            //The value of the bigger input times 10^(gap between BaseTenExponent of inputs) is too big. 
            isWrong = true :
            
            //Overflow-check very unlikely to trigger an error. In fact, with properly normalised variables,
            //triggering an error would be plainly impossible.               
            AreAdditionFinalValuesWrong
            (
                unitInfos2[0].Value, unitInfos2[1].Value, operation
            )
        );

        UnitInfo temp = null;
        if (isWrong)
        {
        	UnitInfo temp = new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }};
            
            temp.Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            
        }
        
        
        return temp;
        
        
        return
        (
            isWrong ?
            //This error is just an easy way to let the calling function know about the fact that no
            //calculation has been performed (too big gap). This isn't a properly-speaking error and
            //that's why it will not be notified to the user.
            new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }} :
            //Returning the new big value. For example: with 5*10^4 & 3*10^2, 500 would be returned.
            new UnitInfo(unitInfos2[bigSmallI[0]])
            {{
                Value = big2.Value;
            }}
        )
    }

    static boolean AreAdditionFinalValuesWrong(double val1, double val2, Operations operation)
    {
        boolean isWrong = false;

        try
        {
            val1 = val1 + val2 *
            (
                operation == Operations.Addition ? 1 : -1
            );
        }
        catch { isWrong = true; }

        return isWrong;
    }

    static UnitInfo PerformManagedOperationMultiplication(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationNormalisedValues
        (
            firstInfo, new UnitInfo[] 
            { 
                NormaliseUnitInfo(firstInfo),
                NormaliseUnitInfo(secondInfo) 
            },
            operation
        );
    }

    public static UnitInfo RaiseToIntegerExponent(double baseValue, int exponent)
    {
        return RaiseToIntegerExponent(new UnitInfo(baseValue), exponent);
    }

    static UnitInfo RaiseToIntegerExponent(UnitInfo baseInfo, int exponent)
    {
        if (exponent <= 1 && exponent >= 0)
        {
            baseInfo.Value = (exponent == 0 ? 1.0 : baseInfo.Value);
            return baseInfo;
        }

        UnitInfo outInfo = new UnitInfo(baseInfo);

        for (int i = 1; i < Math.Abs(exponent); i++)
        {
            outInfo = PerformManagedOperationValues
            (
                outInfo, baseInfo, Operations.Multiplication
            );
            if (outInfo.Error.Type != ErrorTypes.None) return outInfo;
        }

        return
        (
            exponent < 0 ?
            PerformManagedOperationValues(new UnitInfo(1.0), outInfo, Operations.Division) :
            outInfo
        );
    }

    static UnitInfo PerformManagedOperationNormalisedValues(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        outInfo =
        (
            normalisedInfos.Length == 1 ?
            //There is just one operand when the difference between both of them is too big.
            outInfo = normalisedInfos[0] :
            PerformManagedOperationTwoOperands(outInfo, normalisedInfos, operation)
        );

        return outInfo;
    }

    static UnitInfo PerformManagedOperationTwoOperands(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        UnitInfo outInfoNormalised = PerformManagedOperationValues
        (
            normalisedInfos[0], normalisedInfos[1], operation
        );

        if (outInfo.Error.Type != ErrorTypes.None)
        {
            return new UnitInfo(outInfo)
            {
                Error = new ErrorInfo(ErrorTypes.NumericError)
            };
        }

        outInfo.BaseTenExponent = outInfoNormalised.BaseTenExponent;
        outInfo.Value = outInfoNormalised.Value;
        //Normalised means no prefixes.
        outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage); 

        return outInfo;
    }

    static UnitInfo PerformManagedOperationValues(double firstValue, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            new UnitInfo(firstValue), new UnitInfo(secondValue), operation
        );
    }

    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            firstInfo, new UnitInfo(secondValue), operation
        );
    }

    //This method might be used to perform full operations (not just being the last calculation step) instead
    //of the default one (PerformManagedOperationUnits) for simple cases. That is: ones not dealing with the
    //complex numeric reality (Value, Prefix and BaseTenExponent) which makes a pre-analysis required.
    //Note that, unlikely what happens with PerformMangedOperationUnits, the outputs of this method aren't
    //normalised (= primarily stored under Value), what is useful in certain contexts.
    //NOTE: this function assumes that both inputs are normalised, what means that no prefix information is expected.
    //It might also be used with non-normalised inputs, but their prefix information would be plainly ignored.
    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        if (firstInfo.Value == 0.0 || secondInfo.Value == 0.0)
        {
            if (operation == Operations.Multiplication || operation == Operations.Division)
            {
                //Dividing by zero scenarios are taken into account somewhere else.
                return new UnitInfo(firstInfo) { Value = 0.0 };
            }
        }

        UnitInfo outInfo = new UnitInfo(firstInfo);
        UnitInfo firstInfo0 = new UnitInfo(firstInfo);
        UnitInfo secondInfo0 = new UnitInfo(secondInfo);

        boolean isWrong = false;
        try
        {
            if (operation == Operations.Addition)
            {
                outInfo.Value += secondInfo0.Value;
            }
            else if (operation == Operations.Subtraction)
            {
                outInfo.Value -= secondInfo.Value;
            }
            else
            {
                //The reason for checking whether BaseTenExponent is inside/outside the int range before performing 
                //the operation (rather than going ahead and eventually catching the resulting exception) isn't just
                //being quicker, but also the only option in many situations. Note that an addition/subtraction between
                //two int variables whose result is outside the int range might not trigger an exception (+ random 
                //negative value as output).
                if (VaryBaseTenExponent(outInfo, secondInfo0.BaseTenExponent, operation == Operations.Division).Error.Type != ErrorTypes.None)
                {
                    return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
                }

                if (operation == Operations.Multiplication)
                {
                    outInfo.Value *= secondInfo.Value;
                    outInfo.BaseTenExponent += secondInfo.BaseTenExponent;
                }
                else if (operation == Operations.Division)
                {
                    if (secondInfo.Value == 0.0)
                    {
                        return
                        (
                            new UnitInfo(outInfo) 
                            { 
                                Error = new ErrorInfo(ErrorTypes.NumericError) 
                            }
                        );
                    }
                    outInfo.Value /= secondInfo.Value;
                    outInfo.BaseTenExponent -= secondInfo.BaseTenExponent;
                }
            }
        }
        catch { isWrong = true; }

        return
        (
            //An error might not be triggered despite of dealing with numbers outside double precision.
            //For example: 0.00000000000000000001m * 0.0000000000000000000001m can output 0.0 without triggering an error. 
            isWrong || ((operation == Operations.Multiplication || operation == Operations.Division) && outInfo.Value == 0.0.0) ?
            OperationValuesManageError(firstInfo0, secondInfo0, operation) : outInfo
        );
    }

    static UnitInfo OperationValuesManageError(UnitInfo outInfo, UnitInfo secondInfo, Operations operation)
    {
        if (operation != Operations.Multiplication && operation != Operations.Division)
        {
            //This condition should never be true on account of the fact that the pre-modifications performed before
            //adding/subtracting should avoid erroneous situations.
            return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
        }

        UnitInfo secondInfo2 = ConvertValueToBaseTen(secondInfo.Value);
        outInfo = VaryBaseTenExponent(outInfo, secondInfo2.BaseTenExponent, operation == Operations.Division);
        if (Math.Abs(secondInfo2.Value) == 1.0 || outInfo.Error.Type != ErrorTypes.None) return outInfo;
        
        try
        {
            outInfo = PerformManagedOperationUnits
            (
                outInfo, secondInfo2.Value, operation
            );
        }
        catch
        {
            //Very unlikely scenario on account of the fact that Math.Abs(secondInfo2.Value)
            //lies within the 0.1-10.0 range.
            outInfo = OperationValuesManageError
            (
                new UnitInfo(outInfo)
                {
                    Value = secondInfo2.Value,
                    BaseTenExponent = 0
                },
                new UnitInfo()
                {
                    Value = outInfo.Value,
                    BaseTenExponent = outInfo.BaseTenExponent
                },
                operation
            );
        }

        return outInfo;
    }

    static UnitInfo ConvertValueToBaseTen(double value)
    {
        value = Math.Abs(value);
        return FromValueToBaseTenExponent
        (
             new UnitInfo(value), Math.Abs(value), false
        );
    }

    static UnitInfo ConvertBaseTenToValue(UnitInfo unitInfo)
    {
        if (unitInfo.BaseTenExponent == 0) return unitInfo;

        UnitInfo outInfo = new UnitInfo(unitInfo);
        boolean decrease = unitInfo.BaseTenExponent > 0;
        int sign = Math.Sign(outInfo.Value);
        double absValue = Math.Abs(outInfo.Value);

        while (outInfo.BaseTenExponent != 0.0)
        {
            if (decrease)
            {
                if (absValue >= MaxValueDec / 10.0) break;
                absValue *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }
            else
            {
                if (absValue <= MinValueDec * 10.0) break;
                absValue /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
        }

        outInfo.Value = sign * absValue;

        return outInfo;
    }

    static UnitInfo NormaliseUnitInfo(UnitInfo unitInfo)
    {
        if (unitInfo.Value == 0 && unitInfo.Prefix.Factor == 1.0)
        {
            return unitInfo;
        }
        UnitInfo outInfo = new UnitInfo(unitInfo);

        if (outInfo.Prefix.Factor != 1)
        {
            outInfo = FromValueToBaseTenExponent
            (
                outInfo, outInfo.Prefix.Factor, true
            );
            outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage);
        }
        if (outInfo.Value == 0.0) return outInfo;

        outInfo = FromValueToBaseTenExponent
        (
            outInfo, outInfo.Value, false
        );

        return outInfo;
    }

    static UnitInfo FromValueToBaseTenExponent(UnitInfo outInfo, double value, boolean isPrefix)
    {
        if (value == 0.0) return outInfo;

        double valueAbs = Math.Abs(value);
        boolean decrease = (valueAbs > 1.0);
        if (!isPrefix)
        {
            outInfo.Value = outInfo.Value / valueAbs;
        }

        while (valueAbs != 1.0)
        {
            if ((valueAbs < 10.0 && valueAbs > 1.0) || (valueAbs > 0.1.0 && valueAbs < 1.0))
            {
                if (!isPrefix) outInfo.Value = value;
                else
                {
                    outInfo = PerformManagedOperationValues
                    (
                        outInfo, value, Operations.Multiplication
                    );
                }

                return outInfo;
            }

            if (decrease)
            {
                value /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
            else
            {
                value *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }

            valueAbs = Math.Abs(value);
        }

        return outInfo;
    }

    //Method used to vary BaseTenExponent without provoking unhandled exceptions (i.e., bigger than Integer.MAX_VALUE).
    static UnitInfo VaryBaseTenExponent(UnitInfo info, int baseTenIncrease, boolean isDivision = false)
    {
        long val1 = info.BaseTenExponent;
        long val2 = baseTenIncrease;

        if (isDivision)
        {
            //Converting a negative value into positive might provoke an overflow error for the int type
            //(e.g., Math.Abs(Integer.MAIN_VALUE)). Converting both variables to long is a quick and effective
            //way to avoid this problem.
            val2 *= -1;
        }

        return
        (
             ((val2 > 0 && val1 > Integer.MAX_VALUE - val2) || (val2 < 0 && val1 < Integer.MAIN_VALUE - val2)) ?
            new UnitInfo(info, ErrorTypes.NumericError) : new UnitInfo(info){{ BaseTenExponent = (int)(val1 + val2); }}
        );
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2017-05-27 20:05:24.620
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2017-05-27 20:05:24.621
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2017-05-27 20:05:28.291
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
public class OperationsManaged
{
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, double second, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            firstInfo, new UnitInfo(second), operation
        );
    }

    public static UnitInfo PerformManagedOperationUnits(double first, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            new UnitInfo(first), secondInfo, operation
        );
    }

    //This method should always be used when dealing with random UnitInfo variables because it accounts for all the
    //possible scenarios. On the other hand, with simple operations (e.g., random UnitInfo & numeric type) it might
    //be better to use PerformManagedOperationValues. 
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        ErrorTypes errorType = InternalMethods.GetOperationError
        (
            firstInfo, secondInfo, operation
        );
        if (errorType != ErrorTypes.None)
        {
            return new UnitInfo(firstInfo) 
            {{
                Error = new ErrorInfo(errorType); 
            }};
        }

        return
        (
            operation == Operations.Addition || operation == Operations.Subtraction ?
            PerformManagedOperationAddition(firstInfo, secondInfo, operation) :
            PerformManagedOperationMultiplication(firstInfo, secondInfo, operation)
        );
    }

    static UnitInfo PerformManagedOperationAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {   
        //After being normalised, the operands might require further modifications.
        UnitInfo[] normalised = GetOperandsAddition(firstInfo, secondInfo, operation);

        return PerformManagedOperationNormalisedValues
        (
            firstInfo, normalised, operation
        );
    }

    static UnitInfo[] GetOperandsAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        UnitInfo[] operands2 = new UnitInfo[] 
        {
            new UnitInfo(firstInfo), new UnitInfo(secondInfo)
        };

        if (operands2[0].BaseTenExponent != operands2[1].BaseTenExponent || operands2[0].Prefix.Factor != operands2[1].Prefix.Factor)
        {
            //The addition/subtraction might not be performed right away even with normalised values.
            //For example: 5 and 6 from 5*10^2 and 6*10^7 cannot be added right away.
            operands2 = AdaptNormalisedValuesForAddition
            (
                new UnitInfo[] 
                { 
                    NormaliseUnitInfo(operands2[0]), 
                    NormaliseUnitInfo(operands2[1])
                },
                operation
            );
        }

        return operands2;
    }
    
    static UnitInfo[] AdaptNormalisedValuesForAddition(UnitInfo[] unitInfos2, Operations operation)
    {
        if (unitInfos2[0].BaseTenExponent == unitInfos2[1].BaseTenExponent)
        {
            //Having the same BaseTenExponent values means that the given operation can be performed right away.
            return unitInfos2;
        }

        int[] bigSmallI = 
        (
            unitInfos2[0].BaseTenExponent > unitInfos2[1].BaseTenExponent ?
            new int[] { 0, 1 } : new int[] { 1, 0 }
        );

        //Only the variable with the bigger value is modified. For example: 5*10^5 & 3*10^3 is converted
        //into 500*10^3 & 3*10^3 in order to allow the addition 500 + 3. 
        UnitInfo big2 = AdaptBiggerAdditionOperand(unitInfos2, bigSmallI, operation);
        if (big2.Error.Type != ErrorTypes.None)
        {
            return TooBigGapAddition(unitInfos2, bigSmallI, operation);
        }

        unitInfos2[bigSmallI[0]].Value = big2.Value;
        unitInfos2[bigSmallI[0]].BaseTenExponent = unitInfos2[bigSmallI[1]].BaseTenExponent;

        return unitInfos2;
    }

    //When adding/subtracting two numbers whose gap is bigger than the maximum double range, there
    //is no need to perform any operation (i.e., no change will be observed because of being outside
    //the maximum supported precision). This method takes care of these cases and returns the expected
    //output (i.e., biggest value).
    static UnitInfo[] TooBigGapAddition(UnitInfo[] unitInfos2, int[] bigSmallI, Operations operation)
    {
        UnitInfo[] outInfos = new UnitInfo[] 
        {
            //First operand (i.e., one whose information defines the operation) together with the
            //numeric information (i.e., just Value and BaseTenExponent because both are normalised)
            //which is associated with the biggest one.
            new UnitInfo(unitInfos2[0])
            {{
                Value = unitInfos2[bigSmallI[0]].Value;
                BaseTenExponent = unitInfos2[bigSmallI[0]].BaseTenExponent;
            }}
        };

        if (operation == Operations.Subtraction && bigSmallI[0] == 1)
        {
            outInfos[0].Value = -1.0 * outInfos[0].Value;
        }

        if (outInfos[0].Unit == Units.Unitless)
        {
            outInfos[0].Unit = unitInfos2[bigSmallI[1]].Unit;
        }

        return outInfos;
    }

    static UnitInfo AdaptBiggerAdditionOperand(UnitInfo[] unitInfos2, Integer[] bigSmallI, Operations operation)
    {
        int gapExponent = unitInfos2[bigSmallI[0]].BaseTenExponent - unitInfos2[bigSmallI[1]].BaseTenExponent;
        if (gapExponent >= 27)
        {
            //The difference between both inputs is bigger than (or, at least, very close to) the maximum double value/precision;
            //what makes this situation calculation unworthy and the first operand to be returned as the result.
            //Note that the error below these lines is just an easy way to tell the calling function about this eventuality.
            return new UnitInfo(unitInfos2[0]) 
            {{ 
                Error = new ErrorInfo(ErrorTypes.InvalidOperation); 
            }};
        }

        //PerformManagedOperationValues is used to make sure that the resulting numeric information is stored
        //in Value (if possible).
        UnitInfo big2 = PerformManagedOperationValues
        (
            RaiseToIntegerExponent(10.0, gapExponent), unitInfos2[bigSmallI[0]].Value, 
            Operations.Multiplication                
        );

        boolean isWrong = 
        (
            big2.Error.Type != ErrorTypes.None || big2.BaseTenExponent != 0 ?
            
            //The value of the bigger input times 10^(gap between BaseTenExponent of inputs) is too big. 
            isWrong = true :
            
            //Overflow-check very unlikely to trigger an error. In fact, with properly normalised variables,
            //triggering an error would be plainly impossible.               
            AreAdditionFinalValuesWrong
            (
                unitInfos2[0].Value, unitInfos2[1].Value, operation
            )
        );

        UnitInfo temp = null;
        if (isWrong)
        {
        	UnitInfo temp = new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }};
            
            temp.Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            
        }
        
        
        return temp;
        
        
        return
        (
            isWrong ?
            //This error is just an easy way to let the calling function know about the fact that no
            //calculation has been performed (too big gap). This isn't a properly-speaking error and
            //that's why it will not be notified to the user.
            new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }} :
            //Returning the new big value. For example: with 5*10^4 & 3*10^2, 500 would be returned.
            new UnitInfo(unitInfos2[bigSmallI[0]])
            {{
                Value = big2.Value;
            }}
        )
    }

    static boolean AreAdditionFinalValuesWrong(double val1, double val2, Operations operation)
    {
        boolean isWrong = false;

        try
        {
            val1 = val1 + val2 *
            (
                operation == Operations.Addition ? 1 : -1
            );
        }
        catch { isWrong = true; }

        return isWrong;
    }

    static UnitInfo PerformManagedOperationMultiplication(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationNormalisedValues
        (
            firstInfo, new UnitInfo[] 
            { 
                NormaliseUnitInfo(firstInfo),
                NormaliseUnitInfo(secondInfo) 
            },
            operation
        );
    }

    public static UnitInfo RaiseToIntegerExponent(double baseValue, int exponent)
    {
        return RaiseToIntegerExponent(new UnitInfo(baseValue), exponent);
    }

    static UnitInfo RaiseToIntegerExponent(UnitInfo baseInfo, int exponent)
    {
        if (exponent <= 1 && exponent >= 0)
        {
            baseInfo.Value = (exponent == 0 ? 1.0 : baseInfo.Value);
            return baseInfo;
        }

        UnitInfo outInfo = new UnitInfo(baseInfo);

        for (int i = 1; i < Math.Abs(exponent); i++)
        {
            outInfo = PerformManagedOperationValues
            (
                outInfo, baseInfo, Operations.Multiplication
            );
            if (outInfo.Error.Type != ErrorTypes.None) return outInfo;
        }

        return
        (
            exponent < 0 ?
            PerformManagedOperationValues(new UnitInfo(1.0), outInfo, Operations.Division) :
            outInfo
        );
    }

    static UnitInfo PerformManagedOperationNormalisedValues(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        outInfo =
        (
            normalisedInfos.Length == 1 ?
            //There is just one operand when the difference between both of them is too big.
            outInfo = normalisedInfos[0] :
            PerformManagedOperationTwoOperands(outInfo, normalisedInfos, operation)
        );

        return outInfo;
    }

    static UnitInfo PerformManagedOperationTwoOperands(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        UnitInfo outInfoNormalised = PerformManagedOperationValues
        (
            normalisedInfos[0], normalisedInfos[1], operation
        );

        if (outInfo.Error.Type != ErrorTypes.None)
        {
            return new UnitInfo(outInfo)
            {
                Error = new ErrorInfo(ErrorTypes.NumericError)
            };
        }

        outInfo.BaseTenExponent = outInfoNormalised.BaseTenExponent;
        outInfo.Value = outInfoNormalised.Value;
        //Normalised means no prefixes.
        outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage); 

        return outInfo;
    }

    static UnitInfo PerformManagedOperationValues(double firstValue, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            new UnitInfo(firstValue), new UnitInfo(secondValue), operation
        );
    }

    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            firstInfo, new UnitInfo(secondValue), operation
        );
    }

    //This method might be used to perform full operations (not just being the last calculation step) instead
    //of the default one (PerformManagedOperationUnits) for simple cases. That is: ones not dealing with the
    //complex numeric reality (Value, Prefix and BaseTenExponent) which makes a pre-analysis required.
    //Note that, unlikely what happens with PerformMangedOperationUnits, the outputs of this method aren't
    //normalised (= primarily stored under Value), what is useful in certain contexts.
    //NOTE: this function assumes that both inputs are normalised, what means that no prefix information is expected.
    //It might also be used with non-normalised inputs, but their prefix information would be plainly ignored.
    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        if (firstInfo.Value == 0.0 || secondInfo.Value == 0.0)
        {
            if (operation == Operations.Multiplication || operation == Operations.Division)
            {
                //Dividing by zero scenarios are taken into account somewhere else.
                return new UnitInfo(firstInfo) { Value = 0.0 };
            }
        }

        UnitInfo outInfo = new UnitInfo(firstInfo);
        UnitInfo firstInfo0 = new UnitInfo(firstInfo);
        UnitInfo secondInfo0 = new UnitInfo(secondInfo);

        boolean isWrong = false;
        try
        {
            if (operation == Operations.Addition)
            {
                outInfo.Value += secondInfo0.Value;
            }
            else if (operation == Operations.Subtraction)
            {
                outInfo.Value -= secondInfo.Value;
            }
            else
            {
                //The reason for checking whether BaseTenExponent is inside/outside the int range before performing 
                //the operation (rather than going ahead and eventually catching the resulting exception) isn't just
                //being quicker, but also the only option in many situations. Note that an addition/subtraction between
                //two int variables whose result is outside the int range might not trigger an exception (+ random 
                //negative value as output).
                if (VaryBaseTenExponent(outInfo, secondInfo0.BaseTenExponent, operation == Operations.Division).Error.Type != ErrorTypes.None)
                {
                    return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
                }

                if (operation == Operations.Multiplication)
                {
                    outInfo.Value *= secondInfo.Value;
                    outInfo.BaseTenExponent += secondInfo.BaseTenExponent;
                }
                else if (operation == Operations.Division)
                {
                    if (secondInfo.Value == 0.0)
                    {
                        return
                        (
                            new UnitInfo(outInfo) 
                            { 
                                Error = new ErrorInfo(ErrorTypes.NumericError) 
                            }
                        );
                    }
                    outInfo.Value /= secondInfo.Value;
                    outInfo.BaseTenExponent -= secondInfo.BaseTenExponent;
                }
            }
        }
        catch { isWrong = true; }

        return
        (
            //An error might not be triggered despite of dealing with numbers outside double precision.
            //For example: 0.00000000000000000001m * 0.0000000000000000000001m can output 0.0 without triggering an error. 
            isWrong || ((operation == Operations.Multiplication || operation == Operations.Division) && outInfo.Value == 0.0.0) ?
            OperationValuesManageError(firstInfo0, secondInfo0, operation) : outInfo
        );
    }

    static UnitInfo OperationValuesManageError(UnitInfo outInfo, UnitInfo secondInfo, Operations operation)
    {
        if (operation != Operations.Multiplication && operation != Operations.Division)
        {
            //This condition should never be true on account of the fact that the pre-modifications performed before
            //adding/subtracting should avoid erroneous situations.
            return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
        }

        UnitInfo secondInfo2 = ConvertValueToBaseTen(secondInfo.Value);
        outInfo = VaryBaseTenExponent(outInfo, secondInfo2.BaseTenExponent, operation == Operations.Division);
        if (Math.Abs(secondInfo2.Value) == 1.0 || outInfo.Error.Type != ErrorTypes.None) return outInfo;
        
        try
        {
            outInfo = PerformManagedOperationUnits
            (
                outInfo, secondInfo2.Value, operation
            );
        }
        catch
        {
            //Very unlikely scenario on account of the fact that Math.Abs(secondInfo2.Value)
            //lies within the 0.1-10.0 range.
            outInfo = OperationValuesManageError
            (
                new UnitInfo(outInfo)
                {
                    Value = secondInfo2.Value,
                    BaseTenExponent = 0
                },
                new UnitInfo()
                {
                    Value = outInfo.Value,
                    BaseTenExponent = outInfo.BaseTenExponent
                },
                operation
            );
        }

        return outInfo;
    }

    static UnitInfo ConvertValueToBaseTen(double value)
    {
        value = Math.Abs(value);
        return FromValueToBaseTenExponent
        (
             new UnitInfo(value), Math.Abs(value), false
        );
    }

    static UnitInfo ConvertBaseTenToValue(UnitInfo unitInfo)
    {
        if (unitInfo.BaseTenExponent == 0) return unitInfo;

        UnitInfo outInfo = new UnitInfo(unitInfo);
        boolean decrease = unitInfo.BaseTenExponent > 0;
        int sign = Math.Sign(outInfo.Value);
        double absValue = Math.Abs(outInfo.Value);

        while (outInfo.BaseTenExponent != 0.0)
        {
            if (decrease)
            {
                if (absValue >= MaxValueDec / 10.0) break;
                absValue *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }
            else
            {
                if (absValue <= MinValueDec * 10.0) break;
                absValue /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
        }

        outInfo.Value = sign * absValue;

        return outInfo;
    }

    static UnitInfo NormaliseUnitInfo(UnitInfo unitInfo)
    {
        if (unitInfo.Value == 0 && unitInfo.Prefix.Factor == 1.0)
        {
            return unitInfo;
        }
        UnitInfo outInfo = new UnitInfo(unitInfo);

        if (outInfo.Prefix.Factor != 1)
        {
            outInfo = FromValueToBaseTenExponent
            (
                outInfo, outInfo.Prefix.Factor, true
            );
            outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage);
        }
        if (outInfo.Value == 0.0) return outInfo;

        outInfo = FromValueToBaseTenExponent
        (
            outInfo, outInfo.Value, false
        );

        return outInfo;
    }

    static UnitInfo FromValueToBaseTenExponent(UnitInfo outInfo, double value, boolean isPrefix)
    {
        if (value == 0.0) return outInfo;

        double valueAbs = Math.Abs(value);
        boolean decrease = (valueAbs > 1.0);
        if (!isPrefix)
        {
            outInfo.Value = outInfo.Value / valueAbs;
        }

        while (valueAbs != 1.0)
        {
            if ((valueAbs < 10.0 && valueAbs > 1.0) || (valueAbs > 0.1.0 && valueAbs < 1.0))
            {
                if (!isPrefix) outInfo.Value = value;
                else
                {
                    outInfo = PerformManagedOperationValues
                    (
                        outInfo, value, Operations.Multiplication
                    );
                }

                return outInfo;
            }

            if (decrease)
            {
                value /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
            else
            {
                value *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }

            valueAbs = Math.Abs(value);
        }

        return outInfo;
    }

    //Method used to vary BaseTenExponent without provoking unhandled exceptions (i.e., bigger than Integer.MAX_VALUE).
    static UnitInfo VaryBaseTenExponent(UnitInfo info, int baseTenIncrease, boolean isDivision = false)
    {
        long val1 = info.BaseTenExponent;
        long val2 = baseTenIncrease;

        if (isDivision)
        {
            //Converting a negative value into positive might provoke an overflow error for the int type
            //(e.g., Math.Abs(Integer.MAIN_VALUE)). Converting both variables to long is a quick and effective
            //way to avoid this problem.
            val2 *= -1;
        }

        return
        (
             ((val2 > 0 && val1 > Integer.MAX_VALUE - val2) || (val2 < 0 && val1 < Integer.MAIN_VALUE - val2)) ?
            new UnitInfo(info, ErrorTypes.NumericError) : new UnitInfo(info){{ BaseTenExponent = (int)(val1 + val2); }}
        );
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 2 2017-05-27 20:05:28.292
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 0 2017-05-27 20:05:28.292
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.core 4 4 2017-05-27 20:05:29.150
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
public class OperationsManaged
{
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, double second, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            firstInfo, new UnitInfo(second), operation
        );
    }

    public static UnitInfo PerformManagedOperationUnits(double first, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            new UnitInfo(first), secondInfo, operation
        );
    }

    //This method should always be used when dealing with random UnitInfo variables because it accounts for all the
    //possible scenarios. On the other hand, with simple operations (e.g., random UnitInfo & numeric type) it might
    //be better to use PerformManagedOperationValues. 
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        ErrorTypes errorType = InternalMethods.GetOperationError
        (
            firstInfo, secondInfo, operation
        );
        if (errorType != ErrorTypes.None)
        {
            return new UnitInfo(firstInfo) 
            {{
                Error = new ErrorInfo(errorType); 
            }};
        }

        return
        (
            operation == Operations.Addition || operation == Operations.Subtraction ?
            PerformManagedOperationAddition(firstInfo, secondInfo, operation) :
            PerformManagedOperationMultiplication(firstInfo, secondInfo, operation)
        );
    }

    static UnitInfo PerformManagedOperationAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {   
        //After being normalised, the operands might require further modifications.
        UnitInfo[] normalised = GetOperandsAddition(firstInfo, secondInfo, operation);

        return PerformManagedOperationNormalisedValues
        (
            firstInfo, normalised, operation
        );
    }

    static UnitInfo[] GetOperandsAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        UnitInfo[] operands2 = new UnitInfo[] 
        {
            new UnitInfo(firstInfo), new UnitInfo(secondInfo)
        };

        if (operands2[0].BaseTenExponent != operands2[1].BaseTenExponent || operands2[0].Prefix.Factor != operands2[1].Prefix.Factor)
        {
            //The addition/subtraction might not be performed right away even with normalised values.
            //For example: 5 and 6 from 5*10^2 and 6*10^7 cannot be added right away.
            operands2 = AdaptNormalisedValuesForAddition
            (
                new UnitInfo[] 
                { 
                    NormaliseUnitInfo(operands2[0]), 
                    NormaliseUnitInfo(operands2[1])
                },
                operation
            );
        }

        return operands2;
    }
    
    static UnitInfo[] AdaptNormalisedValuesForAddition(UnitInfo[] unitInfos2, Operations operation)
    {
        if (unitInfos2[0].BaseTenExponent == unitInfos2[1].BaseTenExponent)
        {
            //Having the same BaseTenExponent values means that the given operation can be performed right away.
            return unitInfos2;
        }

        int[] bigSmallI = 
        (
            unitInfos2[0].BaseTenExponent > unitInfos2[1].BaseTenExponent ?
            new int[] { 0, 1 } : new int[] { 1, 0 }
        );

        //Only the variable with the bigger value is modified. For example: 5*10^5 & 3*10^3 is converted
        //into 500*10^3 & 3*10^3 in order to allow the addition 500 + 3. 
        UnitInfo big2 = AdaptBiggerAdditionOperand(unitInfos2, bigSmallI, operation);
        if (big2.Error.Type != ErrorTypes.None)
        {
            return TooBigGapAddition(unitInfos2, bigSmallI, operation);
        }

        unitInfos2[bigSmallI[0]].Value = big2.Value;
        unitInfos2[bigSmallI[0]].BaseTenExponent = unitInfos2[bigSmallI[1]].BaseTenExponent;

        return unitInfos2;
    }

    //When adding/subtracting two numbers whose gap is bigger than the maximum double range, there
    //is no need to perform any operation (i.e., no change will be observed because of being outside
    //the maximum supported precision). This method takes care of these cases and returns the expected
    //output (i.e., biggest value).
    static UnitInfo[] TooBigGapAddition(UnitInfo[] unitInfos2, int[] bigSmallI, Operations operation)
    {
        UnitInfo[] outInfos = new UnitInfo[] 
        {
            //First operand (i.e., one whose information defines the operation) together with the
            //numeric information (i.e., just Value and BaseTenExponent because both are normalised)
            //which is associated with the biggest one.
            new UnitInfo(unitInfos2[0])
            {{
                Value = unitInfos2[bigSmallI[0]].Value;
                BaseTenExponent = unitInfos2[bigSmallI[0]].BaseTenExponent;
            }}
        };

        if (operation == Operations.Subtraction && bigSmallI[0] == 1)
        {
            outInfos[0].Value = -1.0 * outInfos[0].Value;
        }

        if (outInfos[0].Unit == Units.Unitless)
        {
            outInfos[0].Unit = unitInfos2[bigSmallI[1]].Unit;
        }

        return outInfos;
    }

    static UnitInfo AdaptBiggerAdditionOperand(UnitInfo[] unitInfos2, Integer[] bigSmallI, Operations operation)
    {
        int gapExponent = unitInfos2[bigSmallI[0]].BaseTenExponent - unitInfos2[bigSmallI[1]].BaseTenExponent;
        if (gapExponent >= 27)
        {
            //The difference between both inputs is bigger than (or, at least, very close to) the maximum double value/precision;
            //what makes this situation calculation unworthy and the first operand to be returned as the result.
            //Note that the error below these lines is just an easy way to tell the calling function about this eventuality.
            return new UnitInfo(unitInfos2[0]) 
            {{ 
                Error = new ErrorInfo(ErrorTypes.InvalidOperation); 
            }};
        }

        //PerformManagedOperationValues is used to make sure that the resulting numeric information is stored
        //in Value (if possible).
        UnitInfo big2 = PerformManagedOperationValues
        (
            RaiseToIntegerExponent(10.0, gapExponent), unitInfos2[bigSmallI[0]].Value, 
            Operations.Multiplication                
        );

        boolean isWrong = 
        (
            big2.Error.Type != ErrorTypes.None || big2.BaseTenExponent != 0 ?
            
            //The value of the bigger input times 10^(gap between BaseTenExponent of inputs) is too big. 
            isWrong = true :
            
            //Overflow-check very unlikely to trigger an error. In fact, with properly normalised variables,
            //triggering an error would be plainly impossible.               
            AreAdditionFinalValuesWrong
            (
                unitInfos2[0].Value, unitInfos2[1].Value, operation
            )
        );

        UnitInfo temp = null;
        if (isWrong)
        {
        	temp = new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }};
            
            temp.Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            
        }
        
        
        return temp;
        
        
        return
        (
            isWrong ?
            //This error is just an easy way to let the calling function know about the fact that no
            //calculation has been performed (too big gap). This isn't a properly-speaking error and
            //that's why it will not be notified to the user.
            new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }} :
            //Returning the new big value. For example: with 5*10^4 & 3*10^2, 500 would be returned.
            new UnitInfo(unitInfos2[bigSmallI[0]])
            {{
                Value = big2.Value;
            }}
        )
    }

    static boolean AreAdditionFinalValuesWrong(double val1, double val2, Operations operation)
    {
        boolean isWrong = false;

        try
        {
            val1 = val1 + val2 *
            (
                operation == Operations.Addition ? 1 : -1
            );
        }
        catch { isWrong = true; }

        return isWrong;
    }

    static UnitInfo PerformManagedOperationMultiplication(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationNormalisedValues
        (
            firstInfo, new UnitInfo[] 
            { 
                NormaliseUnitInfo(firstInfo),
                NormaliseUnitInfo(secondInfo) 
            },
            operation
        );
    }

    public static UnitInfo RaiseToIntegerExponent(double baseValue, int exponent)
    {
        return RaiseToIntegerExponent(new UnitInfo(baseValue), exponent);
    }

    static UnitInfo RaiseToIntegerExponent(UnitInfo baseInfo, int exponent)
    {
        if (exponent <= 1 && exponent >= 0)
        {
            baseInfo.Value = (exponent == 0 ? 1.0 : baseInfo.Value);
            return baseInfo;
        }

        UnitInfo outInfo = new UnitInfo(baseInfo);

        for (int i = 1; i < Math.Abs(exponent); i++)
        {
            outInfo = PerformManagedOperationValues
            (
                outInfo, baseInfo, Operations.Multiplication
            );
            if (outInfo.Error.Type != ErrorTypes.None) return outInfo;
        }

        return
        (
            exponent < 0 ?
            PerformManagedOperationValues(new UnitInfo(1.0), outInfo, Operations.Division) :
            outInfo
        );
    }

    static UnitInfo PerformManagedOperationNormalisedValues(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        outInfo =
        (
            normalisedInfos.Length == 1 ?
            //There is just one operand when the difference between both of them is too big.
            outInfo = normalisedInfos[0] :
            PerformManagedOperationTwoOperands(outInfo, normalisedInfos, operation)
        );

        return outInfo;
    }

    static UnitInfo PerformManagedOperationTwoOperands(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        UnitInfo outInfoNormalised = PerformManagedOperationValues
        (
            normalisedInfos[0], normalisedInfos[1], operation
        );

        if (outInfo.Error.Type != ErrorTypes.None)
        {
            return new UnitInfo(outInfo)
            {
                Error = new ErrorInfo(ErrorTypes.NumericError)
            };
        }

        outInfo.BaseTenExponent = outInfoNormalised.BaseTenExponent;
        outInfo.Value = outInfoNormalised.Value;
        //Normalised means no prefixes.
        outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage); 

        return outInfo;
    }

    static UnitInfo PerformManagedOperationValues(double firstValue, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            new UnitInfo(firstValue), new UnitInfo(secondValue), operation
        );
    }

    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            firstInfo, new UnitInfo(secondValue), operation
        );
    }

    //This method might be used to perform full operations (not just being the last calculation step) instead
    //of the default one (PerformManagedOperationUnits) for simple cases. That is: ones not dealing with the
    //complex numeric reality (Value, Prefix and BaseTenExponent) which makes a pre-analysis required.
    //Note that, unlikely what happens with PerformMangedOperationUnits, the outputs of this method aren't
    //normalised (= primarily stored under Value), what is useful in certain contexts.
    //NOTE: this function assumes that both inputs are normalised, what means that no prefix information is expected.
    //It might also be used with non-normalised inputs, but their prefix information would be plainly ignored.
    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        if (firstInfo.Value == 0.0 || secondInfo.Value == 0.0)
        {
            if (operation == Operations.Multiplication || operation == Operations.Division)
            {
                //Dividing by zero scenarios are taken into account somewhere else.
                return new UnitInfo(firstInfo) { Value = 0.0 };
            }
        }

        UnitInfo outInfo = new UnitInfo(firstInfo);
        UnitInfo firstInfo0 = new UnitInfo(firstInfo);
        UnitInfo secondInfo0 = new UnitInfo(secondInfo);

        boolean isWrong = false;
        try
        {
            if (operation == Operations.Addition)
            {
                outInfo.Value += secondInfo0.Value;
            }
            else if (operation == Operations.Subtraction)
            {
                outInfo.Value -= secondInfo.Value;
            }
            else
            {
                //The reason for checking whether BaseTenExponent is inside/outside the int range before performing 
                //the operation (rather than going ahead and eventually catching the resulting exception) isn't just
                //being quicker, but also the only option in many situations. Note that an addition/subtraction between
                //two int variables whose result is outside the int range might not trigger an exception (+ random 
                //negative value as output).
                if (VaryBaseTenExponent(outInfo, secondInfo0.BaseTenExponent, operation == Operations.Division).Error.Type != ErrorTypes.None)
                {
                    return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
                }

                if (operation == Operations.Multiplication)
                {
                    outInfo.Value *= secondInfo.Value;
                    outInfo.BaseTenExponent += secondInfo.BaseTenExponent;
                }
                else if (operation == Operations.Division)
                {
                    if (secondInfo.Value == 0.0)
                    {
                        return
                        (
                            new UnitInfo(outInfo) 
                            { 
                                Error = new ErrorInfo(ErrorTypes.NumericError) 
                            }
                        );
                    }
                    outInfo.Value /= secondInfo.Value;
                    outInfo.BaseTenExponent -= secondInfo.BaseTenExponent;
                }
            }
        }
        catch { isWrong = true; }

        return
        (
            //An error might not be triggered despite of dealing with numbers outside double precision.
            //For example: 0.00000000000000000001m * 0.0000000000000000000001m can output 0.0 without triggering an error. 
            isWrong || ((operation == Operations.Multiplication || operation == Operations.Division) && outInfo.Value == 0.0.0) ?
            OperationValuesManageError(firstInfo0, secondInfo0, operation) : outInfo
        );
    }

    static UnitInfo OperationValuesManageError(UnitInfo outInfo, UnitInfo secondInfo, Operations operation)
    {
        if (operation != Operations.Multiplication && operation != Operations.Division)
        {
            //This condition should never be true on account of the fact that the pre-modifications performed before
            //adding/subtracting should avoid erroneous situations.
            return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
        }

        UnitInfo secondInfo2 = ConvertValueToBaseTen(secondInfo.Value);
        outInfo = VaryBaseTenExponent(outInfo, secondInfo2.BaseTenExponent, operation == Operations.Division);
        if (Math.Abs(secondInfo2.Value) == 1.0 || outInfo.Error.Type != ErrorTypes.None) return outInfo;
        
        try
        {
            outInfo = PerformManagedOperationUnits
            (
                outInfo, secondInfo2.Value, operation
            );
        }
        catch
        {
            //Very unlikely scenario on account of the fact that Math.Abs(secondInfo2.Value)
            //lies within the 0.1-10.0 range.
            outInfo = OperationValuesManageError
            (
                new UnitInfo(outInfo)
                {
                    Value = secondInfo2.Value,
                    BaseTenExponent = 0
                },
                new UnitInfo()
                {
                    Value = outInfo.Value,
                    BaseTenExponent = outInfo.BaseTenExponent
                },
                operation
            );
        }

        return outInfo;
    }

    static UnitInfo ConvertValueToBaseTen(double value)
    {
        value = Math.Abs(value);
        return FromValueToBaseTenExponent
        (
             new UnitInfo(value), Math.Abs(value), false
        );
    }

    static UnitInfo ConvertBaseTenToValue(UnitInfo unitInfo)
    {
        if (unitInfo.BaseTenExponent == 0) return unitInfo;

        UnitInfo outInfo = new UnitInfo(unitInfo);
        boolean decrease = unitInfo.BaseTenExponent > 0;
        int sign = Math.Sign(outInfo.Value);
        double absValue = Math.Abs(outInfo.Value);

        while (outInfo.BaseTenExponent != 0.0)
        {
            if (decrease)
            {
                if (absValue >= MaxValueDec / 10.0) break;
                absValue *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }
            else
            {
                if (absValue <= MinValueDec * 10.0) break;
                absValue /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
        }

        outInfo.Value = sign * absValue;

        return outInfo;
    }

    static UnitInfo NormaliseUnitInfo(UnitInfo unitInfo)
    {
        if (unitInfo.Value == 0 && unitInfo.Prefix.Factor == 1.0)
        {
            return unitInfo;
        }
        UnitInfo outInfo = new UnitInfo(unitInfo);

        if (outInfo.Prefix.Factor != 1)
        {
            outInfo = FromValueToBaseTenExponent
            (
                outInfo, outInfo.Prefix.Factor, true
            );
            outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage);
        }
        if (outInfo.Value == 0.0) return outInfo;

        outInfo = FromValueToBaseTenExponent
        (
            outInfo, outInfo.Value, false
        );

        return outInfo;
    }

    static UnitInfo FromValueToBaseTenExponent(UnitInfo outInfo, double value, boolean isPrefix)
    {
        if (value == 0.0) return outInfo;

        double valueAbs = Math.Abs(value);
        boolean decrease = (valueAbs > 1.0);
        if (!isPrefix)
        {
            outInfo.Value = outInfo.Value / valueAbs;
        }

        while (valueAbs != 1.0)
        {
            if ((valueAbs < 10.0 && valueAbs > 1.0) || (valueAbs > 0.1.0 && valueAbs < 1.0))
            {
                if (!isPrefix) outInfo.Value = value;
                else
                {
                    outInfo = PerformManagedOperationValues
                    (
                        outInfo, value, Operations.Multiplication
                    );
                }

                return outInfo;
            }

            if (decrease)
            {
                value /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
            else
            {
                value *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }

            valueAbs = Math.Abs(value);
        }

        return outInfo;
    }

    //Method used to vary BaseTenExponent without provoking unhandled exceptions (i.e., bigger than Integer.MAX_VALUE).
    static UnitInfo VaryBaseTenExponent(UnitInfo info, int baseTenIncrease, boolean isDivision = false)
    {
        long val1 = info.BaseTenExponent;
        long val2 = baseTenIncrease;

        if (isDivision)
        {
            //Converting a negative value into positive might provoke an overflow error for the int type
            //(e.g., Math.Abs(Integer.MAIN_VALUE)). Converting both variables to long is a quick and effective
            //way to avoid this problem.
            val2 *= -1;
        }

        return
        (
             ((val2 > 0 && val1 > Integer.MAX_VALUE - val2) || (val2 < 0 && val1 < Integer.MAIN_VALUE - val2)) ?
            new UnitInfo(info, ErrorTypes.NumericError) : new UnitInfo(info){{ BaseTenExponent = (int)(val1 + val2); }}
        );
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2017-05-27 20:05:29.150
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2017-05-27 20:05:29.151
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2017-05-27 20:05:29.175
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
public class OperationsManaged
{
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, double second, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            firstInfo, new UnitInfo(second), operation
        );
    }

    public static UnitInfo PerformManagedOperationUnits(double first, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            new UnitInfo(first), secondInfo, operation
        );
    }

    //This method should always be used when dealing with random UnitInfo variables because it accounts for all the
    //possible scenarios. On the other hand, with simple operations (e.g., random UnitInfo & numeric type) it might
    //be better to use PerformManagedOperationValues. 
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        ErrorTypes errorType = InternalMethods.GetOperationError
        (
            firstInfo, secondInfo, operation
        );
        if (errorType != ErrorTypes.None)
        {
            return new UnitInfo(firstInfo) 
            {{
                Error = new ErrorInfo(errorType); 
            }};
        }

        return
        (
            operation == Operations.Addition || operation == Operations.Subtraction ?
            PerformManagedOperationAddition(firstInfo, secondInfo, operation) :
            PerformManagedOperationMultiplication(firstInfo, secondInfo, operation)
        );
    }

    static UnitInfo PerformManagedOperationAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {   
        //After being normalised, the operands might require further modifications.
        UnitInfo[] normalised = GetOperandsAddition(firstInfo, secondInfo, operation);

        return PerformManagedOperationNormalisedValues
        (
            firstInfo, normalised, operation
        );
    }

    static UnitInfo[] GetOperandsAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        UnitInfo[] operands2 = new UnitInfo[] 
        {
            new UnitInfo(firstInfo), new UnitInfo(secondInfo)
        };

        if (operands2[0].BaseTenExponent != operands2[1].BaseTenExponent || operands2[0].Prefix.Factor != operands2[1].Prefix.Factor)
        {
            //The addition/subtraction might not be performed right away even with normalised values.
            //For example: 5 and 6 from 5*10^2 and 6*10^7 cannot be added right away.
            operands2 = AdaptNormalisedValuesForAddition
            (
                new UnitInfo[] 
                { 
                    NormaliseUnitInfo(operands2[0]), 
                    NormaliseUnitInfo(operands2[1])
                },
                operation
            );
        }

        return operands2;
    }
    
    static UnitInfo[] AdaptNormalisedValuesForAddition(UnitInfo[] unitInfos2, Operations operation)
    {
        if (unitInfos2[0].BaseTenExponent == unitInfos2[1].BaseTenExponent)
        {
            //Having the same BaseTenExponent values means that the given operation can be performed right away.
            return unitInfos2;
        }

        int[] bigSmallI = 
        (
            unitInfos2[0].BaseTenExponent > unitInfos2[1].BaseTenExponent ?
            new int[] { 0, 1 } : new int[] { 1, 0 }
        );

        //Only the variable with the bigger value is modified. For example: 5*10^5 & 3*10^3 is converted
        //into 500*10^3 & 3*10^3 in order to allow the addition 500 + 3. 
        UnitInfo big2 = AdaptBiggerAdditionOperand(unitInfos2, bigSmallI, operation);
        if (big2.Error.Type != ErrorTypes.None)
        {
            return TooBigGapAddition(unitInfos2, bigSmallI, operation);
        }

        unitInfos2[bigSmallI[0]].Value = big2.Value;
        unitInfos2[bigSmallI[0]].BaseTenExponent = unitInfos2[bigSmallI[1]].BaseTenExponent;

        return unitInfos2;
    }

    //When adding/subtracting two numbers whose gap is bigger than the maximum double range, there
    //is no need to perform any operation (i.e., no change will be observed because of being outside
    //the maximum supported precision). This method takes care of these cases and returns the expected
    //output (i.e., biggest value).
    static UnitInfo[] TooBigGapAddition(UnitInfo[] unitInfos2, int[] bigSmallI, Operations operation)
    {
        UnitInfo[] outInfos = new UnitInfo[] 
        {
            //First operand (i.e., one whose information defines the operation) together with the
            //numeric information (i.e., just Value and BaseTenExponent because both are normalised)
            //which is associated with the biggest one.
            new UnitInfo(unitInfos2[0])
            {{
                Value = unitInfos2[bigSmallI[0]].Value;
                BaseTenExponent = unitInfos2[bigSmallI[0]].BaseTenExponent;
            }}
        };

        if (operation == Operations.Subtraction && bigSmallI[0] == 1)
        {
            outInfos[0].Value = -1.0 * outInfos[0].Value;
        }

        if (outInfos[0].Unit == Units.Unitless)
        {
            outInfos[0].Unit = unitInfos2[bigSmallI[1]].Unit;
        }

        return outInfos;
    }

    static UnitInfo AdaptBiggerAdditionOperand(UnitInfo[] unitInfos2, Integer[] bigSmallI, Operations operation)
    {
        int gapExponent = unitInfos2[bigSmallI[0]].BaseTenExponent - unitInfos2[bigSmallI[1]].BaseTenExponent;
        if (gapExponent >= 27)
        {
            //The difference between both inputs is bigger than (or, at least, very close to) the maximum double value/precision;
            //what makes this situation calculation unworthy and the first operand to be returned as the result.
            //Note that the error below these lines is just an easy way to tell the calling function about this eventuality.
            return new UnitInfo(unitInfos2[0]) 
            {{ 
                Error = new ErrorInfo(ErrorTypes.InvalidOperation); 
            }};
        }

        //PerformManagedOperationValues is used to make sure that the resulting numeric information is stored
        //in Value (if possible).
        UnitInfo big2 = PerformManagedOperationValues
        (
            RaiseToIntegerExponent(10.0, gapExponent), unitInfos2[bigSmallI[0]].Value, 
            Operations.Multiplication                
        );

        boolean isWrong = 
        (
            big2.Error.Type != ErrorTypes.None || big2.BaseTenExponent != 0 ?
            
            //The value of the bigger input times 10^(gap between BaseTenExponent of inputs) is too big. 
            isWrong = true :
            
            //Overflow-check very unlikely to trigger an error. In fact, with properly normalised variables,
            //triggering an error would be plainly impossible.               
            AreAdditionFinalValuesWrong
            (
                unitInfos2[0].Value, unitInfos2[1].Value, operation
            )
        );

        UnitInfo temp = null;
        if (isWrong)
        {
        	temp = new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }};
            
            temp.Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            
        }
        
        
        return temp;
        
        
        return
        (
            isWrong ?
            //This error is just an easy way to let the calling function know about the fact that no
            //calculation has been performed (too big gap). This isn't a properly-speaking error and
            //that's why it will not be notified to the user.
            new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }} :
            //Returning the new big value. For example: with 5*10^4 & 3*10^2, 500 would be returned.
            new UnitInfo(unitInfos2[bigSmallI[0]])
            {{
                Value = big2.Value;
            }}
        )
    }

    static boolean AreAdditionFinalValuesWrong(double val1, double val2, Operations operation)
    {
        boolean isWrong = false;

        try
        {
            val1 = val1 + val2 *
            (
                operation == Operations.Addition ? 1 : -1
            );
        }
        catch { isWrong = true; }

        return isWrong;
    }

    static UnitInfo PerformManagedOperationMultiplication(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationNormalisedValues
        (
            firstInfo, new UnitInfo[] 
            { 
                NormaliseUnitInfo(firstInfo),
                NormaliseUnitInfo(secondInfo) 
            },
            operation
        );
    }

    public static UnitInfo RaiseToIntegerExponent(double baseValue, int exponent)
    {
        return RaiseToIntegerExponent(new UnitInfo(baseValue), exponent);
    }

    static UnitInfo RaiseToIntegerExponent(UnitInfo baseInfo, int exponent)
    {
        if (exponent <= 1 && exponent >= 0)
        {
            baseInfo.Value = (exponent == 0 ? 1.0 : baseInfo.Value);
            return baseInfo;
        }

        UnitInfo outInfo = new UnitInfo(baseInfo);

        for (int i = 1; i < Math.Abs(exponent); i++)
        {
            outInfo = PerformManagedOperationValues
            (
                outInfo, baseInfo, Operations.Multiplication
            );
            if (outInfo.Error.Type != ErrorTypes.None) return outInfo;
        }

        return
        (
            exponent < 0 ?
            PerformManagedOperationValues(new UnitInfo(1.0), outInfo, Operations.Division) :
            outInfo
        );
    }

    static UnitInfo PerformManagedOperationNormalisedValues(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        outInfo =
        (
            normalisedInfos.Length == 1 ?
            //There is just one operand when the difference between both of them is too big.
            outInfo = normalisedInfos[0] :
            PerformManagedOperationTwoOperands(outInfo, normalisedInfos, operation)
        );

        return outInfo;
    }

    static UnitInfo PerformManagedOperationTwoOperands(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        UnitInfo outInfoNormalised = PerformManagedOperationValues
        (
            normalisedInfos[0], normalisedInfos[1], operation
        );

        if (outInfo.Error.Type != ErrorTypes.None)
        {
            return new UnitInfo(outInfo)
            {
                Error = new ErrorInfo(ErrorTypes.NumericError)
            };
        }

        outInfo.BaseTenExponent = outInfoNormalised.BaseTenExponent;
        outInfo.Value = outInfoNormalised.Value;
        //Normalised means no prefixes.
        outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage); 

        return outInfo;
    }

    static UnitInfo PerformManagedOperationValues(double firstValue, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            new UnitInfo(firstValue), new UnitInfo(secondValue), operation
        );
    }

    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            firstInfo, new UnitInfo(secondValue), operation
        );
    }

    //This method might be used to perform full operations (not just being the last calculation step) instead
    //of the default one (PerformManagedOperationUnits) for simple cases. That is: ones not dealing with the
    //complex numeric reality (Value, Prefix and BaseTenExponent) which makes a pre-analysis required.
    //Note that, unlikely what happens with PerformMangedOperationUnits, the outputs of this method aren't
    //normalised (= primarily stored under Value), what is useful in certain contexts.
    //NOTE: this function assumes that both inputs are normalised, what means that no prefix information is expected.
    //It might also be used with non-normalised inputs, but their prefix information would be plainly ignored.
    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        if (firstInfo.Value == 0.0 || secondInfo.Value == 0.0)
        {
            if (operation == Operations.Multiplication || operation == Operations.Division)
            {
                //Dividing by zero scenarios are taken into account somewhere else.
                return new UnitInfo(firstInfo) { Value = 0.0 };
            }
        }

        UnitInfo outInfo = new UnitInfo(firstInfo);
        UnitInfo firstInfo0 = new UnitInfo(firstInfo);
        UnitInfo secondInfo0 = new UnitInfo(secondInfo);

        boolean isWrong = false;
        try
        {
            if (operation == Operations.Addition)
            {
                outInfo.Value += secondInfo0.Value;
            }
            else if (operation == Operations.Subtraction)
            {
                outInfo.Value -= secondInfo.Value;
            }
            else
            {
                //The reason for checking whether BaseTenExponent is inside/outside the int range before performing 
                //the operation (rather than going ahead and eventually catching the resulting exception) isn't just
                //being quicker, but also the only option in many situations. Note that an addition/subtraction between
                //two int variables whose result is outside the int range might not trigger an exception (+ random 
                //negative value as output).
                if (VaryBaseTenExponent(outInfo, secondInfo0.BaseTenExponent, operation == Operations.Division).Error.Type != ErrorTypes.None)
                {
                    return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
                }

                if (operation == Operations.Multiplication)
                {
                    outInfo.Value *= secondInfo.Value;
                    outInfo.BaseTenExponent += secondInfo.BaseTenExponent;
                }
                else if (operation == Operations.Division)
                {
                    if (secondInfo.Value == 0.0)
                    {
                        return
                        (
                            new UnitInfo(outInfo) 
                            { 
                                Error = new ErrorInfo(ErrorTypes.NumericError) 
                            }
                        );
                    }
                    outInfo.Value /= secondInfo.Value;
                    outInfo.BaseTenExponent -= secondInfo.BaseTenExponent;
                }
            }
        }
        catch { isWrong = true; }

        return
        (
            //An error might not be triggered despite of dealing with numbers outside double precision.
            //For example: 0.00000000000000000001m * 0.0000000000000000000001m can output 0.0 without triggering an error. 
            isWrong || ((operation == Operations.Multiplication || operation == Operations.Division) && outInfo.Value == 0.0.0) ?
            OperationValuesManageError(firstInfo0, secondInfo0, operation) : outInfo
        );
    }

    static UnitInfo OperationValuesManageError(UnitInfo outInfo, UnitInfo secondInfo, Operations operation)
    {
        if (operation != Operations.Multiplication && operation != Operations.Division)
        {
            //This condition should never be true on account of the fact that the pre-modifications performed before
            //adding/subtracting should avoid erroneous situations.
            return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
        }

        UnitInfo secondInfo2 = ConvertValueToBaseTen(secondInfo.Value);
        outInfo = VaryBaseTenExponent(outInfo, secondInfo2.BaseTenExponent, operation == Operations.Division);
        if (Math.Abs(secondInfo2.Value) == 1.0 || outInfo.Error.Type != ErrorTypes.None) return outInfo;
        
        try
        {
            outInfo = PerformManagedOperationUnits
            (
                outInfo, secondInfo2.Value, operation
            );
        }
        catch
        {
            //Very unlikely scenario on account of the fact that Math.Abs(secondInfo2.Value)
            //lies within the 0.1-10.0 range.
            outInfo = OperationValuesManageError
            (
                new UnitInfo(outInfo)
                {
                    Value = secondInfo2.Value,
                    BaseTenExponent = 0
                },
                new UnitInfo()
                {
                    Value = outInfo.Value,
                    BaseTenExponent = outInfo.BaseTenExponent
                },
                operation
            );
        }

        return outInfo;
    }

    static UnitInfo ConvertValueToBaseTen(double value)
    {
        value = Math.Abs(value);
        return FromValueToBaseTenExponent
        (
             new UnitInfo(value), Math.Abs(value), false
        );
    }

    static UnitInfo ConvertBaseTenToValue(UnitInfo unitInfo)
    {
        if (unitInfo.BaseTenExponent == 0) return unitInfo;

        UnitInfo outInfo = new UnitInfo(unitInfo);
        boolean decrease = unitInfo.BaseTenExponent > 0;
        int sign = Math.Sign(outInfo.Value);
        double absValue = Math.Abs(outInfo.Value);

        while (outInfo.BaseTenExponent != 0.0)
        {
            if (decrease)
            {
                if (absValue >= MaxValueDec / 10.0) break;
                absValue *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }
            else
            {
                if (absValue <= MinValueDec * 10.0) break;
                absValue /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
        }

        outInfo.Value = sign * absValue;

        return outInfo;
    }

    static UnitInfo NormaliseUnitInfo(UnitInfo unitInfo)
    {
        if (unitInfo.Value == 0 && unitInfo.Prefix.Factor == 1.0)
        {
            return unitInfo;
        }
        UnitInfo outInfo = new UnitInfo(unitInfo);

        if (outInfo.Prefix.Factor != 1)
        {
            outInfo = FromValueToBaseTenExponent
            (
                outInfo, outInfo.Prefix.Factor, true
            );
            outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage);
        }
        if (outInfo.Value == 0.0) return outInfo;

        outInfo = FromValueToBaseTenExponent
        (
            outInfo, outInfo.Value, false
        );

        return outInfo;
    }

    static UnitInfo FromValueToBaseTenExponent(UnitInfo outInfo, double value, boolean isPrefix)
    {
        if (value == 0.0) return outInfo;

        double valueAbs = Math.Abs(value);
        boolean decrease = (valueAbs > 1.0);
        if (!isPrefix)
        {
            outInfo.Value = outInfo.Value / valueAbs;
        }

        while (valueAbs != 1.0)
        {
            if ((valueAbs < 10.0 && valueAbs > 1.0) || (valueAbs > 0.1.0 && valueAbs < 1.0))
            {
                if (!isPrefix) outInfo.Value = value;
                else
                {
                    outInfo = PerformManagedOperationValues
                    (
                        outInfo, value, Operations.Multiplication
                    );
                }

                return outInfo;
            }

            if (decrease)
            {
                value /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
            else
            {
                value *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }

            valueAbs = Math.Abs(value);
        }

        return outInfo;
    }

    //Method used to vary BaseTenExponent without provoking unhandled exceptions (i.e., bigger than Integer.MAX_VALUE).
    static UnitInfo VaryBaseTenExponent(UnitInfo info, int baseTenIncrease, boolean isDivision = false)
    {
        long val1 = info.BaseTenExponent;
        long val2 = baseTenIncrease;

        if (isDivision)
        {
            //Converting a negative value into positive might provoke an overflow error for the int type
            //(e.g., Math.Abs(Integer.MAIN_VALUE)). Converting both variables to long is a quick and effective
            //way to avoid this problem.
            val2 *= -1;
        }

        return
        (
             ((val2 > 0 && val1 > Integer.MAX_VALUE - val2) || (val2 < 0 && val1 < Integer.MAIN_VALUE - val2)) ?
            new UnitInfo(info, ErrorTypes.NumericError) : new UnitInfo(info){{ BaseTenExponent = (int)(val1 + val2); }}
        );
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:476)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 2 2017-05-27 20:05:29.175
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:476)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 0 2017-05-27 20:05:29.176
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:476)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.core 4 4 2017-05-27 20:05:29.192
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
public class OperationsManaged
{
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, double second, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            firstInfo, new UnitInfo(second), operation
        );
    }

    public static UnitInfo PerformManagedOperationUnits(double first, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            new UnitInfo(first), secondInfo, operation
        );
    }

    //This method should always be used when dealing with random UnitInfo variables because it accounts for all the
    //possible scenarios. On the other hand, with simple operations (e.g., random UnitInfo & numeric type) it might
    //be better to use PerformManagedOperationValues. 
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        ErrorTypes errorType = InternalMethods.GetOperationError
        (
            firstInfo, secondInfo, operation
        );
        if (errorType != ErrorTypes.None)
        {
            return new UnitInfo(firstInfo) 
            {{
                Error = new ErrorInfo(errorType); 
            }};
        }

        return
        (
            operation == Operations.Addition || operation == Operations.Subtraction ?
            PerformManagedOperationAddition(firstInfo, secondInfo, operation) :
            PerformManagedOperationMultiplication(firstInfo, secondInfo, operation)
        );
    }

    static UnitInfo PerformManagedOperationAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {   
        //After being normalised, the operands might require further modifications.
        UnitInfo[] normalised = GetOperandsAddition(firstInfo, secondInfo, operation);

        return PerformManagedOperationNormalisedValues
        (
            firstInfo, normalised, operation
        );
    }

    static UnitInfo[] GetOperandsAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        UnitInfo[] operands2 = new UnitInfo[] 
        {
            new UnitInfo(firstInfo), new UnitInfo(secondInfo)
        };

        if (operands2[0].BaseTenExponent != operands2[1].BaseTenExponent || operands2[0].Prefix.Factor != operands2[1].Prefix.Factor)
        {
            //The addition/subtraction might not be performed right away even with normalised values.
            //For example: 5 and 6 from 5*10^2 and 6*10^7 cannot be added right away.
            operands2 = AdaptNormalisedValuesForAddition
            (
                new UnitInfo[] 
                { 
                    NormaliseUnitInfo(operands2[0]), 
                    NormaliseUnitInfo(operands2[1])
                },
                operation
            );
        }

        return operands2;
    }
    
    static UnitInfo[] AdaptNormalisedValuesForAddition(UnitInfo[] unitInfos2, Operations operation)
    {
        if (unitInfos2[0].BaseTenExponent == unitInfos2[1].BaseTenExponent)
        {
            //Having the same BaseTenExponent values means that the given operation can be performed right away.
            return unitInfos2;
        }

        int[] bigSmallI = 
        (
            unitInfos2[0].BaseTenExponent > unitInfos2[1].BaseTenExponent ?
            new int[] { 0, 1 } : new int[] { 1, 0 }
        );

        //Only the variable with the bigger value is modified. For example: 5*10^5 & 3*10^3 is converted
        //into 500*10^3 & 3*10^3 in order to allow the addition 500 + 3. 
        UnitInfo big2 = AdaptBiggerAdditionOperand(unitInfos2, bigSmallI, operation);
        if (big2.Error.Type != ErrorTypes.None)
        {
            return TooBigGapAddition(unitInfos2, bigSmallI, operation);
        }

        unitInfos2[bigSmallI[0]].Value = big2.Value;
        unitInfos2[bigSmallI[0]].BaseTenExponent = unitInfos2[bigSmallI[1]].BaseTenExponent;

        return unitInfos2;
    }

    //When adding/subtracting two numbers whose gap is bigger than the maximum double range, there
    //is no need to perform any operation (i.e., no change will be observed because of being outside
    //the maximum supported precision). This method takes care of these cases and returns the expected
    //output (i.e., biggest value).
    static UnitInfo[] TooBigGapAddition(UnitInfo[] unitInfos2, int[] bigSmallI, Operations operation)
    {
        UnitInfo[] outInfos = new UnitInfo[] 
        {
            //First operand (i.e., one whose information defines the operation) together with the
            //numeric information (i.e., just Value and BaseTenExponent because both are normalised)
            //which is associated with the biggest one.
            new UnitInfo(unitInfos2[0])
            {{
                Value = unitInfos2[bigSmallI[0]].Value;
                BaseTenExponent = unitInfos2[bigSmallI[0]].BaseTenExponent;
            }}
        };

        if (operation == Operations.Subtraction && bigSmallI[0] == 1)
        {
            outInfos[0].Value = -1.0 * outInfos[0].Value;
        }

        if (outInfos[0].Unit == Units.Unitless)
        {
            outInfos[0].Unit = unitInfos2[bigSmallI[1]].Unit;
        }

        return outInfos;
    }

    static UnitInfo AdaptBiggerAdditionOperand(UnitInfo[] unitInfos2, Integer[] bigSmallI, Operations operation)
    {
        int gapExponent = unitInfos2[bigSmallI[0]].BaseTenExponent - unitInfos2[bigSmallI[1]].BaseTenExponent;
        if (gapExponent >= 27)
        {
            //The difference between both inputs is bigger than (or, at least, very close to) the maximum double value/precision;
            //what makes this situation calculation unworthy and the first operand to be returned as the result.
            //Note that the error below these lines is just an easy way to tell the calling function about this eventuality.
            return new UnitInfo(unitInfos2[0]) 
            {{ 
                Error = new ErrorInfo(ErrorTypes.InvalidOperation); 
            }};
        }

        //PerformManagedOperationValues is used to make sure that the resulting numeric information is stored
        //in Value (if possible).
        UnitInfo big2 = PerformManagedOperationValues
        (
            RaiseToIntegerExponent(10.0, gapExponent), unitInfos2[bigSmallI[0]].Value, 
            Operations.Multiplication                
        );

        boolean isWrong = 
        (
            big2.Error.Type != ErrorTypes.None || big2.BaseTenExponent != 0 ?
            
            //The value of the bigger input times 10^(gap between BaseTenExponent of inputs) is too big. 
            isWrong = true :
            
            //Overflow-check very unlikely to trigger an error. In fact, with properly normalised variables,
            //triggering an error would be plainly impossible.               
            AreAdditionFinalValuesWrong
            (
                unitInfos2[0].Value, unitInfos2[1].Value, operation
            )
        );

        UnitInfo temp = null;
        if (isWrong)
        {
        	temp = new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }};
            
            temp.Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            
        }
        
        
        return temp;
        
        
        return
        (
            isWrong ?
            //This error is just an easy way to let the calling function know about the fact that no
            //calculation has been performed (too big gap). This isn't a properly-speaking error and
            //that's why it will not be notified to the user.
            new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }} :
            //Returning the new big value. For example: with 5*10^4 & 3*10^2, 500 would be returned.
            new UnitInfo(unitInfos2[bigSmallI[0]])
            {{
                Value = big2.Value;
            }}
        )
    }

    static boolean AreAdditionFinalValuesWrong(double val1, double val2, Operations operation)
    {
        boolean isWrong = false;

        try
        {
            val1 = val1 + val2 *
            (
                operation == Operations.Addition ? 1 : -1
            );
        }
        catch { isWrong = true; }

        return isWrong;
    }

    static UnitInfo PerformManagedOperationMultiplication(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationNormalisedValues
        (
            firstInfo, new UnitInfo[] 
            { 
                NormaliseUnitInfo(firstInfo),
                NormaliseUnitInfo(secondInfo) 
            },
            operation
        );
    }

    public static UnitInfo RaiseToIntegerExponent(double baseValue, int exponent)
    {
        return RaiseToIntegerExponent(new UnitInfo(baseValue), exponent);
    }

    static UnitInfo RaiseToIntegerExponent(UnitInfo baseInfo, int exponent)
    {
        if (exponent <= 1 && exponent >= 0)
        {
            baseInfo.Value = (exponent == 0 ? 1.0 : baseInfo.Value);
            return baseInfo;
        }

        UnitInfo outInfo = new UnitInfo(baseInfo);

        for (int i = 1; i < Math.Abs(exponent); i++)
        {
            outInfo = PerformManagedOperationValues
            (
                outInfo, baseInfo, Operations.Multiplication
            );
            if (outInfo.Error.Type != ErrorTypes.None) return outInfo;
        }

        return
        (
            exponent < 0 ?
            PerformManagedOperationValues(new UnitInfo(1.0), outInfo, Operations.Division) :
            outInfo
        );
    }

    static UnitInfo PerformManagedOperationNormalisedValues(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        outInfo =
        (
            normalisedInfos.Length == 1 ?
            //There is just one operand when the difference between both of them is too big.
            outInfo = normalisedInfos[0] :
            PerformManagedOperationTwoOperands(outInfo, normalisedInfos, operation)
        );

        return outInfo;
    }

    static UnitInfo PerformManagedOperationTwoOperands(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        UnitInfo outInfoNormalised = PerformManagedOperationValues
        (
            normalisedInfos[0], normalisedInfos[1], operation
        );

        if (outInfo.Error.Type != ErrorTypes.None)
        {
            return new UnitInfo(outInfo)
            {
                Error = new ErrorInfo(ErrorTypes.NumericError)
            };
        }

        outInfo.BaseTenExponent = outInfoNormalised.BaseTenExponent;
        outInfo.Value = outInfoNormalised.Value;
        //Normalised means no prefixes.
        outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage); 

        return outInfo;
    }

    static UnitInfo PerformManagedOperationValues(double firstValue, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            new UnitInfo(firstValue), new UnitInfo(secondValue), operation
        );
    }

    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            firstInfo, new UnitInfo(secondValue), operation
        );
    }

    //This method might be used to perform full operations (not just being the last calculation step) instead
    //of the default one (PerformManagedOperationUnits) for simple cases. That is: ones not dealing with the
    //complex numeric reality (Value, Prefix and BaseTenExponent) which makes a pre-analysis required.
    //Note that, unlikely what happens with PerformMangedOperationUnits, the outputs of this method aren't
    //normalised (= primarily stored under Value), what is useful in certain contexts.
    //NOTE: this function assumes that both inputs are normalised, what means that no prefix information is expected.
    //It might also be used with non-normalised inputs, but their prefix information would be plainly ignored.
    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        if (firstInfo.Value == 0.0 || secondInfo.Value == 0.0)
        {
            if (operation == Operations.Multiplication || operation == Operations.Division)
            {
                //Dividing by zero scenarios are taken into account somewhere else.
                return new UnitInfo(firstInfo) { Value = 0.0 };
            }
        }

        UnitInfo outInfo = new UnitInfo(firstInfo);
        UnitInfo firstInfo0 = new UnitInfo(firstInfo);
        UnitInfo secondInfo0 = new UnitInfo(secondInfo);

        boolean isWrong = false;
        try
        {
            if (operation == Operations.Addition)
            {
                outInfo.Value += secondInfo0.Value;
            }
            else if (operation == Operations.Subtraction)
            {
                outInfo.Value -= secondInfo.Value;
            }
            else
            {
                //The reason for checking whether BaseTenExponent is inside/outside the int range before performing 
                //the operation (rather than going ahead and eventually catching the resulting exception) isn't just
                //being quicker, but also the only option in many situations. Note that an addition/subtraction between
                //two int variables whose result is outside the int range might not trigger an exception (+ random 
                //negative value as output).
                if (VaryBaseTenExponent(outInfo, secondInfo0.BaseTenExponent, operation == Operations.Division).Error.Type != ErrorTypes.None)
                {
                    return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
                }

                if (operation == Operations.Multiplication)
                {
                    outInfo.Value *= secondInfo.Value;
                    outInfo.BaseTenExponent += secondInfo.BaseTenExponent;
                }
                else if (operation == Operations.Division)
                {
                    if (secondInfo.Value == 0.0)
                    {
                        return
                        (
                            new UnitInfo(outInfo) 
                            { 
                                Error = new ErrorInfo(ErrorTypes.NumericError) 
                            }
                        );
                    }
                    outInfo.Value /= secondInfo.Value;
                    outInfo.BaseTenExponent -= secondInfo.BaseTenExponent;
                }
            }
        }
        catch { isWrong = true; }

        return
        (
            //An error might not be triggered despite of dealing with numbers outside double precision.
            //For example: 0.00000000000000000001m * 0.0000000000000000000001m can output 0.0 without triggering an error. 
            isWrong || ((operation == Operations.Multiplication || operation == Operations.Division) && outInfo.Value == 0.0.0) ?
            OperationValuesManageError(firstInfo0, secondInfo0, operation) : outInfo
        );
    }

    static UnitInfo OperationValuesManageError(UnitInfo outInfo, UnitInfo secondInfo, Operations operation)
    {
        if (operation != Operations.Multiplication && operation != Operations.Division)
        {
            //This condition should never be true on account of the fact that the pre-modifications performed before
            //adding/subtracting should avoid erroneous situations.
            return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
        }

        UnitInfo secondInfo2 = ConvertValueToBaseTen(secondInfo.Value);
        outInfo = VaryBaseTenExponent(outInfo, secondInfo2.BaseTenExponent, operation == Operations.Division);
        if (Math.Abs(secondInfo2.Value) == 1.0 || outInfo.Error.Type != ErrorTypes.None) return outInfo;
        
        try
        {
            outInfo = PerformManagedOperationUnits
            (
                outInfo, secondInfo2.Value, operation
            );
        }
        catch
        {
            //Very unlikely scenario on account of the fact that Math.Abs(secondInfo2.Value)
            //lies within the 0.1-10.0 range.
            outInfo = OperationValuesManageError
            (
                new UnitInfo(outInfo)
                {
                    Value = secondInfo2.Value,
                    BaseTenExponent = 0
                },
                new UnitInfo()
                {
                    Value = outInfo.Value,
                    BaseTenExponent = outInfo.BaseTenExponent
                },
                operation
            );
        }

        return outInfo;
    }

    static UnitInfo ConvertValueToBaseTen(double value)
    {
        value = Math.Abs(value);
        return FromValueToBaseTenExponent
        (
             new UnitInfo(value), Math.Abs(value), false
        );
    }

    static UnitInfo ConvertBaseTenToValue(UnitInfo unitInfo)
    {
        if (unitInfo.BaseTenExponent == 0) return unitInfo;

        UnitInfo outInfo = new UnitInfo(unitInfo);
        boolean decrease = unitInfo.BaseTenExponent > 0;
        int sign = Math.Sign(outInfo.Value);
        double absValue = Math.Abs(outInfo.Value);

        while (outInfo.BaseTenExponent != 0.0)
        {
            if (decrease)
            {
                if (absValue >= MaxValueDec / 10.0) break;
                absValue *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }
            else
            {
                if (absValue <= MinValueDec * 10.0) break;
                absValue /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
        }

        outInfo.Value = sign * absValue;

        return outInfo;
    }

    static UnitInfo NormaliseUnitInfo(UnitInfo unitInfo)
    {
        if (unitInfo.Value == 0 && unitInfo.Prefix.Factor == 1.0)
        {
            return unitInfo;
        }
        UnitInfo outInfo = new UnitInfo(unitInfo);

        if (outInfo.Prefix.Factor != 1)
        {
            outInfo = FromValueToBaseTenExponent
            (
                outInfo, outInfo.Prefix.Factor, true
            );
            outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage);
        }
        if (outInfo.Value == 0.0) return outInfo;

        outInfo = FromValueToBaseTenExponent
        (
            outInfo, outInfo.Value, false
        );

        return outInfo;
    }

    static UnitInfo FromValueToBaseTenExponent(UnitInfo outInfo, double value, boolean isPrefix)
    {
        if (value == 0.0) return outInfo;

        double valueAbs = Math.Abs(value);
        boolean decrease = (valueAbs > 1.0);
        if (!isPrefix)
        {
            outInfo.Value = outInfo.Value / valueAbs;
        }

        while (valueAbs != 1.0)
        {
            if ((valueAbs < 10.0 && valueAbs > 1.0) || (valueAbs > 0.1.0 && valueAbs < 1.0))
            {
                if (!isPrefix) outInfo.Value = value;
                else
                {
                    outInfo = PerformManagedOperationValues
                    (
                        outInfo, value, Operations.Multiplication
                    );
                }

                return outInfo;
            }

            if (decrease)
            {
                value /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
            else
            {
                value *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }

            valueAbs = Math.Abs(value);
        }

        return outInfo;
    }

    //Method used to vary BaseTenExponent without provoking unhandled exceptions (i.e., bigger than Integer.MAX_VALUE).
    static UnitInfo VaryBaseTenExponent(UnitInfo info, int baseTenIncrease, boolean isDivision = false)
    {
        long val1 = info.BaseTenExponent;
        long val2 = baseTenIncrease;

        if (isDivision)
        {
            //Converting a negative value into positive might provoke an overflow error for the int type
            //(e.g., Math.Abs(Integer.MAIN_VALUE)). Converting both variables to long is a quick and effective
            //way to avoid this problem.
            val2 *= -1;
        }

        return
        (
             ((val2 > 0 && val1 > Integer.MAX_VALUE - val2) || (val2 < 0 && val1 < Integer.MAIN_VALUE - val2)) ?
            new UnitInfo(info, ErrorTypes.NumericError) : new UnitInfo(info){{ BaseTenExponent = (int)(val1 + val2); }}
        );
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:476)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:476)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.recommenders.rcp.utils.JdtUtils.findAstNodeFromEditorSelection(JdtUtils.java:669)
	at org.eclipse.recommenders.internal.rcp.JavaElementSelectionService.handleSelectionInEditor(JavaElementSelectionService.java:110)
	at org.eclipse.recommenders.internal.rcp.JavaElementSelectionService.access$1(JavaElementSelectionService.java:105)
	at org.eclipse.recommenders.internal.rcp.JavaElementSelectionService$1.run(JavaElementSelectionService.java:82)
	at java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source)
	at java.util.concurrent.FutureTask.run(Unknown Source)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(Unknown Source)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(Unknown Source)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source)
	at java.lang.Thread.run(Unknown Source)

!ENTRY org.eclipse.jdt.ui 4 2 2017-05-27 20:05:29.193
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:476)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:476)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.recommenders.rcp.utils.JdtUtils.findAstNodeFromEditorSelection(JdtUtils.java:669)
	at org.eclipse.recommenders.internal.rcp.JavaElementSelectionService.handleSelectionInEditor(JavaElementSelectionService.java:110)
	at org.eclipse.recommenders.internal.rcp.JavaElementSelectionService.access$1(JavaElementSelectionService.java:105)
	at org.eclipse.recommenders.internal.rcp.JavaElementSelectionService$1.run(JavaElementSelectionService.java:82)
	at java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source)
	at java.util.concurrent.FutureTask.run(Unknown Source)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(Unknown Source)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(Unknown Source)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source)
	at java.lang.Thread.run(Unknown Source)

!ENTRY org.eclipse.jdt.ui 4 0 2017-05-27 20:05:29.193
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:476)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:476)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.recommenders.rcp.utils.JdtUtils.findAstNodeFromEditorSelection(JdtUtils.java:669)
	at org.eclipse.recommenders.internal.rcp.JavaElementSelectionService.handleSelectionInEditor(JavaElementSelectionService.java:110)
	at org.eclipse.recommenders.internal.rcp.JavaElementSelectionService.access$1(JavaElementSelectionService.java:105)
	at org.eclipse.recommenders.internal.rcp.JavaElementSelectionService$1.run(JavaElementSelectionService.java:82)
	at java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source)
	at java.util.concurrent.FutureTask.run(Unknown Source)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(Unknown Source)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(Unknown Source)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source)
	at java.lang.Thread.run(Unknown Source)

!ENTRY org.eclipse.jdt.core 4 4 2017-05-27 20:05:29.216
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
public class OperationsManaged
{
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, double second, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            firstInfo, new UnitInfo(second), operation
        );
    }

    public static UnitInfo PerformManagedOperationUnits(double first, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            new UnitInfo(first), secondInfo, operation
        );
    }

    //This method should always be used when dealing with random UnitInfo variables because it accounts for all the
    //possible scenarios. On the other hand, with simple operations (e.g., random UnitInfo & numeric type) it might
    //be better to use PerformManagedOperationValues. 
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        ErrorTypes errorType = InternalMethods.GetOperationError
        (
            firstInfo, secondInfo, operation
        );
        if (errorType != ErrorTypes.None)
        {
            return new UnitInfo(firstInfo) 
            {{
                Error = new ErrorInfo(errorType); 
            }};
        }

        return
        (
            operation == Operations.Addition || operation == Operations.Subtraction ?
            PerformManagedOperationAddition(firstInfo, secondInfo, operation) :
            PerformManagedOperationMultiplication(firstInfo, secondInfo, operation)
        );
    }

    static UnitInfo PerformManagedOperationAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {   
        //After being normalised, the operands might require further modifications.
        UnitInfo[] normalised = GetOperandsAddition(firstInfo, secondInfo, operation);

        return PerformManagedOperationNormalisedValues
        (
            firstInfo, normalised, operation
        );
    }

    static UnitInfo[] GetOperandsAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        UnitInfo[] operands2 = new UnitInfo[] 
        {
            new UnitInfo(firstInfo), new UnitInfo(secondInfo)
        };

        if (operands2[0].BaseTenExponent != operands2[1].BaseTenExponent || operands2[0].Prefix.Factor != operands2[1].Prefix.Factor)
        {
            //The addition/subtraction might not be performed right away even with normalised values.
            //For example: 5 and 6 from 5*10^2 and 6*10^7 cannot be added right away.
            operands2 = AdaptNormalisedValuesForAddition
            (
                new UnitInfo[] 
                { 
                    NormaliseUnitInfo(operands2[0]), 
                    NormaliseUnitInfo(operands2[1])
                },
                operation
            );
        }

        return operands2;
    }
    
    static UnitInfo[] AdaptNormalisedValuesForAddition(UnitInfo[] unitInfos2, Operations operation)
    {
        if (unitInfos2[0].BaseTenExponent == unitInfos2[1].BaseTenExponent)
        {
            //Having the same BaseTenExponent values means that the given operation can be performed right away.
            return unitInfos2;
        }

        int[] bigSmallI = 
        (
            unitInfos2[0].BaseTenExponent > unitInfos2[1].BaseTenExponent ?
            new int[] { 0, 1 } : new int[] { 1, 0 }
        );

        //Only the variable with the bigger value is modified. For example: 5*10^5 & 3*10^3 is converted
        //into 500*10^3 & 3*10^3 in order to allow the addition 500 + 3. 
        UnitInfo big2 = AdaptBiggerAdditionOperand(unitInfos2, bigSmallI, operation);
        if (big2.Error.Type != ErrorTypes.None)
        {
            return TooBigGapAddition(unitInfos2, bigSmallI, operation);
        }

        unitInfos2[bigSmallI[0]].Value = big2.Value;
        unitInfos2[bigSmallI[0]].BaseTenExponent = unitInfos2[bigSmallI[1]].BaseTenExponent;

        return unitInfos2;
    }

    //When adding/subtracting two numbers whose gap is bigger than the maximum double range, there
    //is no need to perform any operation (i.e., no change will be observed because of being outside
    //the maximum supported precision). This method takes care of these cases and returns the expected
    //output (i.e., biggest value).
    static UnitInfo[] TooBigGapAddition(UnitInfo[] unitInfos2, int[] bigSmallI, Operations operation)
    {
        UnitInfo[] outInfos = new UnitInfo[] 
        {
            //First operand (i.e., one whose information defines the operation) together with the
            //numeric information (i.e., just Value and BaseTenExponent because both are normalised)
            //which is associated with the biggest one.
            new UnitInfo(unitInfos2[0])
            {{
                Value = unitInfos2[bigSmallI[0]].Value;
                BaseTenExponent = unitInfos2[bigSmallI[0]].BaseTenExponent;
            }}
        };

        if (operation == Operations.Subtraction && bigSmallI[0] == 1)
        {
            outInfos[0].Value = -1.0 * outInfos[0].Value;
        }

        if (outInfos[0].Unit == Units.Unitless)
        {
            outInfos[0].Unit = unitInfos2[bigSmallI[1]].Unit;
        }

        return outInfos;
    }

    static UnitInfo AdaptBiggerAdditionOperand(UnitInfo[] unitInfos2, Integer[] bigSmallI, Operations operation)
    {
        int gapExponent = unitInfos2[bigSmallI[0]].BaseTenExponent - unitInfos2[bigSmallI[1]].BaseTenExponent;
        if (gapExponent >= 27)
        {
            //The difference between both inputs is bigger than (or, at least, very close to) the maximum double value/precision;
            //what makes this situation calculation unworthy and the first operand to be returned as the result.
            //Note that the error below these lines is just an easy way to tell the calling function about this eventuality.
            return new UnitInfo(unitInfos2[0]) 
            {{ 
                Error = new ErrorInfo(ErrorTypes.InvalidOperation); 
            }};
        }

        //PerformManagedOperationValues is used to make sure that the resulting numeric information is stored
        //in Value (if possible).
        UnitInfo big2 = PerformManagedOperationValues
        (
            RaiseToIntegerExponent(10.0, gapExponent), unitInfos2[bigSmallI[0]].Value, 
            Operations.Multiplication                
        );

        boolean isWrong = 
        (
            big2.Error.Type != ErrorTypes.None || big2.BaseTenExponent != 0 ?
            
            //The value of the bigger input times 10^(gap between BaseTenExponent of inputs) is too big. 
            isWrong = true :
            
            //Overflow-check very unlikely to trigger an error. In fact, with properly normalised variables,
            //triggering an error would be plainly impossible.               
            AreAdditionFinalValuesWrong
            (
                unitInfos2[0].Value, unitInfos2[1].Value, operation
            )
        );

        UnitInfo temp = null;
        if (isWrong)
        {
        	temp = new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }};
            
            temp.Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            
        }
        
        
        return temp;
        
        
        return
        (
            isWrong ?
            //This error is just an easy way to let the calling function know about the fact that no
            //calculation has been performed (too big gap). This isn't a properly-speaking error and
            //that's why it will not be notified to the user.
            new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }} :
            //Returning the new big value. For example: with 5*10^4 & 3*10^2, 500 would be returned.
            new UnitInfo(unitInfos2[bigSmallI[0]])
            {{
                Value = big2.Value;
            }}
        )
    }

    static boolean AreAdditionFinalValuesWrong(double val1, double val2, Operations operation)
    {
        boolean isWrong = false;

        try
        {
            val1 = val1 + val2 *
            (
                operation == Operations.Addition ? 1 : -1
            );
        }
        catch { isWrong = true; }

        return isWrong;
    }

    static UnitInfo PerformManagedOperationMultiplication(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationNormalisedValues
        (
            firstInfo, new UnitInfo[] 
            { 
                NormaliseUnitInfo(firstInfo),
                NormaliseUnitInfo(secondInfo) 
            },
            operation
        );
    }

    public static UnitInfo RaiseToIntegerExponent(double baseValue, int exponent)
    {
        return RaiseToIntegerExponent(new UnitInfo(baseValue), exponent);
    }

    static UnitInfo RaiseToIntegerExponent(UnitInfo baseInfo, int exponent)
    {
        if (exponent <= 1 && exponent >= 0)
        {
            baseInfo.Value = (exponent == 0 ? 1.0 : baseInfo.Value);
            return baseInfo;
        }

        UnitInfo outInfo = new UnitInfo(baseInfo);

        for (int i = 1; i < Math.Abs(exponent); i++)
        {
            outInfo = PerformManagedOperationValues
            (
                outInfo, baseInfo, Operations.Multiplication
            );
            if (outInfo.Error.Type != ErrorTypes.None) return outInfo;
        }

        return
        (
            exponent < 0 ?
            PerformManagedOperationValues(new UnitInfo(1.0), outInfo, Operations.Division) :
            outInfo
        );
    }

    static UnitInfo PerformManagedOperationNormalisedValues(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        outInfo =
        (
            normalisedInfos.Length == 1 ?
            //There is just one operand when the difference between both of them is too big.
            outInfo = normalisedInfos[0] :
            PerformManagedOperationTwoOperands(outInfo, normalisedInfos, operation)
        );

        return outInfo;
    }

    static UnitInfo PerformManagedOperationTwoOperands(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        UnitInfo outInfoNormalised = PerformManagedOperationValues
        (
            normalisedInfos[0], normalisedInfos[1], operation
        );

        if (outInfo.Error.Type != ErrorTypes.None)
        {
            return new UnitInfo(outInfo)
            {
                Error = new ErrorInfo(ErrorTypes.NumericError)
            };
        }

        outInfo.BaseTenExponent = outInfoNormalised.BaseTenExponent;
        outInfo.Value = outInfoNormalised.Value;
        //Normalised means no prefixes.
        outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage); 

        return outInfo;
    }

    static UnitInfo PerformManagedOperationValues(double firstValue, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            new UnitInfo(firstValue), new UnitInfo(secondValue), operation
        );
    }

    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            firstInfo, new UnitInfo(secondValue), operation
        );
    }

    //This method might be used to perform full operations (not just being the last calculation step) instead
    //of the default one (PerformManagedOperationUnits) for simple cases. That is: ones not dealing with the
    //complex numeric reality (Value, Prefix and BaseTenExponent) which makes a pre-analysis required.
    //Note that, unlikely what happens with PerformMangedOperationUnits, the outputs of this method aren't
    //normalised (= primarily stored under Value), what is useful in certain contexts.
    //NOTE: this function assumes that both inputs are normalised, what means that no prefix information is expected.
    //It might also be used with non-normalised inputs, but their prefix information would be plainly ignored.
    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        if (firstInfo.Value == 0.0 || secondInfo.Value == 0.0)
        {
            if (operation == Operations.Multiplication || operation == Operations.Division)
            {
                //Dividing by zero scenarios are taken into account somewhere else.
                return new UnitInfo(firstInfo) { Value = 0.0 };
            }
        }

        UnitInfo outInfo = new UnitInfo(firstInfo);
        UnitInfo firstInfo0 = new UnitInfo(firstInfo);
        UnitInfo secondInfo0 = new UnitInfo(secondInfo);

        boolean isWrong = false;
        try
        {
            if (operation == Operations.Addition)
            {
                outInfo.Value += secondInfo0.Value;
            }
            else if (operation == Operations.Subtraction)
            {
                outInfo.Value -= secondInfo.Value;
            }
            else
            {
                //The reason for checking whether BaseTenExponent is inside/outside the int range before performing 
                //the operation (rather than going ahead and eventually catching the resulting exception) isn't just
                //being quicker, but also the only option in many situations. Note that an addition/subtraction between
                //two int variables whose result is outside the int range might not trigger an exception (+ random 
                //negative value as output).
                if (VaryBaseTenExponent(outInfo, secondInfo0.BaseTenExponent, operation == Operations.Division).Error.Type != ErrorTypes.None)
                {
                    return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
                }

                if (operation == Operations.Multiplication)
                {
                    outInfo.Value *= secondInfo.Value;
                    outInfo.BaseTenExponent += secondInfo.BaseTenExponent;
                }
                else if (operation == Operations.Division)
                {
                    if (secondInfo.Value == 0.0)
                    {
                        return
                        (
                            new UnitInfo(outInfo) 
                            { 
                                Error = new ErrorInfo(ErrorTypes.NumericError) 
                            }
                        );
                    }
                    outInfo.Value /= secondInfo.Value;
                    outInfo.BaseTenExponent -= secondInfo.BaseTenExponent;
                }
            }
        }
        catch { isWrong = true; }

        return
        (
            //An error might not be triggered despite of dealing with numbers outside double precision.
            //For example: 0.00000000000000000001m * 0.0000000000000000000001m can output 0.0 without triggering an error. 
            isWrong || ((operation == Operations.Multiplication || operation == Operations.Division) && outInfo.Value == 0.0.0) ?
            OperationValuesManageError(firstInfo0, secondInfo0, operation) : outInfo
        );
    }

    static UnitInfo OperationValuesManageError(UnitInfo outInfo, UnitInfo secondInfo, Operations operation)
    {
        if (operation != Operations.Multiplication && operation != Operations.Division)
        {
            //This condition should never be true on account of the fact that the pre-modifications performed before
            //adding/subtracting should avoid erroneous situations.
            return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
        }

        UnitInfo secondInfo2 = ConvertValueToBaseTen(secondInfo.Value);
        outInfo = VaryBaseTenExponent(outInfo, secondInfo2.BaseTenExponent, operation == Operations.Division);
        if (Math.Abs(secondInfo2.Value) == 1.0 || outInfo.Error.Type != ErrorTypes.None) return outInfo;
        
        try
        {
            outInfo = PerformManagedOperationUnits
            (
                outInfo, secondInfo2.Value, operation
            );
        }
        catch
        {
            //Very unlikely scenario on account of the fact that Math.Abs(secondInfo2.Value)
            //lies within the 0.1-10.0 range.
            outInfo = OperationValuesManageError
            (
                new UnitInfo(outInfo)
                {
                    Value = secondInfo2.Value,
                    BaseTenExponent = 0
                },
                new UnitInfo()
                {
                    Value = outInfo.Value,
                    BaseTenExponent = outInfo.BaseTenExponent
                },
                operation
            );
        }

        return outInfo;
    }

    static UnitInfo ConvertValueToBaseTen(double value)
    {
        value = Math.Abs(value);
        return FromValueToBaseTenExponent
        (
             new UnitInfo(value), Math.Abs(value), false
        );
    }

    static UnitInfo ConvertBaseTenToValue(UnitInfo unitInfo)
    {
        if (unitInfo.BaseTenExponent == 0) return unitInfo;

        UnitInfo outInfo = new UnitInfo(unitInfo);
        boolean decrease = unitInfo.BaseTenExponent > 0;
        int sign = Math.Sign(outInfo.Value);
        double absValue = Math.Abs(outInfo.Value);

        while (outInfo.BaseTenExponent != 0.0)
        {
            if (decrease)
            {
                if (absValue >= MaxValueDec / 10.0) break;
                absValue *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }
            else
            {
                if (absValue <= MinValueDec * 10.0) break;
                absValue /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
        }

        outInfo.Value = sign * absValue;

        return outInfo;
    }

    static UnitInfo NormaliseUnitInfo(UnitInfo unitInfo)
    {
        if (unitInfo.Value == 0 && unitInfo.Prefix.Factor == 1.0)
        {
            return unitInfo;
        }
        UnitInfo outInfo = new UnitInfo(unitInfo);

        if (outInfo.Prefix.Factor != 1)
        {
            outInfo = FromValueToBaseTenExponent
            (
                outInfo, outInfo.Prefix.Factor, true
            );
            outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage);
        }
        if (outInfo.Value == 0.0) return outInfo;

        outInfo = FromValueToBaseTenExponent
        (
            outInfo, outInfo.Value, false
        );

        return outInfo;
    }

    static UnitInfo FromValueToBaseTenExponent(UnitInfo outInfo, double value, boolean isPrefix)
    {
        if (value == 0.0) return outInfo;

        double valueAbs = Math.Abs(value);
        boolean decrease = (valueAbs > 1.0);
        if (!isPrefix)
        {
            outInfo.Value = outInfo.Value / valueAbs;
        }

        while (valueAbs != 1.0)
        {
            if ((valueAbs < 10.0 && valueAbs > 1.0) || (valueAbs > 0.1.0 && valueAbs < 1.0))
            {
                if (!isPrefix) outInfo.Value = value;
                else
                {
                    outInfo = PerformManagedOperationValues
                    (
                        outInfo, value, Operations.Multiplication
                    );
                }

                return outInfo;
            }

            if (decrease)
            {
                value /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
            else
            {
                value *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }

            valueAbs = Math.Abs(value);
        }

        return outInfo;
    }

    //Method used to vary BaseTenExponent without provoking unhandled exceptions (i.e., bigger than Integer.MAX_VALUE).
    static UnitInfo VaryBaseTenExponent(UnitInfo info, int baseTenIncrease, boolean isDivision = false)
    {
        long val1 = info.BaseTenExponent;
        long val2 = baseTenIncrease;

        if (isDivision)
        {
            //Converting a negative value into positive might provoke an overflow error for the int type
            //(e.g., Math.Abs(Integer.MAIN_VALUE)). Converting both variables to long is a quick and effective
            //way to avoid this problem.
            val2 *= -1;
        }

        return
        (
             ((val2 > 0 && val1 > Integer.MAX_VALUE - val2) || (val2 < 0 && val1 < Integer.MAIN_VALUE - val2)) ?
            new UnitInfo(info, ErrorTypes.NumericError) : new UnitInfo(info){{ BaseTenExponent = (int)(val1 + val2); }}
        );
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.recommenders.rcp.utils.JdtUtils.findAstNodeFromEditorSelection(JdtUtils.java:669)
	at org.eclipse.recommenders.internal.rcp.JavaElementSelectionService.handleSelectionInEditor(JavaElementSelectionService.java:110)
	at org.eclipse.recommenders.internal.rcp.JavaElementSelectionService.access$1(JavaElementSelectionService.java:105)
	at org.eclipse.recommenders.internal.rcp.JavaElementSelectionService$1.run(JavaElementSelectionService.java:82)
	at java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source)
	at java.util.concurrent.FutureTask.run(Unknown Source)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(Unknown Source)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(Unknown Source)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source)
	at java.lang.Thread.run(Unknown Source)
