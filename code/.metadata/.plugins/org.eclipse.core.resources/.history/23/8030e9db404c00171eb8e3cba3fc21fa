package InternalUnitParser.CSharpAdaptation;

import java.text.NumberFormat;
import java.text.ParseException;
import java.util.Locale;

public class TryParseMethods
{
	public static TryParseOutput Double(String input)
	{
		TryParseOutput output = new TryParseOutput();
		
		try 
		{
		    output.DoubleVal = ParseCommon(input).doubleValue();
		    Double val = new Double(output.DoubleVal);
		    if(!(val.isNaN() || val.isInfinite()))
		    {
		    	output.IsOK = true;
		    	
		    	String[] tempVar = CSharpOther.SplitTryCatch(input.toLowerCase(), "e");
		    	if (tempVar.length == 2)
		    	{
		    		if 
		    		(
		    			Linq.FirstOrDefault
		    			(
		    				CSharpOther.StringToCharacters(tempVar[1]), x -> !Character.isDigit(x), '\u0000'
		    			) 
		    			!= '\u0000'
		    		)
		    		{
		    			//Emulating the conditions of the original C# version which doesn't support decimal exponents.
		    			output.IsOK = false;
		    		}
		    	}
		    }
		}
		catch (Exception e) { }
		
		return output;
	}
	
	public static TryParseOutput Int(String input)
	{
		TryParseOutput output = new TryParseOutput();
		if (input.contains("."))
		{
			//Emulating the conditions of the original C# version where decimal numbers cannot be parsed as integer.
			return output;
		}
		
		try 
		{
		    output.IntVal = ParseCommon(input).intValue();
		    output.IsOK = true;
		}
		catch (Exception e) { }
		
		return output;
	}
	
	static Number ParseCommon(String input) throws ParseException 
	{
		//Locale.US because of being the best equivalence for CultureInfo.InvariantCulture in the original C# code.
		return NumberFormat.getInstance(Locale.US).parse(input);
	}
}
