!SESSION 2017-05-27 19:54:17.091 -----------------------------------------------
eclipse.buildId=4.6.3.M20170301-0400
java.version=1.8.0_131
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_ES
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

This is a continuation of log file C:\Users\Alvaro\Desktop\workspace\.metadata\.bak_0.log
Created Time: 2017-05-27 19:57:20.189

!ENTRY org.eclipse.jdt.ui 4 2 2017-05-27 19:57:20.189
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 0 2017-05-27 19:57:20.189
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.core 4 4 2017-05-27 19:57:25.314
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
public class OperationsManaged
{
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, double second, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            firstInfo, new UnitInfo(second), operation
        );
    }

    public static UnitInfo PerformManagedOperationUnits(double first, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            new UnitInfo(first), secondInfo, operation
        );
    }

    //This method should always be used when dealing with random UnitInfo variables because it accounts for all the
    //possible scenarios. On the other hand, with simple operations (e.g., random UnitInfo & numeric type) it might
    //be better to use PerformManagedOperationValues. 
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        ErrorTypes errorType = InternalMethods.GetOperationError
        (
            firstInfo, secondInfo, operation
        );
        if (errorType != ErrorTypes.None)
        {
            return new UnitInfo(firstInfo) 
            {{
                Error = new ErrorInfo(errorType); 
            }};
        }

        return
        (
            operation == Operations.Addition || operation == Operations.Subtraction ?
            PerformManagedOperationAddition(firstInfo, secondInfo, operation) :
            PerformManagedOperationMultiplication(firstInfo, secondInfo, operation)
        );
    }

    static UnitInfo PerformManagedOperationAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {   
        //After being normalised, the operands might require further modifications.
        UnitInfo[] normalised = GetOperandsAddition(firstInfo, secondInfo, operation);

        return PerformManagedOperationNormalisedValues
        (
            firstInfo, normalised, operation
        );
    }

    static UnitInfo[] GetOperandsAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        UnitInfo[] operands2 = new UnitInfo[] 
        {
            new UnitInfo(firstInfo), new UnitInfo(secondInfo)
        };

        if (operands2[0].BaseTenExponent != operands2[1].BaseTenExponent || operands2[0].Prefix.Factor != operands2[1].Prefix.Factor)
        {
            //The addition/subtraction might not be performed right away even with normalised values.
            //For example: 5 and 6 from 5*10^2 and 6*10^7 cannot be added right away.
            operands2 = AdaptNormalisedValuesForAddition
            (
                new UnitInfo[] 
                { 
                    NormaliseUnitInfo(operands2[0]), 
                    NormaliseUnitInfo(operands2[1])
                },
                operation
            );
        }

        return operands2;
    }
    
    static UnitInfo[] AdaptNormalisedValuesForAddition(UnitInfo[] unitInfos2, Operations operation)
    {
        if (unitInfos2[0].BaseTenExponent == unitInfos2[1].BaseTenExponent)
        {
            //Having the same BaseTenExponent values means that the given operation can be performed right away.
            return unitInfos2;
        }

        int[] bigSmallI = 
        (
            unitInfos2[0].BaseTenExponent > unitInfos2[1].BaseTenExponent ?
            new int[] { 0, 1 } : new int[] { 1, 0 }
        );

        //Only the variable with the bigger value is modified. For example: 5*10^5 & 3*10^3 is converted
        //into 500*10^3 & 3*10^3 in order to allow the addition 500 + 3. 
        UnitInfo big2 = AdaptBiggerAdditionOperand(unitInfos2, bigSmallI, operation);
        if (big2.Error.Type != ErrorTypes.None)
        {
            return TooBigGapAddition(unitInfos2, bigSmallI, operation);
        }

        unitInfos2[bigSmallI[0]].Value = big2.Value;
        unitInfos2[bigSmallI[0]].BaseTenExponent = unitInfos2[bigSmallI[1]].BaseTenExponent;

        return unitInfos2;
    }

    //When adding/subtracting two numbers whose gap is bigger than the maximum double range, there
    //is no need to perform any operation (i.e., no change will be observed because of being outside
    //the maximum supported precision). This method takes care of these cases and returns the expected
    //output (i.e., biggest value).
    static UnitInfo[] TooBigGapAddition(UnitInfo[] unitInfos2, int[] bigSmallI, Operations operation)
    {
        UnitInfo[] outInfos = new UnitInfo[] 
        {
            //First operand (i.e., one whose information defines the operation) together with the
            //numeric information (i.e., just Value and BaseTenExponent because both are normalised)
            //which is associated with the biggest one.
            new UnitInfo(unitInfos2[0])
            {{
                Value = unitInfos2[bigSmallI[0]].Value;
                BaseTenExponent = unitInfos2[bigSmallI[0]].BaseTenExponent;
            }}
        };

        if (operation == Operations.Subtraction && bigSmallI[0] == 1)
        {
            outInfos[0].Value = -1.0 * outInfos[0].Value;
        }

        if (outInfos[0].Unit == Units.Unitless)
        {
            outInfos[0].Unit = unitInfos2[bigSmallI[1]].Unit;
        }

        return outInfos;
    }

    static UnitInfo AdaptBiggerAdditionOperand(UnitInfo[] unitInfos2, int[] bigSmallI, Operations operation)
    {
        int gapExponent = unitInfos2[bigSmallI[0]].BaseTenExponent - unitInfos2[bigSmallI[1]].BaseTenExponent;
        if (gapExponent >= 27)
        {
            //The difference between both inputs is bigger than (or, at least, very close to) the maximum double value/precision;
            //what makes this situation calculation unworthy and the first operand to be returned as the result.
            //Note that the error below these lines is just an easy way to tell the calling function about this eventuality.
            return new UnitInfo(unitInfos2[0]) 
            {{ 
                Error = new ErrorInfo(ErrorTypes.InvalidOperation); 
            }};
        }

        //PerformManagedOperationValues is used to make sure that the resulting numeric information is stored
        //in Value (if possible).
        UnitInfo big2 = PerformManagedOperationValues
        (
            RaiseToIntegerExponent(10.0, gapExponent), unitInfos2[bigSmallI[0]].Value, 
            Operations.Multiplication                
        );

        boolean isWrong = 
        (
            big2.Error.Type != ErrorTypes.None || big2.BaseTenExponent != 0 ?
            
            //The value of the bigger input times 10^(gap between BaseTenExponent of inputs) is too big. 
            isWrong = true :
            
            //Overflow-check very unlikely to trigger an error. In fact, with properly normalised variables,
            //triggering an error would be plainly impossible.               
            AreAdditionFinalValuesWrong
            (
                unitInfos2[0].Value, unitInfos2[1].Value, operation
            )
        );

        return
        (
            isWrong ?
            //This error is just an easy way to let the calling function know about the fact that no
            //calculation has been performed (too big gap). This isn't a properly-speaking error and
            //that's why it will not be notified to the user.
            new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }} :
            //Returning the new big value. For example: with 5*10^4 & 3*10^2, 500 would be returned.
            new UnitInfo(unitInfos2[bigSmallI[0]])
            {{
                Value = big2.Value;
            }}
        );
    }

    static boolean AreAdditionFinalValuesWrong(double val1, double val2, Operations operation)
    {
        boolean isWrong = false;

        try
        {
            val1 = val1 + val2 *
            (
                operation == Operations.Addition ? 1 : -1
            );
        }
        catch { isWrong = true; }

        return isWrong;
    }

    static UnitInfo PerformManagedOperationMultiplication(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationNormalisedValues
        (
            firstInfo, new UnitInfo[] 
            { 
                NormaliseUnitInfo(firstInfo),
                NormaliseUnitInfo(secondInfo) 
            },
            operation
        );
    }

    public static UnitInfo RaiseToIntegerExponent(double baseValue, int exponent)
    {
        return RaiseToIntegerExponent(new UnitInfo(baseValue), exponent);
    }

    static UnitInfo RaiseToIntegerExponent(UnitInfo baseInfo, int exponent)
    {
        if (exponent <= 1 && exponent >= 0)
        {
            baseInfo.Value = (exponent == 0 ? 1.0 : baseInfo.Value);
            return baseInfo;
        }

        UnitInfo outInfo = new UnitInfo(baseInfo);

        for (int i = 1; i < Math.Abs(exponent); i++)
        {
            outInfo = PerformManagedOperationValues
            (
                outInfo, baseInfo, Operations.Multiplication
            );
            if (outInfo.Error.Type != ErrorTypes.None) return outInfo;
        }

        return
        (
            exponent < 0 ?
            PerformManagedOperationValues(new UnitInfo(1.0), outInfo, Operations.Division) :
            outInfo
        );
    }

    static UnitInfo PerformManagedOperationNormalisedValues(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        outInfo =
        (
            normalisedInfos.Length == 1 ?
            //There is just one operand when the difference between both of them is too big.
            outInfo = normalisedInfos[0] :
            PerformManagedOperationTwoOperands(outInfo, normalisedInfos, operation)
        );

        return outInfo;
    }

    static UnitInfo PerformManagedOperationTwoOperands(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        UnitInfo outInfoNormalised = PerformManagedOperationValues
        (
            normalisedInfos[0], normalisedInfos[1], operation
        );

        if (outInfo.Error.Type != ErrorTypes.None)
        {
            return new UnitInfo(outInfo)
            {
                Error = new ErrorInfo(ErrorTypes.NumericError)
            };
        }

        outInfo.BaseTenExponent = outInfoNormalised.BaseTenExponent;
        outInfo.Value = outInfoNormalised.Value;
        //Normalised means no prefixes.
        outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage); 

        return outInfo;
    }

    static UnitInfo PerformManagedOperationValues(double firstValue, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            new UnitInfo(firstValue), new UnitInfo(secondValue), operation
        );
    }

    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            firstInfo, new UnitInfo(secondValue), operation
        );
    }

    //This method might be used to perform full operations (not just being the last calculation step) instead
    //of the default one (PerformManagedOperationUnits) for simple cases. That is: ones not dealing with the
    //complex numeric reality (Value, Prefix and BaseTenExponent) which makes a pre-analysis required.
    //Note that, unlikely what happens with PerformMangedOperationUnits, the outputs of this method aren't
    //normalised (= primarily stored under Value), what is useful in certain contexts.
    //NOTE: this function assumes that both inputs are normalised, what means that no prefix information is expected.
    //It might also be used with non-normalised inputs, but their prefix information would be plainly ignored.
    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        if (firstInfo.Value == 0.0 || secondInfo.Value == 0.0)
        {
            if (operation == Operations.Multiplication || operation == Operations.Division)
            {
                //Dividing by zero scenarios are taken into account somewhere else.
                return new UnitInfo(firstInfo) { Value = 0.0 };
            }
        }

        UnitInfo outInfo = new UnitInfo(firstInfo);
        UnitInfo firstInfo0 = new UnitInfo(firstInfo);
        UnitInfo secondInfo0 = new UnitInfo(secondInfo);

        boolean isWrong = false;
        try
        {
            if (operation == Operations.Addition)
            {
                outInfo.Value += secondInfo0.Value;
            }
            else if (operation == Operations.Subtraction)
            {
                outInfo.Value -= secondInfo.Value;
            }
            else
            {
                //The reason for checking whether BaseTenExponent is inside/outside the int range before performing 
                //the operation (rather than going ahead and eventually catching the resulting exception) isn't just
                //being quicker, but also the only option in many situations. Note that an addition/subtraction between
                //two int variables whose result is outside the int range might not trigger an exception (+ random 
                //negative value as output).
                if (VaryBaseTenExponent(outInfo, secondInfo0.BaseTenExponent, operation == Operations.Division).Error.Type != ErrorTypes.None)
                {
                    return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
                }

                if (operation == Operations.Multiplication)
                {
                    outInfo.Value *= secondInfo.Value;
                    outInfo.BaseTenExponent += secondInfo.BaseTenExponent;
                }
                else if (operation == Operations.Division)
                {
                    if (secondInfo.Value == 0.0)
                    {
                        return
                        (
                            new UnitInfo(outInfo) 
                            { 
                                Error = new ErrorInfo(ErrorTypes.NumericError) 
                            }
                        );
                    }
                    outInfo.Value /= secondInfo.Value;
                    outInfo.BaseTenExponent -= secondInfo.BaseTenExponent;
                }
            }
        }
        catch { isWrong = true; }

        return
        (
            //An error might not be triggered despite of dealing with numbers outside double precision.
            //For example: 0.00000000000000000001m * 0.0000000000000000000001m can output 0.0 without triggering an error. 
            isWrong || ((operation == Operations.Multiplication || operation == Operations.Division) && outInfo.Value == 0.0.0) ?
            OperationValuesManageError(firstInfo0, secondInfo0, operation) : outInfo
        );
    }

    static UnitInfo OperationValuesManageError(UnitInfo outInfo, UnitInfo secondInfo, Operations operation)
    {
        if (operation != Operations.Multiplication && operation != Operations.Division)
        {
            //This condition should never be true on account of the fact that the pre-modifications performed before
            //adding/subtracting should avoid erroneous situations.
            return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
        }

        UnitInfo secondInfo2 = ConvertValueToBaseTen(secondInfo.Value);
        outInfo = VaryBaseTenExponent(outInfo, secondInfo2.BaseTenExponent, operation == Operations.Division);
        if (Math.Abs(secondInfo2.Value) == 1.0 || outInfo.Error.Type != ErrorTypes.None) return outInfo;
        
        try
        {
            outInfo = PerformManagedOperationUnits
            (
                outInfo, secondInfo2.Value, operation
            );
        }
        catch
        {
            //Very unlikely scenario on account of the fact that Math.Abs(secondInfo2.Value)
            //lies within the 0.1-10.0 range.
            outInfo = OperationValuesManageError
            (
                new UnitInfo(outInfo)
                {
                    Value = secondInfo2.Value,
                    BaseTenExponent = 0
                },
                new UnitInfo()
                {
                    Value = outInfo.Value,
                    BaseTenExponent = outInfo.BaseTenExponent
                },
                operation
            );
        }

        return outInfo;
    }

    static UnitInfo ConvertValueToBaseTen(double value)
    {
        value = Math.Abs(value);
        return FromValueToBaseTenExponent
        (
             new UnitInfo(value), Math.Abs(value), false
        );
    }

    static UnitInfo ConvertBaseTenToValue(UnitInfo unitInfo)
    {
        if (unitInfo.BaseTenExponent == 0) return unitInfo;

        UnitInfo outInfo = new UnitInfo(unitInfo);
        boolean decrease = unitInfo.BaseTenExponent > 0;
        int sign = Math.Sign(outInfo.Value);
        double absValue = Math.Abs(outInfo.Value);

        while (outInfo.BaseTenExponent != 0.0)
        {
            if (decrease)
            {
                if (absValue >= MaxValueDec / 10.0) break;
                absValue *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }
            else
            {
                if (absValue <= MinValueDec * 10.0) break;
                absValue /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
        }

        outInfo.Value = sign * absValue;

        return outInfo;
    }

    static UnitInfo NormaliseUnitInfo(UnitInfo unitInfo)
    {
        if (unitInfo.Value == 0 && unitInfo.Prefix.Factor == 1.0)
        {
            return unitInfo;
        }
        UnitInfo outInfo = new UnitInfo(unitInfo);

        if (outInfo.Prefix.Factor != 1)
        {
            outInfo = FromValueToBaseTenExponent
            (
                outInfo, outInfo.Prefix.Factor, true
            );
            outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage);
        }
        if (outInfo.Value == 0.0) return outInfo;

        outInfo = FromValueToBaseTenExponent
        (
            outInfo, outInfo.Value, false
        );

        return outInfo;
    }

    static UnitInfo FromValueToBaseTenExponent(UnitInfo outInfo, double value, boolean isPrefix)
    {
        if (value == 0.0) return outInfo;

        double valueAbs = Math.Abs(value);
        boolean decrease = (valueAbs > 1.0);
        if (!isPrefix)
        {
            outInfo.Value = outInfo.Value / valueAbs;
        }

        while (valueAbs != 1.0)
        {
            if ((valueAbs < 10.0 && valueAbs > 1.0) || (valueAbs > 0.1.0 && valueAbs < 1.0))
            {
                if (!isPrefix) outInfo.Value = value;
                else
                {
                    outInfo = PerformManagedOperationValues
                    (
                        outInfo, value, Operations.Multiplication
                    );
                }

                return outInfo;
            }

            if (decrease)
            {
                value /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
            else
            {
                value *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }

            valueAbs = Math.Abs(value);
        }

        return outInfo;
    }

    //Method used to vary BaseTenExponent without provoking unhandled exceptions (i.e., bigger than Integer.MAX_VALUE).
    static UnitInfo VaryBaseTenExponent(UnitInfo info, int baseTenIncrease, boolean isDivision = false)
    {
        long val1 = info.BaseTenExponent;
        long val2 = baseTenIncrease;

        if (isDivision)
        {
            //Converting a negative value into positive might provoke an overflow error for the int type
            //(e.g., Math.Abs(Integer.MAIN_VALUE)). Converting both variables to long is a quick and effective
            //way to avoid this problem.
            val2 *= -1;
        }

        return
        (
             ((val2 > 0 && val1 > Integer.MAX_VALUE - val2) || (val2 < 0 && val1 < Integer.MAIN_VALUE - val2)) ?
            new UnitInfo(info, ErrorTypes.NumericError) : new UnitInfo(info){{ BaseTenExponent = (int)(val1 + val2); }}
        );
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:207)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2017-05-27 19:57:25.315
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:207)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2017-05-27 19:57:25.315
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:207)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2017-05-27 19:57:25.347
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
public class OperationsManaged
{
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, double second, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            firstInfo, new UnitInfo(second), operation
        );
    }

    public static UnitInfo PerformManagedOperationUnits(double first, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            new UnitInfo(first), secondInfo, operation
        );
    }

    //This method should always be used when dealing with random UnitInfo variables because it accounts for all the
    //possible scenarios. On the other hand, with simple operations (e.g., random UnitInfo & numeric type) it might
    //be better to use PerformManagedOperationValues. 
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        ErrorTypes errorType = InternalMethods.GetOperationError
        (
            firstInfo, secondInfo, operation
        );
        if (errorType != ErrorTypes.None)
        {
            return new UnitInfo(firstInfo) 
            {{
                Error = new ErrorInfo(errorType); 
            }};
        }

        return
        (
            operation == Operations.Addition || operation == Operations.Subtraction ?
            PerformManagedOperationAddition(firstInfo, secondInfo, operation) :
            PerformManagedOperationMultiplication(firstInfo, secondInfo, operation)
        );
    }

    static UnitInfo PerformManagedOperationAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {   
        //After being normalised, the operands might require further modifications.
        UnitInfo[] normalised = GetOperandsAddition(firstInfo, secondInfo, operation);

        return PerformManagedOperationNormalisedValues
        (
            firstInfo, normalised, operation
        );
    }

    static UnitInfo[] GetOperandsAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        UnitInfo[] operands2 = new UnitInfo[] 
        {
            new UnitInfo(firstInfo), new UnitInfo(secondInfo)
        };

        if (operands2[0].BaseTenExponent != operands2[1].BaseTenExponent || operands2[0].Prefix.Factor != operands2[1].Prefix.Factor)
        {
            //The addition/subtraction might not be performed right away even with normalised values.
            //For example: 5 and 6 from 5*10^2 and 6*10^7 cannot be added right away.
            operands2 = AdaptNormalisedValuesForAddition
            (
                new UnitInfo[] 
                { 
                    NormaliseUnitInfo(operands2[0]), 
                    NormaliseUnitInfo(operands2[1])
                },
                operation
            );
        }

        return operands2;
    }
    
    static UnitInfo[] AdaptNormalisedValuesForAddition(UnitInfo[] unitInfos2, Operations operation)
    {
        if (unitInfos2[0].BaseTenExponent == unitInfos2[1].BaseTenExponent)
        {
            //Having the same BaseTenExponent values means that the given operation can be performed right away.
            return unitInfos2;
        }

        int[] bigSmallI = 
        (
            unitInfos2[0].BaseTenExponent > unitInfos2[1].BaseTenExponent ?
            new int[] { 0, 1 } : new int[] { 1, 0 }
        );

        //Only the variable with the bigger value is modified. For example: 5*10^5 & 3*10^3 is converted
        //into 500*10^3 & 3*10^3 in order to allow the addition 500 + 3. 
        UnitInfo big2 = AdaptBiggerAdditionOperand(unitInfos2, bigSmallI, operation);
        if (big2.Error.Type != ErrorTypes.None)
        {
            return TooBigGapAddition(unitInfos2, bigSmallI, operation);
        }

        unitInfos2[bigSmallI[0]].Value = big2.Value;
        unitInfos2[bigSmallI[0]].BaseTenExponent = unitInfos2[bigSmallI[1]].BaseTenExponent;

        return unitInfos2;
    }

    //When adding/subtracting two numbers whose gap is bigger than the maximum double range, there
    //is no need to perform any operation (i.e., no change will be observed because of being outside
    //the maximum supported precision). This method takes care of these cases and returns the expected
    //output (i.e., biggest value).
    static UnitInfo[] TooBigGapAddition(UnitInfo[] unitInfos2, int[] bigSmallI, Operations operation)
    {
        UnitInfo[] outInfos = new UnitInfo[] 
        {
            //First operand (i.e., one whose information defines the operation) together with the
            //numeric information (i.e., just Value and BaseTenExponent because both are normalised)
            //which is associated with the biggest one.
            new UnitInfo(unitInfos2[0])
            {{
                Value = unitInfos2[bigSmallI[0]].Value;
                BaseTenExponent = unitInfos2[bigSmallI[0]].BaseTenExponent;
            }}
        };

        if (operation == Operations.Subtraction && bigSmallI[0] == 1)
        {
            outInfos[0].Value = -1.0 * outInfos[0].Value;
        }

        if (outInfos[0].Unit == Units.Unitless)
        {
            outInfos[0].Unit = unitInfos2[bigSmallI[1]].Unit;
        }

        return outInfos;
    }

    static UnitInfo AdaptBiggerAdditionOperand(UnitInfo[] unitInfos2, int[] bigSmallI, Operations operation)
    {
        int gapExponent = unitInfos2[bigSmallI[0]].BaseTenExponent - unitInfos2[bigSmallI[1]].BaseTenExponent;
        if (gapExponent >= 27)
        {
            //The difference between both inputs is bigger than (or, at least, very close to) the maximum double value/precision;
            //what makes this situation calculation unworthy and the first operand to be returned as the result.
            //Note that the error below these lines is just an easy way to tell the calling function about this eventuality.
            return new UnitInfo(unitInfos2[0]) 
            {{ 
                Error = new ErrorInfo(ErrorTypes.InvalidOperation); 
            }};
        }

        //PerformManagedOperationValues is used to make sure that the resulting numeric information is stored
        //in Value (if possible).
        UnitInfo big2 = PerformManagedOperationValues
        (
            RaiseToIntegerExponent(10.0, gapExponent), unitInfos2[bigSmallI[0]].Value, 
            Operations.Multiplication                
        );

        boolean isWrong = 
        (
            big2.Error.Type != ErrorTypes.None || big2.BaseTenExponent != 0 ?
            
            //The value of the bigger input times 10^(gap between BaseTenExponent of inputs) is too big. 
            isWrong = true :
            
            //Overflow-check very unlikely to trigger an error. In fact, with properly normalised variables,
            //triggering an error would be plainly impossible.               
            AreAdditionFinalValuesWrong
            (
                unitInfos2[0].Value, unitInfos2[1].Value, operation
            )
        );

        return
        (
            isWrong ?
            //This error is just an easy way to let the calling function know about the fact that no
            //calculation has been performed (too big gap). This isn't a properly-speaking error and
            //that's why it will not be notified to the user.
            new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }} :
            //Returning the new big value. For example: with 5*10^4 & 3*10^2, 500 would be returned.
            new UnitInfo(unitInfos2[bigSmallI[0]])
            {{
                Value = big2.Value;
            }}
        );
    }

    static boolean AreAdditionFinalValuesWrong(double val1, double val2, Operations operation)
    {
        boolean isWrong = false;

        try
        {
            val1 = val1 + val2 *
            (
                operation == Operations.Addition ? 1 : -1
            );
        }
        catch { isWrong = true; }

        return isWrong;
    }

    static UnitInfo PerformManagedOperationMultiplication(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationNormalisedValues
        (
            firstInfo, new UnitInfo[] 
            { 
                NormaliseUnitInfo(firstInfo),
                NormaliseUnitInfo(secondInfo) 
            },
            operation
        );
    }

    public static UnitInfo RaiseToIntegerExponent(double baseValue, int exponent)
    {
        return RaiseToIntegerExponent(new UnitInfo(baseValue), exponent);
    }

    static UnitInfo RaiseToIntegerExponent(UnitInfo baseInfo, int exponent)
    {
        if (exponent <= 1 && exponent >= 0)
        {
            baseInfo.Value = (exponent == 0 ? 1.0 : baseInfo.Value);
            return baseInfo;
        }

        UnitInfo outInfo = new UnitInfo(baseInfo);

        for (int i = 1; i < Math.Abs(exponent); i++)
        {
            outInfo = PerformManagedOperationValues
            (
                outInfo, baseInfo, Operations.Multiplication
            );
            if (outInfo.Error.Type != ErrorTypes.None) return outInfo;
        }

        return
        (
            exponent < 0 ?
            PerformManagedOperationValues(new UnitInfo(1.0), outInfo, Operations.Division) :
            outInfo
        );
    }

    static UnitInfo PerformManagedOperationNormalisedValues(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        outInfo =
        (
            normalisedInfos.Length == 1 ?
            //There is just one operand when the difference between both of them is too big.
            outInfo = normalisedInfos[0] :
            PerformManagedOperationTwoOperands(outInfo, normalisedInfos, operation)
        );

        return outInfo;
    }

    static UnitInfo PerformManagedOperationTwoOperands(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        UnitInfo outInfoNormalised = PerformManagedOperationValues
        (
            normalisedInfos[0], normalisedInfos[1], operation
        );

        if (outInfo.Error.Type != ErrorTypes.None)
        {
            return new UnitInfo(outInfo)
            {
                Error = new ErrorInfo(ErrorTypes.NumericError)
            };
        }

        outInfo.BaseTenExponent = outInfoNormalised.BaseTenExponent;
        outInfo.Value = outInfoNormalised.Value;
        //Normalised means no prefixes.
        outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage); 

        return outInfo;
    }

    static UnitInfo PerformManagedOperationValues(double firstValue, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            new UnitInfo(firstValue), new UnitInfo(secondValue), operation
        );
    }

    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            firstInfo, new UnitInfo(secondValue), operation
        );
    }

    //This method might be used to perform full operations (not just being the last calculation step) instead
    //of the default one (PerformManagedOperationUnits) for simple cases. That is: ones not dealing with the
    //complex numeric reality (Value, Prefix and BaseTenExponent) which makes a pre-analysis required.
    //Note that, unlikely what happens with PerformMangedOperationUnits, the outputs of this method aren't
    //normalised (= primarily stored under Value), what is useful in certain contexts.
    //NOTE: this function assumes that both inputs are normalised, what means that no prefix information is expected.
    //It might also be used with non-normalised inputs, but their prefix information would be plainly ignored.
    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        if (firstInfo.Value == 0.0 || secondInfo.Value == 0.0)
        {
            if (operation == Operations.Multiplication || operation == Operations.Division)
            {
                //Dividing by zero scenarios are taken into account somewhere else.
                return new UnitInfo(firstInfo) { Value = 0.0 };
            }
        }

        UnitInfo outInfo = new UnitInfo(firstInfo);
        UnitInfo firstInfo0 = new UnitInfo(firstInfo);
        UnitInfo secondInfo0 = new UnitInfo(secondInfo);

        boolean isWrong = false;
        try
        {
            if (operation == Operations.Addition)
            {
                outInfo.Value += secondInfo0.Value;
            }
            else if (operation == Operations.Subtraction)
            {
                outInfo.Value -= secondInfo.Value;
            }
            else
            {
                //The reason for checking whether BaseTenExponent is inside/outside the int range before performing 
                //the operation (rather than going ahead and eventually catching the resulting exception) isn't just
                //being quicker, but also the only option in many situations. Note that an addition/subtraction between
                //two int variables whose result is outside the int range might not trigger an exception (+ random 
                //negative value as output).
                if (VaryBaseTenExponent(outInfo, secondInfo0.BaseTenExponent, operation == Operations.Division).Error.Type != ErrorTypes.None)
                {
                    return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
                }

                if (operation == Operations.Multiplication)
                {
                    outInfo.Value *= secondInfo.Value;
                    outInfo.BaseTenExponent += secondInfo.BaseTenExponent;
                }
                else if (operation == Operations.Division)
                {
                    if (secondInfo.Value == 0.0)
                    {
                        return
                        (
                            new UnitInfo(outInfo) 
                            { 
                                Error = new ErrorInfo(ErrorTypes.NumericError) 
                            }
                        );
                    }
                    outInfo.Value /= secondInfo.Value;
                    outInfo.BaseTenExponent -= secondInfo.BaseTenExponent;
                }
            }
        }
        catch { isWrong = true; }

        return
        (
            //An error might not be triggered despite of dealing with numbers outside double precision.
            //For example: 0.00000000000000000001m * 0.0000000000000000000001m can output 0.0 without triggering an error. 
            isWrong || ((operation == Operations.Multiplication || operation == Operations.Division) && outInfo.Value == 0.0.0) ?
            OperationValuesManageError(firstInfo0, secondInfo0, operation) : outInfo
        );
    }

    static UnitInfo OperationValuesManageError(UnitInfo outInfo, UnitInfo secondInfo, Operations operation)
    {
        if (operation != Operations.Multiplication && operation != Operations.Division)
        {
            //This condition should never be true on account of the fact that the pre-modifications performed before
            //adding/subtracting should avoid erroneous situations.
            return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
        }

        UnitInfo secondInfo2 = ConvertValueToBaseTen(secondInfo.Value);
        outInfo = VaryBaseTenExponent(outInfo, secondInfo2.BaseTenExponent, operation == Operations.Division);
        if (Math.Abs(secondInfo2.Value) == 1.0 || outInfo.Error.Type != ErrorTypes.None) return outInfo;
        
        try
        {
            outInfo = PerformManagedOperationUnits
            (
                outInfo, secondInfo2.Value, operation
            );
        }
        catch
        {
            //Very unlikely scenario on account of the fact that Math.Abs(secondInfo2.Value)
            //lies within the 0.1-10.0 range.
            outInfo = OperationValuesManageError
            (
                new UnitInfo(outInfo)
                {
                    Value = secondInfo2.Value,
                    BaseTenExponent = 0
                },
                new UnitInfo()
                {
                    Value = outInfo.Value,
                    BaseTenExponent = outInfo.BaseTenExponent
                },
                operation
            );
        }

        return outInfo;
    }

    static UnitInfo ConvertValueToBaseTen(double value)
    {
        value = Math.Abs(value);
        return FromValueToBaseTenExponent
        (
             new UnitInfo(value), Math.Abs(value), false
        );
    }

    static UnitInfo ConvertBaseTenToValue(UnitInfo unitInfo)
    {
        if (unitInfo.BaseTenExponent == 0) return unitInfo;

        UnitInfo outInfo = new UnitInfo(unitInfo);
        boolean decrease = unitInfo.BaseTenExponent > 0;
        int sign = Math.Sign(outInfo.Value);
        double absValue = Math.Abs(outInfo.Value);

        while (outInfo.BaseTenExponent != 0.0)
        {
            if (decrease)
            {
                if (absValue >= MaxValueDec / 10.0) break;
                absValue *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }
            else
            {
                if (absValue <= MinValueDec * 10.0) break;
                absValue /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
        }

        outInfo.Value = sign * absValue;

        return outInfo;
    }

    static UnitInfo NormaliseUnitInfo(UnitInfo unitInfo)
    {
        if (unitInfo.Value == 0 && unitInfo.Prefix.Factor == 1.0)
        {
            return unitInfo;
        }
        UnitInfo outInfo = new UnitInfo(unitInfo);

        if (outInfo.Prefix.Factor != 1)
        {
            outInfo = FromValueToBaseTenExponent
            (
                outInfo, outInfo.Prefix.Factor, true
            );
            outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage);
        }
        if (outInfo.Value == 0.0) return outInfo;

        outInfo = FromValueToBaseTenExponent
        (
            outInfo, outInfo.Value, false
        );

        return outInfo;
    }

    static UnitInfo FromValueToBaseTenExponent(UnitInfo outInfo, double value, boolean isPrefix)
    {
        if (value == 0.0) return outInfo;

        double valueAbs = Math.Abs(value);
        boolean decrease = (valueAbs > 1.0);
        if (!isPrefix)
        {
            outInfo.Value = outInfo.Value / valueAbs;
        }

        while (valueAbs != 1.0)
        {
            if ((valueAbs < 10.0 && valueAbs > 1.0) || (valueAbs > 0.1.0 && valueAbs < 1.0))
            {
                if (!isPrefix) outInfo.Value = value;
                else
                {
                    outInfo = PerformManagedOperationValues
                    (
                        outInfo, value, Operations.Multiplication
                    );
                }

                return outInfo;
            }

            if (decrease)
            {
                value /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
            else
            {
                value *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }

            valueAbs = Math.Abs(value);
        }

        return outInfo;
    }

    //Method used to vary BaseTenExponent without provoking unhandled exceptions (i.e., bigger than Integer.MAX_VALUE).
    static UnitInfo VaryBaseTenExponent(UnitInfo info, int baseTenIncrease, boolean isDivision = false)
    {
        long val1 = info.BaseTenExponent;
        long val2 = baseTenIncrease;

        if (isDivision)
        {
            //Converting a negative value into positive might provoke an overflow error for the int type
            //(e.g., Math.Abs(Integer.MAIN_VALUE)). Converting both variables to long is a quick and effective
            //way to avoid this problem.
            val2 *= -1;
        }

        return
        (
             ((val2 > 0 && val1 > Integer.MAX_VALUE - val2) || (val2 < 0 && val1 < Integer.MAIN_VALUE - val2)) ?
            new UnitInfo(info, ErrorTypes.NumericError) : new UnitInfo(info){{ BaseTenExponent = (int)(val1 + val2); }}
        );
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:476)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:157)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:132)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:260)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:260)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:100)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:383)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:367)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:327)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 2 2017-05-27 19:57:25.348
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:476)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:157)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:132)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:260)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:260)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:100)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:383)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:367)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:327)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 0 2017-05-27 19:57:25.349
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:476)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:157)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:132)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:260)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:260)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:100)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:383)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:367)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:327)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.core 4 4 2017-05-27 19:57:32.300
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
public class OperationsManaged
{
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, double second, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            firstInfo, new UnitInfo(second), operation
        );
    }

    public static UnitInfo PerformManagedOperationUnits(double first, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            new UnitInfo(first), secondInfo, operation
        );
    }

    //This method should always be used when dealing with random UnitInfo variables because it accounts for all the
    //possible scenarios. On the other hand, with simple operations (e.g., random UnitInfo & numeric type) it might
    //be better to use PerformManagedOperationValues. 
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        ErrorTypes errorType = InternalMethods.GetOperationError
        (
            firstInfo, secondInfo, operation
        );
        if (errorType != ErrorTypes.None)
        {
            return new UnitInfo(firstInfo) 
            {{
                Error = new ErrorInfo(errorType); 
            }};
        }

        return
        (
            operation == Operations.Addition || operation == Operations.Subtraction ?
            PerformManagedOperationAddition(firstInfo, secondInfo, operation) :
            PerformManagedOperationMultiplication(firstInfo, secondInfo, operation)
        );
    }

    static UnitInfo PerformManagedOperationAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {   
        //After being normalised, the operands might require further modifications.
        UnitInfo[] normalised = GetOperandsAddition(firstInfo, secondInfo, operation);

        return PerformManagedOperationNormalisedValues
        (
            firstInfo, normalised, operation
        );
    }

    static UnitInfo[] GetOperandsAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        UnitInfo[] operands2 = new UnitInfo[] 
        {
            new UnitInfo(firstInfo), new UnitInfo(secondInfo)
        };

        if (operands2[0].BaseTenExponent != operands2[1].BaseTenExponent || operands2[0].Prefix.Factor != operands2[1].Prefix.Factor)
        {
            //The addition/subtraction might not be performed right away even with normalised values.
            //For example: 5 and 6 from 5*10^2 and 6*10^7 cannot be added right away.
            operands2 = AdaptNormalisedValuesForAddition
            (
                new UnitInfo[] 
                { 
                    NormaliseUnitInfo(operands2[0]), 
                    NormaliseUnitInfo(operands2[1])
                },
                operation
            );
        }

        return operands2;
    }
    
    static UnitInfo[] AdaptNormalisedValuesForAddition(UnitInfo[] unitInfos2, Operations operation)
    {
        if (unitInfos2[0].BaseTenExponent == unitInfos2[1].BaseTenExponent)
        {
            //Having the same BaseTenExponent values means that the given operation can be performed right away.
            return unitInfos2;
        }

        int[] bigSmallI = 
        (
            unitInfos2[0].BaseTenExponent > unitInfos2[1].BaseTenExponent ?
            new int[] { 0, 1 } : new int[] { 1, 0 }
        );

        //Only the variable with the bigger value is modified. For example: 5*10^5 & 3*10^3 is converted
        //into 500*10^3 & 3*10^3 in order to allow the addition 500 + 3. 
        UnitInfo big2 = AdaptBiggerAdditionOperand(unitInfos2, bigSmallI, operation);
        if (big2.Error.Type != ErrorTypes.None)
        {
            return TooBigGapAddition(unitInfos2, bigSmallI, operation);
        }

        unitInfos2[bigSmallI[0]].Value = big2.Value;
        unitInfos2[bigSmallI[0]].BaseTenExponent = unitInfos2[bigSmallI[1]].BaseTenExponent;

        return unitInfos2;
    }

    //When adding/subtracting two numbers whose gap is bigger than the maximum double range, there
    //is no need to perform any operation (i.e., no change will be observed because of being outside
    //the maximum supported precision). This method takes care of these cases and returns the expected
    //output (i.e., biggest value).
    static UnitInfo[] TooBigGapAddition(UnitInfo[] unitInfos2, int[] bigSmallI, Operations operation)
    {
        UnitInfo[] outInfos = new UnitInfo[] 
        {
            //First operand (i.e., one whose information defines the operation) together with the
            //numeric information (i.e., just Value and BaseTenExponent because both are normalised)
            //which is associated with the biggest one.
            new UnitInfo(unitInfos2[0])
            {{
                Value = unitInfos2[bigSmallI[0]].Value;
                BaseTenExponent = unitInfos2[bigSmallI[0]].BaseTenExponent;
            }}
        };

        if (operation == Operations.Subtraction && bigSmallI[0] == 1)
        {
            outInfos[0].Value = -1.0 * outInfos[0].Value;
        }

        if (outInfos[0].Unit == Units.Unitless)
        {
            outInfos[0].Unit = unitInfos2[bigSmallI[1]].Unit;
        }

        return outInfos;
    }

    static UnitInfo AdaptBiggerAdditionOperand(UnitInfo[] unitInfos2, int[] bigSmallI, Operations operation)
    {
        int gapExponent = unitInfos2[bigSmallI[0]].BaseTenExponent - unitInfos2[bigSmallI[1]].BaseTenExponent;
        if (gapExponent >= 27)
        {
            //The difference between both inputs is bigger than (or, at least, very close to) the maximum double value/precision;
            //what makes this situation calculation unworthy and the first operand to be returned as the result.
            //Note that the error below these lines is just an easy way to tell the calling function about this eventuality.
            return new UnitInfo(unitInfos2[0]) 
            {{ 
                Error = new ErrorInfo(ErrorTypes.InvalidOperation); 
            }};
        }

        //PerformManagedOperationValues is used to make sure that the resulting numeric information is stored
        //in Value (if possible).
        UnitInfo big2 = PerformManagedOperationValues
        (
            RaiseToIntegerExponent(10.0, gapExponent), unitInfos2[bigSmallI[0]].Value, 
            Operations.Multiplication                
        );

        boolean isWrong = 
        (
            big2.Error.Type != ErrorTypes.None || big2.BaseTenExponent != 0 ?
            
            //The value of the bigger input times 10^(gap between BaseTenExponent of inputs) is too big. 
            isWrong = true :
            
            //Overflow-check very unlikely to trigger an error. In fact, with properly normalised variables,
            //triggering an error would be plainly impossible.               
            AreAdditionFinalValuesWrong
            (
                unitInfos2[0].Value, unitInfos2[1].Value, operation
            )
        );

        return
        (
            isWrong ?
            //This error is just an easy way to let the calling function know about the fact that no
            //calculation has been performed (too big gap). This isn't a properly-speaking error and
            //that's why it will not be notified to the user.
            new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }} :
            //Returning the new big value. For example: with 5*10^4 & 3*10^2, 500 would be returned.
            new UnitInfo(unitInfos2[bigSmallI[0]])
            {{
                Value = big2.Value;
            }}
        );
    }

    static boolean AreAdditionFinalValuesWrong(double val1, double val2, Operations operation)
    {
        boolean isWrong = false;

        try
        {
            val1 = val1 + val2 *
            (
                operation == Operations.Addition ? 1 : -1
            );
        }
        catch { isWrong = true; }

        return isWrong;
    }

    static UnitInfo PerformManagedOperationMultiplication(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationNormalisedValues
        (
            firstInfo, new UnitInfo[] 
            { 
                NormaliseUnitInfo(firstInfo),
                NormaliseUnitInfo(secondInfo) 
            },
            operation
        );
    }

    public static UnitInfo RaiseToIntegerExponent(double baseValue, int exponent)
    {
        return RaiseToIntegerExponent(new UnitInfo(baseValue), exponent);
    }

    static UnitInfo RaiseToIntegerExponent(UnitInfo baseInfo, int exponent)
    {
        if (exponent <= 1 && exponent >= 0)
        {
            baseInfo.Value = (exponent == 0 ? 1.0 : baseInfo.Value);
            return baseInfo;
        }

        UnitInfo outInfo = new UnitInfo(baseInfo);

        for (int i = 1; i < Math.Abs(exponent); i++)
        {
            outInfo = PerformManagedOperationValues
            (
                outInfo, baseInfo, Operations.Multiplication
            );
            if (outInfo.Error.Type != ErrorTypes.None) return outInfo;
        }

        return
        (
            exponent < 0 ?
            PerformManagedOperationValues(new UnitInfo(1.0), outInfo, Operations.Division) :
            outInfo
        );
    }

    static UnitInfo PerformManagedOperationNormalisedValues(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        outInfo =
        (
            normalisedInfos.Length == 1 ?
            //There is just one operand when the difference between both of them is too big.
            outInfo = normalisedInfos[0] :
            PerformManagedOperationTwoOperands(outInfo, normalisedInfos, operation)
        );

        return outInfo;
    }

    static UnitInfo PerformManagedOperationTwoOperands(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        UnitInfo outInfoNormalised = PerformManagedOperationValues
        (
            normalisedInfos[0], normalisedInfos[1], operation
        );

        if (outInfo.Error.Type != ErrorTypes.None)
        {
            return new UnitInfo(outInfo)
            {
                Error = new ErrorInfo(ErrorTypes.NumericError)
            };
        }

        outInfo.BaseTenExponent = outInfoNormalised.BaseTenExponent;
        outInfo.Value = outInfoNormalised.Value;
        //Normalised means no prefixes.
        outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage); 

        return outInfo;
    }

    static UnitInfo PerformManagedOperationValues(double firstValue, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            new UnitInfo(firstValue), new UnitInfo(secondValue), operation
        );
    }

    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            firstInfo, new UnitInfo(secondValue), operation
        );
    }

    //This method might be used to perform full operations (not just being the last calculation step) instead
    //of the default one (PerformManagedOperationUnits) for simple cases. That is: ones not dealing with the
    //complex numeric reality (Value, Prefix and BaseTenExponent) which makes a pre-analysis required.
    //Note that, unlikely what happens with PerformMangedOperationUnits, the outputs of this method aren't
    //normalised (= primarily stored under Value), what is useful in certain contexts.
    //NOTE: this function assumes that both inputs are normalised, what means that no prefix information is expected.
    //It might also be used with non-normalised inputs, but their prefix information would be plainly ignored.
    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        if (firstInfo.Value == 0.0 || secondInfo.Value == 0.0)
        {
            if (operation == Operations.Multiplication || operation == Operations.Division)
            {
                //Dividing by zero scenarios are taken into account somewhere else.
                return new UnitInfo(firstInfo) { Value = 0.0 };
            }
        }

        UnitInfo outInfo = new UnitInfo(firstInfo);
        UnitInfo firstInfo0 = new UnitInfo(firstInfo);
        UnitInfo secondInfo0 = new UnitInfo(secondInfo);

        boolean isWrong = false;
        try
        {
            if (operation == Operations.Addition)
            {
                outInfo.Value += secondInfo0.Value;
            }
            else if (operation == Operations.Subtraction)
            {
                outInfo.Value -= secondInfo.Value;
            }
            else
            {
                //The reason for checking whether BaseTenExponent is inside/outside the int range before performing 
                //the operation (rather than going ahead and eventually catching the resulting exception) isn't just
                //being quicker, but also the only option in many situations. Note that an addition/subtraction between
                //two int variables whose result is outside the int range might not trigger an exception (+ random 
                //negative value as output).
                if (VaryBaseTenExponent(outInfo, secondInfo0.BaseTenExponent, operation == Operations.Division).Error.Type != ErrorTypes.None)
                {
                    return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
                }

                if (operation == Operations.Multiplication)
                {
                    outInfo.Value *= secondInfo.Value;
                    outInfo.BaseTenExponent += secondInfo.BaseTenExponent;
                }
                else if (operation == Operations.Division)
                {
                    if (secondInfo.Value == 0.0)
                    {
                        return
                        (
                            new UnitInfo(outInfo) 
                            { 
                                Error = new ErrorInfo(ErrorTypes.NumericError) 
                            }
                        );
                    }
                    outInfo.Value /= secondInfo.Value;
                    outInfo.BaseTenExponent -= secondInfo.BaseTenExponent;
                }
            }
        }
        catch { isWrong = true; }

        return
        (
            //An error might not be triggered despite of dealing with numbers outside double precision.
            //For example: 0.00000000000000000001m * 0.0000000000000000000001m can output 0.0 without triggering an error. 
            isWrong || ((operation == Operations.Multiplication || operation == Operations.Division) && outInfo.Value == 0.0.0) ?
            OperationValuesManageError(firstInfo0, secondInfo0, operation) : outInfo
        );
    }

    static UnitInfo OperationValuesManageError(UnitInfo outInfo, UnitInfo secondInfo, Operations operation)
    {
        if (operation != Operations.Multiplication && operation != Operations.Division)
        {
            //This condition should never be true on account of the fact that the pre-modifications performed before
            //adding/subtracting should avoid erroneous situations.
            return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
        }

        UnitInfo secondInfo2 = ConvertValueToBaseTen(secondInfo.Value);
        outInfo = VaryBaseTenExponent(outInfo, secondInfo2.BaseTenExponent, operation == Operations.Division);
        if (Math.Abs(secondInfo2.Value) == 1.0 || outInfo.Error.Type != ErrorTypes.None) return outInfo;
        
        try
        {
            outInfo = PerformManagedOperationUnits
            (
                outInfo, secondInfo2.Value, operation
            );
        }
        catch
        {
            //Very unlikely scenario on account of the fact that Math.Abs(secondInfo2.Value)
            //lies within the 0.1-10.0 range.
            outInfo = OperationValuesManageError
            (
                new UnitInfo(outInfo)
                {
                    Value = secondInfo2.Value,
                    BaseTenExponent = 0
                },
                new UnitInfo()
                {
                    Value = outInfo.Value,
                    BaseTenExponent = outInfo.BaseTenExponent
                },
                operation
            );
        }

        return outInfo;
    }

    static UnitInfo ConvertValueToBaseTen(double value)
    {
        value = Math.Abs(value);
        return FromValueToBaseTenExponent
        (
             new UnitInfo(value), Math.Abs(value), false
        );
    }

    static UnitInfo ConvertBaseTenToValue(UnitInfo unitInfo)
    {
        if (unitInfo.BaseTenExponent == 0) return unitInfo;

        UnitInfo outInfo = new UnitInfo(unitInfo);
        boolean decrease = unitInfo.BaseTenExponent > 0;
        int sign = Math.Sign(outInfo.Value);
        double absValue = Math.Abs(outInfo.Value);

        while (outInfo.BaseTenExponent != 0.0)
        {
            if (decrease)
            {
                if (absValue >= MaxValueDec / 10.0) break;
                absValue *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }
            else
            {
                if (absValue <= MinValueDec * 10.0) break;
                absValue /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
        }

        outInfo.Value = sign * absValue;

        return outInfo;
    }

    static UnitInfo NormaliseUnitInfo(UnitInfo unitInfo)
    {
        if (unitInfo.Value == 0 && unitInfo.Prefix.Factor == 1.0)
        {
            return unitInfo;
        }
        UnitInfo outInfo = new UnitInfo(unitInfo);

        if (outInfo.Prefix.Factor != 1)
        {
            outInfo = FromValueToBaseTenExponent
            (
                outInfo, outInfo.Prefix.Factor, true
            );
            outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage);
        }
        if (outInfo.Value == 0.0) return outInfo;

        outInfo = FromValueToBaseTenExponent
        (
            outInfo, outInfo.Value, false
        );

        return outInfo;
    }

    static UnitInfo FromValueToBaseTenExponent(UnitInfo outInfo, double value, boolean isPrefix)
    {
        if (value == 0.0) return outInfo;

        double valueAbs = Math.Abs(value);
        boolean decrease = (valueAbs > 1.0);
        if (!isPrefix)
        {
            outInfo.Value = outInfo.Value / valueAbs;
        }

        while (valueAbs != 1.0)
        {
            if ((valueAbs < 10.0 && valueAbs > 1.0) || (valueAbs > 0.1.0 && valueAbs < 1.0))
            {
                if (!isPrefix) outInfo.Value = value;
                else
                {
                    outInfo = PerformManagedOperationValues
                    (
                        outInfo, value, Operations.Multiplication
                    );
                }

                return outInfo;
            }

            if (decrease)
            {
                value /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
            else
            {
                value *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }

            valueAbs = Math.Abs(value);
        }

        return outInfo;
    }

    //Method used to vary BaseTenExponent without provoking unhandled exceptions (i.e., bigger than Integer.MAX_VALUE).
    static UnitInfo VaryBaseTenExponent(UnitInfo info, int baseTenIncrease, boolean isDivision = false)
    {
        long val1 = info.BaseTenExponent;
        long val2 = baseTenIncrease;

        if (isDivision)
        {
            //Converting a negative value into positive might provoke an overflow error for the int type
            //(e.g., Math.Abs(Integer.MAIN_VALUE)). Converting both variables to long is a quick and effective
            //way to avoid this problem.
            val2 *= -1;
        }

        return
        (
             ((val2 > 0 && val1 > Integer.MAX_VALUE - val2) || (val2 < 0 && val1 < Integer.MAIN_VALUE - val2)) ?
            new UnitInfo(info, ErrorTypes.NumericError) : new UnitInfo(info){{ BaseTenExponent = (int)(val1 + val2); }}
        );
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 2 2017-05-27 19:57:32.301
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 0 2017-05-27 19:57:32.302
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.core 4 4 2017-05-27 19:57:32.887
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
public class OperationsManaged
{
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, double second, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            firstInfo, new UnitInfo(second), operation
        );
    }

    public static UnitInfo PerformManagedOperationUnits(double first, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            new UnitInfo(first), secondInfo, operation
        );
    }

    //This method should always be used when dealing with random UnitInfo variables because it accounts for all the
    //possible scenarios. On the other hand, with simple operations (e.g., random UnitInfo & numeric type) it might
    //be better to use PerformManagedOperationValues. 
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        ErrorTypes errorType = InternalMethods.GetOperationError
        (
            firstInfo, secondInfo, operation
        );
        if (errorType != ErrorTypes.None)
        {
            return new UnitInfo(firstInfo) 
            {{
                Error = new ErrorInfo(errorType); 
            }};
        }

        return
        (
            operation == Operations.Addition || operation == Operations.Subtraction ?
            PerformManagedOperationAddition(firstInfo, secondInfo, operation) :
            PerformManagedOperationMultiplication(firstInfo, secondInfo, operation)
        );
    }

    static UnitInfo PerformManagedOperationAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {   
        //After being normalised, the operands might require further modifications.
        UnitInfo[] normalised = GetOperandsAddition(firstInfo, secondInfo, operation);

        return PerformManagedOperationNormalisedValues
        (
            firstInfo, normalised, operation
        );
    }

    static UnitInfo[] GetOperandsAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        UnitInfo[] operands2 = new UnitInfo[] 
        {
            new UnitInfo(firstInfo), new UnitInfo(secondInfo)
        };

        if (operands2[0].BaseTenExponent != operands2[1].BaseTenExponent || operands2[0].Prefix.Factor != operands2[1].Prefix.Factor)
        {
            //The addition/subtraction might not be performed right away even with normalised values.
            //For example: 5 and 6 from 5*10^2 and 6*10^7 cannot be added right away.
            operands2 = AdaptNormalisedValuesForAddition
            (
                new UnitInfo[] 
                { 
                    NormaliseUnitInfo(operands2[0]), 
                    NormaliseUnitInfo(operands2[1])
                },
                operation
            );
        }

        return operands2;
    }
    
    static UnitInfo[] AdaptNormalisedValuesForAddition(UnitInfo[] unitInfos2, Operations operation)
    {
        if (unitInfos2[0].BaseTenExponent == unitInfos2[1].BaseTenExponent)
        {
            //Having the same BaseTenExponent values means that the given operation can be performed right away.
            return unitInfos2;
        }

        int[] bigSmallI = 
        (
            unitInfos2[0].BaseTenExponent > unitInfos2[1].BaseTenExponent ?
            new int[] { 0, 1 } : new int[] { 1, 0 }
        );

        //Only the variable with the bigger value is modified. For example: 5*10^5 & 3*10^3 is converted
        //into 500*10^3 & 3*10^3 in order to allow the addition 500 + 3. 
        UnitInfo big2 = AdaptBiggerAdditionOperand(unitInfos2, bigSmallI, operation);
        if (big2.Error.Type != ErrorTypes.None)
        {
            return TooBigGapAddition(unitInfos2, bigSmallI, operation);
        }

        unitInfos2[bigSmallI[0]].Value = big2.Value;
        unitInfos2[bigSmallI[0]].BaseTenExponent = unitInfos2[bigSmallI[1]].BaseTenExponent;

        return unitInfos2;
    }

    //When adding/subtracting two numbers whose gap is bigger than the maximum double range, there
    //is no need to perform any operation (i.e., no change will be observed because of being outside
    //the maximum supported precision). This method takes care of these cases and returns the expected
    //output (i.e., biggest value).
    static UnitInfo[] TooBigGapAddition(UnitInfo[] unitInfos2, int[] bigSmallI, Operations operation)
    {
        UnitInfo[] outInfos = new UnitInfo[] 
        {
            //First operand (i.e., one whose information defines the operation) together with the
            //numeric information (i.e., just Value and BaseTenExponent because both are normalised)
            //which is associated with the biggest one.
            new UnitInfo(unitInfos2[0])
            {{
                Value = unitInfos2[bigSmallI[0]].Value;
                BaseTenExponent = unitInfos2[bigSmallI[0]].BaseTenExponent;
            }}
        };

        if (operation == Operations.Subtraction && bigSmallI[0] == 1)
        {
            outInfos[0].Value = -1.0 * outInfos[0].Value;
        }

        if (outInfos[0].Unit == Units.Unitless)
        {
            outInfos[0].Unit = unitInfos2[bigSmallI[1]].Unit;
        }

        return outInfos;
    }

    static UnitInfo AdaptBiggerAdditionOperand(UnitInfo[] unitInfos2, int[] bigSmallI, Operations operation)
    {
        int gapExponent = unitInfos2[bigSmallI[0]].BaseTenExponent - unitInfos2[bigSmallI[1]].BaseTenExponent;
        if (gapExponent >= 27)
        {
            //The difference between both inputs is bigger than (or, at least, very close to) the maximum double value/precision;
            //what makes this situation calculation unworthy and the first operand to be returned as the result.
            //Note that the error below these lines is just an easy way to tell the calling function about this eventuality.
            return new UnitInfo(unitInfos2[0]) 
            {{ 
                Error = new ErrorInfo(ErrorTypes.InvalidOperation); 
            }};
        }

        //PerformManagedOperationValues is used to make sure that the resulting numeric information is stored
        //in Value (if possible).
        UnitInfo big2 = PerformManagedOperationValues
        (
            RaiseToIntegerExponent(10.0, gapExponent), unitInfos2[bigSmallI[0]].Value, 
            Operations.Multiplication                
        );

        boolean isWrong = 
        (
            big2.Error.Type != ErrorTypes.None || big2.BaseTenExponent != 0 ?
            
            //The value of the bigger input times 10^(gap between BaseTenExponent of inputs) is too big. 
            isWrong = true :
            
            //Overflow-check very unlikely to trigger an error. In fact, with properly normalised variables,
            //triggering an error would be plainly impossible.               
            AreAdditionFinalValuesWrong
            (
                unitInfos2[0].Value, unitInfos2[1].Value, operation
            )
        );

        return
        (
            isWrong ?
            //This error is just an easy way to let the calling function know about the fact that no
            //calculation has been performed (too big gap). This isn't a properly-speaking error and
            //that's why it will not be notified to the user.
            new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }} :
            //Returning the new big value. For example: with 5*10^4 & 3*10^2, 500 would be returned.
            new UnitInfo(unitInfos2[bigSmallI[0]])
            {{
                Value = big2.Value;
            }}
        );
    }

    static boolean AreAdditionFinalValuesWrong(double val1, double val2, Operations operation)
    {
        boolean isWrong = false;

        try
        {
            val1 = val1 + val2 *
            (
                operation == Operations.Addition ? 1 : -1
            );
        }
        catch { isWrong = true; }

        return isWrong;
    }

    static UnitInfo PerformManagedOperationMultiplication(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationNormalisedValues
        (
            firstInfo, new UnitInfo[] 
            { 
                NormaliseUnitInfo(firstInfo),
                NormaliseUnitInfo(secondInfo) 
            },
            operation
        );
    }

    public static UnitInfo RaiseToIntegerExponent(double baseValue, int exponent)
    {
        return RaiseToIntegerExponent(new UnitInfo(baseValue), exponent);
    }

    static UnitInfo RaiseToIntegerExponent(UnitInfo baseInfo, int exponent)
    {
        if (exponent <= 1 && exponent >= 0)
        {
            baseInfo.Value = (exponent == 0 ? 1.0 : baseInfo.Value);
            return baseInfo;
        }

        UnitInfo outInfo = new UnitInfo(baseInfo);

        for (int i = 1; i < Math.Abs(exponent); i++)
        {
            outInfo = PerformManagedOperationValues
            (
                outInfo, baseInfo, Operations.Multiplication
            );
            if (outInfo.Error.Type != ErrorTypes.None) return outInfo;
        }

        return
        (
            exponent < 0 ?
            PerformManagedOperationValues(new UnitInfo(1.0), outInfo, Operations.Division) :
            outInfo
        );
    }

    static UnitInfo PerformManagedOperationNormalisedValues(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        outInfo =
        (
            normalisedInfos.Length == 1 ?
            //There is just one operand when the difference between both of them is too big.
            outInfo = normalisedInfos[0] :
            PerformManagedOperationTwoOperands(outInfo, normalisedInfos, operation)
        );

        return outInfo;
    }

    static UnitInfo PerformManagedOperationTwoOperands(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        UnitInfo outInfoNormalised = PerformManagedOperationValues
        (
            normalisedInfos[0], normalisedInfos[1], operation
        );

        if (outInfo.Error.Type != ErrorTypes.None)
        {
            return new UnitInfo(outInfo)
            {
                Error = new ErrorInfo(ErrorTypes.NumericError)
            };
        }

        outInfo.BaseTenExponent = outInfoNormalised.BaseTenExponent;
        outInfo.Value = outInfoNormalised.Value;
        //Normalised means no prefixes.
        outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage); 

        return outInfo;
    }

    static UnitInfo PerformManagedOperationValues(double firstValue, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            new UnitInfo(firstValue), new UnitInfo(secondValue), operation
        );
    }

    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            firstInfo, new UnitInfo(secondValue), operation
        );
    }

    //This method might be used to perform full operations (not just being the last calculation step) instead
    //of the default one (PerformManagedOperationUnits) for simple cases. That is: ones not dealing with the
    //complex numeric reality (Value, Prefix and BaseTenExponent) which makes a pre-analysis required.
    //Note that, unlikely what happens with PerformMangedOperationUnits, the outputs of this method aren't
    //normalised (= primarily stored under Value), what is useful in certain contexts.
    //NOTE: this function assumes that both inputs are normalised, what means that no prefix information is expected.
    //It might also be used with non-normalised inputs, but their prefix information would be plainly ignored.
    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        if (firstInfo.Value == 0.0 || secondInfo.Value == 0.0)
        {
            if (operation == Operations.Multiplication || operation == Operations.Division)
            {
                //Dividing by zero scenarios are taken into account somewhere else.
                return new UnitInfo(firstInfo) { Value = 0.0 };
            }
        }

        UnitInfo outInfo = new UnitInfo(firstInfo);
        UnitInfo firstInfo0 = new UnitInfo(firstInfo);
        UnitInfo secondInfo0 = new UnitInfo(secondInfo);

        boolean isWrong = false;
        try
        {
            if (operation == Operations.Addition)
            {
                outInfo.Value += secondInfo0.Value;
            }
            else if (operation == Operations.Subtraction)
            {
                outInfo.Value -= secondInfo.Value;
            }
            else
            {
                //The reason for checking whether BaseTenExponent is inside/outside the int range before performing 
                //the operation (rather than going ahead and eventually catching the resulting exception) isn't just
                //being quicker, but also the only option in many situations. Note that an addition/subtraction between
                //two int variables whose result is outside the int range might not trigger an exception (+ random 
                //negative value as output).
                if (VaryBaseTenExponent(outInfo, secondInfo0.BaseTenExponent, operation == Operations.Division).Error.Type != ErrorTypes.None)
                {
                    return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
                }

                if (operation == Operations.Multiplication)
                {
                    outInfo.Value *= secondInfo.Value;
                    outInfo.BaseTenExponent += secondInfo.BaseTenExponent;
                }
                else if (operation == Operations.Division)
                {
                    if (secondInfo.Value == 0.0)
                    {
                        return
                        (
                            new UnitInfo(outInfo) 
                            { 
                                Error = new ErrorInfo(ErrorTypes.NumericError) 
                            }
                        );
                    }
                    outInfo.Value /= secondInfo.Value;
                    outInfo.BaseTenExponent -= secondInfo.BaseTenExponent;
                }
            }
        }
        catch { isWrong = true; }

        return
        (
            //An error might not be triggered despite of dealing with numbers outside double precision.
            //For example: 0.00000000000000000001m * 0.0000000000000000000001m can output 0.0 without triggering an error. 
            isWrong || ((operation == Operations.Multiplication || operation == Operations.Division) && outInfo.Value == 0.0.0) ?
            OperationValuesManageError(firstInfo0, secondInfo0, operation) : outInfo
        );
    }

    static UnitInfo OperationValuesManageError(UnitInfo outInfo, UnitInfo secondInfo, Operations operation)
    {
        if (operation != Operations.Multiplication && operation != Operations.Division)
        {
            //This condition should never be true on account of the fact that the pre-modifications performed before
            //adding/subtracting should avoid erroneous situations.
            return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
        }

        UnitInfo secondInfo2 = ConvertValueToBaseTen(secondInfo.Value);
        outInfo = VaryBaseTenExponent(outInfo, secondInfo2.BaseTenExponent, operation == Operations.Division);
        if (Math.Abs(secondInfo2.Value) == 1.0 || outInfo.Error.Type != ErrorTypes.None) return outInfo;
        
        try
        {
            outInfo = PerformManagedOperationUnits
            (
                outInfo, secondInfo2.Value, operation
            );
        }
        catch
        {
            //Very unlikely scenario on account of the fact that Math.Abs(secondInfo2.Value)
            //lies within the 0.1-10.0 range.
            outInfo = OperationValuesManageError
            (
                new UnitInfo(outInfo)
                {
                    Value = secondInfo2.Value,
                    BaseTenExponent = 0
                },
                new UnitInfo()
                {
                    Value = outInfo.Value,
                    BaseTenExponent = outInfo.BaseTenExponent
                },
                operation
            );
        }

        return outInfo;
    }

    static UnitInfo ConvertValueToBaseTen(double value)
    {
        value = Math.Abs(value);
        return FromValueToBaseTenExponent
        (
             new UnitInfo(value), Math.Abs(value), false
        );
    }

    static UnitInfo ConvertBaseTenToValue(UnitInfo unitInfo)
    {
        if (unitInfo.BaseTenExponent == 0) return unitInfo;

        UnitInfo outInfo = new UnitInfo(unitInfo);
        boolean decrease = unitInfo.BaseTenExponent > 0;
        int sign = Math.Sign(outInfo.Value);
        double absValue = Math.Abs(outInfo.Value);

        while (outInfo.BaseTenExponent != 0.0)
        {
            if (decrease)
            {
                if (absValue >= MaxValueDec / 10.0) break;
                absValue *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }
            else
            {
                if (absValue <= MinValueDec * 10.0) break;
                absValue /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
        }

        outInfo.Value = sign * absValue;

        return outInfo;
    }

    static UnitInfo NormaliseUnitInfo(UnitInfo unitInfo)
    {
        if (unitInfo.Value == 0 && unitInfo.Prefix.Factor == 1.0)
        {
            return unitInfo;
        }
        UnitInfo outInfo = new UnitInfo(unitInfo);

        if (outInfo.Prefix.Factor != 1)
        {
            outInfo = FromValueToBaseTenExponent
            (
                outInfo, outInfo.Prefix.Factor, true
            );
            outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage);
        }
        if (outInfo.Value == 0.0) return outInfo;

        outInfo = FromValueToBaseTenExponent
        (
            outInfo, outInfo.Value, false
        );

        return outInfo;
    }

    static UnitInfo FromValueToBaseTenExponent(UnitInfo outInfo, double value, boolean isPrefix)
    {
        if (value == 0.0) return outInfo;

        double valueAbs = Math.Abs(value);
        boolean decrease = (valueAbs > 1.0);
        if (!isPrefix)
        {
            outInfo.Value = outInfo.Value / valueAbs;
        }

        while (valueAbs != 1.0)
        {
            if ((valueAbs < 10.0 && valueAbs > 1.0) || (valueAbs > 0.1.0 && valueAbs < 1.0))
            {
                if (!isPrefix) outInfo.Value = value;
                else
                {
                    outInfo = PerformManagedOperationValues
                    (
                        outInfo, value, Operations.Multiplication
                    );
                }

                return outInfo;
            }

            if (decrease)
            {
                value /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
            else
            {
                value *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }

            valueAbs = Math.Abs(value);
        }

        return outInfo;
    }

    //Method used to vary BaseTenExponent without provoking unhandled exceptions (i.e., bigger than Integer.MAX_VALUE).
    static UnitInfo VaryBaseTenExponent(UnitInfo info, int baseTenIncrease, boolean isDivision = false)
    {
        long val1 = info.BaseTenExponent;
        long val2 = baseTenIncrease;

        if (isDivision)
        {
            //Converting a negative value into positive might provoke an overflow error for the int type
            //(e.g., Math.Abs(Integer.MAIN_VALUE)). Converting both variables to long is a quick and effective
            //way to avoid this problem.
            val2 *= -1;
        }

        return
        (
             ((val2 > 0 && val1 > Integer.MAX_VALUE - val2) || (val2 < 0 && val1 < Integer.MAIN_VALUE - val2)) ?
            new UnitInfo(info, ErrorTypes.NumericError) : new UnitInfo(info){{ BaseTenExponent = (int)(val1 + val2); }}
        );
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData(ClipboardOperationAction.java:430)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImportsOperation(ClipboardOperationAction.java:357)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperation(ClipboardOperationAction.java:317)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction$1.run(ClipboardOperationAction.java:265)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:70)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run(ClipboardOperationAction.java:262)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:473)
	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:118)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:90)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:55)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:282)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:264)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:132)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:152)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:494)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:488)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:210)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:286)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:507)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:558)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:378)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.access$0(KeyBindingDispatcher.java:324)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:86)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1270)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1078)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1103)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1088)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1130)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1126)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1547)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4918)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:364)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4799)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:359)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5110)
	at org.eclipse.swt.internal.win32.OS.DispatchMessageW(Native Method)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(OS.java:2552)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3822)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:1121)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1022)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:150)
	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:693)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:610)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:148)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:138)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:388)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:243)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:673)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:610)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1519)

!ENTRY org.eclipse.jdt.ui 4 2 2017-05-27 19:57:32.890
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData(ClipboardOperationAction.java:430)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImportsOperation(ClipboardOperationAction.java:357)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperation(ClipboardOperationAction.java:317)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction$1.run(ClipboardOperationAction.java:265)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:70)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run(ClipboardOperationAction.java:262)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:473)
	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:118)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:90)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:55)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:282)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:264)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:132)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:152)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:494)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:488)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:210)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:286)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:507)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:558)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:378)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.access$0(KeyBindingDispatcher.java:324)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:86)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1270)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1078)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1103)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1088)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1130)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1126)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1547)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4918)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:364)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4799)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:359)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5110)
	at org.eclipse.swt.internal.win32.OS.DispatchMessageW(Native Method)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(OS.java:2552)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3822)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:1121)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1022)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:150)
	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:693)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:610)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:148)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:138)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:388)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:243)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:673)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:610)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1519)

!ENTRY org.eclipse.jdt.ui 4 0 2017-05-27 19:57:32.891
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData(ClipboardOperationAction.java:430)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImportsOperation(ClipboardOperationAction.java:357)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperation(ClipboardOperationAction.java:317)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction$1.run(ClipboardOperationAction.java:265)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:70)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run(ClipboardOperationAction.java:262)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:473)
	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:118)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:90)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:55)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:282)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:264)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:132)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:152)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:494)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:488)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:210)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:286)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:507)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:558)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:378)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.access$0(KeyBindingDispatcher.java:324)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:86)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1270)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1078)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1103)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1088)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1130)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1126)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1547)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4918)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:364)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4799)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:359)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5110)
	at org.eclipse.swt.internal.win32.OS.DispatchMessageW(Native Method)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(OS.java:2552)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3822)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:1121)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1022)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:150)
	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:693)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:610)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:148)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:138)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:388)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:243)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:673)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:610)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1519)

!ENTRY org.eclipse.jdt.core 4 4 2017-05-27 19:57:34.081
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
public class OperationsManaged
{
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, double second, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            firstInfo, new UnitInfo(second), operation
        );
    }

    public static UnitInfo PerformManagedOperationUnits(double first, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            new UnitInfo(first), secondInfo, operation
        );
    }

    //This method should always be used when dealing with random UnitInfo variables because it accounts for all the
    //possible scenarios. On the other hand, with simple operations (e.g., random UnitInfo & numeric type) it might
    //be better to use PerformManagedOperationValues. 
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        ErrorTypes errorType = InternalMethods.GetOperationError
        (
            firstInfo, secondInfo, operation
        );
        if (errorType != ErrorTypes.None)
        {
            return new UnitInfo(firstInfo) 
            {{
                Error = new ErrorInfo(errorType); 
            }};
        }

        return
        (
            operation == Operations.Addition || operation == Operations.Subtraction ?
            PerformManagedOperationAddition(firstInfo, secondInfo, operation) :
            PerformManagedOperationMultiplication(firstInfo, secondInfo, operation)
        );
    }

    static UnitInfo PerformManagedOperationAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {   
        //After being normalised, the operands might require further modifications.
        UnitInfo[] normalised = GetOperandsAddition(firstInfo, secondInfo, operation);

        return PerformManagedOperationNormalisedValues
        (
            firstInfo, normalised, operation
        );
    }

    static UnitInfo[] GetOperandsAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        UnitInfo[] operands2 = new UnitInfo[] 
        {
            new UnitInfo(firstInfo), new UnitInfo(secondInfo)
        };

        if (operands2[0].BaseTenExponent != operands2[1].BaseTenExponent || operands2[0].Prefix.Factor != operands2[1].Prefix.Factor)
        {
            //The addition/subtraction might not be performed right away even with normalised values.
            //For example: 5 and 6 from 5*10^2 and 6*10^7 cannot be added right away.
            operands2 = AdaptNormalisedValuesForAddition
            (
                new UnitInfo[] 
                { 
                    NormaliseUnitInfo(operands2[0]), 
                    NormaliseUnitInfo(operands2[1])
                },
                operation
            );
        }

        return operands2;
    }
    
    static UnitInfo[] AdaptNormalisedValuesForAddition(UnitInfo[] unitInfos2, Operations operation)
    {
        if (unitInfos2[0].BaseTenExponent == unitInfos2[1].BaseTenExponent)
        {
            //Having the same BaseTenExponent values means that the given operation can be performed right away.
            return unitInfos2;
        }

        int[] bigSmallI = 
        (
            unitInfos2[0].BaseTenExponent > unitInfos2[1].BaseTenExponent ?
            new int[] { 0, 1 } : new int[] { 1, 0 }
        );

        //Only the variable with the bigger value is modified. For example: 5*10^5 & 3*10^3 is converted
        //into 500*10^3 & 3*10^3 in order to allow the addition 500 + 3. 
        UnitInfo big2 = AdaptBiggerAdditionOperand(unitInfos2, bigSmallI, operation);
        if (big2.Error.Type != ErrorTypes.None)
        {
            return TooBigGapAddition(unitInfos2, bigSmallI, operation);
        }

        unitInfos2[bigSmallI[0]].Value = big2.Value;
        unitInfos2[bigSmallI[0]].BaseTenExponent = unitInfos2[bigSmallI[1]].BaseTenExponent;

        return unitInfos2;
    }

    //When adding/subtracting two numbers whose gap is bigger than the maximum double range, there
    //is no need to perform any operation (i.e., no change will be observed because of being outside
    //the maximum supported precision). This method takes care of these cases and returns the expected
    //output (i.e., biggest value).
    static UnitInfo[] TooBigGapAddition(UnitInfo[] unitInfos2, int[] bigSmallI, Operations operation)
    {
        UnitInfo[] outInfos = new UnitInfo[] 
        {
            //First operand (i.e., one whose information defines the operation) together with the
            //numeric information (i.e., just Value and BaseTenExponent because both are normalised)
            //which is associated with the biggest one.
            new UnitInfo(unitInfos2[0])
            {{
                Value = unitInfos2[bigSmallI[0]].Value;
                BaseTenExponent = unitInfos2[bigSmallI[0]].BaseTenExponent;
            }}
        };

        if (operation == Operations.Subtraction && bigSmallI[0] == 1)
        {
            outInfos[0].Value = -1.0 * outInfos[0].Value;
        }

        if (outInfos[0].Unit == Units.Unitless)
        {
            outInfos[0].Unit = unitInfos2[bigSmallI[1]].Unit;
        }

        return outInfos;
    }

    static UnitInfo AdaptBiggerAdditionOperand(UnitInfo[] unitInfos2, int[] bigSmallI, Operations operation)
    {
        int gapExponent = unitInfos2[bigSmallI[0]].BaseTenExponent - unitInfos2[bigSmallI[1]].BaseTenExponent;
        if (gapExponent >= 27)
        {
            //The difference between both inputs is bigger than (or, at least, very close to) the maximum double value/precision;
            //what makes this situation calculation unworthy and the first operand to be returned as the result.
            //Note that the error below these lines is just an easy way to tell the calling function about this eventuality.
            return new UnitInfo(unitInfos2[0]) 
            {{ 
                Error = new ErrorInfo(ErrorTypes.InvalidOperation); 
            }};
        }

        //PerformManagedOperationValues is used to make sure that the resulting numeric information is stored
        //in Value (if possible).
        UnitInfo big2 = PerformManagedOperationValues
        (
            RaiseToIntegerExponent(10.0, gapExponent), unitInfos2[bigSmallI[0]].Value, 
            Operations.Multiplication                
        );

        boolean isWrong = 
        (
            big2.Error.Type != ErrorTypes.None || big2.BaseTenExponent != 0 ?
            
            //The value of the bigger input times 10^(gap between BaseTenExponent of inputs) is too big. 
            isWrong = true :
            
            //Overflow-check very unlikely to trigger an error. In fact, with properly normalised variables,
            //triggering an error would be plainly impossible.               
            AreAdditionFinalValuesWrong
            (
                unitInfos2[0].Value, unitInfos2[1].Value, operation
            )
        );

        return
        (
            isWrong ?
            //This error is just an easy way to let the calling function know about the fact that no
            //calculation has been performed (too big gap). This isn't a properly-speaking error and
            //that's why it will not be notified to the user.
            new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }} :
            //Returning the new big value. For example: with 5*10^4 & 3*10^2, 500 would be returned.
            new UnitInfo(unitInfos2[bigSmallI[0]])
            {{
                Value = big2.Value;
            }}
        );
    }

    static boolean AreAdditionFinalValuesWrong(double val1, double val2, Operations operation)
    {
        boolean isWrong = false;

        try
        {
            val1 = val1 + val2 *
            (
                operation == Operations.Addition ? 1 : -1
            );
        }
        catch { isWrong = true; }

        return isWrong;
    }

    static UnitInfo PerformManagedOperationMultiplication(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationNormalisedValues
        (
            firstInfo, new UnitInfo[] 
            { 
                NormaliseUnitInfo(firstInfo),
                NormaliseUnitInfo(secondInfo) 
            },
            operation
        );
    }

    public static UnitInfo RaiseToIntegerExponent(double baseValue, int exponent)
    {
        return RaiseToIntegerExponent(new UnitInfo(baseValue), exponent);
    }

    static UnitInfo RaiseToIntegerExponent(UnitInfo baseInfo, int exponent)
    {
        if (exponent <= 1 && exponent >= 0)
        {
            baseInfo.Value = (exponent == 0 ? 1.0 : baseInfo.Value);
            return baseInfo;
        }

        UnitInfo outInfo = new UnitInfo(baseInfo);

        for (int i = 1; i < Math.Abs(exponent); i++)
        {
            outInfo = PerformManagedOperationValues
            (
                outInfo, baseInfo, Operations.Multiplication
            );
            if (outInfo.Error.Type != ErrorTypes.None) return outInfo;
        }

        return
        (
            exponent < 0 ?
            PerformManagedOperationValues(new UnitInfo(1.0), outInfo, Operations.Division) :
            outInfo
        );
    }

    static UnitInfo PerformManagedOperationNormalisedValues(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        outInfo =
        (
            normalisedInfos.Length == 1 ?
            //There is just one operand when the difference between both of them is too big.
            outInfo = normalisedInfos[0] :
            PerformManagedOperationTwoOperands(outInfo, normalisedInfos, operation)
        );

        return outInfo;
    }

    static UnitInfo PerformManagedOperationTwoOperands(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        UnitInfo outInfoNormalised = PerformManagedOperationValues
        (
            normalisedInfos[0], normalisedInfos[1], operation
        );

        if (outInfo.Error.Type != ErrorTypes.None)
        {
            return new UnitInfo(outInfo)
            {
                Error = new ErrorInfo(ErrorTypes.NumericError)
            };
        }

        outInfo.BaseTenExponent = outInfoNormalised.BaseTenExponent;
        outInfo.Value = outInfoNormalised.Value;
        //Normalised means no prefixes.
        outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage); 

        return outInfo;
    }

    static UnitInfo PerformManagedOperationValues(double firstValue, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            new UnitInfo(firstValue), new UnitInfo(secondValue), operation
        );
    }

    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            firstInfo, new UnitInfo(secondValue), operation
        );
    }

    //This method might be used to perform full operations (not just being the last calculation step) instead
    //of the default one (PerformManagedOperationUnits) for simple cases. That is: ones not dealing with the
    //complex numeric reality (Value, Prefix and BaseTenExponent) which makes a pre-analysis required.
    //Note that, unlikely what happens with PerformMangedOperationUnits, the outputs of this method aren't
    //normalised (= primarily stored under Value), what is useful in certain contexts.
    //NOTE: this function assumes that both inputs are normalised, what means that no prefix information is expected.
    //It might also be used with non-normalised inputs, but their prefix information would be plainly ignored.
    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        if (firstInfo.Value == 0.0 || secondInfo.Value == 0.0)
        {
            if (operation == Operations.Multiplication || operation == Operations.Division)
            {
                //Dividing by zero scenarios are taken into account somewhere else.
                return new UnitInfo(firstInfo) { Value = 0.0 };
            }
        }

        UnitInfo outInfo = new UnitInfo(firstInfo);
        UnitInfo firstInfo0 = new UnitInfo(firstInfo);
        UnitInfo secondInfo0 = new UnitInfo(secondInfo);

        boolean isWrong = false;
        try
        {
            if (operation == Operations.Addition)
            {
                outInfo.Value += secondInfo0.Value;
            }
            else if (operation == Operations.Subtraction)
            {
                outInfo.Value -= secondInfo.Value;
            }
            else
            {
                //The reason for checking whether BaseTenExponent is inside/outside the int range before performing 
                //the operation (rather than going ahead and eventually catching the resulting exception) isn't just
                //being quicker, but also the only option in many situations. Note that an addition/subtraction between
                //two int variables whose result is outside the int range might not trigger an exception (+ random 
                //negative value as output).
                if (VaryBaseTenExponent(outInfo, secondInfo0.BaseTenExponent, operation == Operations.Division).Error.Type != ErrorTypes.None)
                {
                    return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
                }

                if (operation == Operations.Multiplication)
                {
                    outInfo.Value *= secondInfo.Value;
                    outInfo.BaseTenExponent += secondInfo.BaseTenExponent;
                }
                else if (operation == Operations.Division)
                {
                    if (secondInfo.Value == 0.0)
                    {
                        return
                        (
                            new UnitInfo(outInfo) 
                            { 
                                Error = new ErrorInfo(ErrorTypes.NumericError) 
                            }
                        );
                    }
                    outInfo.Value /= secondInfo.Value;
                    outInfo.BaseTenExponent -= secondInfo.BaseTenExponent;
                }
            }
        }
        catch { isWrong = true; }

        return
        (
            //An error might not be triggered despite of dealing with numbers outside double precision.
            //For example: 0.00000000000000000001m * 0.0000000000000000000001m can output 0.0 without triggering an error. 
            isWrong || ((operation == Operations.Multiplication || operation == Operations.Division) && outInfo.Value == 0.0.0) ?
            OperationValuesManageError(firstInfo0, secondInfo0, operation) : outInfo
        );
    }

    static UnitInfo OperationValuesManageError(UnitInfo outInfo, UnitInfo secondInfo, Operations operation)
    {
        if (operation != Operations.Multiplication && operation != Operations.Division)
        {
            //This condition should never be true on account of the fact that the pre-modifications performed before
            //adding/subtracting should avoid erroneous situations.
            return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
        }

        UnitInfo secondInfo2 = ConvertValueToBaseTen(secondInfo.Value);
        outInfo = VaryBaseTenExponent(outInfo, secondInfo2.BaseTenExponent, operation == Operations.Division);
        if (Math.Abs(secondInfo2.Value) == 1.0 || outInfo.Error.Type != ErrorTypes.None) return outInfo;
        
        try
        {
            outInfo = PerformManagedOperationUnits
            (
                outInfo, secondInfo2.Value, operation
            );
        }
        catch
        {
            //Very unlikely scenario on account of the fact that Math.Abs(secondInfo2.Value)
            //lies within the 0.1-10.0 range.
            outInfo = OperationValuesManageError
            (
                new UnitInfo(outInfo)
                {
                    Value = secondInfo2.Value,
                    BaseTenExponent = 0
                },
                new UnitInfo()
                {
                    Value = outInfo.Value,
                    BaseTenExponent = outInfo.BaseTenExponent
                },
                operation
            );
        }

        return outInfo;
    }

    static UnitInfo ConvertValueToBaseTen(double value)
    {
        value = Math.Abs(value);
        return FromValueToBaseTenExponent
        (
             new UnitInfo(value), Math.Abs(value), false
        );
    }

    static UnitInfo ConvertBaseTenToValue(UnitInfo unitInfo)
    {
        if (unitInfo.BaseTenExponent == 0) return unitInfo;

        UnitInfo outInfo = new UnitInfo(unitInfo);
        boolean decrease = unitInfo.BaseTenExponent > 0;
        int sign = Math.Sign(outInfo.Value);
        double absValue = Math.Abs(outInfo.Value);

        while (outInfo.BaseTenExponent != 0.0)
        {
            if (decrease)
            {
                if (absValue >= MaxValueDec / 10.0) break;
                absValue *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }
            else
            {
                if (absValue <= MinValueDec * 10.0) break;
                absValue /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
        }

        outInfo.Value = sign * absValue;

        return outInfo;
    }

    static UnitInfo NormaliseUnitInfo(UnitInfo unitInfo)
    {
        if (unitInfo.Value == 0 && unitInfo.Prefix.Factor == 1.0)
        {
            return unitInfo;
        }
        UnitInfo outInfo = new UnitInfo(unitInfo);

        if (outInfo.Prefix.Factor != 1)
        {
            outInfo = FromValueToBaseTenExponent
            (
                outInfo, outInfo.Prefix.Factor, true
            );
            outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage);
        }
        if (outInfo.Value == 0.0) return outInfo;

        outInfo = FromValueToBaseTenExponent
        (
            outInfo, outInfo.Value, false
        );

        return outInfo;
    }

    static UnitInfo FromValueToBaseTenExponent(UnitInfo outInfo, double value, boolean isPrefix)
    {
        if (value == 0.0) return outInfo;

        double valueAbs = Math.Abs(value);
        boolean decrease = (valueAbs > 1.0);
        if (!isPrefix)
        {
            outInfo.Value = outInfo.Value / valueAbs;
        }

        while (valueAbs != 1.0)
        {
            if ((valueAbs < 10.0 && valueAbs > 1.0) || (valueAbs > 0.1.0 && valueAbs < 1.0))
            {
                if (!isPrefix) outInfo.Value = value;
                else
                {
                    outInfo = PerformManagedOperationValues
                    (
                        outInfo, value, Operations.Multiplication
                    );
                }

                return outInfo;
            }

            if (decrease)
            {
                value /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
            else
            {
                value *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }

            valueAbs = Math.Abs(value);
        }

        return outInfo;
    }

    //Method used to vary BaseTenExponent without provoking unhandled exceptions (i.e., bigger than Integer.MAX_VALUE).
    static UnitInfo VaryBaseTenExponent(UnitInfo info, int baseTenIncrease, boolean isDivision = false)
    {
        long val1 = info.BaseTenExponent;
        long val2 = baseTenIncrease;

        if (isDivision)
        {
            //Converting a negative value into positive might provoke an overflow error for the int type
            //(e.g., Math.Abs(Integer.MAIN_VALUE)). Converting both variables to long is a quick and effective
            //way to avoid this problem.
            val2 *= -1;
        }

        return
        (
             ((val2 > 0 && val1 > Integer.MAX_VALUE - val2) || (val2 < 0 && val1 < Integer.MAIN_VALUE - val2)) ?
            new UnitInfo(info, ErrorTypes.NumericError) : new UnitInfo(info){{ BaseTenExponent = (int)(val1 + val2); }}
        );
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 2 2017-05-27 19:57:34.082
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 0 2017-05-27 19:57:34.083
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.core 4 4 2017-05-27 19:57:56.573
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
public class OperationsManaged
{
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, double second, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            firstInfo, new UnitInfo(second), operation
        );
    }

    public static UnitInfo PerformManagedOperationUnits(double first, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            new UnitInfo(first), secondInfo, operation
        );
    }

    //This method should always be used when dealing with random UnitInfo variables because it accounts for all the
    //possible scenarios. On the other hand, with simple operations (e.g., random UnitInfo & numeric type) it might
    //be better to use PerformManagedOperationValues. 
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        ErrorTypes errorType = InternalMethods.GetOperationError
        (
            firstInfo, secondInfo, operation
        );
        if (errorType != ErrorTypes.None)
        {
            return new UnitInfo(firstInfo) 
            {{
                Error = new ErrorInfo(errorType); 
            }};
        }

        return
        (
            operation == Operations.Addition || operation == Operations.Subtraction ?
            PerformManagedOperationAddition(firstInfo, secondInfo, operation) :
            PerformManagedOperationMultiplication(firstInfo, secondInfo, operation)
        );
    }

    static UnitInfo PerformManagedOperationAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {   
        //After being normalised, the operands might require further modifications.
        UnitInfo[] normalised = GetOperandsAddition(firstInfo, secondInfo, operation);

        return PerformManagedOperationNormalisedValues
        (
            firstInfo, normalised, operation
        );
    }

    static UnitInfo[] GetOperandsAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        UnitInfo[] operands2 = new UnitInfo[] 
        {
            new UnitInfo(firstInfo), new UnitInfo(secondInfo)
        };

        if (operands2[0].BaseTenExponent != operands2[1].BaseTenExponent || operands2[0].Prefix.Factor != operands2[1].Prefix.Factor)
        {
            //The addition/subtraction might not be performed right away even with normalised values.
            //For example: 5 and 6 from 5*10^2 and 6*10^7 cannot be added right away.
            operands2 = AdaptNormalisedValuesForAddition
            (
                new UnitInfo[] 
                { 
                    NormaliseUnitInfo(operands2[0]), 
                    NormaliseUnitInfo(operands2[1])
                },
                operation
            );
        }

        return operands2;
    }
    
    static UnitInfo[] AdaptNormalisedValuesForAddition(UnitInfo[] unitInfos2, Operations operation)
    {
        if (unitInfos2[0].BaseTenExponent == unitInfos2[1].BaseTenExponent)
        {
            //Having the same BaseTenExponent values means that the given operation can be performed right away.
            return unitInfos2;
        }

        int[] bigSmallI = 
        (
            unitInfos2[0].BaseTenExponent > unitInfos2[1].BaseTenExponent ?
            new int[] { 0, 1 } : new int[] { 1, 0 }
        );

        //Only the variable with the bigger value is modified. For example: 5*10^5 & 3*10^3 is converted
        //into 500*10^3 & 3*10^3 in order to allow the addition 500 + 3. 
        UnitInfo big2 = AdaptBiggerAdditionOperand(unitInfos2, bigSmallI, operation);
        if (big2.Error.Type != ErrorTypes.None)
        {
            return TooBigGapAddition(unitInfos2, bigSmallI, operation);
        }

        unitInfos2[bigSmallI[0]].Value = big2.Value;
        unitInfos2[bigSmallI[0]].BaseTenExponent = unitInfos2[bigSmallI[1]].BaseTenExponent;

        return unitInfos2;
    }

    //When adding/subtracting two numbers whose gap is bigger than the maximum double range, there
    //is no need to perform any operation (i.e., no change will be observed because of being outside
    //the maximum supported precision). This method takes care of these cases and returns the expected
    //output (i.e., biggest value).
    static UnitInfo[] TooBigGapAddition(UnitInfo[] unitInfos2, int[] bigSmallI, Operations operation)
    {
        UnitInfo[] outInfos = new UnitInfo[] 
        {
            //First operand (i.e., one whose information defines the operation) together with the
            //numeric information (i.e., just Value and BaseTenExponent because both are normalised)
            //which is associated with the biggest one.
            new UnitInfo(unitInfos2[0])
            {{
                Value = unitInfos2[bigSmallI[0]].Value;
                BaseTenExponent = unitInfos2[bigSmallI[0]].BaseTenExponent;
            }}
        };

        if (operation == Operations.Subtraction && bigSmallI[0] == 1)
        {
            outInfos[0].Value = -1.0 * outInfos[0].Value;
        }

        if (outInfos[0].Unit == Units.Unitless)
        {
            outInfos[0].Unit = unitInfos2[bigSmallI[1]].Unit;
        }

        return outInfos;
    }

    static UnitInfo AdaptBiggerAdditionOperand(UnitInfo[] unitInfos2, int[] bigSmallI, Operations operation)
    {
        int gapExponent = unitInfos2[bigSmallI[0]].BaseTenExponent - unitInfos2[bigSmallI[1]].BaseTenExponent;
        if (gapExponent >= 27)
        {
            //The difference between both inputs is bigger than (or, at least, very close to) the maximum double value/precision;
            //what makes this situation calculation unworthy and the first operand to be returned as the result.
            //Note that the error below these lines is just an easy way to tell the calling function about this eventuality.
            return new UnitInfo(unitInfos2[0]) 
            {{ 
                Error = new ErrorInfo(ErrorTypes.InvalidOperation); 
            }};
        }

        //PerformManagedOperationValues is used to make sure that the resulting numeric information is stored
        //in Value (if possible).
        UnitInfo big2 = PerformManagedOperationValues
        (
            RaiseToIntegerExponent(10.0, gapExponent), unitInfos2[bigSmallI[0]].Value, 
            Operations.Multiplication                
        );

        boolean isWrong = 
        (
            big2.Error.Type != ErrorTypes.None || big2.BaseTenExponent != 0 ?
            
            //The value of the bigger input times 10^(gap between BaseTenExponent of inputs) is too big. 
            isWrong = true :
            
            //Overflow-check very unlikely to trigger an error. In fact, with properly normalised variables,
            //triggering an error would be plainly impossible.               
            AreAdditionFinalValuesWrong
            (
                unitInfos2[0].Value, unitInfos2[1].Value, operation
            )
        );

        if (isWrong)
        {
        	//This error is just an easy way to let the calling function know about the fact that no
                    //calculation has been performed (too big gap). This isn't a properly-speaking error and
                    //that's why it will not be notified to the user.
                    new UnitInfo(unitInfos2[0])
                    {{
                        Error = new ErrorInfo(ErrorTypes.InvalidOperation);
                    }}
        }
                //This error is just an easy way to let the calling function know about the fact that no
                //calculation has been performed (too big gap). This isn't a properly-speaking error and
                //that's why it will not be notified to the user.
                new UnitInfo(unitInfos2[0])
                {{
                    Error = new ErrorInfo(ErrorTypes.InvalidOperation);
                }} :
                //Returning the new big value. For example: with 5*10^4 & 3*10^2, 500 would be returned.
                new UnitInfo(unitInfos2[bigSmallI[0]])
                {{
                    Value = big2.Value;
                }}
        
        return
        (
            isWrong ?
            //This error is just an easy way to let the calling function know about the fact that no
            //calculation has been performed (too big gap). This isn't a properly-speaking error and
            //that's why it will not be notified to the user.
            new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }} :
            //Returning the new big value. For example: with 5*10^4 & 3*10^2, 500 would be returned.
            new UnitInfo(unitInfos2[bigSmallI[0]])
            {{
                Value = big2.Value;
            }}
        );
    }

    static boolean AreAdditionFinalValuesWrong(double val1, double val2, Operations operation)
    {
        boolean isWrong = false;

        try
        {
            val1 = val1 + val2 *
            (
                operation == Operations.Addition ? 1 : -1
            );
        }
        catch { isWrong = true; }

        return isWrong;
    }

    static UnitInfo PerformManagedOperationMultiplication(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationNormalisedValues
        (
            firstInfo, new UnitInfo[] 
            { 
                NormaliseUnitInfo(firstInfo),
                NormaliseUnitInfo(secondInfo) 
            },
            operation
        );
    }

    public static UnitInfo RaiseToIntegerExponent(double baseValue, int exponent)
    {
        return RaiseToIntegerExponent(new UnitInfo(baseValue), exponent);
    }

    static UnitInfo RaiseToIntegerExponent(UnitInfo baseInfo, int exponent)
    {
        if (exponent <= 1 && exponent >= 0)
        {
            baseInfo.Value = (exponent == 0 ? 1.0 : baseInfo.Value);
            return baseInfo;
        }

        UnitInfo outInfo = new UnitInfo(baseInfo);

        for (int i = 1; i < Math.Abs(exponent); i++)
        {
            outInfo = PerformManagedOperationValues
            (
                outInfo, baseInfo, Operations.Multiplication
            );
            if (outInfo.Error.Type != ErrorTypes.None) return outInfo;
        }

        return
        (
            exponent < 0 ?
            PerformManagedOperationValues(new UnitInfo(1.0), outInfo, Operations.Division) :
            outInfo
        );
    }

    static UnitInfo PerformManagedOperationNormalisedValues(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        outInfo =
        (
            normalisedInfos.Length == 1 ?
            //There is just one operand when the difference between both of them is too big.
            outInfo = normalisedInfos[0] :
            PerformManagedOperationTwoOperands(outInfo, normalisedInfos, operation)
        );

        return outInfo;
    }

    static UnitInfo PerformManagedOperationTwoOperands(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        UnitInfo outInfoNormalised = PerformManagedOperationValues
        (
            normalisedInfos[0], normalisedInfos[1], operation
        );

        if (outInfo.Error.Type != ErrorTypes.None)
        {
            return new UnitInfo(outInfo)
            {
                Error = new ErrorInfo(ErrorTypes.NumericError)
            };
        }

        outInfo.BaseTenExponent = outInfoNormalised.BaseTenExponent;
        outInfo.Value = outInfoNormalised.Value;
        //Normalised means no prefixes.
        outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage); 

        return outInfo;
    }

    static UnitInfo PerformManagedOperationValues(double firstValue, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            new UnitInfo(firstValue), new UnitInfo(secondValue), operation
        );
    }

    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            firstInfo, new UnitInfo(secondValue), operation
        );
    }

    //This method might be used to perform full operations (not just being the last calculation step) instead
    //of the default one (PerformManagedOperationUnits) for simple cases. That is: ones not dealing with the
    //complex numeric reality (Value, Prefix and BaseTenExponent) which makes a pre-analysis required.
    //Note that, unlikely what happens with PerformMangedOperationUnits, the outputs of this method aren't
    //normalised (= primarily stored under Value), what is useful in certain contexts.
    //NOTE: this function assumes that both inputs are normalised, what means that no prefix information is expected.
    //It might also be used with non-normalised inputs, but their prefix information would be plainly ignored.
    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        if (firstInfo.Value == 0.0 || secondInfo.Value == 0.0)
        {
            if (operation == Operations.Multiplication || operation == Operations.Division)
            {
                //Dividing by zero scenarios are taken into account somewhere else.
                return new UnitInfo(firstInfo) { Value = 0.0 };
            }
        }

        UnitInfo outInfo = new UnitInfo(firstInfo);
        UnitInfo firstInfo0 = new UnitInfo(firstInfo);
        UnitInfo secondInfo0 = new UnitInfo(secondInfo);

        boolean isWrong = false;
        try
        {
            if (operation == Operations.Addition)
            {
                outInfo.Value += secondInfo0.Value;
            }
            else if (operation == Operations.Subtraction)
            {
                outInfo.Value -= secondInfo.Value;
            }
            else
            {
                //The reason for checking whether BaseTenExponent is inside/outside the int range before performing 
                //the operation (rather than going ahead and eventually catching the resulting exception) isn't just
                //being quicker, but also the only option in many situations. Note that an addition/subtraction between
                //two int variables whose result is outside the int range might not trigger an exception (+ random 
                //negative value as output).
                if (VaryBaseTenExponent(outInfo, secondInfo0.BaseTenExponent, operation == Operations.Division).Error.Type != ErrorTypes.None)
                {
                    return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
                }

                if (operation == Operations.Multiplication)
                {
                    outInfo.Value *= secondInfo.Value;
                    outInfo.BaseTenExponent += secondInfo.BaseTenExponent;
                }
                else if (operation == Operations.Division)
                {
                    if (secondInfo.Value == 0.0)
                    {
                        return
                        (
                            new UnitInfo(outInfo) 
                            { 
                                Error = new ErrorInfo(ErrorTypes.NumericError) 
                            }
                        );
                    }
                    outInfo.Value /= secondInfo.Value;
                    outInfo.BaseTenExponent -= secondInfo.BaseTenExponent;
                }
            }
        }
        catch { isWrong = true; }

        return
        (
            //An error might not be triggered despite of dealing with numbers outside double precision.
            //For example: 0.00000000000000000001m * 0.0000000000000000000001m can output 0.0 without triggering an error. 
            isWrong || ((operation == Operations.Multiplication || operation == Operations.Division) && outInfo.Value == 0.0.0) ?
            OperationValuesManageError(firstInfo0, secondInfo0, operation) : outInfo
        );
    }

    static UnitInfo OperationValuesManageError(UnitInfo outInfo, UnitInfo secondInfo, Operations operation)
    {
        if (operation != Operations.Multiplication && operation != Operations.Division)
        {
            //This condition should never be true on account of the fact that the pre-modifications performed before
            //adding/subtracting should avoid erroneous situations.
            return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
        }

        UnitInfo secondInfo2 = ConvertValueToBaseTen(secondInfo.Value);
        outInfo = VaryBaseTenExponent(outInfo, secondInfo2.BaseTenExponent, operation == Operations.Division);
        if (Math.Abs(secondInfo2.Value) == 1.0 || outInfo.Error.Type != ErrorTypes.None) return outInfo;
        
        try
        {
            outInfo = PerformManagedOperationUnits
            (
                outInfo, secondInfo2.Value, operation
            );
        }
        catch
        {
            //Very unlikely scenario on account of the fact that Math.Abs(secondInfo2.Value)
            //lies within the 0.1-10.0 range.
            outInfo = OperationValuesManageError
            (
                new UnitInfo(outInfo)
                {
                    Value = secondInfo2.Value,
                    BaseTenExponent = 0
                },
                new UnitInfo()
                {
                    Value = outInfo.Value,
                    BaseTenExponent = outInfo.BaseTenExponent
                },
                operation
            );
        }

        return outInfo;
    }

    static UnitInfo ConvertValueToBaseTen(double value)
    {
        value = Math.Abs(value);
        return FromValueToBaseTenExponent
        (
             new UnitInfo(value), Math.Abs(value), false
        );
    }

    static UnitInfo ConvertBaseTenToValue(UnitInfo unitInfo)
    {
        if (unitInfo.BaseTenExponent == 0) return unitInfo;

        UnitInfo outInfo = new UnitInfo(unitInfo);
        boolean decrease = unitInfo.BaseTenExponent > 0;
        int sign = Math.Sign(outInfo.Value);
        double absValue = Math.Abs(outInfo.Value);

        while (outInfo.BaseTenExponent != 0.0)
        {
            if (decrease)
            {
                if (absValue >= MaxValueDec / 10.0) break;
                absValue *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }
            else
            {
                if (absValue <= MinValueDec * 10.0) break;
                absValue /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
        }

        outInfo.Value = sign * absValue;

        return outInfo;
    }

    static UnitInfo NormaliseUnitInfo(UnitInfo unitInfo)
    {
        if (unitInfo.Value == 0 && unitInfo.Prefix.Factor == 1.0)
        {
            return unitInfo;
        }
        UnitInfo outInfo = new UnitInfo(unitInfo);

        if (outInfo.Prefix.Factor != 1)
        {
            outInfo = FromValueToBaseTenExponent
            (
                outInfo, outInfo.Prefix.Factor, true
            );
            outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage);
        }
        if (outInfo.Value == 0.0) return outInfo;

        outInfo = FromValueToBaseTenExponent
        (
            outInfo, outInfo.Value, false
        );

        return outInfo;
    }

    static UnitInfo FromValueToBaseTenExponent(UnitInfo outInfo, double value, boolean isPrefix)
    {
        if (value == 0.0) return outInfo;

        double valueAbs = Math.Abs(value);
        boolean decrease = (valueAbs > 1.0);
        if (!isPrefix)
        {
            outInfo.Value = outInfo.Value / valueAbs;
        }

        while (valueAbs != 1.0)
        {
            if ((valueAbs < 10.0 && valueAbs > 1.0) || (valueAbs > 0.1.0 && valueAbs < 1.0))
            {
                if (!isPrefix) outInfo.Value = value;
                else
                {
                    outInfo = PerformManagedOperationValues
                    (
                        outInfo, value, Operations.Multiplication
                    );
                }

                return outInfo;
            }

            if (decrease)
            {
                value /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
            else
            {
                value *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }

            valueAbs = Math.Abs(value);
        }

        return outInfo;
    }

    //Method used to vary BaseTenExponent without provoking unhandled exceptions (i.e., bigger than Integer.MAX_VALUE).
    static UnitInfo VaryBaseTenExponent(UnitInfo info, int baseTenIncrease, boolean isDivision = false)
    {
        long val1 = info.BaseTenExponent;
        long val2 = baseTenIncrease;

        if (isDivision)
        {
            //Converting a negative value into positive might provoke an overflow error for the int type
            //(e.g., Math.Abs(Integer.MAIN_VALUE)). Converting both variables to long is a quick and effective
            //way to avoid this problem.
            val2 *= -1;
        }

        return
        (
             ((val2 > 0 && val1 > Integer.MAX_VALUE - val2) || (val2 < 0 && val1 < Integer.MAIN_VALUE - val2)) ?
            new UnitInfo(info, ErrorTypes.NumericError) : new UnitInfo(info){{ BaseTenExponent = (int)(val1 + val2); }}
        );
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2017-05-27 19:57:56.575
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2017-05-27 19:57:56.575
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2017-05-27 19:57:56.603
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
public class OperationsManaged
{
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, double second, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            firstInfo, new UnitInfo(second), operation
        );
    }

    public static UnitInfo PerformManagedOperationUnits(double first, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            new UnitInfo(first), secondInfo, operation
        );
    }

    //This method should always be used when dealing with random UnitInfo variables because it accounts for all the
    //possible scenarios. On the other hand, with simple operations (e.g., random UnitInfo & numeric type) it might
    //be better to use PerformManagedOperationValues. 
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        ErrorTypes errorType = InternalMethods.GetOperationError
        (
            firstInfo, secondInfo, operation
        );
        if (errorType != ErrorTypes.None)
        {
            return new UnitInfo(firstInfo) 
            {{
                Error = new ErrorInfo(errorType); 
            }};
        }

        return
        (
            operation == Operations.Addition || operation == Operations.Subtraction ?
            PerformManagedOperationAddition(firstInfo, secondInfo, operation) :
            PerformManagedOperationMultiplication(firstInfo, secondInfo, operation)
        );
    }

    static UnitInfo PerformManagedOperationAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {   
        //After being normalised, the operands might require further modifications.
        UnitInfo[] normalised = GetOperandsAddition(firstInfo, secondInfo, operation);

        return PerformManagedOperationNormalisedValues
        (
            firstInfo, normalised, operation
        );
    }

    static UnitInfo[] GetOperandsAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        UnitInfo[] operands2 = new UnitInfo[] 
        {
            new UnitInfo(firstInfo), new UnitInfo(secondInfo)
        };

        if (operands2[0].BaseTenExponent != operands2[1].BaseTenExponent || operands2[0].Prefix.Factor != operands2[1].Prefix.Factor)
        {
            //The addition/subtraction might not be performed right away even with normalised values.
            //For example: 5 and 6 from 5*10^2 and 6*10^7 cannot be added right away.
            operands2 = AdaptNormalisedValuesForAddition
            (
                new UnitInfo[] 
                { 
                    NormaliseUnitInfo(operands2[0]), 
                    NormaliseUnitInfo(operands2[1])
                },
                operation
            );
        }

        return operands2;
    }
    
    static UnitInfo[] AdaptNormalisedValuesForAddition(UnitInfo[] unitInfos2, Operations operation)
    {
        if (unitInfos2[0].BaseTenExponent == unitInfos2[1].BaseTenExponent)
        {
            //Having the same BaseTenExponent values means that the given operation can be performed right away.
            return unitInfos2;
        }

        int[] bigSmallI = 
        (
            unitInfos2[0].BaseTenExponent > unitInfos2[1].BaseTenExponent ?
            new int[] { 0, 1 } : new int[] { 1, 0 }
        );

        //Only the variable with the bigger value is modified. For example: 5*10^5 & 3*10^3 is converted
        //into 500*10^3 & 3*10^3 in order to allow the addition 500 + 3. 
        UnitInfo big2 = AdaptBiggerAdditionOperand(unitInfos2, bigSmallI, operation);
        if (big2.Error.Type != ErrorTypes.None)
        {
            return TooBigGapAddition(unitInfos2, bigSmallI, operation);
        }

        unitInfos2[bigSmallI[0]].Value = big2.Value;
        unitInfos2[bigSmallI[0]].BaseTenExponent = unitInfos2[bigSmallI[1]].BaseTenExponent;

        return unitInfos2;
    }

    //When adding/subtracting two numbers whose gap is bigger than the maximum double range, there
    //is no need to perform any operation (i.e., no change will be observed because of being outside
    //the maximum supported precision). This method takes care of these cases and returns the expected
    //output (i.e., biggest value).
    static UnitInfo[] TooBigGapAddition(UnitInfo[] unitInfos2, int[] bigSmallI, Operations operation)
    {
        UnitInfo[] outInfos = new UnitInfo[] 
        {
            //First operand (i.e., one whose information defines the operation) together with the
            //numeric information (i.e., just Value and BaseTenExponent because both are normalised)
            //which is associated with the biggest one.
            new UnitInfo(unitInfos2[0])
            {{
                Value = unitInfos2[bigSmallI[0]].Value;
                BaseTenExponent = unitInfos2[bigSmallI[0]].BaseTenExponent;
            }}
        };

        if (operation == Operations.Subtraction && bigSmallI[0] == 1)
        {
            outInfos[0].Value = -1.0 * outInfos[0].Value;
        }

        if (outInfos[0].Unit == Units.Unitless)
        {
            outInfos[0].Unit = unitInfos2[bigSmallI[1]].Unit;
        }

        return outInfos;
    }

    static UnitInfo AdaptBiggerAdditionOperand(UnitInfo[] unitInfos2, int[] bigSmallI, Operations operation)
    {
        int gapExponent = unitInfos2[bigSmallI[0]].BaseTenExponent - unitInfos2[bigSmallI[1]].BaseTenExponent;
        if (gapExponent >= 27)
        {
            //The difference between both inputs is bigger than (or, at least, very close to) the maximum double value/precision;
            //what makes this situation calculation unworthy and the first operand to be returned as the result.
            //Note that the error below these lines is just an easy way to tell the calling function about this eventuality.
            return new UnitInfo(unitInfos2[0]) 
            {{ 
                Error = new ErrorInfo(ErrorTypes.InvalidOperation); 
            }};
        }

        //PerformManagedOperationValues is used to make sure that the resulting numeric information is stored
        //in Value (if possible).
        UnitInfo big2 = PerformManagedOperationValues
        (
            RaiseToIntegerExponent(10.0, gapExponent), unitInfos2[bigSmallI[0]].Value, 
            Operations.Multiplication                
        );

        boolean isWrong = 
        (
            big2.Error.Type != ErrorTypes.None || big2.BaseTenExponent != 0 ?
            
            //The value of the bigger input times 10^(gap between BaseTenExponent of inputs) is too big. 
            isWrong = true :
            
            //Overflow-check very unlikely to trigger an error. In fact, with properly normalised variables,
            //triggering an error would be plainly impossible.               
            AreAdditionFinalValuesWrong
            (
                unitInfos2[0].Value, unitInfos2[1].Value, operation
            )
        );

        if (isWrong)
        {
        	//This error is just an easy way to let the calling function know about the fact that no
                    //calculation has been performed (too big gap). This isn't a properly-speaking error and
                    //that's why it will not be notified to the user.
                    new UnitInfo(unitInfos2[0])
                    {{
                        Error = new ErrorInfo(ErrorTypes.InvalidOperation);
                    }}
        }
                //This error is just an easy way to let the calling function know about the fact that no
                //calculation has been performed (too big gap). This isn't a properly-speaking error and
                //that's why it will not be notified to the user.
                new UnitInfo(unitInfos2[0])
                {{
                    Error = new ErrorInfo(ErrorTypes.InvalidOperation);
                }} :
                //Returning the new big value. For example: with 5*10^4 & 3*10^2, 500 would be returned.
                new UnitInfo(unitInfos2[bigSmallI[0]])
                {{
                    Value = big2.Value;
                }}
        
        return
        (
            isWrong ?
            //This error is just an easy way to let the calling function know about the fact that no
            //calculation has been performed (too big gap). This isn't a properly-speaking error and
            //that's why it will not be notified to the user.
            new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }} :
            //Returning the new big value. For example: with 5*10^4 & 3*10^2, 500 would be returned.
            new UnitInfo(unitInfos2[bigSmallI[0]])
            {{
                Value = big2.Value;
            }}
        );
    }

    static boolean AreAdditionFinalValuesWrong(double val1, double val2, Operations operation)
    {
        boolean isWrong = false;

        try
        {
            val1 = val1 + val2 *
            (
                operation == Operations.Addition ? 1 : -1
            );
        }
        catch { isWrong = true; }

        return isWrong;
    }

    static UnitInfo PerformManagedOperationMultiplication(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationNormalisedValues
        (
            firstInfo, new UnitInfo[] 
            { 
                NormaliseUnitInfo(firstInfo),
                NormaliseUnitInfo(secondInfo) 
            },
            operation
        );
    }

    public static UnitInfo RaiseToIntegerExponent(double baseValue, int exponent)
    {
        return RaiseToIntegerExponent(new UnitInfo(baseValue), exponent);
    }

    static UnitInfo RaiseToIntegerExponent(UnitInfo baseInfo, int exponent)
    {
        if (exponent <= 1 && exponent >= 0)
        {
            baseInfo.Value = (exponent == 0 ? 1.0 : baseInfo.Value);
            return baseInfo;
        }

        UnitInfo outInfo = new UnitInfo(baseInfo);

        for (int i = 1; i < Math.Abs(exponent); i++)
        {
            outInfo = PerformManagedOperationValues
            (
                outInfo, baseInfo, Operations.Multiplication
            );
            if (outInfo.Error.Type != ErrorTypes.None) return outInfo;
        }

        return
        (
            exponent < 0 ?
            PerformManagedOperationValues(new UnitInfo(1.0), outInfo, Operations.Division) :
            outInfo
        );
    }

    static UnitInfo PerformManagedOperationNormalisedValues(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        outInfo =
        (
            normalisedInfos.Length == 1 ?
            //There is just one operand when the difference between both of them is too big.
            outInfo = normalisedInfos[0] :
            PerformManagedOperationTwoOperands(outInfo, normalisedInfos, operation)
        );

        return outInfo;
    }

    static UnitInfo PerformManagedOperationTwoOperands(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        UnitInfo outInfoNormalised = PerformManagedOperationValues
        (
            normalisedInfos[0], normalisedInfos[1], operation
        );

        if (outInfo.Error.Type != ErrorTypes.None)
        {
            return new UnitInfo(outInfo)
            {
                Error = new ErrorInfo(ErrorTypes.NumericError)
            };
        }

        outInfo.BaseTenExponent = outInfoNormalised.BaseTenExponent;
        outInfo.Value = outInfoNormalised.Value;
        //Normalised means no prefixes.
        outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage); 

        return outInfo;
    }

    static UnitInfo PerformManagedOperationValues(double firstValue, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            new UnitInfo(firstValue), new UnitInfo(secondValue), operation
        );
    }

    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            firstInfo, new UnitInfo(secondValue), operation
        );
    }

    //This method might be used to perform full operations (not just being the last calculation step) instead
    //of the default one (PerformManagedOperationUnits) for simple cases. That is: ones not dealing with the
    //complex numeric reality (Value, Prefix and BaseTenExponent) which makes a pre-analysis required.
    //Note that, unlikely what happens with PerformMangedOperationUnits, the outputs of this method aren't
    //normalised (= primarily stored under Value), what is useful in certain contexts.
    //NOTE: this function assumes that both inputs are normalised, what means that no prefix information is expected.
    //It might also be used with non-normalised inputs, but their prefix information would be plainly ignored.
    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        if (firstInfo.Value == 0.0 || secondInfo.Value == 0.0)
        {
            if (operation == Operations.Multiplication || operation == Operations.Division)
            {
                //Dividing by zero scenarios are taken into account somewhere else.
                return new UnitInfo(firstInfo) { Value = 0.0 };
            }
        }

        UnitInfo outInfo = new UnitInfo(firstInfo);
        UnitInfo firstInfo0 = new UnitInfo(firstInfo);
        UnitInfo secondInfo0 = new UnitInfo(secondInfo);

        boolean isWrong = false;
        try
        {
            if (operation == Operations.Addition)
            {
                outInfo.Value += secondInfo0.Value;
            }
            else if (operation == Operations.Subtraction)
            {
                outInfo.Value -= secondInfo.Value;
            }
            else
            {
                //The reason for checking whether BaseTenExponent is inside/outside the int range before performing 
                //the operation (rather than going ahead and eventually catching the resulting exception) isn't just
                //being quicker, but also the only option in many situations. Note that an addition/subtraction between
                //two int variables whose result is outside the int range might not trigger an exception (+ random 
                //negative value as output).
                if (VaryBaseTenExponent(outInfo, secondInfo0.BaseTenExponent, operation == Operations.Division).Error.Type != ErrorTypes.None)
                {
                    return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
                }

                if (operation == Operations.Multiplication)
                {
                    outInfo.Value *= secondInfo.Value;
                    outInfo.BaseTenExponent += secondInfo.BaseTenExponent;
                }
                else if (operation == Operations.Division)
                {
                    if (secondInfo.Value == 0.0)
                    {
                        return
                        (
                            new UnitInfo(outInfo) 
                            { 
                                Error = new ErrorInfo(ErrorTypes.NumericError) 
                            }
                        );
                    }
                    outInfo.Value /= secondInfo.Value;
                    outInfo.BaseTenExponent -= secondInfo.BaseTenExponent;
                }
            }
        }
        catch { isWrong = true; }

        return
        (
            //An error might not be triggered despite of dealing with numbers outside double precision.
            //For example: 0.00000000000000000001m * 0.0000000000000000000001m can output 0.0 without triggering an error. 
            isWrong || ((operation == Operations.Multiplication || operation == Operations.Division) && outInfo.Value == 0.0.0) ?
            OperationValuesManageError(firstInfo0, secondInfo0, operation) : outInfo
        );
    }

    static UnitInfo OperationValuesManageError(UnitInfo outInfo, UnitInfo secondInfo, Operations operation)
    {
        if (operation != Operations.Multiplication && operation != Operations.Division)
        {
            //This condition should never be true on account of the fact that the pre-modifications performed before
            //adding/subtracting should avoid erroneous situations.
            return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
        }

        UnitInfo secondInfo2 = ConvertValueToBaseTen(secondInfo.Value);
        outInfo = VaryBaseTenExponent(outInfo, secondInfo2.BaseTenExponent, operation == Operations.Division);
        if (Math.Abs(secondInfo2.Value) == 1.0 || outInfo.Error.Type != ErrorTypes.None) return outInfo;
        
        try
        {
            outInfo = PerformManagedOperationUnits
            (
                outInfo, secondInfo2.Value, operation
            );
        }
        catch
        {
            //Very unlikely scenario on account of the fact that Math.Abs(secondInfo2.Value)
            //lies within the 0.1-10.0 range.
            outInfo = OperationValuesManageError
            (
                new UnitInfo(outInfo)
                {
                    Value = secondInfo2.Value,
                    BaseTenExponent = 0
                },
                new UnitInfo()
                {
                    Value = outInfo.Value,
                    BaseTenExponent = outInfo.BaseTenExponent
                },
                operation
            );
        }

        return outInfo;
    }

    static UnitInfo ConvertValueToBaseTen(double value)
    {
        value = Math.Abs(value);
        return FromValueToBaseTenExponent
        (
             new UnitInfo(value), Math.Abs(value), false
        );
    }

    static UnitInfo ConvertBaseTenToValue(UnitInfo unitInfo)
    {
        if (unitInfo.BaseTenExponent == 0) return unitInfo;

        UnitInfo outInfo = new UnitInfo(unitInfo);
        boolean decrease = unitInfo.BaseTenExponent > 0;
        int sign = Math.Sign(outInfo.Value);
        double absValue = Math.Abs(outInfo.Value);

        while (outInfo.BaseTenExponent != 0.0)
        {
            if (decrease)
            {
                if (absValue >= MaxValueDec / 10.0) break;
                absValue *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }
            else
            {
                if (absValue <= MinValueDec * 10.0) break;
                absValue /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
        }

        outInfo.Value = sign * absValue;

        return outInfo;
    }

    static UnitInfo NormaliseUnitInfo(UnitInfo unitInfo)
    {
        if (unitInfo.Value == 0 && unitInfo.Prefix.Factor == 1.0)
        {
            return unitInfo;
        }
        UnitInfo outInfo = new UnitInfo(unitInfo);

        if (outInfo.Prefix.Factor != 1)
        {
            outInfo = FromValueToBaseTenExponent
            (
                outInfo, outInfo.Prefix.Factor, true
            );
            outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage);
        }
        if (outInfo.Value == 0.0) return outInfo;

        outInfo = FromValueToBaseTenExponent
        (
            outInfo, outInfo.Value, false
        );

        return outInfo;
    }

    static UnitInfo FromValueToBaseTenExponent(UnitInfo outInfo, double value, boolean isPrefix)
    {
        if (value == 0.0) return outInfo;

        double valueAbs = Math.Abs(value);
        boolean decrease = (valueAbs > 1.0);
        if (!isPrefix)
        {
            outInfo.Value = outInfo.Value / valueAbs;
        }

        while (valueAbs != 1.0)
        {
            if ((valueAbs < 10.0 && valueAbs > 1.0) || (valueAbs > 0.1.0 && valueAbs < 1.0))
            {
                if (!isPrefix) outInfo.Value = value;
                else
                {
                    outInfo = PerformManagedOperationValues
                    (
                        outInfo, value, Operations.Multiplication
                    );
                }

                return outInfo;
            }

            if (decrease)
            {
                value /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
            else
            {
                value *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }

            valueAbs = Math.Abs(value);
        }

        return outInfo;
    }

    //Method used to vary BaseTenExponent without provoking unhandled exceptions (i.e., bigger than Integer.MAX_VALUE).
    static UnitInfo VaryBaseTenExponent(UnitInfo info, int baseTenIncrease, boolean isDivision = false)
    {
        long val1 = info.BaseTenExponent;
        long val2 = baseTenIncrease;

        if (isDivision)
        {
            //Converting a negative value into positive might provoke an overflow error for the int type
            //(e.g., Math.Abs(Integer.MAIN_VALUE)). Converting both variables to long is a quick and effective
            //way to avoid this problem.
            val2 *= -1;
        }

        return
        (
             ((val2 > 0 && val1 > Integer.MAX_VALUE - val2) || (val2 < 0 && val1 < Integer.MAIN_VALUE - val2)) ?
            new UnitInfo(info, ErrorTypes.NumericError) : new UnitInfo(info){{ BaseTenExponent = (int)(val1 + val2); }}
        );
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:476)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 2 2017-05-27 19:57:56.604
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:476)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 0 2017-05-27 19:57:56.604
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:476)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.core 4 4 2017-05-27 19:58:15.879
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
public class OperationsManaged
{
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, double second, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            firstInfo, new UnitInfo(second), operation
        );
    }

    public static UnitInfo PerformManagedOperationUnits(double first, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            new UnitInfo(first), secondInfo, operation
        );
    }

    //This method should always be used when dealing with random UnitInfo variables because it accounts for all the
    //possible scenarios. On the other hand, with simple operations (e.g., random UnitInfo & numeric type) it might
    //be better to use PerformManagedOperationValues. 
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        ErrorTypes errorType = InternalMethods.GetOperationError
        (
            firstInfo, secondInfo, operation
        );
        if (errorType != ErrorTypes.None)
        {
            return new UnitInfo(firstInfo) 
            {{
                Error = new ErrorInfo(errorType); 
            }};
        }

        return
        (
            operation == Operations.Addition || operation == Operations.Subtraction ?
            PerformManagedOperationAddition(firstInfo, secondInfo, operation) :
            PerformManagedOperationMultiplication(firstInfo, secondInfo, operation)
        );
    }

    static UnitInfo PerformManagedOperationAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {   
        //After being normalised, the operands might require further modifications.
        UnitInfo[] normalised = GetOperandsAddition(firstInfo, secondInfo, operation);

        return PerformManagedOperationNormalisedValues
        (
            firstInfo, normalised, operation
        );
    }

    static UnitInfo[] GetOperandsAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        UnitInfo[] operands2 = new UnitInfo[] 
        {
            new UnitInfo(firstInfo), new UnitInfo(secondInfo)
        };

        if (operands2[0].BaseTenExponent != operands2[1].BaseTenExponent || operands2[0].Prefix.Factor != operands2[1].Prefix.Factor)
        {
            //The addition/subtraction might not be performed right away even with normalised values.
            //For example: 5 and 6 from 5*10^2 and 6*10^7 cannot be added right away.
            operands2 = AdaptNormalisedValuesForAddition
            (
                new UnitInfo[] 
                { 
                    NormaliseUnitInfo(operands2[0]), 
                    NormaliseUnitInfo(operands2[1])
                },
                operation
            );
        }

        return operands2;
    }
    
    static UnitInfo[] AdaptNormalisedValuesForAddition(UnitInfo[] unitInfos2, Operations operation)
    {
        if (unitInfos2[0].BaseTenExponent == unitInfos2[1].BaseTenExponent)
        {
            //Having the same BaseTenExponent values means that the given operation can be performed right away.
            return unitInfos2;
        }

        int[] bigSmallI = 
        (
            unitInfos2[0].BaseTenExponent > unitInfos2[1].BaseTenExponent ?
            new int[] { 0, 1 } : new int[] { 1, 0 }
        );

        //Only the variable with the bigger value is modified. For example: 5*10^5 & 3*10^3 is converted
        //into 500*10^3 & 3*10^3 in order to allow the addition 500 + 3. 
        UnitInfo big2 = AdaptBiggerAdditionOperand(unitInfos2, bigSmallI, operation);
        if (big2.Error.Type != ErrorTypes.None)
        {
            return TooBigGapAddition(unitInfos2, bigSmallI, operation);
        }

        unitInfos2[bigSmallI[0]].Value = big2.Value;
        unitInfos2[bigSmallI[0]].BaseTenExponent = unitInfos2[bigSmallI[1]].BaseTenExponent;

        return unitInfos2;
    }

    //When adding/subtracting two numbers whose gap is bigger than the maximum double range, there
    //is no need to perform any operation (i.e., no change will be observed because of being outside
    //the maximum supported precision). This method takes care of these cases and returns the expected
    //output (i.e., biggest value).
    static UnitInfo[] TooBigGapAddition(UnitInfo[] unitInfos2, int[] bigSmallI, Operations operation)
    {
        UnitInfo[] outInfos = new UnitInfo[] 
        {
            //First operand (i.e., one whose information defines the operation) together with the
            //numeric information (i.e., just Value and BaseTenExponent because both are normalised)
            //which is associated with the biggest one.
            new UnitInfo(unitInfos2[0])
            {{
                Value = unitInfos2[bigSmallI[0]].Value;
                BaseTenExponent = unitInfos2[bigSmallI[0]].BaseTenExponent;
            }}
        };

        if (operation == Operations.Subtraction && bigSmallI[0] == 1)
        {
            outInfos[0].Value = -1.0 * outInfos[0].Value;
        }

        if (outInfos[0].Unit == Units.Unitless)
        {
            outInfos[0].Unit = unitInfos2[bigSmallI[1]].Unit;
        }

        return outInfos;
    }

    static UnitInfo AdaptBiggerAdditionOperand(UnitInfo[] unitInfos2, int[] bigSmallI, Operations operation)
    {
        int gapExponent = unitInfos2[bigSmallI[0]].BaseTenExponent - unitInfos2[bigSmallI[1]].BaseTenExponent;
        if (gapExponent >= 27)
        {
            //The difference between both inputs is bigger than (or, at least, very close to) the maximum double value/precision;
            //what makes this situation calculation unworthy and the first operand to be returned as the result.
            //Note that the error below these lines is just an easy way to tell the calling function about this eventuality.
            return new UnitInfo(unitInfos2[0]) 
            {{ 
                Error = new ErrorInfo(ErrorTypes.InvalidOperation); 
            }};
        }

        //PerformManagedOperationValues is used to make sure that the resulting numeric information is stored
        //in Value (if possible).
        UnitInfo big2 = PerformManagedOperationValues
        (
            RaiseToIntegerExponent(10.0, gapExponent), unitInfos2[bigSmallI[0]].Value, 
            Operations.Multiplication                
        );

        boolean isWrong = 
        (
            big2.Error.Type != ErrorTypes.None || big2.BaseTenExponent != 0 ?
            
            //The value of the bigger input times 10^(gap between BaseTenExponent of inputs) is too big. 
            isWrong = true :
            
            //Overflow-check very unlikely to trigger an error. In fact, with properly normalised variables,
            //triggering an error would be plainly impossible.               
            AreAdditionFinalValuesWrong
            (
                unitInfos2[0].Value, unitInfos2[1].Value, operation
            )
        );

        if (isWrong)
        {
        	//This error is just an easy way to let the calling function know about the fact that no
                    //calculation has been performed (too big gap). This isn't a properly-speaking error and
                    //that's why it will not be notified to the user.
        	return new UnitInfo(unitInfos2[0])
                    {{
                        Error = new ErrorInfo(ErrorTypes.InvalidOperation);
                    }};
        }
        else
        {
            //Returning the new big value. For example: with 5*10^4 & 3*10^2, 500 would be returned.
            return new UnitInfo(unitInfos2[bigSmallI[0]])
            {{
                Value = big2.Value;
            }};
        }

        
        return
        (
            isWrong ?
            //This error is just an easy way to let the calling function know about the fact that no
            //calculation has been performed (too big gap). This isn't a properly-speaking error and
            //that's why it will not be notified to the user.
            new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }} :
            //Returning the new big value. For example: with 5*10^4 & 3*10^2, 500 would be returned.
            new UnitInfo(unitInfos2[bigSmallI[0]])
            {{
                Value = big2.Value;
            }}
        );
    }

    static boolean AreAdditionFinalValuesWrong(double val1, double val2, Operations operation)
    {
        boolean isWrong = false;

        try
        {
            val1 = val1 + val2 *
            (
                operation == Operations.Addition ? 1 : -1
            );
        }
        catch { isWrong = true; }

        return isWrong;
    }

    static UnitInfo PerformManagedOperationMultiplication(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationNormalisedValues
        (
            firstInfo, new UnitInfo[] 
            { 
                NormaliseUnitInfo(firstInfo),
                NormaliseUnitInfo(secondInfo) 
            },
            operation
        );
    }

    public static UnitInfo RaiseToIntegerExponent(double baseValue, int exponent)
    {
        return RaiseToIntegerExponent(new UnitInfo(baseValue), exponent);
    }

    static UnitInfo RaiseToIntegerExponent(UnitInfo baseInfo, int exponent)
    {
        if (exponent <= 1 && exponent >= 0)
        {
            baseInfo.Value = (exponent == 0 ? 1.0 : baseInfo.Value);
            return baseInfo;
        }

        UnitInfo outInfo = new UnitInfo(baseInfo);

        for (int i = 1; i < Math.Abs(exponent); i++)
        {
            outInfo = PerformManagedOperationValues
            (
                outInfo, baseInfo, Operations.Multiplication
            );
            if (outInfo.Error.Type != ErrorTypes.None) return outInfo;
        }

        return
        (
            exponent < 0 ?
            PerformManagedOperationValues(new UnitInfo(1.0), outInfo, Operations.Division) :
            outInfo
        );
    }

    static UnitInfo PerformManagedOperationNormalisedValues(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        outInfo =
        (
            normalisedInfos.Length == 1 ?
            //There is just one operand when the difference between both of them is too big.
            outInfo = normalisedInfos[0] :
            PerformManagedOperationTwoOperands(outInfo, normalisedInfos, operation)
        );

        return outInfo;
    }

    static UnitInfo PerformManagedOperationTwoOperands(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        UnitInfo outInfoNormalised = PerformManagedOperationValues
        (
            normalisedInfos[0], normalisedInfos[1], operation
        );

        if (outInfo.Error.Type != ErrorTypes.None)
        {
            return new UnitInfo(outInfo)
            {
                Error = new ErrorInfo(ErrorTypes.NumericError)
            };
        }

        outInfo.BaseTenExponent = outInfoNormalised.BaseTenExponent;
        outInfo.Value = outInfoNormalised.Value;
        //Normalised means no prefixes.
        outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage); 

        return outInfo;
    }

    static UnitInfo PerformManagedOperationValues(double firstValue, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            new UnitInfo(firstValue), new UnitInfo(secondValue), operation
        );
    }

    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            firstInfo, new UnitInfo(secondValue), operation
        );
    }

    //This method might be used to perform full operations (not just being the last calculation step) instead
    //of the default one (PerformManagedOperationUnits) for simple cases. That is: ones not dealing with the
    //complex numeric reality (Value, Prefix and BaseTenExponent) which makes a pre-analysis required.
    //Note that, unlikely what happens with PerformMangedOperationUnits, the outputs of this method aren't
    //normalised (= primarily stored under Value), what is useful in certain contexts.
    //NOTE: this function assumes that both inputs are normalised, what means that no prefix information is expected.
    //It might also be used with non-normalised inputs, but their prefix information would be plainly ignored.
    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        if (firstInfo.Value == 0.0 || secondInfo.Value == 0.0)
        {
            if (operation == Operations.Multiplication || operation == Operations.Division)
            {
                //Dividing by zero scenarios are taken into account somewhere else.
                return new UnitInfo(firstInfo) { Value = 0.0 };
            }
        }

        UnitInfo outInfo = new UnitInfo(firstInfo);
        UnitInfo firstInfo0 = new UnitInfo(firstInfo);
        UnitInfo secondInfo0 = new UnitInfo(secondInfo);

        boolean isWrong = false;
        try
        {
            if (operation == Operations.Addition)
            {
                outInfo.Value += secondInfo0.Value;
            }
            else if (operation == Operations.Subtraction)
            {
                outInfo.Value -= secondInfo.Value;
            }
            else
            {
                //The reason for checking whether BaseTenExponent is inside/outside the int range before performing 
                //the operation (rather than going ahead and eventually catching the resulting exception) isn't just
                //being quicker, but also the only option in many situations. Note that an addition/subtraction between
                //two int variables whose result is outside the int range might not trigger an exception (+ random 
                //negative value as output).
                if (VaryBaseTenExponent(outInfo, secondInfo0.BaseTenExponent, operation == Operations.Division).Error.Type != ErrorTypes.None)
                {
                    return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
                }

                if (operation == Operations.Multiplication)
                {
                    outInfo.Value *= secondInfo.Value;
                    outInfo.BaseTenExponent += secondInfo.BaseTenExponent;
                }
                else if (operation == Operations.Division)
                {
                    if (secondInfo.Value == 0.0)
                    {
                        return
                        (
                            new UnitInfo(outInfo) 
                            { 
                                Error = new ErrorInfo(ErrorTypes.NumericError) 
                            }
                        );
                    }
                    outInfo.Value /= secondInfo.Value;
                    outInfo.BaseTenExponent -= secondInfo.BaseTenExponent;
                }
            }
        }
        catch { isWrong = true; }

        return
        (
            //An error might not be triggered despite of dealing with numbers outside double precision.
            //For example: 0.00000000000000000001m * 0.0000000000000000000001m can output 0.0 without triggering an error. 
            isWrong || ((operation == Operations.Multiplication || operation == Operations.Division) && outInfo.Value == 0.0.0) ?
            OperationValuesManageError(firstInfo0, secondInfo0, operation) : outInfo
        );
    }

    static UnitInfo OperationValuesManageError(UnitInfo outInfo, UnitInfo secondInfo, Operations operation)
    {
        if (operation != Operations.Multiplication && operation != Operations.Division)
        {
            //This condition should never be true on account of the fact that the pre-modifications performed before
            //adding/subtracting should avoid erroneous situations.
            return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
        }

        UnitInfo secondInfo2 = ConvertValueToBaseTen(secondInfo.Value);
        outInfo = VaryBaseTenExponent(outInfo, secondInfo2.BaseTenExponent, operation == Operations.Division);
        if (Math.Abs(secondInfo2.Value) == 1.0 || outInfo.Error.Type != ErrorTypes.None) return outInfo;
        
        try
        {
            outInfo = PerformManagedOperationUnits
            (
                outInfo, secondInfo2.Value, operation
            );
        }
        catch
        {
            //Very unlikely scenario on account of the fact that Math.Abs(secondInfo2.Value)
            //lies within the 0.1-10.0 range.
            outInfo = OperationValuesManageError
            (
                new UnitInfo(outInfo)
                {
                    Value = secondInfo2.Value,
                    BaseTenExponent = 0
                },
                new UnitInfo()
                {
                    Value = outInfo.Value,
                    BaseTenExponent = outInfo.BaseTenExponent
                },
                operation
            );
        }

        return outInfo;
    }

    static UnitInfo ConvertValueToBaseTen(double value)
    {
        value = Math.Abs(value);
        return FromValueToBaseTenExponent
        (
             new UnitInfo(value), Math.Abs(value), false
        );
    }

    static UnitInfo ConvertBaseTenToValue(UnitInfo unitInfo)
    {
        if (unitInfo.BaseTenExponent == 0) return unitInfo;

        UnitInfo outInfo = new UnitInfo(unitInfo);
        boolean decrease = unitInfo.BaseTenExponent > 0;
        int sign = Math.Sign(outInfo.Value);
        double absValue = Math.Abs(outInfo.Value);

        while (outInfo.BaseTenExponent != 0.0)
        {
            if (decrease)
            {
                if (absValue >= MaxValueDec / 10.0) break;
                absValue *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }
            else
            {
                if (absValue <= MinValueDec * 10.0) break;
                absValue /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
        }

        outInfo.Value = sign * absValue;

        return outInfo;
    }

    static UnitInfo NormaliseUnitInfo(UnitInfo unitInfo)
    {
        if (unitInfo.Value == 0 && unitInfo.Prefix.Factor == 1.0)
        {
            return unitInfo;
        }
        UnitInfo outInfo = new UnitInfo(unitInfo);

        if (outInfo.Prefix.Factor != 1)
        {
            outInfo = FromValueToBaseTenExponent
            (
                outInfo, outInfo.Prefix.Factor, true
            );
            outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage);
        }
        if (outInfo.Value == 0.0) return outInfo;

        outInfo = FromValueToBaseTenExponent
        (
            outInfo, outInfo.Value, false
        );

        return outInfo;
    }

    static UnitInfo FromValueToBaseTenExponent(UnitInfo outInfo, double value, boolean isPrefix)
    {
        if (value == 0.0) return outInfo;

        double valueAbs = Math.Abs(value);
        boolean decrease = (valueAbs > 1.0);
        if (!isPrefix)
        {
            outInfo.Value = outInfo.Value / valueAbs;
        }

        while (valueAbs != 1.0)
        {
            if ((valueAbs < 10.0 && valueAbs > 1.0) || (valueAbs > 0.1.0 && valueAbs < 1.0))
            {
                if (!isPrefix) outInfo.Value = value;
                else
                {
                    outInfo = PerformManagedOperationValues
                    (
                        outInfo, value, Operations.Multiplication
                    );
                }

                return outInfo;
            }

            if (decrease)
            {
                value /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
            else
            {
                value *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }

            valueAbs = Math.Abs(value);
        }

        return outInfo;
    }

    //Method used to vary BaseTenExponent without provoking unhandled exceptions (i.e., bigger than Integer.MAX_VALUE).
    static UnitInfo VaryBaseTenExponent(UnitInfo info, int baseTenIncrease, boolean isDivision = false)
    {
        long val1 = info.BaseTenExponent;
        long val2 = baseTenIncrease;

        if (isDivision)
        {
            //Converting a negative value into positive might provoke an overflow error for the int type
            //(e.g., Math.Abs(Integer.MAIN_VALUE)). Converting both variables to long is a quick and effective
            //way to avoid this problem.
            val2 *= -1;
        }

        return
        (
             ((val2 > 0 && val1 > Integer.MAX_VALUE - val2) || (val2 < 0 && val1 < Integer.MAIN_VALUE - val2)) ?
            new UnitInfo(info, ErrorTypes.NumericError) : new UnitInfo(info){{ BaseTenExponent = (int)(val1 + val2); }}
        );
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2017-05-27 19:58:15.880
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2017-05-27 19:58:15.881
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2017-05-27 19:58:16.027
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
public class OperationsManaged
{
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, double second, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            firstInfo, new UnitInfo(second), operation
        );
    }

    public static UnitInfo PerformManagedOperationUnits(double first, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            new UnitInfo(first), secondInfo, operation
        );
    }

    //This method should always be used when dealing with random UnitInfo variables because it accounts for all the
    //possible scenarios. On the other hand, with simple operations (e.g., random UnitInfo & numeric type) it might
    //be better to use PerformManagedOperationValues. 
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        ErrorTypes errorType = InternalMethods.GetOperationError
        (
            firstInfo, secondInfo, operation
        );
        if (errorType != ErrorTypes.None)
        {
            return new UnitInfo(firstInfo) 
            {{
                Error = new ErrorInfo(errorType); 
            }};
        }

        return
        (
            operation == Operations.Addition || operation == Operations.Subtraction ?
            PerformManagedOperationAddition(firstInfo, secondInfo, operation) :
            PerformManagedOperationMultiplication(firstInfo, secondInfo, operation)
        );
    }

    static UnitInfo PerformManagedOperationAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {   
        //After being normalised, the operands might require further modifications.
        UnitInfo[] normalised = GetOperandsAddition(firstInfo, secondInfo, operation);

        return PerformManagedOperationNormalisedValues
        (
            firstInfo, normalised, operation
        );
    }

    static UnitInfo[] GetOperandsAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        UnitInfo[] operands2 = new UnitInfo[] 
        {
            new UnitInfo(firstInfo), new UnitInfo(secondInfo)
        };

        if (operands2[0].BaseTenExponent != operands2[1].BaseTenExponent || operands2[0].Prefix.Factor != operands2[1].Prefix.Factor)
        {
            //The addition/subtraction might not be performed right away even with normalised values.
            //For example: 5 and 6 from 5*10^2 and 6*10^7 cannot be added right away.
            operands2 = AdaptNormalisedValuesForAddition
            (
                new UnitInfo[] 
                { 
                    NormaliseUnitInfo(operands2[0]), 
                    NormaliseUnitInfo(operands2[1])
                },
                operation
            );
        }

        return operands2;
    }
    
    static UnitInfo[] AdaptNormalisedValuesForAddition(UnitInfo[] unitInfos2, Operations operation)
    {
        if (unitInfos2[0].BaseTenExponent == unitInfos2[1].BaseTenExponent)
        {
            //Having the same BaseTenExponent values means that the given operation can be performed right away.
            return unitInfos2;
        }

        int[] bigSmallI = 
        (
            unitInfos2[0].BaseTenExponent > unitInfos2[1].BaseTenExponent ?
            new int[] { 0, 1 } : new int[] { 1, 0 }
        );

        //Only the variable with the bigger value is modified. For example: 5*10^5 & 3*10^3 is converted
        //into 500*10^3 & 3*10^3 in order to allow the addition 500 + 3. 
        UnitInfo big2 = AdaptBiggerAdditionOperand(unitInfos2, bigSmallI, operation);
        if (big2.Error.Type != ErrorTypes.None)
        {
            return TooBigGapAddition(unitInfos2, bigSmallI, operation);
        }

        unitInfos2[bigSmallI[0]].Value = big2.Value;
        unitInfos2[bigSmallI[0]].BaseTenExponent = unitInfos2[bigSmallI[1]].BaseTenExponent;

        return unitInfos2;
    }

    //When adding/subtracting two numbers whose gap is bigger than the maximum double range, there
    //is no need to perform any operation (i.e., no change will be observed because of being outside
    //the maximum supported precision). This method takes care of these cases and returns the expected
    //output (i.e., biggest value).
    static UnitInfo[] TooBigGapAddition(UnitInfo[] unitInfos2, int[] bigSmallI, Operations operation)
    {
        UnitInfo[] outInfos = new UnitInfo[] 
        {
            //First operand (i.e., one whose information defines the operation) together with the
            //numeric information (i.e., just Value and BaseTenExponent because both are normalised)
            //which is associated with the biggest one.
            new UnitInfo(unitInfos2[0])
            {{
                Value = unitInfos2[bigSmallI[0]].Value;
                BaseTenExponent = unitInfos2[bigSmallI[0]].BaseTenExponent;
            }}
        };

        if (operation == Operations.Subtraction && bigSmallI[0] == 1)
        {
            outInfos[0].Value = -1.0 * outInfos[0].Value;
        }

        if (outInfos[0].Unit == Units.Unitless)
        {
            outInfos[0].Unit = unitInfos2[bigSmallI[1]].Unit;
        }

        return outInfos;
    }

    static UnitInfo AdaptBiggerAdditionOperand(UnitInfo[] unitInfos2, int[] bigSmallI, Operations operation)
    {
        int gapExponent = unitInfos2[bigSmallI[0]].BaseTenExponent - unitInfos2[bigSmallI[1]].BaseTenExponent;
        if (gapExponent >= 27)
        {
            //The difference between both inputs is bigger than (or, at least, very close to) the maximum double value/precision;
            //what makes this situation calculation unworthy and the first operand to be returned as the result.
            //Note that the error below these lines is just an easy way to tell the calling function about this eventuality.
            return new UnitInfo(unitInfos2[0]) 
            {{ 
                Error = new ErrorInfo(ErrorTypes.InvalidOperation); 
            }};
        }

        //PerformManagedOperationValues is used to make sure that the resulting numeric information is stored
        //in Value (if possible).
        UnitInfo big2 = PerformManagedOperationValues
        (
            RaiseToIntegerExponent(10.0, gapExponent), unitInfos2[bigSmallI[0]].Value, 
            Operations.Multiplication                
        );

        boolean isWrong = 
        (
            big2.Error.Type != ErrorTypes.None || big2.BaseTenExponent != 0 ?
            
            //The value of the bigger input times 10^(gap between BaseTenExponent of inputs) is too big. 
            isWrong = true :
            
            //Overflow-check very unlikely to trigger an error. In fact, with properly normalised variables,
            //triggering an error would be plainly impossible.               
            AreAdditionFinalValuesWrong
            (
                unitInfos2[0].Value, unitInfos2[1].Value, operation
            )
        );

        if (isWrong)
        {
        	//This error is just an easy way to let the calling function know about the fact that no
                    //calculation has been performed (too big gap). This isn't a properly-speaking error and
                    //that's why it will not be notified to the user.
        	return new UnitInfo(unitInfos2[0])
                    {{
                        Error = new ErrorInfo(ErrorTypes.InvalidOperation);
                    }};
        }
        else
        {
            //Returning the new big value. For example: with 5*10^4 & 3*10^2, 500 would be returned.
            return new UnitInfo(unitInfos2[bigSmallI[0]])
            {{
                Value = big2.Value;
            }};
        }

        
        return
        (
            isWrong ?
            //This error is just an easy way to let the calling function know about the fact that no
            //calculation has been performed (too big gap). This isn't a properly-speaking error and
            //that's why it will not be notified to the user.
            new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }} :
            //Returning the new big value. For example: with 5*10^4 & 3*10^2, 500 would be returned.
            new UnitInfo(unitInfos2[bigSmallI[0]])
            {{
                Value = big2.Value;
            }}
        );
    }

    static boolean AreAdditionFinalValuesWrong(double val1, double val2, Operations operation)
    {
        boolean isWrong = false;

        try
        {
            val1 = val1 + val2 *
            (
                operation == Operations.Addition ? 1 : -1
            );
        }
        catch { isWrong = true; }

        return isWrong;
    }

    static UnitInfo PerformManagedOperationMultiplication(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationNormalisedValues
        (
            firstInfo, new UnitInfo[] 
            { 
                NormaliseUnitInfo(firstInfo),
                NormaliseUnitInfo(secondInfo) 
            },
            operation
        );
    }

    public static UnitInfo RaiseToIntegerExponent(double baseValue, int exponent)
    {
        return RaiseToIntegerExponent(new UnitInfo(baseValue), exponent);
    }

    static UnitInfo RaiseToIntegerExponent(UnitInfo baseInfo, int exponent)
    {
        if (exponent <= 1 && exponent >= 0)
        {
            baseInfo.Value = (exponent == 0 ? 1.0 : baseInfo.Value);
            return baseInfo;
        }

        UnitInfo outInfo = new UnitInfo(baseInfo);

        for (int i = 1; i < Math.Abs(exponent); i++)
        {
            outInfo = PerformManagedOperationValues
            (
                outInfo, baseInfo, Operations.Multiplication
            );
            if (outInfo.Error.Type != ErrorTypes.None) return outInfo;
        }

        return
        (
            exponent < 0 ?
            PerformManagedOperationValues(new UnitInfo(1.0), outInfo, Operations.Division) :
            outInfo
        );
    }

    static UnitInfo PerformManagedOperationNormalisedValues(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        outInfo =
        (
            normalisedInfos.Length == 1 ?
            //There is just one operand when the difference between both of them is too big.
            outInfo = normalisedInfos[0] :
            PerformManagedOperationTwoOperands(outInfo, normalisedInfos, operation)
        );

        return outInfo;
    }

    static UnitInfo PerformManagedOperationTwoOperands(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        UnitInfo outInfoNormalised = PerformManagedOperationValues
        (
            normalisedInfos[0], normalisedInfos[1], operation
        );

        if (outInfo.Error.Type != ErrorTypes.None)
        {
            return new UnitInfo(outInfo)
            {
                Error = new ErrorInfo(ErrorTypes.NumericError)
            };
        }

        outInfo.BaseTenExponent = outInfoNormalised.BaseTenExponent;
        outInfo.Value = outInfoNormalised.Value;
        //Normalised means no prefixes.
        outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage); 

        return outInfo;
    }

    static UnitInfo PerformManagedOperationValues(double firstValue, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            new UnitInfo(firstValue), new UnitInfo(secondValue), operation
        );
    }

    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            firstInfo, new UnitInfo(secondValue), operation
        );
    }

    //This method might be used to perform full operations (not just being the last calculation step) instead
    //of the default one (PerformManagedOperationUnits) for simple cases. That is: ones not dealing with the
    //complex numeric reality (Value, Prefix and BaseTenExponent) which makes a pre-analysis required.
    //Note that, unlikely what happens with PerformMangedOperationUnits, the outputs of this method aren't
    //normalised (= primarily stored under Value), what is useful in certain contexts.
    //NOTE: this function assumes that both inputs are normalised, what means that no prefix information is expected.
    //It might also be used with non-normalised inputs, but their prefix information would be plainly ignored.
    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        if (firstInfo.Value == 0.0 || secondInfo.Value == 0.0)
        {
            if (operation == Operations.Multiplication || operation == Operations.Division)
            {
                //Dividing by zero scenarios are taken into account somewhere else.
                return new UnitInfo(firstInfo) { Value = 0.0 };
            }
        }

        UnitInfo outInfo = new UnitInfo(firstInfo);
        UnitInfo firstInfo0 = new UnitInfo(firstInfo);
        UnitInfo secondInfo0 = new UnitInfo(secondInfo);

        boolean isWrong = false;
        try
        {
            if (operation == Operations.Addition)
            {
                outInfo.Value += secondInfo0.Value;
            }
            else if (operation == Operations.Subtraction)
            {
                outInfo.Value -= secondInfo.Value;
            }
            else
            {
                //The reason for checking whether BaseTenExponent is inside/outside the int range before performing 
                //the operation (rather than going ahead and eventually catching the resulting exception) isn't just
                //being quicker, but also the only option in many situations. Note that an addition/subtraction between
                //two int variables whose result is outside the int range might not trigger an exception (+ random 
                //negative value as output).
                if (VaryBaseTenExponent(outInfo, secondInfo0.BaseTenExponent, operation == Operations.Division).Error.Type != ErrorTypes.None)
                {
                    return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
                }

                if (operation == Operations.Multiplication)
                {
                    outInfo.Value *= secondInfo.Value;
                    outInfo.BaseTenExponent += secondInfo.BaseTenExponent;
                }
                else if (operation == Operations.Division)
                {
                    if (secondInfo.Value == 0.0)
                    {
                        return
                        (
                            new UnitInfo(outInfo) 
                            { 
                                Error = new ErrorInfo(ErrorTypes.NumericError) 
                            }
                        );
                    }
                    outInfo.Value /= secondInfo.Value;
                    outInfo.BaseTenExponent -= secondInfo.BaseTenExponent;
                }
            }
        }
        catch { isWrong = true; }

        return
        (
            //An error might not be triggered despite of dealing with numbers outside double precision.
            //For example: 0.00000000000000000001m * 0.0000000000000000000001m can output 0.0 without triggering an error. 
            isWrong || ((operation == Operations.Multiplication || operation == Operations.Division) && outInfo.Value == 0.0.0) ?
            OperationValuesManageError(firstInfo0, secondInfo0, operation) : outInfo
        );
    }

    static UnitInfo OperationValuesManageError(UnitInfo outInfo, UnitInfo secondInfo, Operations operation)
    {
        if (operation != Operations.Multiplication && operation != Operations.Division)
        {
            //This condition should never be true on account of the fact that the pre-modifications performed before
            //adding/subtracting should avoid erroneous situations.
            return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
        }

        UnitInfo secondInfo2 = ConvertValueToBaseTen(secondInfo.Value);
        outInfo = VaryBaseTenExponent(outInfo, secondInfo2.BaseTenExponent, operation == Operations.Division);
        if (Math.Abs(secondInfo2.Value) == 1.0 || outInfo.Error.Type != ErrorTypes.None) return outInfo;
        
        try
        {
            outInfo = PerformManagedOperationUnits
            (
                outInfo, secondInfo2.Value, operation
            );
        }
        catch
        {
            //Very unlikely scenario on account of the fact that Math.Abs(secondInfo2.Value)
            //lies within the 0.1-10.0 range.
            outInfo = OperationValuesManageError
            (
                new UnitInfo(outInfo)
                {
                    Value = secondInfo2.Value,
                    BaseTenExponent = 0
                },
                new UnitInfo()
                {
                    Value = outInfo.Value,
                    BaseTenExponent = outInfo.BaseTenExponent
                },
                operation
            );
        }

        return outInfo;
    }

    static UnitInfo ConvertValueToBaseTen(double value)
    {
        value = Math.Abs(value);
        return FromValueToBaseTenExponent
        (
             new UnitInfo(value), Math.Abs(value), false
        );
    }

    static UnitInfo ConvertBaseTenToValue(UnitInfo unitInfo)
    {
        if (unitInfo.BaseTenExponent == 0) return unitInfo;

        UnitInfo outInfo = new UnitInfo(unitInfo);
        boolean decrease = unitInfo.BaseTenExponent > 0;
        int sign = Math.Sign(outInfo.Value);
        double absValue = Math.Abs(outInfo.Value);

        while (outInfo.BaseTenExponent != 0.0)
        {
            if (decrease)
            {
                if (absValue >= MaxValueDec / 10.0) break;
                absValue *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }
            else
            {
                if (absValue <= MinValueDec * 10.0) break;
                absValue /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
        }

        outInfo.Value = sign * absValue;

        return outInfo;
    }

    static UnitInfo NormaliseUnitInfo(UnitInfo unitInfo)
    {
        if (unitInfo.Value == 0 && unitInfo.Prefix.Factor == 1.0)
        {
            return unitInfo;
        }
        UnitInfo outInfo = new UnitInfo(unitInfo);

        if (outInfo.Prefix.Factor != 1)
        {
            outInfo = FromValueToBaseTenExponent
            (
                outInfo, outInfo.Prefix.Factor, true
            );
            outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage);
        }
        if (outInfo.Value == 0.0) return outInfo;

        outInfo = FromValueToBaseTenExponent
        (
            outInfo, outInfo.Value, false
        );

        return outInfo;
    }

    static UnitInfo FromValueToBaseTenExponent(UnitInfo outInfo, double value, boolean isPrefix)
    {
        if (value == 0.0) return outInfo;

        double valueAbs = Math.Abs(value);
        boolean decrease = (valueAbs > 1.0);
        if (!isPrefix)
        {
            outInfo.Value = outInfo.Value / valueAbs;
        }

        while (valueAbs != 1.0)
        {
            if ((valueAbs < 10.0 && valueAbs > 1.0) || (valueAbs > 0.1.0 && valueAbs < 1.0))
            {
                if (!isPrefix) outInfo.Value = value;
                else
                {
                    outInfo = PerformManagedOperationValues
                    (
                        outInfo, value, Operations.Multiplication
                    );
                }

                return outInfo;
            }

            if (decrease)
            {
                value /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
            else
            {
                value *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }

            valueAbs = Math.Abs(value);
        }

        return outInfo;
    }

    //Method used to vary BaseTenExponent without provoking unhandled exceptions (i.e., bigger than Integer.MAX_VALUE).
    static UnitInfo VaryBaseTenExponent(UnitInfo info, int baseTenIncrease, boolean isDivision = false)
    {
        long val1 = info.BaseTenExponent;
        long val2 = baseTenIncrease;

        if (isDivision)
        {
            //Converting a negative value into positive might provoke an overflow error for the int type
            //(e.g., Math.Abs(Integer.MAIN_VALUE)). Converting both variables to long is a quick and effective
            //way to avoid this problem.
            val2 *= -1;
        }

        return
        (
             ((val2 > 0 && val1 > Integer.MAX_VALUE - val2) || (val2 < 0 && val1 < Integer.MAIN_VALUE - val2)) ?
            new UnitInfo(info, ErrorTypes.NumericError) : new UnitInfo(info){{ BaseTenExponent = (int)(val1 + val2); }}
        );
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 2 2017-05-27 19:58:16.028
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 0 2017-05-27 19:58:16.029
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.core 4 4 2017-05-27 19:58:17.685
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
public class OperationsManaged
{
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, double second, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            firstInfo, new UnitInfo(second), operation
        );
    }

    public static UnitInfo PerformManagedOperationUnits(double first, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            new UnitInfo(first), secondInfo, operation
        );
    }

    //This method should always be used when dealing with random UnitInfo variables because it accounts for all the
    //possible scenarios. On the other hand, with simple operations (e.g., random UnitInfo & numeric type) it might
    //be better to use PerformManagedOperationValues. 
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        ErrorTypes errorType = InternalMethods.GetOperationError
        (
            firstInfo, secondInfo, operation
        );
        if (errorType != ErrorTypes.None)
        {
            return new UnitInfo(firstInfo) 
            {{
                Error = new ErrorInfo(errorType); 
            }};
        }

        return
        (
            operation == Operations.Addition || operation == Operations.Subtraction ?
            PerformManagedOperationAddition(firstInfo, secondInfo, operation) :
            PerformManagedOperationMultiplication(firstInfo, secondInfo, operation)
        );
    }

    static UnitInfo PerformManagedOperationAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {   
        //After being normalised, the operands might require further modifications.
        UnitInfo[] normalised = GetOperandsAddition(firstInfo, secondInfo, operation);

        return PerformManagedOperationNormalisedValues
        (
            firstInfo, normalised, operation
        );
    }

    static UnitInfo[] GetOperandsAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        UnitInfo[] operands2 = new UnitInfo[] 
        {
            new UnitInfo(firstInfo), new UnitInfo(secondInfo)
        };

        if (operands2[0].BaseTenExponent != operands2[1].BaseTenExponent || operands2[0].Prefix.Factor != operands2[1].Prefix.Factor)
        {
            //The addition/subtraction might not be performed right away even with normalised values.
            //For example: 5 and 6 from 5*10^2 and 6*10^7 cannot be added right away.
            operands2 = AdaptNormalisedValuesForAddition
            (
                new UnitInfo[] 
                { 
                    NormaliseUnitInfo(operands2[0]), 
                    NormaliseUnitInfo(operands2[1])
                },
                operation
            );
        }

        return operands2;
    }
    
    static UnitInfo[] AdaptNormalisedValuesForAddition(UnitInfo[] unitInfos2, Operations operation)
    {
        if (unitInfos2[0].BaseTenExponent == unitInfos2[1].BaseTenExponent)
        {
            //Having the same BaseTenExponent values means that the given operation can be performed right away.
            return unitInfos2;
        }

        int[] bigSmallI = 
        (
            unitInfos2[0].BaseTenExponent > unitInfos2[1].BaseTenExponent ?
            new int[] { 0, 1 } : new int[] { 1, 0 }
        );

        //Only the variable with the bigger value is modified. For example: 5*10^5 & 3*10^3 is converted
        //into 500*10^3 & 3*10^3 in order to allow the addition 500 + 3. 
        UnitInfo big2 = AdaptBiggerAdditionOperand(unitInfos2, bigSmallI, operation);
        if (big2.Error.Type != ErrorTypes.None)
        {
            return TooBigGapAddition(unitInfos2, bigSmallI, operation);
        }

        unitInfos2[bigSmallI[0]].Value = big2.Value;
        unitInfos2[bigSmallI[0]].BaseTenExponent = unitInfos2[bigSmallI[1]].BaseTenExponent;

        return unitInfos2;
    }

    //When adding/subtracting two numbers whose gap is bigger than the maximum double range, there
    //is no need to perform any operation (i.e., no change will be observed because of being outside
    //the maximum supported precision). This method takes care of these cases and returns the expected
    //output (i.e., biggest value).
    static UnitInfo[] TooBigGapAddition(UnitInfo[] unitInfos2, int[] bigSmallI, Operations operation)
    {
        UnitInfo[] outInfos = new UnitInfo[] 
        {
            //First operand (i.e., one whose information defines the operation) together with the
            //numeric information (i.e., just Value and BaseTenExponent because both are normalised)
            //which is associated with the biggest one.
            new UnitInfo(unitInfos2[0])
            {{
                Value = unitInfos2[bigSmallI[0]].Value;
                BaseTenExponent = unitInfos2[bigSmallI[0]].BaseTenExponent;
            }}
        };

        if (operation == Operations.Subtraction && bigSmallI[0] == 1)
        {
            outInfos[0].Value = -1.0 * outInfos[0].Value;
        }

        if (outInfos[0].Unit == Units.Unitless)
        {
            outInfos[0].Unit = unitInfos2[bigSmallI[1]].Unit;
        }

        return outInfos;
    }

    static UnitInfo AdaptBiggerAdditionOperand(UnitInfo[] unitInfos2, int[] bigSmallI, Operations operation)
    {
        int gapExponent = unitInfos2[bigSmallI[0]].BaseTenExponent - unitInfos2[bigSmallI[1]].BaseTenExponent;
        if (gapExponent >= 27)
        {
            //The difference between both inputs is bigger than (or, at least, very close to) the maximum double value/precision;
            //what makes this situation calculation unworthy and the first operand to be returned as the result.
            //Note that the error below these lines is just an easy way to tell the calling function about this eventuality.
            return new UnitInfo(unitInfos2[0]) 
            {{ 
                Error = new ErrorInfo(ErrorTypes.InvalidOperation); 
            }};
        }

        //PerformManagedOperationValues is used to make sure that the resulting numeric information is stored
        //in Value (if possible).
        UnitInfo big2 = PerformManagedOperationValues
        (
            RaiseToIntegerExponent(10.0, gapExponent), unitInfos2[bigSmallI[0]].Value, 
            Operations.Multiplication                
        );

        boolean isWrong = 
        (
            big2.Error.Type != ErrorTypes.None || big2.BaseTenExponent != 0 ?
            
            //The value of the bigger input times 10^(gap between BaseTenExponent of inputs) is too big. 
            isWrong = true :
            
            //Overflow-check very unlikely to trigger an error. In fact, with properly normalised variables,
            //triggering an error would be plainly impossible.               
            AreAdditionFinalValuesWrong
            (
                unitInfos2[0].Value, unitInfos2[1].Value, operation
            )
        );

        if (isWrong)
        {
        	//This error is just an easy way to let the calling function know about the fact that no
                    //calculation has been performed (too big gap). This isn't a properly-speaking error and
                    //that's why it will not be notified to the user.
        	return new UnitInfo(unitInfos2[0])
                    {{
                        Error = new ErrorInfo(ErrorTypes.InvalidOperation);
                    }};
        }
        else
        {
            //Returning the new big value. For example: with 5*10^4 & 3*10^2, 500 would be returned.
            return new UnitInfo(unitInfos2[bigSmallI[0]])
            {{
                Value = big2.Value;
            }};
        }

        
        return
        (
            isWrong ?
            //This error is just an easy way to let the calling function know about the fact that no
            //calculation has been performed (too big gap). This isn't a properly-speaking error and
            //that's why it will not be notified to the user.
            new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }} :
            //Returning the new big value. For example: with 5*10^4 & 3*10^2, 500 would be returned.
            new UnitInfo(unitInfos2[bigSmallI[0]])
            {{
                Value = big2.Value;
            }}
        );
    }

    static boolean AreAdditionFinalValuesWrong(double val1, double val2, Operations operation)
    {
        boolean isWrong = false;

        try
        {
            val1 = val1 + val2 *
            (
                operation == Operations.Addition ? 1 : -1
            );
        }
        catch { isWrong = true; }

        return isWrong;
    }

    static UnitInfo PerformManagedOperationMultiplication(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationNormalisedValues
        (
            firstInfo, new UnitInfo[] 
            { 
                NormaliseUnitInfo(firstInfo),
                NormaliseUnitInfo(secondInfo) 
            },
            operation
        );
    }

    public static UnitInfo RaiseToIntegerExponent(double baseValue, int exponent)
    {
        return RaiseToIntegerExponent(new UnitInfo(baseValue), exponent);
    }

    static UnitInfo RaiseToIntegerExponent(UnitInfo baseInfo, int exponent)
    {
        if (exponent <= 1 && exponent >= 0)
        {
            baseInfo.Value = (exponent == 0 ? 1.0 : baseInfo.Value);
            return baseInfo;
        }

        UnitInfo outInfo = new UnitInfo(baseInfo);

        for (int i = 1; i < Math.Abs(exponent); i++)
        {
            outInfo = PerformManagedOperationValues
            (
                outInfo, baseInfo, Operations.Multiplication
            );
            if (outInfo.Error.Type != ErrorTypes.None) return outInfo;
        }

        return
        (
            exponent < 0 ?
            PerformManagedOperationValues(new UnitInfo(1.0), outInfo, Operations.Division) :
            outInfo
        );
    }

    static UnitInfo PerformManagedOperationNormalisedValues(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        outInfo =
        (
            normalisedInfos.Length == 1 ?
            //There is just one operand when the difference between both of them is too big.
            outInfo = normalisedInfos[0] :
            PerformManagedOperationTwoOperands(outInfo, normalisedInfos, operation)
        );

        return outInfo;
    }

    static UnitInfo PerformManagedOperationTwoOperands(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        UnitInfo outInfoNormalised = PerformManagedOperationValues
        (
            normalisedInfos[0], normalisedInfos[1], operation
        );

        if (outInfo.Error.Type != ErrorTypes.None)
        {
            return new UnitInfo(outInfo)
            {
                Error = new ErrorInfo(ErrorTypes.NumericError)
            };
        }

        outInfo.BaseTenExponent = outInfoNormalised.BaseTenExponent;
        outInfo.Value = outInfoNormalised.Value;
        //Normalised means no prefixes.
        outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage); 

        return outInfo;
    }

    static UnitInfo PerformManagedOperationValues(double firstValue, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            new UnitInfo(firstValue), new UnitInfo(secondValue), operation
        );
    }

    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            firstInfo, new UnitInfo(secondValue), operation
        );
    }

    //This method might be used to perform full operations (not just being the last calculation step) instead
    //of the default one (PerformManagedOperationUnits) for simple cases. That is: ones not dealing with the
    //complex numeric reality (Value, Prefix and BaseTenExponent) which makes a pre-analysis required.
    //Note that, unlikely what happens with PerformMangedOperationUnits, the outputs of this method aren't
    //normalised (= primarily stored under Value), what is useful in certain contexts.
    //NOTE: this function assumes that both inputs are normalised, what means that no prefix information is expected.
    //It might also be used with non-normalised inputs, but their prefix information would be plainly ignored.
    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        if (firstInfo.Value == 0.0 || secondInfo.Value == 0.0)
        {
            if (operation == Operations.Multiplication || operation == Operations.Division)
            {
                //Dividing by zero scenarios are taken into account somewhere else.
                return new UnitInfo(firstInfo) { Value = 0.0 };
            }
        }

        UnitInfo outInfo = new UnitInfo(firstInfo);
        UnitInfo firstInfo0 = new UnitInfo(firstInfo);
        UnitInfo secondInfo0 = new UnitInfo(secondInfo);

        boolean isWrong = false;
        try
        {
            if (operation == Operations.Addition)
            {
                outInfo.Value += secondInfo0.Value;
            }
            else if (operation == Operations.Subtraction)
            {
                outInfo.Value -= secondInfo.Value;
            }
            else
            {
                //The reason for checking whether BaseTenExponent is inside/outside the int range before performing 
                //the operation (rather than going ahead and eventually catching the resulting exception) isn't just
                //being quicker, but also the only option in many situations. Note that an addition/subtraction between
                //two int variables whose result is outside the int range might not trigger an exception (+ random 
                //negative value as output).
                if (VaryBaseTenExponent(outInfo, secondInfo0.BaseTenExponent, operation == Operations.Division).Error.Type != ErrorTypes.None)
                {
                    return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
                }

                if (operation == Operations.Multiplication)
                {
                    outInfo.Value *= secondInfo.Value;
                    outInfo.BaseTenExponent += secondInfo.BaseTenExponent;
                }
                else if (operation == Operations.Division)
                {
                    if (secondInfo.Value == 0.0)
                    {
                        return
                        (
                            new UnitInfo(outInfo) 
                            { 
                                Error = new ErrorInfo(ErrorTypes.NumericError) 
                            }
                        );
                    }
                    outInfo.Value /= secondInfo.Value;
                    outInfo.BaseTenExponent -= secondInfo.BaseTenExponent;
                }
            }
        }
        catch { isWrong = true; }

        return
        (
            //An error might not be triggered despite of dealing with numbers outside double precision.
            //For example: 0.00000000000000000001m * 0.0000000000000000000001m can output 0.0 without triggering an error. 
            isWrong || ((operation == Operations.Multiplication || operation == Operations.Division) && outInfo.Value == 0.0.0) ?
            OperationValuesManageError(firstInfo0, secondInfo0, operation) : outInfo
        );
    }

    static UnitInfo OperationValuesManageError(UnitInfo outInfo, UnitInfo secondInfo, Operations operation)
    {
        if (operation != Operations.Multiplication && operation != Operations.Division)
        {
            //This condition should never be true on account of the fact that the pre-modifications performed before
            //adding/subtracting should avoid erroneous situations.
            return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
        }

        UnitInfo secondInfo2 = ConvertValueToBaseTen(secondInfo.Value);
        outInfo = VaryBaseTenExponent(outInfo, secondInfo2.BaseTenExponent, operation == Operations.Division);
        if (Math.Abs(secondInfo2.Value) == 1.0 || outInfo.Error.Type != ErrorTypes.None) return outInfo;
        
        try
        {
            outInfo = PerformManagedOperationUnits
            (
                outInfo, secondInfo2.Value, operation
            );
        }
        catch
        {
            //Very unlikely scenario on account of the fact that Math.Abs(secondInfo2.Value)
            //lies within the 0.1-10.0 range.
            outInfo = OperationValuesManageError
            (
                new UnitInfo(outInfo)
                {
                    Value = secondInfo2.Value,
                    BaseTenExponent = 0
                },
                new UnitInfo()
                {
                    Value = outInfo.Value,
                    BaseTenExponent = outInfo.BaseTenExponent
                },
                operation
            );
        }

        return outInfo;
    }

    static UnitInfo ConvertValueToBaseTen(double value)
    {
        value = Math.Abs(value);
        return FromValueToBaseTenExponent
        (
             new UnitInfo(value), Math.Abs(value), false
        );
    }

    static UnitInfo ConvertBaseTenToValue(UnitInfo unitInfo)
    {
        if (unitInfo.BaseTenExponent == 0) return unitInfo;

        UnitInfo outInfo = new UnitInfo(unitInfo);
        boolean decrease = unitInfo.BaseTenExponent > 0;
        int sign = Math.Sign(outInfo.Value);
        double absValue = Math.Abs(outInfo.Value);

        while (outInfo.BaseTenExponent != 0.0)
        {
            if (decrease)
            {
                if (absValue >= MaxValueDec / 10.0) break;
                absValue *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }
            else
            {
                if (absValue <= MinValueDec * 10.0) break;
                absValue /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
        }

        outInfo.Value = sign * absValue;

        return outInfo;
    }

    static UnitInfo NormaliseUnitInfo(UnitInfo unitInfo)
    {
        if (unitInfo.Value == 0 && unitInfo.Prefix.Factor == 1.0)
        {
            return unitInfo;
        }
        UnitInfo outInfo = new UnitInfo(unitInfo);

        if (outInfo.Prefix.Factor != 1)
        {
            outInfo = FromValueToBaseTenExponent
            (
                outInfo, outInfo.Prefix.Factor, true
            );
            outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage);
        }
        if (outInfo.Value == 0.0) return outInfo;

        outInfo = FromValueToBaseTenExponent
        (
            outInfo, outInfo.Value, false
        );

        return outInfo;
    }

    static UnitInfo FromValueToBaseTenExponent(UnitInfo outInfo, double value, boolean isPrefix)
    {
        if (value == 0.0) return outInfo;

        double valueAbs = Math.Abs(value);
        boolean decrease = (valueAbs > 1.0);
        if (!isPrefix)
        {
            outInfo.Value = outInfo.Value / valueAbs;
        }

        while (valueAbs != 1.0)
        {
            if ((valueAbs < 10.0 && valueAbs > 1.0) || (valueAbs > 0.1.0 && valueAbs < 1.0))
            {
                if (!isPrefix) outInfo.Value = value;
                else
                {
                    outInfo = PerformManagedOperationValues
                    (
                        outInfo, value, Operations.Multiplication
                    );
                }

                return outInfo;
            }

            if (decrease)
            {
                value /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
            else
            {
                value *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }

            valueAbs = Math.Abs(value);
        }

        return outInfo;
    }

    //Method used to vary BaseTenExponent without provoking unhandled exceptions (i.e., bigger than Integer.MAX_VALUE).
    static UnitInfo VaryBaseTenExponent(UnitInfo info, int baseTenIncrease, boolean isDivision = false)
    {
        long val1 = info.BaseTenExponent;
        long val2 = baseTenIncrease;

        if (isDivision)
        {
            //Converting a negative value into positive might provoke an overflow error for the int type
            //(e.g., Math.Abs(Integer.MAIN_VALUE)). Converting both variables to long is a quick and effective
            //way to avoid this problem.
            val2 *= -1;
        }

        return
        (
             ((val2 > 0 && val1 > Integer.MAX_VALUE - val2) || (val2 < 0 && val1 < Integer.MAIN_VALUE - val2)) ?
            new UnitInfo(info, ErrorTypes.NumericError) : new UnitInfo(info){{ BaseTenExponent = (int)(val1 + val2); }}
        );
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 2 2017-05-27 19:58:17.686
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 0 2017-05-27 19:58:17.686
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.core 4 4 2017-05-27 19:58:20.660
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
public class OperationsManaged
{
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, double second, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            firstInfo, new UnitInfo(second), operation
        );
    }

    public static UnitInfo PerformManagedOperationUnits(double first, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            new UnitInfo(first), secondInfo, operation
        );
    }

    //This method should always be used when dealing with random UnitInfo variables because it accounts for all the
    //possible scenarios. On the other hand, with simple operations (e.g., random UnitInfo & numeric type) it might
    //be better to use PerformManagedOperationValues. 
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        ErrorTypes errorType = InternalMethods.GetOperationError
        (
            firstInfo, secondInfo, operation
        );
        if (errorType != ErrorTypes.None)
        {
            return new UnitInfo(firstInfo) 
            {{
                Error = new ErrorInfo(errorType); 
            }};
        }

        return
        (
            operation == Operations.Addition || operation == Operations.Subtraction ?
            PerformManagedOperationAddition(firstInfo, secondInfo, operation) :
            PerformManagedOperationMultiplication(firstInfo, secondInfo, operation)
        );
    }

    static UnitInfo PerformManagedOperationAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {   
        //After being normalised, the operands might require further modifications.
        UnitInfo[] normalised = GetOperandsAddition(firstInfo, secondInfo, operation);

        return PerformManagedOperationNormalisedValues
        (
            firstInfo, normalised, operation
        );
    }

    static UnitInfo[] GetOperandsAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        UnitInfo[] operands2 = new UnitInfo[] 
        {
            new UnitInfo(firstInfo), new UnitInfo(secondInfo)
        };

        if (operands2[0].BaseTenExponent != operands2[1].BaseTenExponent || operands2[0].Prefix.Factor != operands2[1].Prefix.Factor)
        {
            //The addition/subtraction might not be performed right away even with normalised values.
            //For example: 5 and 6 from 5*10^2 and 6*10^7 cannot be added right away.
            operands2 = AdaptNormalisedValuesForAddition
            (
                new UnitInfo[] 
                { 
                    NormaliseUnitInfo(operands2[0]), 
                    NormaliseUnitInfo(operands2[1])
                },
                operation
            );
        }

        return operands2;
    }
    
    static UnitInfo[] AdaptNormalisedValuesForAddition(UnitInfo[] unitInfos2, Operations operation)
    {
        if (unitInfos2[0].BaseTenExponent == unitInfos2[1].BaseTenExponent)
        {
            //Having the same BaseTenExponent values means that the given operation can be performed right away.
            return unitInfos2;
        }

        int[] bigSmallI = 
        (
            unitInfos2[0].BaseTenExponent > unitInfos2[1].BaseTenExponent ?
            new int[] { 0, 1 } : new int[] { 1, 0 }
        );

        //Only the variable with the bigger value is modified. For example: 5*10^5 & 3*10^3 is converted
        //into 500*10^3 & 3*10^3 in order to allow the addition 500 + 3. 
        UnitInfo big2 = AdaptBiggerAdditionOperand(unitInfos2, bigSmallI, operation);
        if (big2.Error.Type != ErrorTypes.None)
        {
            return TooBigGapAddition(unitInfos2, bigSmallI, operation);
        }

        unitInfos2[bigSmallI[0]].Value = big2.Value;
        unitInfos2[bigSmallI[0]].BaseTenExponent = unitInfos2[bigSmallI[1]].BaseTenExponent;

        return unitInfos2;
    }

    //When adding/subtracting two numbers whose gap is bigger than the maximum double range, there
    //is no need to perform any operation (i.e., no change will be observed because of being outside
    //the maximum supported precision). This method takes care of these cases and returns the expected
    //output (i.e., biggest value).
    static UnitInfo[] TooBigGapAddition(UnitInfo[] unitInfos2, int[] bigSmallI, Operations operation)
    {
        UnitInfo[] outInfos = new UnitInfo[] 
        {
            //First operand (i.e., one whose information defines the operation) together with the
            //numeric information (i.e., just Value and BaseTenExponent because both are normalised)
            //which is associated with the biggest one.
            new UnitInfo(unitInfos2[0])
            {{
                Value = unitInfos2[bigSmallI[0]].Value;
                BaseTenExponent = unitInfos2[bigSmallI[0]].BaseTenExponent;
            }}
        };

        if (operation == Operations.Subtraction && bigSmallI[0] == 1)
        {
            outInfos[0].Value = -1.0 * outInfos[0].Value;
        }

        if (outInfos[0].Unit == Units.Unitless)
        {
            outInfos[0].Unit = unitInfos2[bigSmallI[1]].Unit;
        }

        return outInfos;
    }

    static UnitInfo AdaptBiggerAdditionOperand(UnitInfo[] unitInfos2, int[] bigSmallI, Operations operation)
    {
        int gapExponent = unitInfos2[bigSmallI[0]].BaseTenExponent - unitInfos2[bigSmallI[1]].BaseTenExponent;
        if (gapExponent >= 27)
        {
            //The difference between both inputs is bigger than (or, at least, very close to) the maximum double value/precision;
            //what makes this situation calculation unworthy and the first operand to be returned as the result.
            //Note that the error below these lines is just an easy way to tell the calling function about this eventuality.
            return new UnitInfo(unitInfos2[0]) 
            {{ 
                Error = new ErrorInfo(ErrorTypes.InvalidOperation); 
            }};
        }

        //PerformManagedOperationValues is used to make sure that the resulting numeric information is stored
        //in Value (if possible).
        UnitInfo big2 = PerformManagedOperationValues
        (
            RaiseToIntegerExponent(10.0, gapExponent), unitInfos2[bigSmallI[0]].Value, 
            Operations.Multiplication                
        );

        boolean isWrong = 
        (
            big2.Error.Type != ErrorTypes.None || big2.BaseTenExponent != 0 ?
            
            //The value of the bigger input times 10^(gap between BaseTenExponent of inputs) is too big. 
            isWrong = true :
            
            //Overflow-check very unlikely to trigger an error. In fact, with properly normalised variables,
            //triggering an error would be plainly impossible.               
            AreAdditionFinalValuesWrong
            (
                unitInfos2[0].Value, unitInfos2[1].Value, operation
            )
        );

        if (isWrong)
        {
        	//This error is just an easy way to let the calling function know about the fact that no
                    //calculation has been performed (too big gap). This isn't a properly-speaking error and
                    //that's why it will not be notified to the user.
        	return new UnitInfo(unitInfos2[0])
                    {{
                        Error = new ErrorInfo(ErrorTypes.InvalidOperation);
                    }};
        }
        else
        {
            //Returning the new big value. For example: with 5*10^4 & 3*10^2, 500 would be returned.
            return new UnitInfo(unitInfos2[bigSmallI[0]])
            {{
                Value = big2.Value;
            }};
        }

        
        return
        (
            isWrong ?
            //This error is just an easy way to let the calling function know about the fact that no
            //calculation has been performed (too big gap). This isn't a properly-speaking error and
            //that's why it will not be notified to the user.
            new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }} :
            //Returning the new big value. For example: with 5*10^4 & 3*10^2, 500 would be returned.
            new UnitInfo(unitInfos2[bigSmallI[0]])
            {{
                Value = big2.Value;
            }}
        );
    }

    static boolean AreAdditionFinalValuesWrong(double val1, double val2, Operations operation)
    {
        boolean isWrong = false;

        try
        {
            val1 = val1 + val2 *
            (
                operation == Operations.Addition ? 1 : -1
            );
        }
        catch { isWrong = true; }

        return isWrong;
    }

    static UnitInfo PerformManagedOperationMultiplication(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationNormalisedValues
        (
            firstInfo, new UnitInfo[] 
            { 
                NormaliseUnitInfo(firstInfo),
                NormaliseUnitInfo(secondInfo) 
            },
            operation
        );
    }

    public static UnitInfo RaiseToIntegerExponent(double baseValue, int exponent)
    {
        return RaiseToIntegerExponent(new UnitInfo(baseValue), exponent);
    }

    static UnitInfo RaiseToIntegerExponent(UnitInfo baseInfo, int exponent)
    {
        if (exponent <= 1 && exponent >= 0)
        {
            baseInfo.Value = (exponent == 0 ? 1.0 : baseInfo.Value);
            return baseInfo;
        }

        UnitInfo outInfo = new UnitInfo(baseInfo);

        for (int i = 1; i < Math.Abs(exponent); i++)
        {
            outInfo = PerformManagedOperationValues
            (
                outInfo, baseInfo, Operations.Multiplication
            );
            if (outInfo.Error.Type != ErrorTypes.None) return outInfo;
        }

        return
        (
            exponent < 0 ?
            PerformManagedOperationValues(new UnitInfo(1.0), outInfo, Operations.Division) :
            outInfo
        );
    }

    static UnitInfo PerformManagedOperationNormalisedValues(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        outInfo =
        (
            normalisedInfos.Length == 1 ?
            //There is just one operand when the difference between both of them is too big.
            outInfo = normalisedInfos[0] :
            PerformManagedOperationTwoOperands(outInfo, normalisedInfos, operation)
        );

        return outInfo;
    }

    static UnitInfo PerformManagedOperationTwoOperands(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        UnitInfo outInfoNormalised = PerformManagedOperationValues
        (
            normalisedInfos[0], normalisedInfos[1], operation
        );

        if (outInfo.Error.Type != ErrorTypes.None)
        {
            return new UnitInfo(outInfo)
            {
                Error = new ErrorInfo(ErrorTypes.NumericError)
            };
        }

        outInfo.BaseTenExponent = outInfoNormalised.BaseTenExponent;
        outInfo.Value = outInfoNormalised.Value;
        //Normalised means no prefixes.
        outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage); 

        return outInfo;
    }

    static UnitInfo PerformManagedOperationValues(double firstValue, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            new UnitInfo(firstValue), new UnitInfo(secondValue), operation
        );
    }

    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            firstInfo, new UnitInfo(secondValue), operation
        );
    }

    //This method might be used to perform full operations (not just being the last calculation step) instead
    //of the default one (PerformManagedOperationUnits) for simple cases. That is: ones not dealing with the
    //complex numeric reality (Value, Prefix and BaseTenExponent) which makes a pre-analysis required.
    //Note that, unlikely what happens with PerformMangedOperationUnits, the outputs of this method aren't
    //normalised (= primarily stored under Value), what is useful in certain contexts.
    //NOTE: this function assumes that both inputs are normalised, what means that no prefix information is expected.
    //It might also be used with non-normalised inputs, but their prefix information would be plainly ignored.
    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        if (firstInfo.Value == 0.0 || secondInfo.Value == 0.0)
        {
            if (operation == Operations.Multiplication || operation == Operations.Division)
            {
                //Dividing by zero scenarios are taken into account somewhere else.
                return new UnitInfo(firstInfo) { Value = 0.0 };
            }
        }

        UnitInfo outInfo = new UnitInfo(firstInfo);
        UnitInfo firstInfo0 = new UnitInfo(firstInfo);
        UnitInfo secondInfo0 = new UnitInfo(secondInfo);

        boolean isWrong = false;
        try
        {
            if (operation == Operations.Addition)
            {
                outInfo.Value += secondInfo0.Value;
            }
            else if (operation == Operations.Subtraction)
            {
                outInfo.Value -= secondInfo.Value;
            }
            else
            {
                //The reason for checking whether BaseTenExponent is inside/outside the int range before performing 
                //the operation (rather than going ahead and eventually catching the resulting exception) isn't just
                //being quicker, but also the only option in many situations. Note that an addition/subtraction between
                //two int variables whose result is outside the int range might not trigger an exception (+ random 
                //negative value as output).
                if (VaryBaseTenExponent(outInfo, secondInfo0.BaseTenExponent, operation == Operations.Division).Error.Type != ErrorTypes.None)
                {
                    return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
                }

                if (operation == Operations.Multiplication)
                {
                    outInfo.Value *= secondInfo.Value;
                    outInfo.BaseTenExponent += secondInfo.BaseTenExponent;
                }
                else if (operation == Operations.Division)
                {
                    if (secondInfo.Value == 0.0)
                    {
                        return
                        (
                            new UnitInfo(outInfo) 
                            { 
                                Error = new ErrorInfo(ErrorTypes.NumericError) 
                            }
                        );
                    }
                    outInfo.Value /= secondInfo.Value;
                    outInfo.BaseTenExponent -= secondInfo.BaseTenExponent;
                }
            }
        }
        catch { isWrong = true; }

        return
        (
            //An error might not be triggered despite of dealing with numbers outside double precision.
            //For example: 0.00000000000000000001m * 0.0000000000000000000001m can output 0.0 without triggering an error. 
            isWrong || ((operation == Operations.Multiplication || operation == Operations.Division) && outInfo.Value == 0.0.0) ?
            OperationValuesManageError(firstInfo0, secondInfo0, operation) : outInfo
        );
    }

    static UnitInfo OperationValuesManageError(UnitInfo outInfo, UnitInfo secondInfo, Operations operation)
    {
        if (operation != Operations.Multiplication && operation != Operations.Division)
        {
            //This condition should never be true on account of the fact that the pre-modifications performed before
            //adding/subtracting should avoid erroneous situations.
            return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
        }

        UnitInfo secondInfo2 = ConvertValueToBaseTen(secondInfo.Value);
        outInfo = VaryBaseTenExponent(outInfo, secondInfo2.BaseTenExponent, operation == Operations.Division);
        if (Math.Abs(secondInfo2.Value) == 1.0 || outInfo.Error.Type != ErrorTypes.None) return outInfo;
        
        try
        {
            outInfo = PerformManagedOperationUnits
            (
                outInfo, secondInfo2.Value, operation
            );
        }
        catch
        {
            //Very unlikely scenario on account of the fact that Math.Abs(secondInfo2.Value)
            //lies within the 0.1-10.0 range.
            outInfo = OperationValuesManageError
            (
                new UnitInfo(outInfo)
                {
                    Value = secondInfo2.Value,
                    BaseTenExponent = 0
                },
                new UnitInfo()
                {
                    Value = outInfo.Value,
                    BaseTenExponent = outInfo.BaseTenExponent
                },
                operation
            );
        }

        return outInfo;
    }

    static UnitInfo ConvertValueToBaseTen(double value)
    {
        value = Math.Abs(value);
        return FromValueToBaseTenExponent
        (
             new UnitInfo(value), Math.Abs(value), false
        );
    }

    static UnitInfo ConvertBaseTenToValue(UnitInfo unitInfo)
    {
        if (unitInfo.BaseTenExponent == 0) return unitInfo;

        UnitInfo outInfo = new UnitInfo(unitInfo);
        boolean decrease = unitInfo.BaseTenExponent > 0;
        int sign = Math.Sign(outInfo.Value);
        double absValue = Math.Abs(outInfo.Value);

        while (outInfo.BaseTenExponent != 0.0)
        {
            if (decrease)
            {
                if (absValue >= MaxValueDec / 10.0) break;
                absValue *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }
            else
            {
                if (absValue <= MinValueDec * 10.0) break;
                absValue /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
        }

        outInfo.Value = sign * absValue;

        return outInfo;
    }

    static UnitInfo NormaliseUnitInfo(UnitInfo unitInfo)
    {
        if (unitInfo.Value == 0 && unitInfo.Prefix.Factor == 1.0)
        {
            return unitInfo;
        }
        UnitInfo outInfo = new UnitInfo(unitInfo);

        if (outInfo.Prefix.Factor != 1)
        {
            outInfo = FromValueToBaseTenExponent
            (
                outInfo, outInfo.Prefix.Factor, true
            );
            outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage);
        }
        if (outInfo.Value == 0.0) return outInfo;

        outInfo = FromValueToBaseTenExponent
        (
            outInfo, outInfo.Value, false
        );

        return outInfo;
    }

    static UnitInfo FromValueToBaseTenExponent(UnitInfo outInfo, double value, boolean isPrefix)
    {
        if (value == 0.0) return outInfo;

        double valueAbs = Math.Abs(value);
        boolean decrease = (valueAbs > 1.0);
        if (!isPrefix)
        {
            outInfo.Value = outInfo.Value / valueAbs;
        }

        while (valueAbs != 1.0)
        {
            if ((valueAbs < 10.0 && valueAbs > 1.0) || (valueAbs > 0.1.0 && valueAbs < 1.0))
            {
                if (!isPrefix) outInfo.Value = value;
                else
                {
                    outInfo = PerformManagedOperationValues
                    (
                        outInfo, value, Operations.Multiplication
                    );
                }

                return outInfo;
            }

            if (decrease)
            {
                value /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
            else
            {
                value *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }

            valueAbs = Math.Abs(value);
        }

        return outInfo;
    }

    //Method used to vary BaseTenExponent without provoking unhandled exceptions (i.e., bigger than Integer.MAX_VALUE).
    static UnitInfo VaryBaseTenExponent(UnitInfo info, int baseTenIncrease, boolean isDivision = false)
    {
        long val1 = info.BaseTenExponent;
        long val2 = baseTenIncrease;

        if (isDivision)
        {
            //Converting a negative value into positive might provoke an overflow error for the int type
            //(e.g., Math.Abs(Integer.MAIN_VALUE)). Converting both variables to long is a quick and effective
            //way to avoid this problem.
            val2 *= -1;
        }

        return
        (
             ((val2 > 0 && val1 > Integer.MAX_VALUE - val2) || (val2 < 0 && val1 < Integer.MAIN_VALUE - val2)) ?
            new UnitInfo(info, ErrorTypes.NumericError) : new UnitInfo(info){{ BaseTenExponent = (int)(val1 + val2); }}
        );
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 2 2017-05-27 19:58:20.661
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 0 2017-05-27 19:58:20.662
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.core 4 4 2017-05-27 19:58:21.593
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
public class OperationsManaged
{
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, double second, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            firstInfo, new UnitInfo(second), operation
        );
    }

    public static UnitInfo PerformManagedOperationUnits(double first, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            new UnitInfo(first), secondInfo, operation
        );
    }

    //This method should always be used when dealing with random UnitInfo variables because it accounts for all the
    //possible scenarios. On the other hand, with simple operations (e.g., random UnitInfo & numeric type) it might
    //be better to use PerformManagedOperationValues. 
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        ErrorTypes errorType = InternalMethods.GetOperationError
        (
            firstInfo, secondInfo, operation
        );
        if (errorType != ErrorTypes.None)
        {
            return new UnitInfo(firstInfo) 
            {{
                Error = new ErrorInfo(errorType); 
            }};
        }

        return
        (
            operation == Operations.Addition || operation == Operations.Subtraction ?
            PerformManagedOperationAddition(firstInfo, secondInfo, operation) :
            PerformManagedOperationMultiplication(firstInfo, secondInfo, operation)
        );
    }

    static UnitInfo PerformManagedOperationAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {   
        //After being normalised, the operands might require further modifications.
        UnitInfo[] normalised = GetOperandsAddition(firstInfo, secondInfo, operation);

        return PerformManagedOperationNormalisedValues
        (
            firstInfo, normalised, operation
        );
    }

    static UnitInfo[] GetOperandsAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        UnitInfo[] operands2 = new UnitInfo[] 
        {
            new UnitInfo(firstInfo), new UnitInfo(secondInfo)
        };

        if (operands2[0].BaseTenExponent != operands2[1].BaseTenExponent || operands2[0].Prefix.Factor != operands2[1].Prefix.Factor)
        {
            //The addition/subtraction might not be performed right away even with normalised values.
            //For example: 5 and 6 from 5*10^2 and 6*10^7 cannot be added right away.
            operands2 = AdaptNormalisedValuesForAddition
            (
                new UnitInfo[] 
                { 
                    NormaliseUnitInfo(operands2[0]), 
                    NormaliseUnitInfo(operands2[1])
                },
                operation
            );
        }

        return operands2;
    }
    
    static UnitInfo[] AdaptNormalisedValuesForAddition(UnitInfo[] unitInfos2, Operations operation)
    {
        if (unitInfos2[0].BaseTenExponent == unitInfos2[1].BaseTenExponent)
        {
            //Having the same BaseTenExponent values means that the given operation can be performed right away.
            return unitInfos2;
        }

        int[] bigSmallI = 
        (
            unitInfos2[0].BaseTenExponent > unitInfos2[1].BaseTenExponent ?
            new int[] { 0, 1 } : new int[] { 1, 0 }
        );

        //Only the variable with the bigger value is modified. For example: 5*10^5 & 3*10^3 is converted
        //into 500*10^3 & 3*10^3 in order to allow the addition 500 + 3. 
        UnitInfo big2 = AdaptBiggerAdditionOperand(unitInfos2, bigSmallI, operation);
        if (big2.Error.Type != ErrorTypes.None)
        {
            return TooBigGapAddition(unitInfos2, bigSmallI, operation);
        }

        unitInfos2[bigSmallI[0]].Value = big2.Value;
        unitInfos2[bigSmallI[0]].BaseTenExponent = unitInfos2[bigSmallI[1]].BaseTenExponent;

        return unitInfos2;
    }

    //When adding/subtracting two numbers whose gap is bigger than the maximum double range, there
    //is no need to perform any operation (i.e., no change will be observed because of being outside
    //the maximum supported precision). This method takes care of these cases and returns the expected
    //output (i.e., biggest value).
    static UnitInfo[] TooBigGapAddition(UnitInfo[] unitInfos2, int[] bigSmallI, Operations operation)
    {
        UnitInfo[] outInfos = new UnitInfo[] 
        {
            //First operand (i.e., one whose information defines the operation) together with the
            //numeric information (i.e., just Value and BaseTenExponent because both are normalised)
            //which is associated with the biggest one.
            new UnitInfo(unitInfos2[0])
            {{
                Value = unitInfos2[bigSmallI[0]].Value;
                BaseTenExponent = unitInfos2[bigSmallI[0]].BaseTenExponent;
            }}
        };

        if (operation == Operations.Subtraction && bigSmallI[0] == 1)
        {
            outInfos[0].Value = -1.0 * outInfos[0].Value;
        }

        if (outInfos[0].Unit == Units.Unitless)
        {
            outInfos[0].Unit = unitInfos2[bigSmallI[1]].Unit;
        }

        return outInfos;
    }

    static UnitInfo AdaptBiggerAdditionOperand(UnitInfo[] unitInfos2, int[] bigSmallI, Operations operation)
    {
        int gapExponent = unitInfos2[bigSmallI[0]].BaseTenExponent - unitInfos2[bigSmallI[1]].BaseTenExponent;
        if (gapExponent >= 27)
        {
            //The difference between both inputs is bigger than (or, at least, very close to) the maximum double value/precision;
            //what makes this situation calculation unworthy and the first operand to be returned as the result.
            //Note that the error below these lines is just an easy way to tell the calling function about this eventuality.
            return new UnitInfo(unitInfos2[0]) 
            {{ 
                Error = new ErrorInfo(ErrorTypes.InvalidOperation); 
            }};
        }

        //PerformManagedOperationValues is used to make sure that the resulting numeric information is stored
        //in Value (if possible).
        UnitInfo big2 = PerformManagedOperationValues
        (
            RaiseToIntegerExponent(10.0, gapExponent), unitInfos2[bigSmallI[0]].Value, 
            Operations.Multiplication                
        );

        boolean isWrong = 
        (
            big2.Error.Type != ErrorTypes.None || big2.BaseTenExponent != 0 ?
            
            //The value of the bigger input times 10^(gap between BaseTenExponent of inputs) is too big. 
            isWrong = true :
            
            //Overflow-check very unlikely to trigger an error. In fact, with properly normalised variables,
            //triggering an error would be plainly impossible.               
            AreAdditionFinalValuesWrong
            (
                unitInfos2[0].Value, unitInfos2[1].Value, operation
            )
        );

        if (isWrong)
        {
        	//This error is just an easy way to let the calling function know about the fact that no
                    //calculation has been performed (too big gap). This isn't a properly-speaking error and
                    //that's why it will not be notified to the user.
        	return new UnitInfo(unitInfos2[0])
                    {{
                        Error = new ErrorInfo(ErrorTypes.InvalidOperation);
                    }};
        }
        else
        {
            //Returning the new big value. For example: with 5*10^4 & 3*10^2, 500 would be returned.
            return new UnitInfo(unitInfos2[bigSmallI[0]])
            {{
                Value = big2.Value;
            }};
        }

        
        return
        (
            isWrong ?
            //This error is just an easy way to let the calling function know about the fact that no
            //calculation has been performed (too big gap). This isn't a properly-speaking error and
            //that's why it will not be notified to the user.
            new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }} :
            //Returning the new big value. For example: with 5*10^4 & 3*10^2, 500 would be returned.
            new UnitInfo(unitInfos2[bigSmallI[0]])
            {{
                Value = big2.Value;
            }}
        );
    }

    static boolean AreAdditionFinalValuesWrong(double val1, double val2, Operations operation)
    {
        boolean isWrong = false;

        try
        {
            val1 = val1 + val2 *
            (
                operation == Operations.Addition ? 1 : -1
            );
        }
        catch { isWrong = true; }

        return isWrong;
    }

    static UnitInfo PerformManagedOperationMultiplication(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationNormalisedValues
        (
            firstInfo, new UnitInfo[] 
            { 
                NormaliseUnitInfo(firstInfo),
                NormaliseUnitInfo(secondInfo) 
            },
            operation
        );
    }

    public static UnitInfo RaiseToIntegerExponent(double baseValue, int exponent)
    {
        return RaiseToIntegerExponent(new UnitInfo(baseValue), exponent);
    }

    static UnitInfo RaiseToIntegerExponent(UnitInfo baseInfo, int exponent)
    {
        if (exponent <= 1 && exponent >= 0)
        {
            baseInfo.Value = (exponent == 0 ? 1.0 : baseInfo.Value);
            return baseInfo;
        }

        UnitInfo outInfo = new UnitInfo(baseInfo);

        for (int i = 1; i < Math.Abs(exponent); i++)
        {
            outInfo = PerformManagedOperationValues
            (
                outInfo, baseInfo, Operations.Multiplication
            );
            if (outInfo.Error.Type != ErrorTypes.None) return outInfo;
        }

        return
        (
            exponent < 0 ?
            PerformManagedOperationValues(new UnitInfo(1.0), outInfo, Operations.Division) :
            outInfo
        );
    }

    static UnitInfo PerformManagedOperationNormalisedValues(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        outInfo =
        (
            normalisedInfos.Length == 1 ?
            //There is just one operand when the difference between both of them is too big.
            outInfo = normalisedInfos[0] :
            PerformManagedOperationTwoOperands(outInfo, normalisedInfos, operation)
        );

        return outInfo;
    }

    static UnitInfo PerformManagedOperationTwoOperands(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        UnitInfo outInfoNormalised = PerformManagedOperationValues
        (
            normalisedInfos[0], normalisedInfos[1], operation
        );

        if (outInfo.Error.Type != ErrorTypes.None)
        {
            return new UnitInfo(outInfo)
            {
                Error = new ErrorInfo(ErrorTypes.NumericError)
            };
        }

        outInfo.BaseTenExponent = outInfoNormalised.BaseTenExponent;
        outInfo.Value = outInfoNormalised.Value;
        //Normalised means no prefixes.
        outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage); 

        return outInfo;
    }

    static UnitInfo PerformManagedOperationValues(double firstValue, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            new UnitInfo(firstValue), new UnitInfo(secondValue), operation
        );
    }

    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            firstInfo, new UnitInfo(secondValue), operation
        );
    }

    //This method might be used to perform full operations (not just being the last calculation step) instead
    //of the default one (PerformManagedOperationUnits) for simple cases. That is: ones not dealing with the
    //complex numeric reality (Value, Prefix and BaseTenExponent) which makes a pre-analysis required.
    //Note that, unlikely what happens with PerformMangedOperationUnits, the outputs of this method aren't
    //normalised (= primarily stored under Value), what is useful in certain contexts.
    //NOTE: this function assumes that both inputs are normalised, what means that no prefix information is expected.
    //It might also be used with non-normalised inputs, but their prefix information would be plainly ignored.
    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        if (firstInfo.Value == 0.0 || secondInfo.Value == 0.0)
        {
            if (operation == Operations.Multiplication || operation == Operations.Division)
            {
                //Dividing by zero scenarios are taken into account somewhere else.
                return new UnitInfo(firstInfo) { Value = 0.0 };
            }
        }

        UnitInfo outInfo = new UnitInfo(firstInfo);
        UnitInfo firstInfo0 = new UnitInfo(firstInfo);
        UnitInfo secondInfo0 = new UnitInfo(secondInfo);

        boolean isWrong = false;
        try
        {
            if (operation == Operations.Addition)
            {
                outInfo.Value += secondInfo0.Value;
            }
            else if (operation == Operations.Subtraction)
            {
                outInfo.Value -= secondInfo.Value;
            }
            else
            {
                //The reason for checking whether BaseTenExponent is inside/outside the int range before performing 
                //the operation (rather than going ahead and eventually catching the resulting exception) isn't just
                //being quicker, but also the only option in many situations. Note that an addition/subtraction between
                //two int variables whose result is outside the int range might not trigger an exception (+ random 
                //negative value as output).
                if (VaryBaseTenExponent(outInfo, secondInfo0.BaseTenExponent, operation == Operations.Division).Error.Type != ErrorTypes.None)
                {
                    return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
                }

                if (operation == Operations.Multiplication)
                {
                    outInfo.Value *= secondInfo.Value;
                    outInfo.BaseTenExponent += secondInfo.BaseTenExponent;
                }
                else if (operation == Operations.Division)
                {
                    if (secondInfo.Value == 0.0)
                    {
                        return
                        (
                            new UnitInfo(outInfo) 
                            { 
                                Error = new ErrorInfo(ErrorTypes.NumericError) 
                            }
                        );
                    }
                    outInfo.Value /= secondInfo.Value;
                    outInfo.BaseTenExponent -= secondInfo.BaseTenExponent;
                }
            }
        }
        catch { isWrong = true; }

        return
        (
            //An error might not be triggered despite of dealing with numbers outside double precision.
            //For example: 0.00000000000000000001m * 0.0000000000000000000001m can output 0.0 without triggering an error. 
            isWrong || ((operation == Operations.Multiplication || operation == Operations.Division) && outInfo.Value == 0.0.0) ?
            OperationValuesManageError(firstInfo0, secondInfo0, operation) : outInfo
        );
    }

    static UnitInfo OperationValuesManageError(UnitInfo outInfo, UnitInfo secondInfo, Operations operation)
    {
        if (operation != Operations.Multiplication && operation != Operations.Division)
        {
            //This condition should never be true on account of the fact that the pre-modifications performed before
            //adding/subtracting should avoid erroneous situations.
            return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
        }

        UnitInfo secondInfo2 = ConvertValueToBaseTen(secondInfo.Value);
        outInfo = VaryBaseTenExponent(outInfo, secondInfo2.BaseTenExponent, operation == Operations.Division);
        if (Math.Abs(secondInfo2.Value) == 1.0 || outInfo.Error.Type != ErrorTypes.None) return outInfo;
        
        try
        {
            outInfo = PerformManagedOperationUnits
            (
                outInfo, secondInfo2.Value, operation
            );
        }
        catch
        {
            //Very unlikely scenario on account of the fact that Math.Abs(secondInfo2.Value)
            //lies within the 0.1-10.0 range.
            outInfo = OperationValuesManageError
            (
                new UnitInfo(outInfo)
                {
                    Value = secondInfo2.Value,
                    BaseTenExponent = 0
                },
                new UnitInfo()
                {
                    Value = outInfo.Value,
                    BaseTenExponent = outInfo.BaseTenExponent
                },
                operation
            );
        }

        return outInfo;
    }

    static UnitInfo ConvertValueToBaseTen(double value)
    {
        value = Math.Abs(value);
        return FromValueToBaseTenExponent
        (
             new UnitInfo(value), Math.Abs(value), false
        );
    }

    static UnitInfo ConvertBaseTenToValue(UnitInfo unitInfo)
    {
        if (unitInfo.BaseTenExponent == 0) return unitInfo;

        UnitInfo outInfo = new UnitInfo(unitInfo);
        boolean decrease = unitInfo.BaseTenExponent > 0;
        int sign = Math.Sign(outInfo.Value);
        double absValue = Math.Abs(outInfo.Value);

        while (outInfo.BaseTenExponent != 0.0)
        {
            if (decrease)
            {
                if (absValue >= MaxValueDec / 10.0) break;
                absValue *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }
            else
            {
                if (absValue <= MinValueDec * 10.0) break;
                absValue /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
        }

        outInfo.Value = sign * absValue;

        return outInfo;
    }

    static UnitInfo NormaliseUnitInfo(UnitInfo unitInfo)
    {
        if (unitInfo.Value == 0 && unitInfo.Prefix.Factor == 1.0)
        {
            return unitInfo;
        }
        UnitInfo outInfo = new UnitInfo(unitInfo);

        if (outInfo.Prefix.Factor != 1)
        {
            outInfo = FromValueToBaseTenExponent
            (
                outInfo, outInfo.Prefix.Factor, true
            );
            outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage);
        }
        if (outInfo.Value == 0.0) return outInfo;

        outInfo = FromValueToBaseTenExponent
        (
            outInfo, outInfo.Value, false
        );

        return outInfo;
    }

    static UnitInfo FromValueToBaseTenExponent(UnitInfo outInfo, double value, boolean isPrefix)
    {
        if (value == 0.0) return outInfo;

        double valueAbs = Math.Abs(value);
        boolean decrease = (valueAbs > 1.0);
        if (!isPrefix)
        {
            outInfo.Value = outInfo.Value / valueAbs;
        }

        while (valueAbs != 1.0)
        {
            if ((valueAbs < 10.0 && valueAbs > 1.0) || (valueAbs > 0.1.0 && valueAbs < 1.0))
            {
                if (!isPrefix) outInfo.Value = value;
                else
                {
                    outInfo = PerformManagedOperationValues
                    (
                        outInfo, value, Operations.Multiplication
                    );
                }

                return outInfo;
            }

            if (decrease)
            {
                value /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
            else
            {
                value *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }

            valueAbs = Math.Abs(value);
        }

        return outInfo;
    }

    //Method used to vary BaseTenExponent without provoking unhandled exceptions (i.e., bigger than Integer.MAX_VALUE).
    static UnitInfo VaryBaseTenExponent(UnitInfo info, int baseTenIncrease, boolean isDivision = false)
    {
        long val1 = info.BaseTenExponent;
        long val2 = baseTenIncrease;

        if (isDivision)
        {
            //Converting a negative value into positive might provoke an overflow error for the int type
            //(e.g., Math.Abs(Integer.MAIN_VALUE)). Converting both variables to long is a quick and effective
            //way to avoid this problem.
            val2 *= -1;
        }

        return
        (
             ((val2 > 0 && val1 > Integer.MAX_VALUE - val2) || (val2 < 0 && val1 < Integer.MAIN_VALUE - val2)) ?
            new UnitInfo(info, ErrorTypes.NumericError) : new UnitInfo(info){{ BaseTenExponent = (int)(val1 + val2); }}
        );
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 2 2017-05-27 19:58:21.594
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 0 2017-05-27 19:58:21.594
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.core 4 4 2017-05-27 19:58:22.118
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
public class OperationsManaged
{
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, double second, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            firstInfo, new UnitInfo(second), operation
        );
    }

    public static UnitInfo PerformManagedOperationUnits(double first, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            new UnitInfo(first), secondInfo, operation
        );
    }

    //This method should always be used when dealing with random UnitInfo variables because it accounts for all the
    //possible scenarios. On the other hand, with simple operations (e.g., random UnitInfo & numeric type) it might
    //be better to use PerformManagedOperationValues. 
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        ErrorTypes errorType = InternalMethods.GetOperationError
        (
            firstInfo, secondInfo, operation
        );
        if (errorType != ErrorTypes.None)
        {
            return new UnitInfo(firstInfo) 
            {{
                Error = new ErrorInfo(errorType); 
            }};
        }

        return
        (
            operation == Operations.Addition || operation == Operations.Subtraction ?
            PerformManagedOperationAddition(firstInfo, secondInfo, operation) :
            PerformManagedOperationMultiplication(firstInfo, secondInfo, operation)
        );
    }

    static UnitInfo PerformManagedOperationAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {   
        //After being normalised, the operands might require further modifications.
        UnitInfo[] normalised = GetOperandsAddition(firstInfo, secondInfo, operation);

        return PerformManagedOperationNormalisedValues
        (
            firstInfo, normalised, operation
        );
    }

    static UnitInfo[] GetOperandsAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        UnitInfo[] operands2 = new UnitInfo[] 
        {
            new UnitInfo(firstInfo), new UnitInfo(secondInfo)
        };

        if (operands2[0].BaseTenExponent != operands2[1].BaseTenExponent || operands2[0].Prefix.Factor != operands2[1].Prefix.Factor)
        {
            //The addition/subtraction might not be performed right away even with normalised values.
            //For example: 5 and 6 from 5*10^2 and 6*10^7 cannot be added right away.
            operands2 = AdaptNormalisedValuesForAddition
            (
                new UnitInfo[] 
                { 
                    NormaliseUnitInfo(operands2[0]), 
                    NormaliseUnitInfo(operands2[1])
                },
                operation
            );
        }

        return operands2;
    }
    
    static UnitInfo[] AdaptNormalisedValuesForAddition(UnitInfo[] unitInfos2, Operations operation)
    {
        if (unitInfos2[0].BaseTenExponent == unitInfos2[1].BaseTenExponent)
        {
            //Having the same BaseTenExponent values means that the given operation can be performed right away.
            return unitInfos2;
        }

        int[] bigSmallI = 
        (
            unitInfos2[0].BaseTenExponent > unitInfos2[1].BaseTenExponent ?
            new int[] { 0, 1 } : new int[] { 1, 0 }
        );

        //Only the variable with the bigger value is modified. For example: 5*10^5 & 3*10^3 is converted
        //into 500*10^3 & 3*10^3 in order to allow the addition 500 + 3. 
        UnitInfo big2 = AdaptBiggerAdditionOperand(unitInfos2, bigSmallI, operation);
        if (big2.Error.Type != ErrorTypes.None)
        {
            return TooBigGapAddition(unitInfos2, bigSmallI, operation);
        }

        unitInfos2[bigSmallI[0]].Value = big2.Value;
        unitInfos2[bigSmallI[0]].BaseTenExponent = unitInfos2[bigSmallI[1]].BaseTenExponent;

        return unitInfos2;
    }

    //When adding/subtracting two numbers whose gap is bigger than the maximum double range, there
    //is no need to perform any operation (i.e., no change will be observed because of being outside
    //the maximum supported precision). This method takes care of these cases and returns the expected
    //output (i.e., biggest value).
    static UnitInfo[] TooBigGapAddition(UnitInfo[] unitInfos2, int[] bigSmallI, Operations operation)
    {
        UnitInfo[] outInfos = new UnitInfo[] 
        {
            //First operand (i.e., one whose information defines the operation) together with the
            //numeric information (i.e., just Value and BaseTenExponent because both are normalised)
            //which is associated with the biggest one.
            new UnitInfo(unitInfos2[0])
            {{
                Value = unitInfos2[bigSmallI[0]].Value;
                BaseTenExponent = unitInfos2[bigSmallI[0]].BaseTenExponent;
            }}
        };

        if (operation == Operations.Subtraction && bigSmallI[0] == 1)
        {
            outInfos[0].Value = -1.0 * outInfos[0].Value;
        }

        if (outInfos[0].Unit == Units.Unitless)
        {
            outInfos[0].Unit = unitInfos2[bigSmallI[1]].Unit;
        }

        return outInfos;
    }

    static UnitInfo AdaptBiggerAdditionOperand(UnitInfo[] unitInfos2, int[] bigSmallI, Operations operation)
    {
        int gapExponent = unitInfos2[bigSmallI[0]].BaseTenExponent - unitInfos2[bigSmallI[1]].BaseTenExponent;
        if (gapExponent >= 27)
        {
            //The difference between both inputs is bigger than (or, at least, very close to) the maximum double value/precision;
            //what makes this situation calculation unworthy and the first operand to be returned as the result.
            //Note that the error below these lines is just an easy way to tell the calling function about this eventuality.
            return new UnitInfo(unitInfos2[0]) 
            {{ 
                Error = new ErrorInfo(ErrorTypes.InvalidOperation); 
            }};
        }

        //PerformManagedOperationValues is used to make sure that the resulting numeric information is stored
        //in Value (if possible).
        UnitInfo big2 = PerformManagedOperationValues
        (
            RaiseToIntegerExponent(10.0, gapExponent), unitInfos2[bigSmallI[0]].Value, 
            Operations.Multiplication                
        );

        boolean isWrong = 
        (
            big2.Error.Type != ErrorTypes.None || big2.BaseTenExponent != 0 ?
            
            //The value of the bigger input times 10^(gap between BaseTenExponent of inputs) is too big. 
            isWrong = true :
            
            //Overflow-check very unlikely to trigger an error. In fact, with properly normalised variables,
            //triggering an error would be plainly impossible.               
            AreAdditionFinalValuesWrong
            (
                unitInfos2[0].Value, unitInfos2[1].Value, operation
            )
        );

        if (isWrong)
        {
        	//This error is just an easy way to let the calling function know about the fact that no
                    //calculation has been performed (too big gap). This isn't a properly-speaking error and
                    //that's why it will not be notified to the user.
        	return new UnitInfo(unitInfos2[0])
                    {{
                        Error = new ErrorInfo(ErrorTypes.InvalidOperation);
                    }};
        }
        else
        {
            //Returning the new big value. For example: with 5*10^4 & 3*10^2, 500 would be returned.
            return new UnitInfo(unitInfos2[bigSmallI[0]])
            {{
                Value = big2.Value;
            }};
        }

        
        return
        (
            isWrong ?
            //This error is just an easy way to let the calling function know about the fact that no
            //calculation has been performed (too big gap). This isn't a properly-speaking error and
            //that's why it will not be notified to the user.
            new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }} :
            //Returning the new big value. For example: with 5*10^4 & 3*10^2, 500 would be returned.
            new UnitInfo(unitInfos2[bigSmallI[0]])
            {{
                Value = big2.Value;
            }}
        );
    }

    static boolean AreAdditionFinalValuesWrong(double val1, double val2, Operations operation)
    {
        boolean isWrong = false;

        try
        {
            val1 = val1 + val2 *
            (
                operation == Operations.Addition ? 1 : -1
            );
        }
        catch { isWrong = true; }

        return isWrong;
    }

    static UnitInfo PerformManagedOperationMultiplication(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationNormalisedValues
        (
            firstInfo, new UnitInfo[] 
            { 
                NormaliseUnitInfo(firstInfo),
                NormaliseUnitInfo(secondInfo) 
            },
            operation
        );
    }

    public static UnitInfo RaiseToIntegerExponent(double baseValue, int exponent)
    {
        return RaiseToIntegerExponent(new UnitInfo(baseValue), exponent);
    }

    static UnitInfo RaiseToIntegerExponent(UnitInfo baseInfo, int exponent)
    {
        if (exponent <= 1 && exponent >= 0)
        {
            baseInfo.Value = (exponent == 0 ? 1.0 : baseInfo.Value);
            return baseInfo;
        }

        UnitInfo outInfo = new UnitInfo(baseInfo);

        for (int i = 1; i < Math.Abs(exponent); i++)
        {
            outInfo = PerformManagedOperationValues
            (
                outInfo, baseInfo, Operations.Multiplication
            );
            if (outInfo.Error.Type != ErrorTypes.None) return outInfo;
        }

        return
        (
            exponent < 0 ?
            PerformManagedOperationValues(new UnitInfo(1.0), outInfo, Operations.Division) :
            outInfo
        );
    }

    static UnitInfo PerformManagedOperationNormalisedValues(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        outInfo =
        (
            normalisedInfos.Length == 1 ?
            //There is just one operand when the difference between both of them is too big.
            outInfo = normalisedInfos[0] :
            PerformManagedOperationTwoOperands(outInfo, normalisedInfos, operation)
        );

        return outInfo;
    }

    static UnitInfo PerformManagedOperationTwoOperands(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        UnitInfo outInfoNormalised = PerformManagedOperationValues
        (
            normalisedInfos[0], normalisedInfos[1], operation
        );

        if (outInfo.Error.Type != ErrorTypes.None)
        {
            return new UnitInfo(outInfo)
            {
                Error = new ErrorInfo(ErrorTypes.NumericError)
            };
        }

        outInfo.BaseTenExponent = outInfoNormalised.BaseTenExponent;
        outInfo.Value = outInfoNormalised.Value;
        //Normalised means no prefixes.
        outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage); 

        return outInfo;
    }

    static UnitInfo PerformManagedOperationValues(double firstValue, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            new UnitInfo(firstValue), new UnitInfo(secondValue), operation
        );
    }

    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            firstInfo, new UnitInfo(secondValue), operation
        );
    }

    //This method might be used to perform full operations (not just being the last calculation step) instead
    //of the default one (PerformManagedOperationUnits) for simple cases. That is: ones not dealing with the
    //complex numeric reality (Value, Prefix and BaseTenExponent) which makes a pre-analysis required.
    //Note that, unlikely what happens with PerformMangedOperationUnits, the outputs of this method aren't
    //normalised (= primarily stored under Value), what is useful in certain contexts.
    //NOTE: this function assumes that both inputs are normalised, what means that no prefix information is expected.
    //It might also be used with non-normalised inputs, but their prefix information would be plainly ignored.
    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        if (firstInfo.Value == 0.0 || secondInfo.Value == 0.0)
        {
            if (operation == Operations.Multiplication || operation == Operations.Division)
            {
                //Dividing by zero scenarios are taken into account somewhere else.
                return new UnitInfo(firstInfo) { Value = 0.0 };
            }
        }

        UnitInfo outInfo = new UnitInfo(firstInfo);
        UnitInfo firstInfo0 = new UnitInfo(firstInfo);
        UnitInfo secondInfo0 = new UnitInfo(secondInfo);

        boolean isWrong = false;
        try
        {
            if (operation == Operations.Addition)
            {
                outInfo.Value += secondInfo0.Value;
            }
            else if (operation == Operations.Subtraction)
            {
                outInfo.Value -= secondInfo.Value;
            }
            else
            {
                //The reason for checking whether BaseTenExponent is inside/outside the int range before performing 
                //the operation (rather than going ahead and eventually catching the resulting exception) isn't just
                //being quicker, but also the only option in many situations. Note that an addition/subtraction between
                //two int variables whose result is outside the int range might not trigger an exception (+ random 
                //negative value as output).
                if (VaryBaseTenExponent(outInfo, secondInfo0.BaseTenExponent, operation == Operations.Division).Error.Type != ErrorTypes.None)
                {
                    return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
                }

                if (operation == Operations.Multiplication)
                {
                    outInfo.Value *= secondInfo.Value;
                    outInfo.BaseTenExponent += secondInfo.BaseTenExponent;
                }
                else if (operation == Operations.Division)
                {
                    if (secondInfo.Value == 0.0)
                    {
                        return
                        (
                            new UnitInfo(outInfo) 
                            { 
                                Error = new ErrorInfo(ErrorTypes.NumericError) 
                            }
                        );
                    }
                    outInfo.Value /= secondInfo.Value;
                    outInfo.BaseTenExponent -= secondInfo.BaseTenExponent;
                }
            }
        }
        catch { isWrong = true; }

        return
        (
            //An error might not be triggered despite of dealing with numbers outside double precision.
            //For example: 0.00000000000000000001m * 0.0000000000000000000001m can output 0.0 without triggering an error. 
            isWrong || ((operation == Operations.Multiplication || operation == Operations.Division) && outInfo.Value == 0.0.0) ?
            OperationValuesManageError(firstInfo0, secondInfo0, operation) : outInfo
        );
    }

    static UnitInfo OperationValuesManageError(UnitInfo outInfo, UnitInfo secondInfo, Operations operation)
    {
        if (operation != Operations.Multiplication && operation != Operations.Division)
        {
            //This condition should never be true on account of the fact that the pre-modifications performed before
            //adding/subtracting should avoid erroneous situations.
            return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
        }

        UnitInfo secondInfo2 = ConvertValueToBaseTen(secondInfo.Value);
        outInfo = VaryBaseTenExponent(outInfo, secondInfo2.BaseTenExponent, operation == Operations.Division);
        if (Math.Abs(secondInfo2.Value) == 1.0 || outInfo.Error.Type != ErrorTypes.None) return outInfo;
        
        try
        {
            outInfo = PerformManagedOperationUnits
            (
                outInfo, secondInfo2.Value, operation
            );
        }
        catch
        {
            //Very unlikely scenario on account of the fact that Math.Abs(secondInfo2.Value)
            //lies within the 0.1-10.0 range.
            outInfo = OperationValuesManageError
            (
                new UnitInfo(outInfo)
                {
                    Value = secondInfo2.Value,
                    BaseTenExponent = 0
                },
                new UnitInfo()
                {
                    Value = outInfo.Value,
                    BaseTenExponent = outInfo.BaseTenExponent
                },
                operation
            );
        }

        return outInfo;
    }

    static UnitInfo ConvertValueToBaseTen(double value)
    {
        value = Math.Abs(value);
        return FromValueToBaseTenExponent
        (
             new UnitInfo(value), Math.Abs(value), false
        );
    }

    static UnitInfo ConvertBaseTenToValue(UnitInfo unitInfo)
    {
        if (unitInfo.BaseTenExponent == 0) return unitInfo;

        UnitInfo outInfo = new UnitInfo(unitInfo);
        boolean decrease = unitInfo.BaseTenExponent > 0;
        int sign = Math.Sign(outInfo.Value);
        double absValue = Math.Abs(outInfo.Value);

        while (outInfo.BaseTenExponent != 0.0)
        {
            if (decrease)
            {
                if (absValue >= MaxValueDec / 10.0) break;
                absValue *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }
            else
            {
                if (absValue <= MinValueDec * 10.0) break;
                absValue /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
        }

        outInfo.Value = sign * absValue;

        return outInfo;
    }

    static UnitInfo NormaliseUnitInfo(UnitInfo unitInfo)
    {
        if (unitInfo.Value == 0 && unitInfo.Prefix.Factor == 1.0)
        {
            return unitInfo;
        }
        UnitInfo outInfo = new UnitInfo(unitInfo);

        if (outInfo.Prefix.Factor != 1)
        {
            outInfo = FromValueToBaseTenExponent
            (
                outInfo, outInfo.Prefix.Factor, true
            );
            outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage);
        }
        if (outInfo.Value == 0.0) return outInfo;

        outInfo = FromValueToBaseTenExponent
        (
            outInfo, outInfo.Value, false
        );

        return outInfo;
    }

    static UnitInfo FromValueToBaseTenExponent(UnitInfo outInfo, double value, boolean isPrefix)
    {
        if (value == 0.0) return outInfo;

        double valueAbs = Math.Abs(value);
        boolean decrease = (valueAbs > 1.0);
        if (!isPrefix)
        {
            outInfo.Value = outInfo.Value / valueAbs;
        }

        while (valueAbs != 1.0)
        {
            if ((valueAbs < 10.0 && valueAbs > 1.0) || (valueAbs > 0.1.0 && valueAbs < 1.0))
            {
                if (!isPrefix) outInfo.Value = value;
                else
                {
                    outInfo = PerformManagedOperationValues
                    (
                        outInfo, value, Operations.Multiplication
                    );
                }

                return outInfo;
            }

            if (decrease)
            {
                value /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
            else
            {
                value *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }

            valueAbs = Math.Abs(value);
        }

        return outInfo;
    }

    //Method used to vary BaseTenExponent without provoking unhandled exceptions (i.e., bigger than Integer.MAX_VALUE).
    static UnitInfo VaryBaseTenExponent(UnitInfo info, int baseTenIncrease, boolean isDivision = false)
    {
        long val1 = info.BaseTenExponent;
        long val2 = baseTenIncrease;

        if (isDivision)
        {
            //Converting a negative value into positive might provoke an overflow error for the int type
            //(e.g., Math.Abs(Integer.MAIN_VALUE)). Converting both variables to long is a quick and effective
            //way to avoid this problem.
            val2 *= -1;
        }

        return
        (
             ((val2 > 0 && val1 > Integer.MAX_VALUE - val2) || (val2 < 0 && val1 < Integer.MAIN_VALUE - val2)) ?
            new UnitInfo(info, ErrorTypes.NumericError) : new UnitInfo(info){{ BaseTenExponent = (int)(val1 + val2); }}
        );
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:137)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:116)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:164)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:86)
	at org.eclipse.jface.text.TextViewerHoverManager$4.run(TextViewerHoverManager.java:165)

!ENTRY org.eclipse.jdt.ui 4 2 2017-05-27 19:58:22.120
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:137)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:116)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:164)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:86)
	at org.eclipse.jface.text.TextViewerHoverManager$4.run(TextViewerHoverManager.java:165)

!ENTRY org.eclipse.jdt.ui 4 0 2017-05-27 19:58:22.121
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:137)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:116)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:164)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:86)
	at org.eclipse.jface.text.TextViewerHoverManager$4.run(TextViewerHoverManager.java:165)

!ENTRY org.eclipse.jdt.core 4 4 2017-05-27 19:58:23.418
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
public class OperationsManaged
{
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, double second, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            firstInfo, new UnitInfo(second), operation
        );
    }

    public static UnitInfo PerformManagedOperationUnits(double first, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            new UnitInfo(first), secondInfo, operation
        );
    }

    //This method should always be used when dealing with random UnitInfo variables because it accounts for all the
    //possible scenarios. On the other hand, with simple operations (e.g., random UnitInfo & numeric type) it might
    //be better to use PerformManagedOperationValues. 
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        ErrorTypes errorType = InternalMethods.GetOperationError
        (
            firstInfo, secondInfo, operation
        );
        if (errorType != ErrorTypes.None)
        {
            return new UnitInfo(firstInfo) 
            {{
                Error = new ErrorInfo(errorType); 
            }};
        }

        return
        (
            operation == Operations.Addition || operation == Operations.Subtraction ?
            PerformManagedOperationAddition(firstInfo, secondInfo, operation) :
            PerformManagedOperationMultiplication(firstInfo, secondInfo, operation)
        );
    }

    static UnitInfo PerformManagedOperationAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {   
        //After being normalised, the operands might require further modifications.
        UnitInfo[] normalised = GetOperandsAddition(firstInfo, secondInfo, operation);

        return PerformManagedOperationNormalisedValues
        (
            firstInfo, normalised, operation
        );
    }

    static UnitInfo[] GetOperandsAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        UnitInfo[] operands2 = new UnitInfo[] 
        {
            new UnitInfo(firstInfo), new UnitInfo(secondInfo)
        };

        if (operands2[0].BaseTenExponent != operands2[1].BaseTenExponent || operands2[0].Prefix.Factor != operands2[1].Prefix.Factor)
        {
            //The addition/subtraction might not be performed right away even with normalised values.
            //For example: 5 and 6 from 5*10^2 and 6*10^7 cannot be added right away.
            operands2 = AdaptNormalisedValuesForAddition
            (
                new UnitInfo[] 
                { 
                    NormaliseUnitInfo(operands2[0]), 
                    NormaliseUnitInfo(operands2[1])
                },
                operation
            );
        }

        return operands2;
    }
    
    static UnitInfo[] AdaptNormalisedValuesForAddition(UnitInfo[] unitInfos2, Operations operation)
    {
        if (unitInfos2[0].BaseTenExponent == unitInfos2[1].BaseTenExponent)
        {
            //Having the same BaseTenExponent values means that the given operation can be performed right away.
            return unitInfos2;
        }

        int[] bigSmallI = 
        (
            unitInfos2[0].BaseTenExponent > unitInfos2[1].BaseTenExponent ?
            new int[] { 0, 1 } : new int[] { 1, 0 }
        );

        //Only the variable with the bigger value is modified. For example: 5*10^5 & 3*10^3 is converted
        //into 500*10^3 & 3*10^3 in order to allow the addition 500 + 3. 
        UnitInfo big2 = AdaptBiggerAdditionOperand(unitInfos2, bigSmallI, operation);
        if (big2.Error.Type != ErrorTypes.None)
        {
            return TooBigGapAddition(unitInfos2, bigSmallI, operation);
        }

        unitInfos2[bigSmallI[0]].Value = big2.Value;
        unitInfos2[bigSmallI[0]].BaseTenExponent = unitInfos2[bigSmallI[1]].BaseTenExponent;

        return unitInfos2;
    }

    //When adding/subtracting two numbers whose gap is bigger than the maximum double range, there
    //is no need to perform any operation (i.e., no change will be observed because of being outside
    //the maximum supported precision). This method takes care of these cases and returns the expected
    //output (i.e., biggest value).
    static UnitInfo[] TooBigGapAddition(UnitInfo[] unitInfos2, int[] bigSmallI, Operations operation)
    {
        UnitInfo[] outInfos = new UnitInfo[] 
        {
            //First operand (i.e., one whose information defines the operation) together with the
            //numeric information (i.e., just Value and BaseTenExponent because both are normalised)
            //which is associated with the biggest one.
            new UnitInfo(unitInfos2[0])
            {{
                Value = unitInfos2[bigSmallI[0]].Value;
                BaseTenExponent = unitInfos2[bigSmallI[0]].BaseTenExponent;
            }}
        };

        if (operation == Operations.Subtraction && bigSmallI[0] == 1)
        {
            outInfos[0].Value = -1.0 * outInfos[0].Value;
        }

        if (outInfos[0].Unit == Units.Unitless)
        {
            outInfos[0].Unit = unitInfos2[bigSmallI[1]].Unit;
        }

        return outInfos;
    }

    static UnitInfo AdaptBiggerAdditionOperand(UnitInfo[] unitInfos2, int[] bigSmallI, Operations operation)
    {
        int gapExponent = unitInfos2[bigSmallI[0]].BaseTenExponent - unitInfos2[bigSmallI[1]].BaseTenExponent;
        if (gapExponent >= 27)
        {
            //The difference between both inputs is bigger than (or, at least, very close to) the maximum double value/precision;
            //what makes this situation calculation unworthy and the first operand to be returned as the result.
            //Note that the error below these lines is just an easy way to tell the calling function about this eventuality.
            return new UnitInfo(unitInfos2[0]) 
            {{ 
                Error = new ErrorInfo(ErrorTypes.InvalidOperation); 
            }};
        }

        //PerformManagedOperationValues is used to make sure that the resulting numeric information is stored
        //in Value (if possible).
        UnitInfo big2 = PerformManagedOperationValues
        (
            RaiseToIntegerExponent(10.0, gapExponent), unitInfos2[bigSmallI[0]].Value, 
            Operations.Multiplication                
        );

        boolean isWrong = 
        (
            big2.Error.Type != ErrorTypes.None || big2.BaseTenExponent != 0 ?
            
            //The value of the bigger input times 10^(gap between BaseTenExponent of inputs) is too big. 
            isWrong = true :
            
            //Overflow-check very unlikely to trigger an error. In fact, with properly normalised variables,
            //triggering an error would be plainly impossible.               
            AreAdditionFinalValuesWrong
            (
                unitInfos2[0].Value, unitInfos2[1].Value, operation
            )
        );

        if (isWrong)
        {
        	//This error is just an easy way to let the calling function know about the fact that no
            //calculation has been performed (too big gap). This isn't a properly-speaking error and
                    //that's why it will not be notified to the user.
        	return new UnitInfo(unitInfos2[0])
                    {{
                        Error = new ErrorInfo(ErrorTypes.InvalidOperation);
                    }};
        }
        else
        {
            //Returning the new big value. For example: with 5*10^4 & 3*10^2, 500 would be returned.
            return new UnitInfo(unitInfos2[bigSmallI[0]])
            {{
                Value = big2.Value;
            }};
        }

        
        return
        (
            isWrong ?
            //This error is just an easy way to let the calling function know about the fact that no
            //calculation has been performed (too big gap). This isn't a properly-speaking error and
            //that's why it will not be notified to the user.
            new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }} :
            //Returning the new big value. For example: with 5*10^4 & 3*10^2, 500 would be returned.
            new UnitInfo(unitInfos2[bigSmallI[0]])
            {{
                Value = big2.Value;
            }}
        );
    }

    static boolean AreAdditionFinalValuesWrong(double val1, double val2, Operations operation)
    {
        boolean isWrong = false;

        try
        {
            val1 = val1 + val2 *
            (
                operation == Operations.Addition ? 1 : -1
            );
        }
        catch { isWrong = true; }

        return isWrong;
    }

    static UnitInfo PerformManagedOperationMultiplication(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationNormalisedValues
        (
            firstInfo, new UnitInfo[] 
            { 
                NormaliseUnitInfo(firstInfo),
                NormaliseUnitInfo(secondInfo) 
            },
            operation
        );
    }

    public static UnitInfo RaiseToIntegerExponent(double baseValue, int exponent)
    {
        return RaiseToIntegerExponent(new UnitInfo(baseValue), exponent);
    }

    static UnitInfo RaiseToIntegerExponent(UnitInfo baseInfo, int exponent)
    {
        if (exponent <= 1 && exponent >= 0)
        {
            baseInfo.Value = (exponent == 0 ? 1.0 : baseInfo.Value);
            return baseInfo;
        }

        UnitInfo outInfo = new UnitInfo(baseInfo);

        for (int i = 1; i < Math.Abs(exponent); i++)
        {
            outInfo = PerformManagedOperationValues
            (
                outInfo, baseInfo, Operations.Multiplication
            );
            if (outInfo.Error.Type != ErrorTypes.None) return outInfo;
        }

        return
        (
            exponent < 0 ?
            PerformManagedOperationValues(new UnitInfo(1.0), outInfo, Operations.Division) :
            outInfo
        );
    }

    static UnitInfo PerformManagedOperationNormalisedValues(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        outInfo =
        (
            normalisedInfos.Length == 1 ?
            //There is just one operand when the difference between both of them is too big.
            outInfo = normalisedInfos[0] :
            PerformManagedOperationTwoOperands(outInfo, normalisedInfos, operation)
        );

        return outInfo;
    }

    static UnitInfo PerformManagedOperationTwoOperands(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        UnitInfo outInfoNormalised = PerformManagedOperationValues
        (
            normalisedInfos[0], normalisedInfos[1], operation
        );

        if (outInfo.Error.Type != ErrorTypes.None)
        {
            return new UnitInfo(outInfo)
            {
                Error = new ErrorInfo(ErrorTypes.NumericError)
            };
        }

        outInfo.BaseTenExponent = outInfoNormalised.BaseTenExponent;
        outInfo.Value = outInfoNormalised.Value;
        //Normalised means no prefixes.
        outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage); 

        return outInfo;
    }

    static UnitInfo PerformManagedOperationValues(double firstValue, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            new UnitInfo(firstValue), new UnitInfo(secondValue), operation
        );
    }

    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            firstInfo, new UnitInfo(secondValue), operation
        );
    }

    //This method might be used to perform full operations (not just being the last calculation step) instead
    //of the default one (PerformManagedOperationUnits) for simple cases. That is: ones not dealing with the
    //complex numeric reality (Value, Prefix and BaseTenExponent) which makes a pre-analysis required.
    //Note that, unlikely what happens with PerformMangedOperationUnits, the outputs of this method aren't
    //normalised (= primarily stored under Value), what is useful in certain contexts.
    //NOTE: this function assumes that both inputs are normalised, what means that no prefix information is expected.
    //It might also be used with non-normalised inputs, but their prefix information would be plainly ignored.
    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        if (firstInfo.Value == 0.0 || secondInfo.Value == 0.0)
        {
            if (operation == Operations.Multiplication || operation == Operations.Division)
            {
                //Dividing by zero scenarios are taken into account somewhere else.
                return new UnitInfo(firstInfo) { Value = 0.0 };
            }
        }

        UnitInfo outInfo = new UnitInfo(firstInfo);
        UnitInfo firstInfo0 = new UnitInfo(firstInfo);
        UnitInfo secondInfo0 = new UnitInfo(secondInfo);

        boolean isWrong = false;
        try
        {
            if (operation == Operations.Addition)
            {
                outInfo.Value += secondInfo0.Value;
            }
            else if (operation == Operations.Subtraction)
            {
                outInfo.Value -= secondInfo.Value;
            }
            else
            {
                //The reason for checking whether BaseTenExponent is inside/outside the int range before performing 
                //the operation (rather than going ahead and eventually catching the resulting exception) isn't just
                //being quicker, but also the only option in many situations. Note that an addition/subtraction between
                //two int variables whose result is outside the int range might not trigger an exception (+ random 
                //negative value as output).
                if (VaryBaseTenExponent(outInfo, secondInfo0.BaseTenExponent, operation == Operations.Division).Error.Type != ErrorTypes.None)
                {
                    return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
                }

                if (operation == Operations.Multiplication)
                {
                    outInfo.Value *= secondInfo.Value;
                    outInfo.BaseTenExponent += secondInfo.BaseTenExponent;
                }
                else if (operation == Operations.Division)
                {
                    if (secondInfo.Value == 0.0)
                    {
                        return
                        (
                            new UnitInfo(outInfo) 
                            { 
                                Error = new ErrorInfo(ErrorTypes.NumericError) 
                            }
                        );
                    }
                    outInfo.Value /= secondInfo.Value;
                    outInfo.BaseTenExponent -= secondInfo.BaseTenExponent;
                }
            }
        }
        catch { isWrong = true; }

        return
        (
            //An error might not be triggered despite of dealing with numbers outside double precision.
            //For example: 0.00000000000000000001m * 0.0000000000000000000001m can output 0.0 without triggering an error. 
            isWrong || ((operation == Operations.Multiplication || operation == Operations.Division) && outInfo.Value == 0.0.0) ?
            OperationValuesManageError(firstInfo0, secondInfo0, operation) : outInfo
        );
    }

    static UnitInfo OperationValuesManageError(UnitInfo outInfo, UnitInfo secondInfo, Operations operation)
    {
        if (operation != Operations.Multiplication && operation != Operations.Division)
        {
            //This condition should never be true on account of the fact that the pre-modifications performed before
            //adding/subtracting should avoid erroneous situations.
            return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
        }

        UnitInfo secondInfo2 = ConvertValueToBaseTen(secondInfo.Value);
        outInfo = VaryBaseTenExponent(outInfo, secondInfo2.BaseTenExponent, operation == Operations.Division);
        if (Math.Abs(secondInfo2.Value) == 1.0 || outInfo.Error.Type != ErrorTypes.None) return outInfo;
        
        try
        {
            outInfo = PerformManagedOperationUnits
            (
                outInfo, secondInfo2.Value, operation
            );
        }
        catch
        {
            //Very unlikely scenario on account of the fact that Math.Abs(secondInfo2.Value)
            //lies within the 0.1-10.0 range.
            outInfo = OperationValuesManageError
            (
                new UnitInfo(outInfo)
                {
                    Value = secondInfo2.Value,
                    BaseTenExponent = 0
                },
                new UnitInfo()
                {
                    Value = outInfo.Value,
                    BaseTenExponent = outInfo.BaseTenExponent
                },
                operation
            );
        }

        return outInfo;
    }

    static UnitInfo ConvertValueToBaseTen(double value)
    {
        value = Math.Abs(value);
        return FromValueToBaseTenExponent
        (
             new UnitInfo(value), Math.Abs(value), false
        );
    }

    static UnitInfo ConvertBaseTenToValue(UnitInfo unitInfo)
    {
        if (unitInfo.BaseTenExponent == 0) return unitInfo;

        UnitInfo outInfo = new UnitInfo(unitInfo);
        boolean decrease = unitInfo.BaseTenExponent > 0;
        int sign = Math.Sign(outInfo.Value);
        double absValue = Math.Abs(outInfo.Value);

        while (outInfo.BaseTenExponent != 0.0)
        {
            if (decrease)
            {
                if (absValue >= MaxValueDec / 10.0) break;
                absValue *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }
            else
            {
                if (absValue <= MinValueDec * 10.0) break;
                absValue /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
        }

        outInfo.Value = sign * absValue;

        return outInfo;
    }

    static UnitInfo NormaliseUnitInfo(UnitInfo unitInfo)
    {
        if (unitInfo.Value == 0 && unitInfo.Prefix.Factor == 1.0)
        {
            return unitInfo;
        }
        UnitInfo outInfo = new UnitInfo(unitInfo);

        if (outInfo.Prefix.Factor != 1)
        {
            outInfo = FromValueToBaseTenExponent
            (
                outInfo, outInfo.Prefix.Factor, true
            );
            outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage);
        }
        if (outInfo.Value == 0.0) return outInfo;

        outInfo = FromValueToBaseTenExponent
        (
            outInfo, outInfo.Value, false
        );

        return outInfo;
    }

    static UnitInfo FromValueToBaseTenExponent(UnitInfo outInfo, double value, boolean isPrefix)
    {
        if (value == 0.0) return outInfo;

        double valueAbs = Math.Abs(value);
        boolean decrease = (valueAbs > 1.0);
        if (!isPrefix)
        {
            outInfo.Value = outInfo.Value / valueAbs;
        }

        while (valueAbs != 1.0)
        {
            if ((valueAbs < 10.0 && valueAbs > 1.0) || (valueAbs > 0.1.0 && valueAbs < 1.0))
            {
                if (!isPrefix) outInfo.Value = value;
                else
                {
                    outInfo = PerformManagedOperationValues
                    (
                        outInfo, value, Operations.Multiplication
                    );
                }

                return outInfo;
            }

            if (decrease)
            {
                value /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
            else
            {
                value *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }

            valueAbs = Math.Abs(value);
        }

        return outInfo;
    }

    //Method used to vary BaseTenExponent without provoking unhandled exceptions (i.e., bigger than Integer.MAX_VALUE).
    static UnitInfo VaryBaseTenExponent(UnitInfo info, int baseTenIncrease, boolean isDivision = false)
    {
        long val1 = info.BaseTenExponent;
        long val2 = baseTenIncrease;

        if (isDivision)
        {
            //Converting a negative value into positive might provoke an overflow error for the int type
            //(e.g., Math.Abs(Integer.MAIN_VALUE)). Converting both variables to long is a quick and effective
            //way to avoid this problem.
            val2 *= -1;
        }

        return
        (
             ((val2 > 0 && val1 > Integer.MAX_VALUE - val2) || (val2 < 0 && val1 < Integer.MAIN_VALUE - val2)) ?
            new UnitInfo(info, ErrorTypes.NumericError) : new UnitInfo(info){{ BaseTenExponent = (int)(val1 + val2); }}
        );
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2017-05-27 19:58:23.419
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2017-05-27 19:58:23.419
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2017-05-27 19:58:23.644
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
public class OperationsManaged
{
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, double second, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            firstInfo, new UnitInfo(second), operation
        );
    }

    public static UnitInfo PerformManagedOperationUnits(double first, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            new UnitInfo(first), secondInfo, operation
        );
    }

    //This method should always be used when dealing with random UnitInfo variables because it accounts for all the
    //possible scenarios. On the other hand, with simple operations (e.g., random UnitInfo & numeric type) it might
    //be better to use PerformManagedOperationValues. 
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        ErrorTypes errorType = InternalMethods.GetOperationError
        (
            firstInfo, secondInfo, operation
        );
        if (errorType != ErrorTypes.None)
        {
            return new UnitInfo(firstInfo) 
            {{
                Error = new ErrorInfo(errorType); 
            }};
        }

        return
        (
            operation == Operations.Addition || operation == Operations.Subtraction ?
            PerformManagedOperationAddition(firstInfo, secondInfo, operation) :
            PerformManagedOperationMultiplication(firstInfo, secondInfo, operation)
        );
    }

    static UnitInfo PerformManagedOperationAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {   
        //After being normalised, the operands might require further modifications.
        UnitInfo[] normalised = GetOperandsAddition(firstInfo, secondInfo, operation);

        return PerformManagedOperationNormalisedValues
        (
            firstInfo, normalised, operation
        );
    }

    static UnitInfo[] GetOperandsAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        UnitInfo[] operands2 = new UnitInfo[] 
        {
            new UnitInfo(firstInfo), new UnitInfo(secondInfo)
        };

        if (operands2[0].BaseTenExponent != operands2[1].BaseTenExponent || operands2[0].Prefix.Factor != operands2[1].Prefix.Factor)
        {
            //The addition/subtraction might not be performed right away even with normalised values.
            //For example: 5 and 6 from 5*10^2 and 6*10^7 cannot be added right away.
            operands2 = AdaptNormalisedValuesForAddition
            (
                new UnitInfo[] 
                { 
                    NormaliseUnitInfo(operands2[0]), 
                    NormaliseUnitInfo(operands2[1])
                },
                operation
            );
        }

        return operands2;
    }
    
    static UnitInfo[] AdaptNormalisedValuesForAddition(UnitInfo[] unitInfos2, Operations operation)
    {
        if (unitInfos2[0].BaseTenExponent == unitInfos2[1].BaseTenExponent)
        {
            //Having the same BaseTenExponent values means that the given operation can be performed right away.
            return unitInfos2;
        }

        int[] bigSmallI = 
        (
            unitInfos2[0].BaseTenExponent > unitInfos2[1].BaseTenExponent ?
            new int[] { 0, 1 } : new int[] { 1, 0 }
        );

        //Only the variable with the bigger value is modified. For example: 5*10^5 & 3*10^3 is converted
        //into 500*10^3 & 3*10^3 in order to allow the addition 500 + 3. 
        UnitInfo big2 = AdaptBiggerAdditionOperand(unitInfos2, bigSmallI, operation);
        if (big2.Error.Type != ErrorTypes.None)
        {
            return TooBigGapAddition(unitInfos2, bigSmallI, operation);
        }

        unitInfos2[bigSmallI[0]].Value = big2.Value;
        unitInfos2[bigSmallI[0]].BaseTenExponent = unitInfos2[bigSmallI[1]].BaseTenExponent;

        return unitInfos2;
    }

    //When adding/subtracting two numbers whose gap is bigger than the maximum double range, there
    //is no need to perform any operation (i.e., no change will be observed because of being outside
    //the maximum supported precision). This method takes care of these cases and returns the expected
    //output (i.e., biggest value).
    static UnitInfo[] TooBigGapAddition(UnitInfo[] unitInfos2, int[] bigSmallI, Operations operation)
    {
        UnitInfo[] outInfos = new UnitInfo[] 
        {
            //First operand (i.e., one whose information defines the operation) together with the
            //numeric information (i.e., just Value and BaseTenExponent because both are normalised)
            //which is associated with the biggest one.
            new UnitInfo(unitInfos2[0])
            {{
                Value = unitInfos2[bigSmallI[0]].Value;
                BaseTenExponent = unitInfos2[bigSmallI[0]].BaseTenExponent;
            }}
        };

        if (operation == Operations.Subtraction && bigSmallI[0] == 1)
        {
            outInfos[0].Value = -1.0 * outInfos[0].Value;
        }

        if (outInfos[0].Unit == Units.Unitless)
        {
            outInfos[0].Unit = unitInfos2[bigSmallI[1]].Unit;
        }

        return outInfos;
    }

    static UnitInfo AdaptBiggerAdditionOperand(UnitInfo[] unitInfos2, int[] bigSmallI, Operations operation)
    {
        int gapExponent = unitInfos2[bigSmallI[0]].BaseTenExponent - unitInfos2[bigSmallI[1]].BaseTenExponent;
        if (gapExponent >= 27)
        {
            //The difference between both inputs is bigger than (or, at least, very close to) the maximum double value/precision;
            //what makes this situation calculation unworthy and the first operand to be returned as the result.
            //Note that the error below these lines is just an easy way to tell the calling function about this eventuality.
            return new UnitInfo(unitInfos2[0]) 
            {{ 
                Error = new ErrorInfo(ErrorTypes.InvalidOperation); 
            }};
        }

        //PerformManagedOperationValues is used to make sure that the resulting numeric information is stored
        //in Value (if possible).
        UnitInfo big2 = PerformManagedOperationValues
        (
            RaiseToIntegerExponent(10.0, gapExponent), unitInfos2[bigSmallI[0]].Value, 
            Operations.Multiplication                
        );

        boolean isWrong = 
        (
            big2.Error.Type != ErrorTypes.None || big2.BaseTenExponent != 0 ?
            
            //The value of the bigger input times 10^(gap between BaseTenExponent of inputs) is too big. 
            isWrong = true :
            
            //Overflow-check very unlikely to trigger an error. In fact, with properly normalised variables,
            //triggering an error would be plainly impossible.               
            AreAdditionFinalValuesWrong
            (
                unitInfos2[0].Value, unitInfos2[1].Value, operation
            )
        );

        if (isWrong)
        {
        	//This error is just an easy way to let the calling function know about the fact that no
            //calculation has been performed (too big gap). This isn't a properly-speaking error and
                    //that's why it will not be notified to the user.
        	return new UnitInfo(unitInfos2[0])
                    {{
                        Error = new ErrorInfo(ErrorTypes.InvalidOperation);
                    }};
        }
        else
        {
            //Returning the new big value. For example: with 5*10^4 & 3*10^2, 500 would be returned.
            return new UnitInfo(unitInfos2[bigSmallI[0]])
            {{
                Value = big2.Value;
            }};
        }

        
        return
        (
            isWrong ?
            //This error is just an easy way to let the calling function know about the fact that no
            //calculation has been performed (too big gap). This isn't a properly-speaking error and
            //that's why it will not be notified to the user.
            new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }} :
            //Returning the new big value. For example: with 5*10^4 & 3*10^2, 500 would be returned.
            new UnitInfo(unitInfos2[bigSmallI[0]])
            {{
                Value = big2.Value;
            }}
        );
    }

    static boolean AreAdditionFinalValuesWrong(double val1, double val2, Operations operation)
    {
        boolean isWrong = false;

        try
        {
            val1 = val1 + val2 *
            (
                operation == Operations.Addition ? 1 : -1
            );
        }
        catch { isWrong = true; }

        return isWrong;
    }

    static UnitInfo PerformManagedOperationMultiplication(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationNormalisedValues
        (
            firstInfo, new UnitInfo[] 
            { 
                NormaliseUnitInfo(firstInfo),
                NormaliseUnitInfo(secondInfo) 
            },
            operation
        );
    }

    public static UnitInfo RaiseToIntegerExponent(double baseValue, int exponent)
    {
        return RaiseToIntegerExponent(new UnitInfo(baseValue), exponent);
    }

    static UnitInfo RaiseToIntegerExponent(UnitInfo baseInfo, int exponent)
    {
        if (exponent <= 1 && exponent >= 0)
        {
            baseInfo.Value = (exponent == 0 ? 1.0 : baseInfo.Value);
            return baseInfo;
        }

        UnitInfo outInfo = new UnitInfo(baseInfo);

        for (int i = 1; i < Math.Abs(exponent); i++)
        {
            outInfo = PerformManagedOperationValues
            (
                outInfo, baseInfo, Operations.Multiplication
            );
            if (outInfo.Error.Type != ErrorTypes.None) return outInfo;
        }

        return
        (
            exponent < 0 ?
            PerformManagedOperationValues(new UnitInfo(1.0), outInfo, Operations.Division) :
            outInfo
        );
    }

    static UnitInfo PerformManagedOperationNormalisedValues(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        outInfo =
        (
            normalisedInfos.Length == 1 ?
            //There is just one operand when the difference between both of them is too big.
            outInfo = normalisedInfos[0] :
            PerformManagedOperationTwoOperands(outInfo, normalisedInfos, operation)
        );

        return outInfo;
    }

    static UnitInfo PerformManagedOperationTwoOperands(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        UnitInfo outInfoNormalised = PerformManagedOperationValues
        (
            normalisedInfos[0], normalisedInfos[1], operation
        );

        if (outInfo.Error.Type != ErrorTypes.None)
        {
            return new UnitInfo(outInfo)
            {
                Error = new ErrorInfo(ErrorTypes.NumericError)
            };
        }

        outInfo.BaseTenExponent = outInfoNormalised.BaseTenExponent;
        outInfo.Value = outInfoNormalised.Value;
        //Normalised means no prefixes.
        outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage); 

        return outInfo;
    }

    static UnitInfo PerformManagedOperationValues(double firstValue, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            new UnitInfo(firstValue), new UnitInfo(secondValue), operation
        );
    }

    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            firstInfo, new UnitInfo(secondValue), operation
        );
    }

    //This method might be used to perform full operations (not just being the last calculation step) instead
    //of the default one (PerformManagedOperationUnits) for simple cases. That is: ones not dealing with the
    //complex numeric reality (Value, Prefix and BaseTenExponent) which makes a pre-analysis required.
    //Note that, unlikely what happens with PerformMangedOperationUnits, the outputs of this method aren't
    //normalised (= primarily stored under Value), what is useful in certain contexts.
    //NOTE: this function assumes that both inputs are normalised, what means that no prefix information is expected.
    //It might also be used with non-normalised inputs, but their prefix information would be plainly ignored.
    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        if (firstInfo.Value == 0.0 || secondInfo.Value == 0.0)
        {
            if (operation == Operations.Multiplication || operation == Operations.Division)
            {
                //Dividing by zero scenarios are taken into account somewhere else.
                return new UnitInfo(firstInfo) { Value = 0.0 };
            }
        }

        UnitInfo outInfo = new UnitInfo(firstInfo);
        UnitInfo firstInfo0 = new UnitInfo(firstInfo);
        UnitInfo secondInfo0 = new UnitInfo(secondInfo);

        boolean isWrong = false;
        try
        {
            if (operation == Operations.Addition)
            {
                outInfo.Value += secondInfo0.Value;
            }
            else if (operation == Operations.Subtraction)
            {
                outInfo.Value -= secondInfo.Value;
            }
            else
            {
                //The reason for checking whether BaseTenExponent is inside/outside the int range before performing 
                //the operation (rather than going ahead and eventually catching the resulting exception) isn't just
                //being quicker, but also the only option in many situations. Note that an addition/subtraction between
                //two int variables whose result is outside the int range might not trigger an exception (+ random 
                //negative value as output).
                if (VaryBaseTenExponent(outInfo, secondInfo0.BaseTenExponent, operation == Operations.Division).Error.Type != ErrorTypes.None)
                {
                    return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
                }

                if (operation == Operations.Multiplication)
                {
                    outInfo.Value *= secondInfo.Value;
                    outInfo.BaseTenExponent += secondInfo.BaseTenExponent;
                }
                else if (operation == Operations.Division)
                {
                    if (secondInfo.Value == 0.0)
                    {
                        return
                        (
                            new UnitInfo(outInfo) 
                            { 
                                Error = new ErrorInfo(ErrorTypes.NumericError) 
                            }
                        );
                    }
                    outInfo.Value /= secondInfo.Value;
                    outInfo.BaseTenExponent -= secondInfo.BaseTenExponent;
                }
            }
        }
        catch { isWrong = true; }

        return
        (
            //An error might not be triggered despite of dealing with numbers outside double precision.
            //For example: 0.00000000000000000001m * 0.0000000000000000000001m can output 0.0 without triggering an error. 
            isWrong || ((operation == Operations.Multiplication || operation == Operations.Division) && outInfo.Value == 0.0.0) ?
            OperationValuesManageError(firstInfo0, secondInfo0, operation) : outInfo
        );
    }

    static UnitInfo OperationValuesManageError(UnitInfo outInfo, UnitInfo secondInfo, Operations operation)
    {
        if (operation != Operations.Multiplication && operation != Operations.Division)
        {
            //This condition should never be true on account of the fact that the pre-modifications performed before
            //adding/subtracting should avoid erroneous situations.
            return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
        }

        UnitInfo secondInfo2 = ConvertValueToBaseTen(secondInfo.Value);
        outInfo = VaryBaseTenExponent(outInfo, secondInfo2.BaseTenExponent, operation == Operations.Division);
        if (Math.Abs(secondInfo2.Value) == 1.0 || outInfo.Error.Type != ErrorTypes.None) return outInfo;
        
        try
        {
            outInfo = PerformManagedOperationUnits
            (
                outInfo, secondInfo2.Value, operation
            );
        }
        catch
        {
            //Very unlikely scenario on account of the fact that Math.Abs(secondInfo2.Value)
            //lies within the 0.1-10.0 range.
            outInfo = OperationValuesManageError
            (
                new UnitInfo(outInfo)
                {
                    Value = secondInfo2.Value,
                    BaseTenExponent = 0
                },
                new UnitInfo()
                {
                    Value = outInfo.Value,
                    BaseTenExponent = outInfo.BaseTenExponent
                },
                operation
            );
        }

        return outInfo;
    }

    static UnitInfo ConvertValueToBaseTen(double value)
    {
        value = Math.Abs(value);
        return FromValueToBaseTenExponent
        (
             new UnitInfo(value), Math.Abs(value), false
        );
    }

    static UnitInfo ConvertBaseTenToValue(UnitInfo unitInfo)
    {
        if (unitInfo.BaseTenExponent == 0) return unitInfo;

        UnitInfo outInfo = new UnitInfo(unitInfo);
        boolean decrease = unitInfo.BaseTenExponent > 0;
        int sign = Math.Sign(outInfo.Value);
        double absValue = Math.Abs(outInfo.Value);

        while (outInfo.BaseTenExponent != 0.0)
        {
            if (decrease)
            {
                if (absValue >= MaxValueDec / 10.0) break;
                absValue *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }
            else
            {
                if (absValue <= MinValueDec * 10.0) break;
                absValue /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
        }

        outInfo.Value = sign * absValue;

        return outInfo;
    }

    static UnitInfo NormaliseUnitInfo(UnitInfo unitInfo)
    {
        if (unitInfo.Value == 0 && unitInfo.Prefix.Factor == 1.0)
        {
            return unitInfo;
        }
        UnitInfo outInfo = new UnitInfo(unitInfo);

        if (outInfo.Prefix.Factor != 1)
        {
            outInfo = FromValueToBaseTenExponent
            (
                outInfo, outInfo.Prefix.Factor, true
            );
            outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage);
        }
        if (outInfo.Value == 0.0) return outInfo;

        outInfo = FromValueToBaseTenExponent
        (
            outInfo, outInfo.Value, false
        );

        return outInfo;
    }

    static UnitInfo FromValueToBaseTenExponent(UnitInfo outInfo, double value, boolean isPrefix)
    {
        if (value == 0.0) return outInfo;

        double valueAbs = Math.Abs(value);
        boolean decrease = (valueAbs > 1.0);
        if (!isPrefix)
        {
            outInfo.Value = outInfo.Value / valueAbs;
        }

        while (valueAbs != 1.0)
        {
            if ((valueAbs < 10.0 && valueAbs > 1.0) || (valueAbs > 0.1.0 && valueAbs < 1.0))
            {
                if (!isPrefix) outInfo.Value = value;
                else
                {
                    outInfo = PerformManagedOperationValues
                    (
                        outInfo, value, Operations.Multiplication
                    );
                }

                return outInfo;
            }

            if (decrease)
            {
                value /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
            else
            {
                value *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }

            valueAbs = Math.Abs(value);
        }

        return outInfo;
    }

    //Method used to vary BaseTenExponent without provoking unhandled exceptions (i.e., bigger than Integer.MAX_VALUE).
    static UnitInfo VaryBaseTenExponent(UnitInfo info, int baseTenIncrease, boolean isDivision = false)
    {
        long val1 = info.BaseTenExponent;
        long val2 = baseTenIncrease;

        if (isDivision)
        {
            //Converting a negative value into positive might provoke an overflow error for the int type
            //(e.g., Math.Abs(Integer.MAIN_VALUE)). Converting both variables to long is a quick and effective
            //way to avoid this problem.
            val2 *= -1;
        }

        return
        (
             ((val2 > 0 && val1 > Integer.MAX_VALUE - val2) || (val2 < 0 && val1 < Integer.MAIN_VALUE - val2)) ?
            new UnitInfo(info, ErrorTypes.NumericError) : new UnitInfo(info){{ BaseTenExponent = (int)(val1 + val2); }}
        );
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 2 2017-05-27 19:58:23.646
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 0 2017-05-27 19:58:23.647
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.core 4 4 2017-05-27 19:58:25.953
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
public class OperationsManaged
{
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, double second, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            firstInfo, new UnitInfo(second), operation
        );
    }

    public static UnitInfo PerformManagedOperationUnits(double first, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            new UnitInfo(first), secondInfo, operation
        );
    }

    //This method should always be used when dealing with random UnitInfo variables because it accounts for all the
    //possible scenarios. On the other hand, with simple operations (e.g., random UnitInfo & numeric type) it might
    //be better to use PerformManagedOperationValues. 
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        ErrorTypes errorType = InternalMethods.GetOperationError
        (
            firstInfo, secondInfo, operation
        );
        if (errorType != ErrorTypes.None)
        {
            return new UnitInfo(firstInfo) 
            {{
                Error = new ErrorInfo(errorType); 
            }};
        }

        return
        (
            operation == Operations.Addition || operation == Operations.Subtraction ?
            PerformManagedOperationAddition(firstInfo, secondInfo, operation) :
            PerformManagedOperationMultiplication(firstInfo, secondInfo, operation)
        );
    }

    static UnitInfo PerformManagedOperationAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {   
        //After being normalised, the operands might require further modifications.
        UnitInfo[] normalised = GetOperandsAddition(firstInfo, secondInfo, operation);

        return PerformManagedOperationNormalisedValues
        (
            firstInfo, normalised, operation
        );
    }

    static UnitInfo[] GetOperandsAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        UnitInfo[] operands2 = new UnitInfo[] 
        {
            new UnitInfo(firstInfo), new UnitInfo(secondInfo)
        };

        if (operands2[0].BaseTenExponent != operands2[1].BaseTenExponent || operands2[0].Prefix.Factor != operands2[1].Prefix.Factor)
        {
            //The addition/subtraction might not be performed right away even with normalised values.
            //For example: 5 and 6 from 5*10^2 and 6*10^7 cannot be added right away.
            operands2 = AdaptNormalisedValuesForAddition
            (
                new UnitInfo[] 
                { 
                    NormaliseUnitInfo(operands2[0]), 
                    NormaliseUnitInfo(operands2[1])
                },
                operation
            );
        }

        return operands2;
    }
    
    static UnitInfo[] AdaptNormalisedValuesForAddition(UnitInfo[] unitInfos2, Operations operation)
    {
        if (unitInfos2[0].BaseTenExponent == unitInfos2[1].BaseTenExponent)
        {
            //Having the same BaseTenExponent values means that the given operation can be performed right away.
            return unitInfos2;
        }

        int[] bigSmallI = 
        (
            unitInfos2[0].BaseTenExponent > unitInfos2[1].BaseTenExponent ?
            new int[] { 0, 1 } : new int[] { 1, 0 }
        );

        //Only the variable with the bigger value is modified. For example: 5*10^5 & 3*10^3 is converted
        //into 500*10^3 & 3*10^3 in order to allow the addition 500 + 3. 
        UnitInfo big2 = AdaptBiggerAdditionOperand(unitInfos2, bigSmallI, operation);
        if (big2.Error.Type != ErrorTypes.None)
        {
            return TooBigGapAddition(unitInfos2, bigSmallI, operation);
        }

        unitInfos2[bigSmallI[0]].Value = big2.Value;
        unitInfos2[bigSmallI[0]].BaseTenExponent = unitInfos2[bigSmallI[1]].BaseTenExponent;

        return unitInfos2;
    }

    //When adding/subtracting two numbers whose gap is bigger than the maximum double range, there
    //is no need to perform any operation (i.e., no change will be observed because of being outside
    //the maximum supported precision). This method takes care of these cases and returns the expected
    //output (i.e., biggest value).
    static UnitInfo[] TooBigGapAddition(UnitInfo[] unitInfos2, int[] bigSmallI, Operations operation)
    {
        UnitInfo[] outInfos = new UnitInfo[] 
        {
            //First operand (i.e., one whose information defines the operation) together with the
            //numeric information (i.e., just Value and BaseTenExponent because both are normalised)
            //which is associated with the biggest one.
            new UnitInfo(unitInfos2[0])
            {{
                Value = unitInfos2[bigSmallI[0]].Value;
                BaseTenExponent = unitInfos2[bigSmallI[0]].BaseTenExponent;
            }}
        };

        if (operation == Operations.Subtraction && bigSmallI[0] == 1)
        {
            outInfos[0].Value = -1.0 * outInfos[0].Value;
        }

        if (outInfos[0].Unit == Units.Unitless)
        {
            outInfos[0].Unit = unitInfos2[bigSmallI[1]].Unit;
        }

        return outInfos;
    }

    static UnitInfo AdaptBiggerAdditionOperand(UnitInfo[] unitInfos2, int[] bigSmallI, Operations operation)
    {
        int gapExponent = unitInfos2[bigSmallI[0]].BaseTenExponent - unitInfos2[bigSmallI[1]].BaseTenExponent;
        if (gapExponent >= 27)
        {
            //The difference between both inputs is bigger than (or, at least, very close to) the maximum double value/precision;
            //what makes this situation calculation unworthy and the first operand to be returned as the result.
            //Note that the error below these lines is just an easy way to tell the calling function about this eventuality.
            return new UnitInfo(unitInfos2[0]) 
            {{ 
                Error = new ErrorInfo(ErrorTypes.InvalidOperation); 
            }};
        }

        //PerformManagedOperationValues is used to make sure that the resulting numeric information is stored
        //in Value (if possible).
        UnitInfo big2 = PerformManagedOperationValues
        (
            RaiseToIntegerExponent(10.0, gapExponent), unitInfos2[bigSmallI[0]].Value, 
            Operations.Multiplication                
        );

        boolean isWrong = 
        (
            big2.Error.Type != ErrorTypes.None || big2.BaseTenExponent != 0 ?
            
            //The value of the bigger input times 10^(gap between BaseTenExponent of inputs) is too big. 
            isWrong = true :
            
            //Overflow-check very unlikely to trigger an error. In fact, with properly normalised variables,
            //triggering an error would be plainly impossible.               
            AreAdditionFinalValuesWrong
            (
                unitInfos2[0].Value, unitInfos2[1].Value, operation
            )
        );

        if (isWrong)
        {
        	//This error is just an easy way to let the calling function know about the fact that no
            //calculation has been performed (too big gap). This isn't a properly-speaking error and
            //that's why it will not be notified to the user.
        	return new UnitInfo(unitInfos2[0])
                    {{
                        Error = new ErrorInfo(ErrorTypes.InvalidOperation);
                    }};
        }
        else
        {
            //Returning the new big value. For example: with 5*10^4 & 3*10^2, 500 would be returned.
            return new UnitInfo(unitInfos2[bigSmallI[0]])
            {{
                Value = big2.Value;
            }};
        }

        
        return
        (
            isWrong ?
            //This error is just an easy way to let the calling function know about the fact that no
            //calculation has been performed (too big gap). This isn't a properly-speaking error and
            //that's why it will not be notified to the user.
            new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }} :
            //Returning the new big value. For example: with 5*10^4 & 3*10^2, 500 would be returned.
            new UnitInfo(unitInfos2[bigSmallI[0]])
            {{
                Value = big2.Value;
            }}
        );
    }

    static boolean AreAdditionFinalValuesWrong(double val1, double val2, Operations operation)
    {
        boolean isWrong = false;

        try
        {
            val1 = val1 + val2 *
            (
                operation == Operations.Addition ? 1 : -1
            );
        }
        catch { isWrong = true; }

        return isWrong;
    }

    static UnitInfo PerformManagedOperationMultiplication(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationNormalisedValues
        (
            firstInfo, new UnitInfo[] 
            { 
                NormaliseUnitInfo(firstInfo),
                NormaliseUnitInfo(secondInfo) 
            },
            operation
        );
    }

    public static UnitInfo RaiseToIntegerExponent(double baseValue, int exponent)
    {
        return RaiseToIntegerExponent(new UnitInfo(baseValue), exponent);
    }

    static UnitInfo RaiseToIntegerExponent(UnitInfo baseInfo, int exponent)
    {
        if (exponent <= 1 && exponent >= 0)
        {
            baseInfo.Value = (exponent == 0 ? 1.0 : baseInfo.Value);
            return baseInfo;
        }

        UnitInfo outInfo = new UnitInfo(baseInfo);

        for (int i = 1; i < Math.Abs(exponent); i++)
        {
            outInfo = PerformManagedOperationValues
            (
                outInfo, baseInfo, Operations.Multiplication
            );
            if (outInfo.Error.Type != ErrorTypes.None) return outInfo;
        }

        return
        (
            exponent < 0 ?
            PerformManagedOperationValues(new UnitInfo(1.0), outInfo, Operations.Division) :
            outInfo
        );
    }

    static UnitInfo PerformManagedOperationNormalisedValues(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        outInfo =
        (
            normalisedInfos.Length == 1 ?
            //There is just one operand when the difference between both of them is too big.
            outInfo = normalisedInfos[0] :
            PerformManagedOperationTwoOperands(outInfo, normalisedInfos, operation)
        );

        return outInfo;
    }

    static UnitInfo PerformManagedOperationTwoOperands(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        UnitInfo outInfoNormalised = PerformManagedOperationValues
        (
            normalisedInfos[0], normalisedInfos[1], operation
        );

        if (outInfo.Error.Type != ErrorTypes.None)
        {
            return new UnitInfo(outInfo)
            {
                Error = new ErrorInfo(ErrorTypes.NumericError)
            };
        }

        outInfo.BaseTenExponent = outInfoNormalised.BaseTenExponent;
        outInfo.Value = outInfoNormalised.Value;
        //Normalised means no prefixes.
        outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage); 

        return outInfo;
    }

    static UnitInfo PerformManagedOperationValues(double firstValue, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            new UnitInfo(firstValue), new UnitInfo(secondValue), operation
        );
    }

    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            firstInfo, new UnitInfo(secondValue), operation
        );
    }

    //This method might be used to perform full operations (not just being the last calculation step) instead
    //of the default one (PerformManagedOperationUnits) for simple cases. That is: ones not dealing with the
    //complex numeric reality (Value, Prefix and BaseTenExponent) which makes a pre-analysis required.
    //Note that, unlikely what happens with PerformMangedOperationUnits, the outputs of this method aren't
    //normalised (= primarily stored under Value), what is useful in certain contexts.
    //NOTE: this function assumes that both inputs are normalised, what means that no prefix information is expected.
    //It might also be used with non-normalised inputs, but their prefix information would be plainly ignored.
    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        if (firstInfo.Value == 0.0 || secondInfo.Value == 0.0)
        {
            if (operation == Operations.Multiplication || operation == Operations.Division)
            {
                //Dividing by zero scenarios are taken into account somewhere else.
                return new UnitInfo(firstInfo) { Value = 0.0 };
            }
        }

        UnitInfo outInfo = new UnitInfo(firstInfo);
        UnitInfo firstInfo0 = new UnitInfo(firstInfo);
        UnitInfo secondInfo0 = new UnitInfo(secondInfo);

        boolean isWrong = false;
        try
        {
            if (operation == Operations.Addition)
            {
                outInfo.Value += secondInfo0.Value;
            }
            else if (operation == Operations.Subtraction)
            {
                outInfo.Value -= secondInfo.Value;
            }
            else
            {
                //The reason for checking whether BaseTenExponent is inside/outside the int range before performing 
                //the operation (rather than going ahead and eventually catching the resulting exception) isn't just
                //being quicker, but also the only option in many situations. Note that an addition/subtraction between
                //two int variables whose result is outside the int range might not trigger an exception (+ random 
                //negative value as output).
                if (VaryBaseTenExponent(outInfo, secondInfo0.BaseTenExponent, operation == Operations.Division).Error.Type != ErrorTypes.None)
                {
                    return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
                }

                if (operation == Operations.Multiplication)
                {
                    outInfo.Value *= secondInfo.Value;
                    outInfo.BaseTenExponent += secondInfo.BaseTenExponent;
                }
                else if (operation == Operations.Division)
                {
                    if (secondInfo.Value == 0.0)
                    {
                        return
                        (
                            new UnitInfo(outInfo) 
                            { 
                                Error = new ErrorInfo(ErrorTypes.NumericError) 
                            }
                        );
                    }
                    outInfo.Value /= secondInfo.Value;
                    outInfo.BaseTenExponent -= secondInfo.BaseTenExponent;
                }
            }
        }
        catch { isWrong = true; }

        return
        (
            //An error might not be triggered despite of dealing with numbers outside double precision.
            //For example: 0.00000000000000000001m * 0.0000000000000000000001m can output 0.0 without triggering an error. 
            isWrong || ((operation == Operations.Multiplication || operation == Operations.Division) && outInfo.Value == 0.0.0) ?
            OperationValuesManageError(firstInfo0, secondInfo0, operation) : outInfo
        );
    }

    static UnitInfo OperationValuesManageError(UnitInfo outInfo, UnitInfo secondInfo, Operations operation)
    {
        if (operation != Operations.Multiplication && operation != Operations.Division)
        {
            //This condition should never be true on account of the fact that the pre-modifications performed before
            //adding/subtracting should avoid erroneous situations.
            return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
        }

        UnitInfo secondInfo2 = ConvertValueToBaseTen(secondInfo.Value);
        outInfo = VaryBaseTenExponent(outInfo, secondInfo2.BaseTenExponent, operation == Operations.Division);
        if (Math.Abs(secondInfo2.Value) == 1.0 || outInfo.Error.Type != ErrorTypes.None) return outInfo;
        
        try
        {
            outInfo = PerformManagedOperationUnits
            (
                outInfo, secondInfo2.Value, operation
            );
        }
        catch
        {
            //Very unlikely scenario on account of the fact that Math.Abs(secondInfo2.Value)
            //lies within the 0.1-10.0 range.
            outInfo = OperationValuesManageError
            (
                new UnitInfo(outInfo)
                {
                    Value = secondInfo2.Value,
                    BaseTenExponent = 0
                },
                new UnitInfo()
                {
                    Value = outInfo.Value,
                    BaseTenExponent = outInfo.BaseTenExponent
                },
                operation
            );
        }

        return outInfo;
    }

    static UnitInfo ConvertValueToBaseTen(double value)
    {
        value = Math.Abs(value);
        return FromValueToBaseTenExponent
        (
             new UnitInfo(value), Math.Abs(value), false
        );
    }

    static UnitInfo ConvertBaseTenToValue(UnitInfo unitInfo)
    {
        if (unitInfo.BaseTenExponent == 0) return unitInfo;

        UnitInfo outInfo = new UnitInfo(unitInfo);
        boolean decrease = unitInfo.BaseTenExponent > 0;
        int sign = Math.Sign(outInfo.Value);
        double absValue = Math.Abs(outInfo.Value);

        while (outInfo.BaseTenExponent != 0.0)
        {
            if (decrease)
            {
                if (absValue >= MaxValueDec / 10.0) break;
                absValue *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }
            else
            {
                if (absValue <= MinValueDec * 10.0) break;
                absValue /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
        }

        outInfo.Value = sign * absValue;

        return outInfo;
    }

    static UnitInfo NormaliseUnitInfo(UnitInfo unitInfo)
    {
        if (unitInfo.Value == 0 && unitInfo.Prefix.Factor == 1.0)
        {
            return unitInfo;
        }
        UnitInfo outInfo = new UnitInfo(unitInfo);

        if (outInfo.Prefix.Factor != 1)
        {
            outInfo = FromValueToBaseTenExponent
            (
                outInfo, outInfo.Prefix.Factor, true
            );
            outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage);
        }
        if (outInfo.Value == 0.0) return outInfo;

        outInfo = FromValueToBaseTenExponent
        (
            outInfo, outInfo.Value, false
        );

        return outInfo;
    }

    static UnitInfo FromValueToBaseTenExponent(UnitInfo outInfo, double value, boolean isPrefix)
    {
        if (value == 0.0) return outInfo;

        double valueAbs = Math.Abs(value);
        boolean decrease = (valueAbs > 1.0);
        if (!isPrefix)
        {
            outInfo.Value = outInfo.Value / valueAbs;
        }

        while (valueAbs != 1.0)
        {
            if ((valueAbs < 10.0 && valueAbs > 1.0) || (valueAbs > 0.1.0 && valueAbs < 1.0))
            {
                if (!isPrefix) outInfo.Value = value;
                else
                {
                    outInfo = PerformManagedOperationValues
                    (
                        outInfo, value, Operations.Multiplication
                    );
                }

                return outInfo;
            }

            if (decrease)
            {
                value /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
            else
            {
                value *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }

            valueAbs = Math.Abs(value);
        }

        return outInfo;
    }

    //Method used to vary BaseTenExponent without provoking unhandled exceptions (i.e., bigger than Integer.MAX_VALUE).
    static UnitInfo VaryBaseTenExponent(UnitInfo info, int baseTenIncrease, boolean isDivision = false)
    {
        long val1 = info.BaseTenExponent;
        long val2 = baseTenIncrease;

        if (isDivision)
        {
            //Converting a negative value into positive might provoke an overflow error for the int type
            //(e.g., Math.Abs(Integer.MAIN_VALUE)). Converting both variables to long is a quick and effective
            //way to avoid this problem.
            val2 *= -1;
        }

        return
        (
             ((val2 > 0 && val1 > Integer.MAX_VALUE - val2) || (val2 < 0 && val1 < Integer.MAIN_VALUE - val2)) ?
            new UnitInfo(info, ErrorTypes.NumericError) : new UnitInfo(info){{ BaseTenExponent = (int)(val1 + val2); }}
        );
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2017-05-27 19:58:25.955
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2017-05-27 19:58:25.955
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2017-05-27 19:58:28.488
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
public class OperationsManaged
{
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, double second, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            firstInfo, new UnitInfo(second), operation
        );
    }

    public static UnitInfo PerformManagedOperationUnits(double first, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            new UnitInfo(first), secondInfo, operation
        );
    }

    //This method should always be used when dealing with random UnitInfo variables because it accounts for all the
    //possible scenarios. On the other hand, with simple operations (e.g., random UnitInfo & numeric type) it might
    //be better to use PerformManagedOperationValues. 
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        ErrorTypes errorType = InternalMethods.GetOperationError
        (
            firstInfo, secondInfo, operation
        );
        if (errorType != ErrorTypes.None)
        {
            return new UnitInfo(firstInfo) 
            {{
                Error = new ErrorInfo(errorType); 
            }};
        }

        return
        (
            operation == Operations.Addition || operation == Operations.Subtraction ?
            PerformManagedOperationAddition(firstInfo, secondInfo, operation) :
            PerformManagedOperationMultiplication(firstInfo, secondInfo, operation)
        );
    }

    static UnitInfo PerformManagedOperationAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {   
        //After being normalised, the operands might require further modifications.
        UnitInfo[] normalised = GetOperandsAddition(firstInfo, secondInfo, operation);

        return PerformManagedOperationNormalisedValues
        (
            firstInfo, normalised, operation
        );
    }

    static UnitInfo[] GetOperandsAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        UnitInfo[] operands2 = new UnitInfo[] 
        {
            new UnitInfo(firstInfo), new UnitInfo(secondInfo)
        };

        if (operands2[0].BaseTenExponent != operands2[1].BaseTenExponent || operands2[0].Prefix.Factor != operands2[1].Prefix.Factor)
        {
            //The addition/subtraction might not be performed right away even with normalised values.
            //For example: 5 and 6 from 5*10^2 and 6*10^7 cannot be added right away.
            operands2 = AdaptNormalisedValuesForAddition
            (
                new UnitInfo[] 
                { 
                    NormaliseUnitInfo(operands2[0]), 
                    NormaliseUnitInfo(operands2[1])
                },
                operation
            );
        }

        return operands2;
    }
    
    static UnitInfo[] AdaptNormalisedValuesForAddition(UnitInfo[] unitInfos2, Operations operation)
    {
        if (unitInfos2[0].BaseTenExponent == unitInfos2[1].BaseTenExponent)
        {
            //Having the same BaseTenExponent values means that the given operation can be performed right away.
            return unitInfos2;
        }

        int[] bigSmallI = 
        (
            unitInfos2[0].BaseTenExponent > unitInfos2[1].BaseTenExponent ?
            new int[] { 0, 1 } : new int[] { 1, 0 }
        );

        //Only the variable with the bigger value is modified. For example: 5*10^5 & 3*10^3 is converted
        //into 500*10^3 & 3*10^3 in order to allow the addition 500 + 3. 
        UnitInfo big2 = AdaptBiggerAdditionOperand(unitInfos2, bigSmallI, operation);
        if (big2.Error.Type != ErrorTypes.None)
        {
            return TooBigGapAddition(unitInfos2, bigSmallI, operation);
        }

        unitInfos2[bigSmallI[0]].Value = big2.Value;
        unitInfos2[bigSmallI[0]].BaseTenExponent = unitInfos2[bigSmallI[1]].BaseTenExponent;

        return unitInfos2;
    }

    //When adding/subtracting two numbers whose gap is bigger than the maximum double range, there
    //is no need to perform any operation (i.e., no change will be observed because of being outside
    //the maximum supported precision). This method takes care of these cases and returns the expected
    //output (i.e., biggest value).
    static UnitInfo[] TooBigGapAddition(UnitInfo[] unitInfos2, int[] bigSmallI, Operations operation)
    {
        UnitInfo[] outInfos = new UnitInfo[] 
        {
            //First operand (i.e., one whose information defines the operation) together with the
            //numeric information (i.e., just Value and BaseTenExponent because both are normalised)
            //which is associated with the biggest one.
            new UnitInfo(unitInfos2[0])
            {{
                Value = unitInfos2[bigSmallI[0]].Value;
                BaseTenExponent = unitInfos2[bigSmallI[0]].BaseTenExponent;
            }}
        };

        if (operation == Operations.Subtraction && bigSmallI[0] == 1)
        {
            outInfos[0].Value = -1.0 * outInfos[0].Value;
        }

        if (outInfos[0].Unit == Units.Unitless)
        {
            outInfos[0].Unit = unitInfos2[bigSmallI[1]].Unit;
        }

        return outInfos;
    }

    static UnitInfo AdaptBiggerAdditionOperand(UnitInfo[] unitInfos2, int[] bigSmallI, Operations operation)
    {
        int gapExponent = unitInfos2[bigSmallI[0]].BaseTenExponent - unitInfos2[bigSmallI[1]].BaseTenExponent;
        if (gapExponent >= 27)
        {
            //The difference between both inputs is bigger than (or, at least, very close to) the maximum double value/precision;
            //what makes this situation calculation unworthy and the first operand to be returned as the result.
            //Note that the error below these lines is just an easy way to tell the calling function about this eventuality.
            return new UnitInfo(unitInfos2[0]) 
            {{ 
                Error = new ErrorInfo(ErrorTypes.InvalidOperation); 
            }};
        }

        //PerformManagedOperationValues is used to make sure that the resulting numeric information is stored
        //in Value (if possible).
        UnitInfo big2 = PerformManagedOperationValues
        (
            RaiseToIntegerExponent(10.0, gapExponent), unitInfos2[bigSmallI[0]].Value, 
            Operations.Multiplication                
        );

        boolean isWrong = 
        (
            big2.Error.Type != ErrorTypes.None || big2.BaseTenExponent != 0 ?
            
            //The value of the bigger input times 10^(gap between BaseTenExponent of inputs) is too big. 
            isWrong = true :
            
            //Overflow-check very unlikely to trigger an error. In fact, with properly normalised variables,
            //triggering an error would be plainly impossible.               
            AreAdditionFinalValuesWrong
            (
                unitInfos2[0].Value, unitInfos2[1].Value, operation
            )
        );

        if (isWrong)
        {
        	//This error is just an easy way to let the calling function know about the fact that no
            //calculation has been performed (too big gap). This isn't a properly-speaking error and
            //that's why it will not be notified to the user.
        	return new UnitInfo(unitInfos2[0])
            {{
                        Error = new ErrorInfo(ErrorTypes.InvalidOperation);
                    }};
        }
        else
        {
            //Returning the new big value. For example: with 5*10^4 & 3*10^2, 500 would be returned.
            return new UnitInfo(unitInfos2[bigSmallI[0]])
            {{
                Value = big2.Value;
            }};
        }

        
        return
        (
            isWrong ?
            //This error is just an easy way to let the calling function know about the fact that no
            //calculation has been performed (too big gap). This isn't a properly-speaking error and
            //that's why it will not be notified to the user.
            new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }} :
            //Returning the new big value. For example: with 5*10^4 & 3*10^2, 500 would be returned.
            new UnitInfo(unitInfos2[bigSmallI[0]])
            {{
                Value = big2.Value;
            }}
        );
    }

    static boolean AreAdditionFinalValuesWrong(double val1, double val2, Operations operation)
    {
        boolean isWrong = false;

        try
        {
            val1 = val1 + val2 *
            (
                operation == Operations.Addition ? 1 : -1
            );
        }
        catch { isWrong = true; }

        return isWrong;
    }

    static UnitInfo PerformManagedOperationMultiplication(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationNormalisedValues
        (
            firstInfo, new UnitInfo[] 
            { 
                NormaliseUnitInfo(firstInfo),
                NormaliseUnitInfo(secondInfo) 
            },
            operation
        );
    }

    public static UnitInfo RaiseToIntegerExponent(double baseValue, int exponent)
    {
        return RaiseToIntegerExponent(new UnitInfo(baseValue), exponent);
    }

    static UnitInfo RaiseToIntegerExponent(UnitInfo baseInfo, int exponent)
    {
        if (exponent <= 1 && exponent >= 0)
        {
            baseInfo.Value = (exponent == 0 ? 1.0 : baseInfo.Value);
            return baseInfo;
        }

        UnitInfo outInfo = new UnitInfo(baseInfo);

        for (int i = 1; i < Math.Abs(exponent); i++)
        {
            outInfo = PerformManagedOperationValues
            (
                outInfo, baseInfo, Operations.Multiplication
            );
            if (outInfo.Error.Type != ErrorTypes.None) return outInfo;
        }

        return
        (
            exponent < 0 ?
            PerformManagedOperationValues(new UnitInfo(1.0), outInfo, Operations.Division) :
            outInfo
        );
    }

    static UnitInfo PerformManagedOperationNormalisedValues(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        outInfo =
        (
            normalisedInfos.Length == 1 ?
            //There is just one operand when the difference between both of them is too big.
            outInfo = normalisedInfos[0] :
            PerformManagedOperationTwoOperands(outInfo, normalisedInfos, operation)
        );

        return outInfo;
    }

    static UnitInfo PerformManagedOperationTwoOperands(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        UnitInfo outInfoNormalised = PerformManagedOperationValues
        (
            normalisedInfos[0], normalisedInfos[1], operation
        );

        if (outInfo.Error.Type != ErrorTypes.None)
        {
            return new UnitInfo(outInfo)
            {
                Error = new ErrorInfo(ErrorTypes.NumericError)
            };
        }

        outInfo.BaseTenExponent = outInfoNormalised.BaseTenExponent;
        outInfo.Value = outInfoNormalised.Value;
        //Normalised means no prefixes.
        outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage); 

        return outInfo;
    }

    static UnitInfo PerformManagedOperationValues(double firstValue, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            new UnitInfo(firstValue), new UnitInfo(secondValue), operation
        );
    }

    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            firstInfo, new UnitInfo(secondValue), operation
        );
    }

    //This method might be used to perform full operations (not just being the last calculation step) instead
    //of the default one (PerformManagedOperationUnits) for simple cases. That is: ones not dealing with the
    //complex numeric reality (Value, Prefix and BaseTenExponent) which makes a pre-analysis required.
    //Note that, unlikely what happens with PerformMangedOperationUnits, the outputs of this method aren't
    //normalised (= primarily stored under Value), what is useful in certain contexts.
    //NOTE: this function assumes that both inputs are normalised, what means that no prefix information is expected.
    //It might also be used with non-normalised inputs, but their prefix information would be plainly ignored.
    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        if (firstInfo.Value == 0.0 || secondInfo.Value == 0.0)
        {
            if (operation == Operations.Multiplication || operation == Operations.Division)
            {
                //Dividing by zero scenarios are taken into account somewhere else.
                return new UnitInfo(firstInfo) { Value = 0.0 };
            }
        }

        UnitInfo outInfo = new UnitInfo(firstInfo);
        UnitInfo firstInfo0 = new UnitInfo(firstInfo);
        UnitInfo secondInfo0 = new UnitInfo(secondInfo);

        boolean isWrong = false;
        try
        {
            if (operation == Operations.Addition)
            {
                outInfo.Value += secondInfo0.Value;
            }
            else if (operation == Operations.Subtraction)
            {
                outInfo.Value -= secondInfo.Value;
            }
            else
            {
                //The reason for checking whether BaseTenExponent is inside/outside the int range before performing 
                //the operation (rather than going ahead and eventually catching the resulting exception) isn't just
                //being quicker, but also the only option in many situations. Note that an addition/subtraction between
                //two int variables whose result is outside the int range might not trigger an exception (+ random 
                //negative value as output).
                if (VaryBaseTenExponent(outInfo, secondInfo0.BaseTenExponent, operation == Operations.Division).Error.Type != ErrorTypes.None)
                {
                    return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
                }

                if (operation == Operations.Multiplication)
                {
                    outInfo.Value *= secondInfo.Value;
                    outInfo.BaseTenExponent += secondInfo.BaseTenExponent;
                }
                else if (operation == Operations.Division)
                {
                    if (secondInfo.Value == 0.0)
                    {
                        return
                        (
                            new UnitInfo(outInfo) 
                            { 
                                Error = new ErrorInfo(ErrorTypes.NumericError) 
                            }
                        );
                    }
                    outInfo.Value /= secondInfo.Value;
                    outInfo.BaseTenExponent -= secondInfo.BaseTenExponent;
                }
            }
        }
        catch { isWrong = true; }

        return
        (
            //An error might not be triggered despite of dealing with numbers outside double precision.
            //For example: 0.00000000000000000001m * 0.0000000000000000000001m can output 0.0 without triggering an error. 
            isWrong || ((operation == Operations.Multiplication || operation == Operations.Division) && outInfo.Value == 0.0.0) ?
            OperationValuesManageError(firstInfo0, secondInfo0, operation) : outInfo
        );
    }

    static UnitInfo OperationValuesManageError(UnitInfo outInfo, UnitInfo secondInfo, Operations operation)
    {
        if (operation != Operations.Multiplication && operation != Operations.Division)
        {
            //This condition should never be true on account of the fact that the pre-modifications performed before
            //adding/subtracting should avoid erroneous situations.
            return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
        }

        UnitInfo secondInfo2 = ConvertValueToBaseTen(secondInfo.Value);
        outInfo = VaryBaseTenExponent(outInfo, secondInfo2.BaseTenExponent, operation == Operations.Division);
        if (Math.Abs(secondInfo2.Value) == 1.0 || outInfo.Error.Type != ErrorTypes.None) return outInfo;
        
        try
        {
            outInfo = PerformManagedOperationUnits
            (
                outInfo, secondInfo2.Value, operation
            );
        }
        catch
        {
            //Very unlikely scenario on account of the fact that Math.Abs(secondInfo2.Value)
            //lies within the 0.1-10.0 range.
            outInfo = OperationValuesManageError
            (
                new UnitInfo(outInfo)
                {
                    Value = secondInfo2.Value,
                    BaseTenExponent = 0
                },
                new UnitInfo()
                {
                    Value = outInfo.Value,
                    BaseTenExponent = outInfo.BaseTenExponent
                },
                operation
            );
        }

        return outInfo;
    }

    static UnitInfo ConvertValueToBaseTen(double value)
    {
        value = Math.Abs(value);
        return FromValueToBaseTenExponent
        (
             new UnitInfo(value), Math.Abs(value), false
        );
    }

    static UnitInfo ConvertBaseTenToValue(UnitInfo unitInfo)
    {
        if (unitInfo.BaseTenExponent == 0) return unitInfo;

        UnitInfo outInfo = new UnitInfo(unitInfo);
        boolean decrease = unitInfo.BaseTenExponent > 0;
        int sign = Math.Sign(outInfo.Value);
        double absValue = Math.Abs(outInfo.Value);

        while (outInfo.BaseTenExponent != 0.0)
        {
            if (decrease)
            {
                if (absValue >= MaxValueDec / 10.0) break;
                absValue *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }
            else
            {
                if (absValue <= MinValueDec * 10.0) break;
                absValue /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
        }

        outInfo.Value = sign * absValue;

        return outInfo;
    }

    static UnitInfo NormaliseUnitInfo(UnitInfo unitInfo)
    {
        if (unitInfo.Value == 0 && unitInfo.Prefix.Factor == 1.0)
        {
            return unitInfo;
        }
        UnitInfo outInfo = new UnitInfo(unitInfo);

        if (outInfo.Prefix.Factor != 1)
        {
            outInfo = FromValueToBaseTenExponent
            (
                outInfo, outInfo.Prefix.Factor, true
            );
            outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage);
        }
        if (outInfo.Value == 0.0) return outInfo;

        outInfo = FromValueToBaseTenExponent
        (
            outInfo, outInfo.Value, false
        );

        return outInfo;
    }

    static UnitInfo FromValueToBaseTenExponent(UnitInfo outInfo, double value, boolean isPrefix)
    {
        if (value == 0.0) return outInfo;

        double valueAbs = Math.Abs(value);
        boolean decrease = (valueAbs > 1.0);
        if (!isPrefix)
        {
            outInfo.Value = outInfo.Value / valueAbs;
        }

        while (valueAbs != 1.0)
        {
            if ((valueAbs < 10.0 && valueAbs > 1.0) || (valueAbs > 0.1.0 && valueAbs < 1.0))
            {
                if (!isPrefix) outInfo.Value = value;
                else
                {
                    outInfo = PerformManagedOperationValues
                    (
                        outInfo, value, Operations.Multiplication
                    );
                }

                return outInfo;
            }

            if (decrease)
            {
                value /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
            else
            {
                value *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }

            valueAbs = Math.Abs(value);
        }

        return outInfo;
    }

    //Method used to vary BaseTenExponent without provoking unhandled exceptions (i.e., bigger than Integer.MAX_VALUE).
    static UnitInfo VaryBaseTenExponent(UnitInfo info, int baseTenIncrease, boolean isDivision = false)
    {
        long val1 = info.BaseTenExponent;
        long val2 = baseTenIncrease;

        if (isDivision)
        {
            //Converting a negative value into positive might provoke an overflow error for the int type
            //(e.g., Math.Abs(Integer.MAIN_VALUE)). Converting both variables to long is a quick and effective
            //way to avoid this problem.
            val2 *= -1;
        }

        return
        (
             ((val2 > 0 && val1 > Integer.MAX_VALUE - val2) || (val2 < 0 && val1 < Integer.MAIN_VALUE - val2)) ?
            new UnitInfo(info, ErrorTypes.NumericError) : new UnitInfo(info){{ BaseTenExponent = (int)(val1 + val2); }}
        );
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2017-05-27 19:58:28.489
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2017-05-27 19:58:28.490
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2017-05-27 19:58:32.025
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
public class OperationsManaged
{
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, double second, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            firstInfo, new UnitInfo(second), operation
        );
    }

    public static UnitInfo PerformManagedOperationUnits(double first, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            new UnitInfo(first), secondInfo, operation
        );
    }

    //This method should always be used when dealing with random UnitInfo variables because it accounts for all the
    //possible scenarios. On the other hand, with simple operations (e.g., random UnitInfo & numeric type) it might
    //be better to use PerformManagedOperationValues. 
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        ErrorTypes errorType = InternalMethods.GetOperationError
        (
            firstInfo, secondInfo, operation
        );
        if (errorType != ErrorTypes.None)
        {
            return new UnitInfo(firstInfo) 
            {{
                Error = new ErrorInfo(errorType); 
            }};
        }

        return
        (
            operation == Operations.Addition || operation == Operations.Subtraction ?
            PerformManagedOperationAddition(firstInfo, secondInfo, operation) :
            PerformManagedOperationMultiplication(firstInfo, secondInfo, operation)
        );
    }

    static UnitInfo PerformManagedOperationAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {   
        //After being normalised, the operands might require further modifications.
        UnitInfo[] normalised = GetOperandsAddition(firstInfo, secondInfo, operation);

        return PerformManagedOperationNormalisedValues
        (
            firstInfo, normalised, operation
        );
    }

    static UnitInfo[] GetOperandsAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        UnitInfo[] operands2 = new UnitInfo[] 
        {
            new UnitInfo(firstInfo), new UnitInfo(secondInfo)
        };

        if (operands2[0].BaseTenExponent != operands2[1].BaseTenExponent || operands2[0].Prefix.Factor != operands2[1].Prefix.Factor)
        {
            //The addition/subtraction might not be performed right away even with normalised values.
            //For example: 5 and 6 from 5*10^2 and 6*10^7 cannot be added right away.
            operands2 = AdaptNormalisedValuesForAddition
            (
                new UnitInfo[] 
                { 
                    NormaliseUnitInfo(operands2[0]), 
                    NormaliseUnitInfo(operands2[1])
                },
                operation
            );
        }

        return operands2;
    }
    
    static UnitInfo[] AdaptNormalisedValuesForAddition(UnitInfo[] unitInfos2, Operations operation)
    {
        if (unitInfos2[0].BaseTenExponent == unitInfos2[1].BaseTenExponent)
        {
            //Having the same BaseTenExponent values means that the given operation can be performed right away.
            return unitInfos2;
        }

        int[] bigSmallI = 
        (
            unitInfos2[0].BaseTenExponent > unitInfos2[1].BaseTenExponent ?
            new int[] { 0, 1 } : new int[] { 1, 0 }
        );

        //Only the variable with the bigger value is modified. For example: 5*10^5 & 3*10^3 is converted
        //into 500*10^3 & 3*10^3 in order to allow the addition 500 + 3. 
        UnitInfo big2 = AdaptBiggerAdditionOperand(unitInfos2, bigSmallI, operation);
        if (big2.Error.Type != ErrorTypes.None)
        {
            return TooBigGapAddition(unitInfos2, bigSmallI, operation);
        }

        unitInfos2[bigSmallI[0]].Value = big2.Value;
        unitInfos2[bigSmallI[0]].BaseTenExponent = unitInfos2[bigSmallI[1]].BaseTenExponent;

        return unitInfos2;
    }

    //When adding/subtracting two numbers whose gap is bigger than the maximum double range, there
    //is no need to perform any operation (i.e., no change will be observed because of being outside
    //the maximum supported precision). This method takes care of these cases and returns the expected
    //output (i.e., biggest value).
    static UnitInfo[] TooBigGapAddition(UnitInfo[] unitInfos2, int[] bigSmallI, Operations operation)
    {
        UnitInfo[] outInfos = new UnitInfo[] 
        {
            //First operand (i.e., one whose information defines the operation) together with the
            //numeric information (i.e., just Value and BaseTenExponent because both are normalised)
            //which is associated with the biggest one.
            new UnitInfo(unitInfos2[0])
            {{
                Value = unitInfos2[bigSmallI[0]].Value;
                BaseTenExponent = unitInfos2[bigSmallI[0]].BaseTenExponent;
            }}
        };

        if (operation == Operations.Subtraction && bigSmallI[0] == 1)
        {
            outInfos[0].Value = -1.0 * outInfos[0].Value;
        }

        if (outInfos[0].Unit == Units.Unitless)
        {
            outInfos[0].Unit = unitInfos2[bigSmallI[1]].Unit;
        }

        return outInfos;
    }

    static UnitInfo AdaptBiggerAdditionOperand(UnitInfo[] unitInfos2, int[] bigSmallI, Operations operation)
    {
        int gapExponent = unitInfos2[bigSmallI[0]].BaseTenExponent - unitInfos2[bigSmallI[1]].BaseTenExponent;
        if (gapExponent >= 27)
        {
            //The difference between both inputs is bigger than (or, at least, very close to) the maximum double value/precision;
            //what makes this situation calculation unworthy and the first operand to be returned as the result.
            //Note that the error below these lines is just an easy way to tell the calling function about this eventuality.
            return new UnitInfo(unitInfos2[0]) 
            {{ 
                Error = new ErrorInfo(ErrorTypes.InvalidOperation); 
            }};
        }

        //PerformManagedOperationValues is used to make sure that the resulting numeric information is stored
        //in Value (if possible).
        UnitInfo big2 = PerformManagedOperationValues
        (
            RaiseToIntegerExponent(10.0, gapExponent), unitInfos2[bigSmallI[0]].Value, 
            Operations.Multiplication                
        );

        boolean isWrong = 
        (
            big2.Error.Type != ErrorTypes.None || big2.BaseTenExponent != 0 ?
            
            //The value of the bigger input times 10^(gap between BaseTenExponent of inputs) is too big. 
            isWrong = true :
            
            //Overflow-check very unlikely to trigger an error. In fact, with properly normalised variables,
            //triggering an error would be plainly impossible.               
            AreAdditionFinalValuesWrong
            (
                unitInfos2[0].Value, unitInfos2[1].Value, operation
            )
        );

        if (isWrong)
        {
        	//This error is just an easy way to let the calling function know about the fact that no
            //calculation has been performed (too big gap). This isn't a properly-speaking error and
            //that's why it will not be notified to the user.
        	return new UnitInfo(unitInfos2[0])
            {{
            Error = new ErrorInfo(ErrorTypes.InvalidOperation);
                    }};
        }
        else
        {
            //Returning the new big value. For example: with 5*10^4 & 3*10^2, 500 would be returned.
            return new UnitInfo(unitInfos2[bigSmallI[0]])
            {{
                Value = big2.Value;
            }};
        }

        
        return
        (
            isWrong ?
            //This error is just an easy way to let the calling function know about the fact that no
            //calculation has been performed (too big gap). This isn't a properly-speaking error and
            //that's why it will not be notified to the user.
            new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }} :
            //Returning the new big value. For example: with 5*10^4 & 3*10^2, 500 would be returned.
            new UnitInfo(unitInfos2[bigSmallI[0]])
            {{
                Value = big2.Value;
            }}
        );
    }

    static boolean AreAdditionFinalValuesWrong(double val1, double val2, Operations operation)
    {
        boolean isWrong = false;

        try
        {
            val1 = val1 + val2 *
            (
                operation == Operations.Addition ? 1 : -1
            );
        }
        catch { isWrong = true; }

        return isWrong;
    }

    static UnitInfo PerformManagedOperationMultiplication(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationNormalisedValues
        (
            firstInfo, new UnitInfo[] 
            { 
                NormaliseUnitInfo(firstInfo),
                NormaliseUnitInfo(secondInfo) 
            },
            operation
        );
    }

    public static UnitInfo RaiseToIntegerExponent(double baseValue, int exponent)
    {
        return RaiseToIntegerExponent(new UnitInfo(baseValue), exponent);
    }

    static UnitInfo RaiseToIntegerExponent(UnitInfo baseInfo, int exponent)
    {
        if (exponent <= 1 && exponent >= 0)
        {
            baseInfo.Value = (exponent == 0 ? 1.0 : baseInfo.Value);
            return baseInfo;
        }

        UnitInfo outInfo = new UnitInfo(baseInfo);

        for (int i = 1; i < Math.Abs(exponent); i++)
        {
            outInfo = PerformManagedOperationValues
            (
                outInfo, baseInfo, Operations.Multiplication
            );
            if (outInfo.Error.Type != ErrorTypes.None) return outInfo;
        }

        return
        (
            exponent < 0 ?
            PerformManagedOperationValues(new UnitInfo(1.0), outInfo, Operations.Division) :
            outInfo
        );
    }

    static UnitInfo PerformManagedOperationNormalisedValues(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        outInfo =
        (
            normalisedInfos.Length == 1 ?
            //There is just one operand when the difference between both of them is too big.
            outInfo = normalisedInfos[0] :
            PerformManagedOperationTwoOperands(outInfo, normalisedInfos, operation)
        );

        return outInfo;
    }

    static UnitInfo PerformManagedOperationTwoOperands(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        UnitInfo outInfoNormalised = PerformManagedOperationValues
        (
            normalisedInfos[0], normalisedInfos[1], operation
        );

        if (outInfo.Error.Type != ErrorTypes.None)
        {
            return new UnitInfo(outInfo)
            {
                Error = new ErrorInfo(ErrorTypes.NumericError)
            };
        }

        outInfo.BaseTenExponent = outInfoNormalised.BaseTenExponent;
        outInfo.Value = outInfoNormalised.Value;
        //Normalised means no prefixes.
        outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage); 

        return outInfo;
    }

    static UnitInfo PerformManagedOperationValues(double firstValue, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            new UnitInfo(firstValue), new UnitInfo(secondValue), operation
        );
    }

    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            firstInfo, new UnitInfo(secondValue), operation
        );
    }

    //This method might be used to perform full operations (not just being the last calculation step) instead
    //of the default one (PerformManagedOperationUnits) for simple cases. That is: ones not dealing with the
    //complex numeric reality (Value, Prefix and BaseTenExponent) which makes a pre-analysis required.
    //Note that, unlikely what happens with PerformMangedOperationUnits, the outputs of this method aren't
    //normalised (= primarily stored under Value), what is useful in certain contexts.
    //NOTE: this function assumes that both inputs are normalised, what means that no prefix information is expected.
    //It might also be used with non-normalised inputs, but their prefix information would be plainly ignored.
    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        if (firstInfo.Value == 0.0 || secondInfo.Value == 0.0)
        {
            if (operation == Operations.Multiplication || operation == Operations.Division)
            {
                //Dividing by zero scenarios are taken into account somewhere else.
                return new UnitInfo(firstInfo) { Value = 0.0 };
            }
        }

        UnitInfo outInfo = new UnitInfo(firstInfo);
        UnitInfo firstInfo0 = new UnitInfo(firstInfo);
        UnitInfo secondInfo0 = new UnitInfo(secondInfo);

        boolean isWrong = false;
        try
        {
            if (operation == Operations.Addition)
            {
                outInfo.Value += secondInfo0.Value;
            }
            else if (operation == Operations.Subtraction)
            {
                outInfo.Value -= secondInfo.Value;
            }
            else
            {
                //The reason for checking whether BaseTenExponent is inside/outside the int range before performing 
                //the operation (rather than going ahead and eventually catching the resulting exception) isn't just
                //being quicker, but also the only option in many situations. Note that an addition/subtraction between
                //two int variables whose result is outside the int range might not trigger an exception (+ random 
                //negative value as output).
                if (VaryBaseTenExponent(outInfo, secondInfo0.BaseTenExponent, operation == Operations.Division).Error.Type != ErrorTypes.None)
                {
                    return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
                }

                if (operation == Operations.Multiplication)
                {
                    outInfo.Value *= secondInfo.Value;
                    outInfo.BaseTenExponent += secondInfo.BaseTenExponent;
                }
                else if (operation == Operations.Division)
                {
                    if (secondInfo.Value == 0.0)
                    {
                        return
                        (
                            new UnitInfo(outInfo) 
                            { 
                                Error = new ErrorInfo(ErrorTypes.NumericError) 
                            }
                        );
                    }
                    outInfo.Value /= secondInfo.Value;
                    outInfo.BaseTenExponent -= secondInfo.BaseTenExponent;
                }
            }
        }
        catch { isWrong = true; }

        return
        (
            //An error might not be triggered despite of dealing with numbers outside double precision.
            //For example: 0.00000000000000000001m * 0.0000000000000000000001m can output 0.0 without triggering an error. 
            isWrong || ((operation == Operations.Multiplication || operation == Operations.Division) && outInfo.Value == 0.0.0) ?
            OperationValuesManageError(firstInfo0, secondInfo0, operation) : outInfo
        );
    }

    static UnitInfo OperationValuesManageError(UnitInfo outInfo, UnitInfo secondInfo, Operations operation)
    {
        if (operation != Operations.Multiplication && operation != Operations.Division)
        {
            //This condition should never be true on account of the fact that the pre-modifications performed before
            //adding/subtracting should avoid erroneous situations.
            return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
        }

        UnitInfo secondInfo2 = ConvertValueToBaseTen(secondInfo.Value);
        outInfo = VaryBaseTenExponent(outInfo, secondInfo2.BaseTenExponent, operation == Operations.Division);
        if (Math.Abs(secondInfo2.Value) == 1.0 || outInfo.Error.Type != ErrorTypes.None) return outInfo;
        
        try
        {
            outInfo = PerformManagedOperationUnits
            (
                outInfo, secondInfo2.Value, operation
            );
        }
        catch
        {
            //Very unlikely scenario on account of the fact that Math.Abs(secondInfo2.Value)
            //lies within the 0.1-10.0 range.
            outInfo = OperationValuesManageError
            (
                new UnitInfo(outInfo)
                {
                    Value = secondInfo2.Value,
                    BaseTenExponent = 0
                },
                new UnitInfo()
                {
                    Value = outInfo.Value,
                    BaseTenExponent = outInfo.BaseTenExponent
                },
                operation
            );
        }

        return outInfo;
    }

    static UnitInfo ConvertValueToBaseTen(double value)
    {
        value = Math.Abs(value);
        return FromValueToBaseTenExponent
        (
             new UnitInfo(value), Math.Abs(value), false
        );
    }

    static UnitInfo ConvertBaseTenToValue(UnitInfo unitInfo)
    {
        if (unitInfo.BaseTenExponent == 0) return unitInfo;

        UnitInfo outInfo = new UnitInfo(unitInfo);
        boolean decrease = unitInfo.BaseTenExponent > 0;
        int sign = Math.Sign(outInfo.Value);
        double absValue = Math.Abs(outInfo.Value);

        while (outInfo.BaseTenExponent != 0.0)
        {
            if (decrease)
            {
                if (absValue >= MaxValueDec / 10.0) break;
                absValue *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }
            else
            {
                if (absValue <= MinValueDec * 10.0) break;
                absValue /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
        }

        outInfo.Value = sign * absValue;

        return outInfo;
    }

    static UnitInfo NormaliseUnitInfo(UnitInfo unitInfo)
    {
        if (unitInfo.Value == 0 && unitInfo.Prefix.Factor == 1.0)
        {
            return unitInfo;
        }
        UnitInfo outInfo = new UnitInfo(unitInfo);

        if (outInfo.Prefix.Factor != 1)
        {
            outInfo = FromValueToBaseTenExponent
            (
                outInfo, outInfo.Prefix.Factor, true
            );
            outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage);
        }
        if (outInfo.Value == 0.0) return outInfo;

        outInfo = FromValueToBaseTenExponent
        (
            outInfo, outInfo.Value, false
        );

        return outInfo;
    }

    static UnitInfo FromValueToBaseTenExponent(UnitInfo outInfo, double value, boolean isPrefix)
    {
        if (value == 0.0) return outInfo;

        double valueAbs = Math.Abs(value);
        boolean decrease = (valueAbs > 1.0);
        if (!isPrefix)
        {
            outInfo.Value = outInfo.Value / valueAbs;
        }

        while (valueAbs != 1.0)
        {
            if ((valueAbs < 10.0 && valueAbs > 1.0) || (valueAbs > 0.1.0 && valueAbs < 1.0))
            {
                if (!isPrefix) outInfo.Value = value;
                else
                {
                    outInfo = PerformManagedOperationValues
                    (
                        outInfo, value, Operations.Multiplication
                    );
                }

                return outInfo;
            }

            if (decrease)
            {
                value /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
            else
            {
                value *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }

            valueAbs = Math.Abs(value);
        }

        return outInfo;
    }

    //Method used to vary BaseTenExponent without provoking unhandled exceptions (i.e., bigger than Integer.MAX_VALUE).
    static UnitInfo VaryBaseTenExponent(UnitInfo info, int baseTenIncrease, boolean isDivision = false)
    {
        long val1 = info.BaseTenExponent;
        long val2 = baseTenIncrease;

        if (isDivision)
        {
            //Converting a negative value into positive might provoke an overflow error for the int type
            //(e.g., Math.Abs(Integer.MAIN_VALUE)). Converting both variables to long is a quick and effective
            //way to avoid this problem.
            val2 *= -1;
        }

        return
        (
             ((val2 > 0 && val1 > Integer.MAX_VALUE - val2) || (val2 < 0 && val1 < Integer.MAIN_VALUE - val2)) ?
            new UnitInfo(info, ErrorTypes.NumericError) : new UnitInfo(info){{ BaseTenExponent = (int)(val1 + val2); }}
        );
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2017-05-27 19:58:32.026
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2017-05-27 19:58:32.026
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2017-05-27 19:58:32.049
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
public class OperationsManaged
{
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, double second, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            firstInfo, new UnitInfo(second), operation
        );
    }

    public static UnitInfo PerformManagedOperationUnits(double first, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            new UnitInfo(first), secondInfo, operation
        );
    }

    //This method should always be used when dealing with random UnitInfo variables because it accounts for all the
    //possible scenarios. On the other hand, with simple operations (e.g., random UnitInfo & numeric type) it might
    //be better to use PerformManagedOperationValues. 
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        ErrorTypes errorType = InternalMethods.GetOperationError
        (
            firstInfo, secondInfo, operation
        );
        if (errorType != ErrorTypes.None)
        {
            return new UnitInfo(firstInfo) 
            {{
                Error = new ErrorInfo(errorType); 
            }};
        }

        return
        (
            operation == Operations.Addition || operation == Operations.Subtraction ?
            PerformManagedOperationAddition(firstInfo, secondInfo, operation) :
            PerformManagedOperationMultiplication(firstInfo, secondInfo, operation)
        );
    }

    static UnitInfo PerformManagedOperationAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {   
        //After being normalised, the operands might require further modifications.
        UnitInfo[] normalised = GetOperandsAddition(firstInfo, secondInfo, operation);

        return PerformManagedOperationNormalisedValues
        (
            firstInfo, normalised, operation
        );
    }

    static UnitInfo[] GetOperandsAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        UnitInfo[] operands2 = new UnitInfo[] 
        {
            new UnitInfo(firstInfo), new UnitInfo(secondInfo)
        };

        if (operands2[0].BaseTenExponent != operands2[1].BaseTenExponent || operands2[0].Prefix.Factor != operands2[1].Prefix.Factor)
        {
            //The addition/subtraction might not be performed right away even with normalised values.
            //For example: 5 and 6 from 5*10^2 and 6*10^7 cannot be added right away.
            operands2 = AdaptNormalisedValuesForAddition
            (
                new UnitInfo[] 
                { 
                    NormaliseUnitInfo(operands2[0]), 
                    NormaliseUnitInfo(operands2[1])
                },
                operation
            );
        }

        return operands2;
    }
    
    static UnitInfo[] AdaptNormalisedValuesForAddition(UnitInfo[] unitInfos2, Operations operation)
    {
        if (unitInfos2[0].BaseTenExponent == unitInfos2[1].BaseTenExponent)
        {
            //Having the same BaseTenExponent values means that the given operation can be performed right away.
            return unitInfos2;
        }

        int[] bigSmallI = 
        (
            unitInfos2[0].BaseTenExponent > unitInfos2[1].BaseTenExponent ?
            new int[] { 0, 1 } : new int[] { 1, 0 }
        );

        //Only the variable with the bigger value is modified. For example: 5*10^5 & 3*10^3 is converted
        //into 500*10^3 & 3*10^3 in order to allow the addition 500 + 3. 
        UnitInfo big2 = AdaptBiggerAdditionOperand(unitInfos2, bigSmallI, operation);
        if (big2.Error.Type != ErrorTypes.None)
        {
            return TooBigGapAddition(unitInfos2, bigSmallI, operation);
        }

        unitInfos2[bigSmallI[0]].Value = big2.Value;
        unitInfos2[bigSmallI[0]].BaseTenExponent = unitInfos2[bigSmallI[1]].BaseTenExponent;

        return unitInfos2;
    }

    //When adding/subtracting two numbers whose gap is bigger than the maximum double range, there
    //is no need to perform any operation (i.e., no change will be observed because of being outside
    //the maximum supported precision). This method takes care of these cases and returns the expected
    //output (i.e., biggest value).
    static UnitInfo[] TooBigGapAddition(UnitInfo[] unitInfos2, int[] bigSmallI, Operations operation)
    {
        UnitInfo[] outInfos = new UnitInfo[] 
        {
            //First operand (i.e., one whose information defines the operation) together with the
            //numeric information (i.e., just Value and BaseTenExponent because both are normalised)
            //which is associated with the biggest one.
            new UnitInfo(unitInfos2[0])
            {{
                Value = unitInfos2[bigSmallI[0]].Value;
                BaseTenExponent = unitInfos2[bigSmallI[0]].BaseTenExponent;
            }}
        };

        if (operation == Operations.Subtraction && bigSmallI[0] == 1)
        {
            outInfos[0].Value = -1.0 * outInfos[0].Value;
        }

        if (outInfos[0].Unit == Units.Unitless)
        {
            outInfos[0].Unit = unitInfos2[bigSmallI[1]].Unit;
        }

        return outInfos;
    }

    static UnitInfo AdaptBiggerAdditionOperand(UnitInfo[] unitInfos2, int[] bigSmallI, Operations operation)
    {
        int gapExponent = unitInfos2[bigSmallI[0]].BaseTenExponent - unitInfos2[bigSmallI[1]].BaseTenExponent;
        if (gapExponent >= 27)
        {
            //The difference between both inputs is bigger than (or, at least, very close to) the maximum double value/precision;
            //what makes this situation calculation unworthy and the first operand to be returned as the result.
            //Note that the error below these lines is just an easy way to tell the calling function about this eventuality.
            return new UnitInfo(unitInfos2[0]) 
            {{ 
                Error = new ErrorInfo(ErrorTypes.InvalidOperation); 
            }};
        }

        //PerformManagedOperationValues is used to make sure that the resulting numeric information is stored
        //in Value (if possible).
        UnitInfo big2 = PerformManagedOperationValues
        (
            RaiseToIntegerExponent(10.0, gapExponent), unitInfos2[bigSmallI[0]].Value, 
            Operations.Multiplication                
        );

        boolean isWrong = 
        (
            big2.Error.Type != ErrorTypes.None || big2.BaseTenExponent != 0 ?
            
            //The value of the bigger input times 10^(gap between BaseTenExponent of inputs) is too big. 
            isWrong = true :
            
            //Overflow-check very unlikely to trigger an error. In fact, with properly normalised variables,
            //triggering an error would be plainly impossible.               
            AreAdditionFinalValuesWrong
            (
                unitInfos2[0].Value, unitInfos2[1].Value, operation
            )
        );

        if (isWrong)
        {
        	//This error is just an easy way to let the calling function know about the fact that no
            //calculation has been performed (too big gap). This isn't a properly-speaking error and
            //that's why it will not be notified to the user.
        	return new UnitInfo(unitInfos2[0])
            {{
            Error = new ErrorInfo(ErrorTypes.InvalidOperation);
                    }};
        }
        else
        {
            //Returning the new big value. For example: with 5*10^4 & 3*10^2, 500 would be returned.
            return new UnitInfo(unitInfos2[bigSmallI[0]])
            {{
                Value = big2.Value;
            }};
        }

        
        return
        (
            isWrong ?
            //This error is just an easy way to let the calling function know about the fact that no
            //calculation has been performed (too big gap). This isn't a properly-speaking error and
            //that's why it will not be notified to the user.
            new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }} :
            //Returning the new big value. For example: with 5*10^4 & 3*10^2, 500 would be returned.
            new UnitInfo(unitInfos2[bigSmallI[0]])
            {{
                Value = big2.Value;
            }}
        );
    }

    static boolean AreAdditionFinalValuesWrong(double val1, double val2, Operations operation)
    {
        boolean isWrong = false;

        try
        {
            val1 = val1 + val2 *
            (
                operation == Operations.Addition ? 1 : -1
            );
        }
        catch { isWrong = true; }

        return isWrong;
    }

    static UnitInfo PerformManagedOperationMultiplication(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationNormalisedValues
        (
            firstInfo, new UnitInfo[] 
            { 
                NormaliseUnitInfo(firstInfo),
                NormaliseUnitInfo(secondInfo) 
            },
            operation
        );
    }

    public static UnitInfo RaiseToIntegerExponent(double baseValue, int exponent)
    {
        return RaiseToIntegerExponent(new UnitInfo(baseValue), exponent);
    }

    static UnitInfo RaiseToIntegerExponent(UnitInfo baseInfo, int exponent)
    {
        if (exponent <= 1 && exponent >= 0)
        {
            baseInfo.Value = (exponent == 0 ? 1.0 : baseInfo.Value);
            return baseInfo;
        }

        UnitInfo outInfo = new UnitInfo(baseInfo);

        for (int i = 1; i < Math.Abs(exponent); i++)
        {
            outInfo = PerformManagedOperationValues
            (
                outInfo, baseInfo, Operations.Multiplication
            );
            if (outInfo.Error.Type != ErrorTypes.None) return outInfo;
        }

        return
        (
            exponent < 0 ?
            PerformManagedOperationValues(new UnitInfo(1.0), outInfo, Operations.Division) :
            outInfo
        );
    }

    static UnitInfo PerformManagedOperationNormalisedValues(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        outInfo =
        (
            normalisedInfos.Length == 1 ?
            //There is just one operand when the difference between both of them is too big.
            outInfo = normalisedInfos[0] :
            PerformManagedOperationTwoOperands(outInfo, normalisedInfos, operation)
        );

        return outInfo;
    }

    static UnitInfo PerformManagedOperationTwoOperands(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        UnitInfo outInfoNormalised = PerformManagedOperationValues
        (
            normalisedInfos[0], normalisedInfos[1], operation
        );

        if (outInfo.Error.Type != ErrorTypes.None)
        {
            return new UnitInfo(outInfo)
            {
                Error = new ErrorInfo(ErrorTypes.NumericError)
            };
        }

        outInfo.BaseTenExponent = outInfoNormalised.BaseTenExponent;
        outInfo.Value = outInfoNormalised.Value;
        //Normalised means no prefixes.
        outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage); 

        return outInfo;
    }

    static UnitInfo PerformManagedOperationValues(double firstValue, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            new UnitInfo(firstValue), new UnitInfo(secondValue), operation
        );
    }

    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            firstInfo, new UnitInfo(secondValue), operation
        );
    }

    //This method might be used to perform full operations (not just being the last calculation step) instead
    //of the default one (PerformManagedOperationUnits) for simple cases. That is: ones not dealing with the
    //complex numeric reality (Value, Prefix and BaseTenExponent) which makes a pre-analysis required.
    //Note that, unlikely what happens with PerformMangedOperationUnits, the outputs of this method aren't
    //normalised (= primarily stored under Value), what is useful in certain contexts.
    //NOTE: this function assumes that both inputs are normalised, what means that no prefix information is expected.
    //It might also be used with non-normalised inputs, but their prefix information would be plainly ignored.
    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        if (firstInfo.Value == 0.0 || secondInfo.Value == 0.0)
        {
            if (operation == Operations.Multiplication || operation == Operations.Division)
            {
                //Dividing by zero scenarios are taken into account somewhere else.
                return new UnitInfo(firstInfo) { Value = 0.0 };
            }
        }

        UnitInfo outInfo = new UnitInfo(firstInfo);
        UnitInfo firstInfo0 = new UnitInfo(firstInfo);
        UnitInfo secondInfo0 = new UnitInfo(secondInfo);

        boolean isWrong = false;
        try
        {
            if (operation == Operations.Addition)
            {
                outInfo.Value += secondInfo0.Value;
            }
            else if (operation == Operations.Subtraction)
            {
                outInfo.Value -= secondInfo.Value;
            }
            else
            {
                //The reason for checking whether BaseTenExponent is inside/outside the int range before performing 
                //the operation (rather than going ahead and eventually catching the resulting exception) isn't just
                //being quicker, but also the only option in many situations. Note that an addition/subtraction between
                //two int variables whose result is outside the int range might not trigger an exception (+ random 
                //negative value as output).
                if (VaryBaseTenExponent(outInfo, secondInfo0.BaseTenExponent, operation == Operations.Division).Error.Type != ErrorTypes.None)
                {
                    return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
                }

                if (operation == Operations.Multiplication)
                {
                    outInfo.Value *= secondInfo.Value;
                    outInfo.BaseTenExponent += secondInfo.BaseTenExponent;
                }
                else if (operation == Operations.Division)
                {
                    if (secondInfo.Value == 0.0)
                    {
                        return
                        (
                            new UnitInfo(outInfo) 
                            { 
                                Error = new ErrorInfo(ErrorTypes.NumericError) 
                            }
                        );
                    }
                    outInfo.Value /= secondInfo.Value;
                    outInfo.BaseTenExponent -= secondInfo.BaseTenExponent;
                }
            }
        }
        catch { isWrong = true; }

        return
        (
            //An error might not be triggered despite of dealing with numbers outside double precision.
            //For example: 0.00000000000000000001m * 0.0000000000000000000001m can output 0.0 without triggering an error. 
            isWrong || ((operation == Operations.Multiplication || operation == Operations.Division) && outInfo.Value == 0.0.0) ?
            OperationValuesManageError(firstInfo0, secondInfo0, operation) : outInfo
        );
    }

    static UnitInfo OperationValuesManageError(UnitInfo outInfo, UnitInfo secondInfo, Operations operation)
    {
        if (operation != Operations.Multiplication && operation != Operations.Division)
        {
            //This condition should never be true on account of the fact that the pre-modifications performed before
            //adding/subtracting should avoid erroneous situations.
            return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
        }

        UnitInfo secondInfo2 = ConvertValueToBaseTen(secondInfo.Value);
        outInfo = VaryBaseTenExponent(outInfo, secondInfo2.BaseTenExponent, operation == Operations.Division);
        if (Math.Abs(secondInfo2.Value) == 1.0 || outInfo.Error.Type != ErrorTypes.None) return outInfo;
        
        try
        {
            outInfo = PerformManagedOperationUnits
            (
                outInfo, secondInfo2.Value, operation
            );
        }
        catch
        {
            //Very unlikely scenario on account of the fact that Math.Abs(secondInfo2.Value)
            //lies within the 0.1-10.0 range.
            outInfo = OperationValuesManageError
            (
                new UnitInfo(outInfo)
                {
                    Value = secondInfo2.Value,
                    BaseTenExponent = 0
                },
                new UnitInfo()
                {
                    Value = outInfo.Value,
                    BaseTenExponent = outInfo.BaseTenExponent
                },
                operation
            );
        }

        return outInfo;
    }

    static UnitInfo ConvertValueToBaseTen(double value)
    {
        value = Math.Abs(value);
        return FromValueToBaseTenExponent
        (
             new UnitInfo(value), Math.Abs(value), false
        );
    }

    static UnitInfo ConvertBaseTenToValue(UnitInfo unitInfo)
    {
        if (unitInfo.BaseTenExponent == 0) return unitInfo;

        UnitInfo outInfo = new UnitInfo(unitInfo);
        boolean decrease = unitInfo.BaseTenExponent > 0;
        int sign = Math.Sign(outInfo.Value);
        double absValue = Math.Abs(outInfo.Value);

        while (outInfo.BaseTenExponent != 0.0)
        {
            if (decrease)
            {
                if (absValue >= MaxValueDec / 10.0) break;
                absValue *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }
            else
            {
                if (absValue <= MinValueDec * 10.0) break;
                absValue /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
        }

        outInfo.Value = sign * absValue;

        return outInfo;
    }

    static UnitInfo NormaliseUnitInfo(UnitInfo unitInfo)
    {
        if (unitInfo.Value == 0 && unitInfo.Prefix.Factor == 1.0)
        {
            return unitInfo;
        }
        UnitInfo outInfo = new UnitInfo(unitInfo);

        if (outInfo.Prefix.Factor != 1)
        {
            outInfo = FromValueToBaseTenExponent
            (
                outInfo, outInfo.Prefix.Factor, true
            );
            outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage);
        }
        if (outInfo.Value == 0.0) return outInfo;

        outInfo = FromValueToBaseTenExponent
        (
            outInfo, outInfo.Value, false
        );

        return outInfo;
    }

    static UnitInfo FromValueToBaseTenExponent(UnitInfo outInfo, double value, boolean isPrefix)
    {
        if (value == 0.0) return outInfo;

        double valueAbs = Math.Abs(value);
        boolean decrease = (valueAbs > 1.0);
        if (!isPrefix)
        {
            outInfo.Value = outInfo.Value / valueAbs;
        }

        while (valueAbs != 1.0)
        {
            if ((valueAbs < 10.0 && valueAbs > 1.0) || (valueAbs > 0.1.0 && valueAbs < 1.0))
            {
                if (!isPrefix) outInfo.Value = value;
                else
                {
                    outInfo = PerformManagedOperationValues
                    (
                        outInfo, value, Operations.Multiplication
                    );
                }

                return outInfo;
            }

            if (decrease)
            {
                value /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
            else
            {
                value *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }

            valueAbs = Math.Abs(value);
        }

        return outInfo;
    }

    //Method used to vary BaseTenExponent without provoking unhandled exceptions (i.e., bigger than Integer.MAX_VALUE).
    static UnitInfo VaryBaseTenExponent(UnitInfo info, int baseTenIncrease, boolean isDivision = false)
    {
        long val1 = info.BaseTenExponent;
        long val2 = baseTenIncrease;

        if (isDivision)
        {
            //Converting a negative value into positive might provoke an overflow error for the int type
            //(e.g., Math.Abs(Integer.MAIN_VALUE)). Converting both variables to long is a quick and effective
            //way to avoid this problem.
            val2 *= -1;
        }

        return
        (
             ((val2 > 0 && val1 > Integer.MAX_VALUE - val2) || (val2 < 0 && val1 < Integer.MAIN_VALUE - val2)) ?
            new UnitInfo(info, ErrorTypes.NumericError) : new UnitInfo(info){{ BaseTenExponent = (int)(val1 + val2); }}
        );
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:476)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 2 2017-05-27 19:58:32.050
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:476)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 0 2017-05-27 19:58:32.051
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:476)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.core 4 4 2017-05-27 19:58:34.080
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
public class OperationsManaged
{
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, double second, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            firstInfo, new UnitInfo(second), operation
        );
    }

    public static UnitInfo PerformManagedOperationUnits(double first, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            new UnitInfo(first), secondInfo, operation
        );
    }

    //This method should always be used when dealing with random UnitInfo variables because it accounts for all the
    //possible scenarios. On the other hand, with simple operations (e.g., random UnitInfo & numeric type) it might
    //be better to use PerformManagedOperationValues. 
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        ErrorTypes errorType = InternalMethods.GetOperationError
        (
            firstInfo, secondInfo, operation
        );
        if (errorType != ErrorTypes.None)
        {
            return new UnitInfo(firstInfo) 
            {{
                Error = new ErrorInfo(errorType); 
            }};
        }

        return
        (
            operation == Operations.Addition || operation == Operations.Subtraction ?
            PerformManagedOperationAddition(firstInfo, secondInfo, operation) :
            PerformManagedOperationMultiplication(firstInfo, secondInfo, operation)
        );
    }

    static UnitInfo PerformManagedOperationAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {   
        //After being normalised, the operands might require further modifications.
        UnitInfo[] normalised = GetOperandsAddition(firstInfo, secondInfo, operation);

        return PerformManagedOperationNormalisedValues
        (
            firstInfo, normalised, operation
        );
    }

    static UnitInfo[] GetOperandsAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        UnitInfo[] operands2 = new UnitInfo[] 
        {
            new UnitInfo(firstInfo), new UnitInfo(secondInfo)
        };

        if (operands2[0].BaseTenExponent != operands2[1].BaseTenExponent || operands2[0].Prefix.Factor != operands2[1].Prefix.Factor)
        {
            //The addition/subtraction might not be performed right away even with normalised values.
            //For example: 5 and 6 from 5*10^2 and 6*10^7 cannot be added right away.
            operands2 = AdaptNormalisedValuesForAddition
            (
                new UnitInfo[] 
                { 
                    NormaliseUnitInfo(operands2[0]), 
                    NormaliseUnitInfo(operands2[1])
                },
                operation
            );
        }

        return operands2;
    }
    
    static UnitInfo[] AdaptNormalisedValuesForAddition(UnitInfo[] unitInfos2, Operations operation)
    {
        if (unitInfos2[0].BaseTenExponent == unitInfos2[1].BaseTenExponent)
        {
            //Having the same BaseTenExponent values means that the given operation can be performed right away.
            return unitInfos2;
        }

        int[] bigSmallI = 
        (
            unitInfos2[0].BaseTenExponent > unitInfos2[1].BaseTenExponent ?
            new int[] { 0, 1 } : new int[] { 1, 0 }
        );

        //Only the variable with the bigger value is modified. For example: 5*10^5 & 3*10^3 is converted
        //into 500*10^3 & 3*10^3 in order to allow the addition 500 + 3. 
        UnitInfo big2 = AdaptBiggerAdditionOperand(unitInfos2, bigSmallI, operation);
        if (big2.Error.Type != ErrorTypes.None)
        {
            return TooBigGapAddition(unitInfos2, bigSmallI, operation);
        }

        unitInfos2[bigSmallI[0]].Value = big2.Value;
        unitInfos2[bigSmallI[0]].BaseTenExponent = unitInfos2[bigSmallI[1]].BaseTenExponent;

        return unitInfos2;
    }

    //When adding/subtracting two numbers whose gap is bigger than the maximum double range, there
    //is no need to perform any operation (i.e., no change will be observed because of being outside
    //the maximum supported precision). This method takes care of these cases and returns the expected
    //output (i.e., biggest value).
    static UnitInfo[] TooBigGapAddition(UnitInfo[] unitInfos2, int[] bigSmallI, Operations operation)
    {
        UnitInfo[] outInfos = new UnitInfo[] 
        {
            //First operand (i.e., one whose information defines the operation) together with the
            //numeric information (i.e., just Value and BaseTenExponent because both are normalised)
            //which is associated with the biggest one.
            new UnitInfo(unitInfos2[0])
            {{
                Value = unitInfos2[bigSmallI[0]].Value;
                BaseTenExponent = unitInfos2[bigSmallI[0]].BaseTenExponent;
            }}
        };

        if (operation == Operations.Subtraction && bigSmallI[0] == 1)
        {
            outInfos[0].Value = -1.0 * outInfos[0].Value;
        }

        if (outInfos[0].Unit == Units.Unitless)
        {
            outInfos[0].Unit = unitInfos2[bigSmallI[1]].Unit;
        }

        return outInfos;
    }

    static UnitInfo AdaptBiggerAdditionOperand(UnitInfo[] unitInfos2, int[] bigSmallI, Operations operation)
    {
        int gapExponent = unitInfos2[bigSmallI[0]].BaseTenExponent - unitInfos2[bigSmallI[1]].BaseTenExponent;
        if (gapExponent >= 27)
        {
            //The difference between both inputs is bigger than (or, at least, very close to) the maximum double value/precision;
            //what makes this situation calculation unworthy and the first operand to be returned as the result.
            //Note that the error below these lines is just an easy way to tell the calling function about this eventuality.
            return new UnitInfo(unitInfos2[0]) 
            {{ 
                Error = new ErrorInfo(ErrorTypes.InvalidOperation); 
            }};
        }

        //PerformManagedOperationValues is used to make sure that the resulting numeric information is stored
        //in Value (if possible).
        UnitInfo big2 = PerformManagedOperationValues
        (
            RaiseToIntegerExponent(10.0, gapExponent), unitInfos2[bigSmallI[0]].Value, 
            Operations.Multiplication                
        );

        boolean isWrong = 
        (
            big2.Error.Type != ErrorTypes.None || big2.BaseTenExponent != 0 ?
            
            //The value of the bigger input times 10^(gap between BaseTenExponent of inputs) is too big. 
            isWrong = true :
            
            //Overflow-check very unlikely to trigger an error. In fact, with properly normalised variables,
            //triggering an error would be plainly impossible.               
            AreAdditionFinalValuesWrong
            (
                unitInfos2[0].Value, unitInfos2[1].Value, operation
            )
        );

        if (isWrong)
        {
        	//This error is just an easy way to let the calling function know about the fact that no
            //calculation has been performed (too big gap). This isn't a properly-speaking error and
            //that's why it will not be notified to the user.
        	return new UnitInfo(unitInfos2[0])
            {{
            	Error = new ErrorInfo(ErrorTypes.InvalidOperation);
                 }};
        }
        else
        {
            //Returning the new big value. For example: with 5*10^4 & 3*10^2, 500 would be returned.
            return new UnitInfo(unitInfos2[bigSmallI[0]])
            {{
                Value = big2.Value;
            }};
        }

        
        return
        (
            isWrong ?
            //This error is just an easy way to let the calling function know about the fact that no
            //calculation has been performed (too big gap). This isn't a properly-speaking error and
            //that's why it will not be notified to the user.
            new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }} :
            //Returning the new big value. For example: with 5*10^4 & 3*10^2, 500 would be returned.
            new UnitInfo(unitInfos2[bigSmallI[0]])
            {{
                Value = big2.Value;
            }}
        );
    }

    static boolean AreAdditionFinalValuesWrong(double val1, double val2, Operations operation)
    {
        boolean isWrong = false;

        try
        {
            val1 = val1 + val2 *
            (
                operation == Operations.Addition ? 1 : -1
            );
        }
        catch { isWrong = true; }

        return isWrong;
    }

    static UnitInfo PerformManagedOperationMultiplication(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationNormalisedValues
        (
            firstInfo, new UnitInfo[] 
            { 
                NormaliseUnitInfo(firstInfo),
                NormaliseUnitInfo(secondInfo) 
            },
            operation
        );
    }

    public static UnitInfo RaiseToIntegerExponent(double baseValue, int exponent)
    {
        return RaiseToIntegerExponent(new UnitInfo(baseValue), exponent);
    }

    static UnitInfo RaiseToIntegerExponent(UnitInfo baseInfo, int exponent)
    {
        if (exponent <= 1 && exponent >= 0)
        {
            baseInfo.Value = (exponent == 0 ? 1.0 : baseInfo.Value);
            return baseInfo;
        }

        UnitInfo outInfo = new UnitInfo(baseInfo);

        for (int i = 1; i < Math.Abs(exponent); i++)
        {
            outInfo = PerformManagedOperationValues
            (
                outInfo, baseInfo, Operations.Multiplication
            );
            if (outInfo.Error.Type != ErrorTypes.None) return outInfo;
        }

        return
        (
            exponent < 0 ?
            PerformManagedOperationValues(new UnitInfo(1.0), outInfo, Operations.Division) :
            outInfo
        );
    }

    static UnitInfo PerformManagedOperationNormalisedValues(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        outInfo =
        (
            normalisedInfos.Length == 1 ?
            //There is just one operand when the difference between both of them is too big.
            outInfo = normalisedInfos[0] :
            PerformManagedOperationTwoOperands(outInfo, normalisedInfos, operation)
        );

        return outInfo;
    }

    static UnitInfo PerformManagedOperationTwoOperands(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        UnitInfo outInfoNormalised = PerformManagedOperationValues
        (
            normalisedInfos[0], normalisedInfos[1], operation
        );

        if (outInfo.Error.Type != ErrorTypes.None)
        {
            return new UnitInfo(outInfo)
            {
                Error = new ErrorInfo(ErrorTypes.NumericError)
            };
        }

        outInfo.BaseTenExponent = outInfoNormalised.BaseTenExponent;
        outInfo.Value = outInfoNormalised.Value;
        //Normalised means no prefixes.
        outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage); 

        return outInfo;
    }

    static UnitInfo PerformManagedOperationValues(double firstValue, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            new UnitInfo(firstValue), new UnitInfo(secondValue), operation
        );
    }

    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            firstInfo, new UnitInfo(secondValue), operation
        );
    }

    //This method might be used to perform full operations (not just being the last calculation step) instead
    //of the default one (PerformManagedOperationUnits) for simple cases. That is: ones not dealing with the
    //complex numeric reality (Value, Prefix and BaseTenExponent) which makes a pre-analysis required.
    //Note that, unlikely what happens with PerformMangedOperationUnits, the outputs of this method aren't
    //normalised (= primarily stored under Value), what is useful in certain contexts.
    //NOTE: this function assumes that both inputs are normalised, what means that no prefix information is expected.
    //It might also be used with non-normalised inputs, but their prefix information would be plainly ignored.
    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        if (firstInfo.Value == 0.0 || secondInfo.Value == 0.0)
        {
            if (operation == Operations.Multiplication || operation == Operations.Division)
            {
                //Dividing by zero scenarios are taken into account somewhere else.
                return new UnitInfo(firstInfo) { Value = 0.0 };
            }
        }

        UnitInfo outInfo = new UnitInfo(firstInfo);
        UnitInfo firstInfo0 = new UnitInfo(firstInfo);
        UnitInfo secondInfo0 = new UnitInfo(secondInfo);

        boolean isWrong = false;
        try
        {
            if (operation == Operations.Addition)
            {
                outInfo.Value += secondInfo0.Value;
            }
            else if (operation == Operations.Subtraction)
            {
                outInfo.Value -= secondInfo.Value;
            }
            else
            {
                //The reason for checking whether BaseTenExponent is inside/outside the int range before performing 
                //the operation (rather than going ahead and eventually catching the resulting exception) isn't just
                //being quicker, but also the only option in many situations. Note that an addition/subtraction between
                //two int variables whose result is outside the int range might not trigger an exception (+ random 
                //negative value as output).
                if (VaryBaseTenExponent(outInfo, secondInfo0.BaseTenExponent, operation == Operations.Division).Error.Type != ErrorTypes.None)
                {
                    return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
                }

                if (operation == Operations.Multiplication)
                {
                    outInfo.Value *= secondInfo.Value;
                    outInfo.BaseTenExponent += secondInfo.BaseTenExponent;
                }
                else if (operation == Operations.Division)
                {
                    if (secondInfo.Value == 0.0)
                    {
                        return
                        (
                            new UnitInfo(outInfo) 
                            { 
                                Error = new ErrorInfo(ErrorTypes.NumericError) 
                            }
                        );
                    }
                    outInfo.Value /= secondInfo.Value;
                    outInfo.BaseTenExponent -= secondInfo.BaseTenExponent;
                }
            }
        }
        catch { isWrong = true; }

        return
        (
            //An error might not be triggered despite of dealing with numbers outside double precision.
            //For example: 0.00000000000000000001m * 0.0000000000000000000001m can output 0.0 without triggering an error. 
            isWrong || ((operation == Operations.Multiplication || operation == Operations.Division) && outInfo.Value == 0.0.0) ?
            OperationValuesManageError(firstInfo0, secondInfo0, operation) : outInfo
        );
    }

    static UnitInfo OperationValuesManageError(UnitInfo outInfo, UnitInfo secondInfo, Operations operation)
    {
        if (operation != Operations.Multiplication && operation != Operations.Division)
        {
            //This condition should never be true on account of the fact that the pre-modifications performed before
            //adding/subtracting should avoid erroneous situations.
            return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
        }

        UnitInfo secondInfo2 = ConvertValueToBaseTen(secondInfo.Value);
        outInfo = VaryBaseTenExponent(outInfo, secondInfo2.BaseTenExponent, operation == Operations.Division);
        if (Math.Abs(secondInfo2.Value) == 1.0 || outInfo.Error.Type != ErrorTypes.None) return outInfo;
        
        try
        {
            outInfo = PerformManagedOperationUnits
            (
                outInfo, secondInfo2.Value, operation
            );
        }
        catch
        {
            //Very unlikely scenario on account of the fact that Math.Abs(secondInfo2.Value)
            //lies within the 0.1-10.0 range.
            outInfo = OperationValuesManageError
            (
                new UnitInfo(outInfo)
                {
                    Value = secondInfo2.Value,
                    BaseTenExponent = 0
                },
                new UnitInfo()
                {
                    Value = outInfo.Value,
                    BaseTenExponent = outInfo.BaseTenExponent
                },
                operation
            );
        }

        return outInfo;
    }

    static UnitInfo ConvertValueToBaseTen(double value)
    {
        value = Math.Abs(value);
        return FromValueToBaseTenExponent
        (
             new UnitInfo(value), Math.Abs(value), false
        );
    }

    static UnitInfo ConvertBaseTenToValue(UnitInfo unitInfo)
    {
        if (unitInfo.BaseTenExponent == 0) return unitInfo;

        UnitInfo outInfo = new UnitInfo(unitInfo);
        boolean decrease = unitInfo.BaseTenExponent > 0;
        int sign = Math.Sign(outInfo.Value);
        double absValue = Math.Abs(outInfo.Value);

        while (outInfo.BaseTenExponent != 0.0)
        {
            if (decrease)
            {
                if (absValue >= MaxValueDec / 10.0) break;
                absValue *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }
            else
            {
                if (absValue <= MinValueDec * 10.0) break;
                absValue /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
        }

        outInfo.Value = sign * absValue;

        return outInfo;
    }

    static UnitInfo NormaliseUnitInfo(UnitInfo unitInfo)
    {
        if (unitInfo.Value == 0 && unitInfo.Prefix.Factor == 1.0)
        {
            return unitInfo;
        }
        UnitInfo outInfo = new UnitInfo(unitInfo);

        if (outInfo.Prefix.Factor != 1)
        {
            outInfo = FromValueToBaseTenExponent
            (
                outInfo, outInfo.Prefix.Factor, true
            );
            outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage);
        }
        if (outInfo.Value == 0.0) return outInfo;

        outInfo = FromValueToBaseTenExponent
        (
            outInfo, outInfo.Value, false
        );

        return outInfo;
    }

    static UnitInfo FromValueToBaseTenExponent(UnitInfo outInfo, double value, boolean isPrefix)
    {
        if (value == 0.0) return outInfo;

        double valueAbs = Math.Abs(value);
        boolean decrease = (valueAbs > 1.0);
        if (!isPrefix)
        {
            outInfo.Value = outInfo.Value / valueAbs;
        }

        while (valueAbs != 1.0)
        {
            if ((valueAbs < 10.0 && valueAbs > 1.0) || (valueAbs > 0.1.0 && valueAbs < 1.0))
            {
                if (!isPrefix) outInfo.Value = value;
                else
                {
                    outInfo = PerformManagedOperationValues
                    (
                        outInfo, value, Operations.Multiplication
                    );
                }

                return outInfo;
            }

            if (decrease)
            {
                value /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
            else
            {
                value *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }

            valueAbs = Math.Abs(value);
        }

        return outInfo;
    }

    //Method used to vary BaseTenExponent without provoking unhandled exceptions (i.e., bigger than Integer.MAX_VALUE).
    static UnitInfo VaryBaseTenExponent(UnitInfo info, int baseTenIncrease, boolean isDivision = false)
    {
        long val1 = info.BaseTenExponent;
        long val2 = baseTenIncrease;

        if (isDivision)
        {
            //Converting a negative value into positive might provoke an overflow error for the int type
            //(e.g., Math.Abs(Integer.MAIN_VALUE)). Converting both variables to long is a quick and effective
            //way to avoid this problem.
            val2 *= -1;
        }

        return
        (
             ((val2 > 0 && val1 > Integer.MAX_VALUE - val2) || (val2 < 0 && val1 < Integer.MAIN_VALUE - val2)) ?
            new UnitInfo(info, ErrorTypes.NumericError) : new UnitInfo(info){{ BaseTenExponent = (int)(val1 + val2); }}
        );
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2017-05-27 19:58:34.081
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2017-05-27 19:58:34.082
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2017-05-27 19:58:34.139
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
public class OperationsManaged
{
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, double second, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            firstInfo, new UnitInfo(second), operation
        );
    }

    public static UnitInfo PerformManagedOperationUnits(double first, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            new UnitInfo(first), secondInfo, operation
        );
    }

    //This method should always be used when dealing with random UnitInfo variables because it accounts for all the
    //possible scenarios. On the other hand, with simple operations (e.g., random UnitInfo & numeric type) it might
    //be better to use PerformManagedOperationValues. 
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        ErrorTypes errorType = InternalMethods.GetOperationError
        (
            firstInfo, secondInfo, operation
        );
        if (errorType != ErrorTypes.None)
        {
            return new UnitInfo(firstInfo) 
            {{
                Error = new ErrorInfo(errorType); 
            }};
        }

        return
        (
            operation == Operations.Addition || operation == Operations.Subtraction ?
            PerformManagedOperationAddition(firstInfo, secondInfo, operation) :
            PerformManagedOperationMultiplication(firstInfo, secondInfo, operation)
        );
    }

    static UnitInfo PerformManagedOperationAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {   
        //After being normalised, the operands might require further modifications.
        UnitInfo[] normalised = GetOperandsAddition(firstInfo, secondInfo, operation);

        return PerformManagedOperationNormalisedValues
        (
            firstInfo, normalised, operation
        );
    }

    static UnitInfo[] GetOperandsAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        UnitInfo[] operands2 = new UnitInfo[] 
        {
            new UnitInfo(firstInfo), new UnitInfo(secondInfo)
        };

        if (operands2[0].BaseTenExponent != operands2[1].BaseTenExponent || operands2[0].Prefix.Factor != operands2[1].Prefix.Factor)
        {
            //The addition/subtraction might not be performed right away even with normalised values.
            //For example: 5 and 6 from 5*10^2 and 6*10^7 cannot be added right away.
            operands2 = AdaptNormalisedValuesForAddition
            (
                new UnitInfo[] 
                { 
                    NormaliseUnitInfo(operands2[0]), 
                    NormaliseUnitInfo(operands2[1])
                },
                operation
            );
        }

        return operands2;
    }
    
    static UnitInfo[] AdaptNormalisedValuesForAddition(UnitInfo[] unitInfos2, Operations operation)
    {
        if (unitInfos2[0].BaseTenExponent == unitInfos2[1].BaseTenExponent)
        {
            //Having the same BaseTenExponent values means that the given operation can be performed right away.
            return unitInfos2;
        }

        int[] bigSmallI = 
        (
            unitInfos2[0].BaseTenExponent > unitInfos2[1].BaseTenExponent ?
            new int[] { 0, 1 } : new int[] { 1, 0 }
        );

        //Only the variable with the bigger value is modified. For example: 5*10^5 & 3*10^3 is converted
        //into 500*10^3 & 3*10^3 in order to allow the addition 500 + 3. 
        UnitInfo big2 = AdaptBiggerAdditionOperand(unitInfos2, bigSmallI, operation);
        if (big2.Error.Type != ErrorTypes.None)
        {
            return TooBigGapAddition(unitInfos2, bigSmallI, operation);
        }

        unitInfos2[bigSmallI[0]].Value = big2.Value;
        unitInfos2[bigSmallI[0]].BaseTenExponent = unitInfos2[bigSmallI[1]].BaseTenExponent;

        return unitInfos2;
    }

    //When adding/subtracting two numbers whose gap is bigger than the maximum double range, there
    //is no need to perform any operation (i.e., no change will be observed because of being outside
    //the maximum supported precision). This method takes care of these cases and returns the expected
    //output (i.e., biggest value).
    static UnitInfo[] TooBigGapAddition(UnitInfo[] unitInfos2, int[] bigSmallI, Operations operation)
    {
        UnitInfo[] outInfos = new UnitInfo[] 
        {
            //First operand (i.e., one whose information defines the operation) together with the
            //numeric information (i.e., just Value and BaseTenExponent because both are normalised)
            //which is associated with the biggest one.
            new UnitInfo(unitInfos2[0])
            {{
                Value = unitInfos2[bigSmallI[0]].Value;
                BaseTenExponent = unitInfos2[bigSmallI[0]].BaseTenExponent;
            }}
        };

        if (operation == Operations.Subtraction && bigSmallI[0] == 1)
        {
            outInfos[0].Value = -1.0 * outInfos[0].Value;
        }

        if (outInfos[0].Unit == Units.Unitless)
        {
            outInfos[0].Unit = unitInfos2[bigSmallI[1]].Unit;
        }

        return outInfos;
    }

    static UnitInfo AdaptBiggerAdditionOperand(UnitInfo[] unitInfos2, int[] bigSmallI, Operations operation)
    {
        int gapExponent = unitInfos2[bigSmallI[0]].BaseTenExponent - unitInfos2[bigSmallI[1]].BaseTenExponent;
        if (gapExponent >= 27)
        {
            //The difference between both inputs is bigger than (or, at least, very close to) the maximum double value/precision;
            //what makes this situation calculation unworthy and the first operand to be returned as the result.
            //Note that the error below these lines is just an easy way to tell the calling function about this eventuality.
            return new UnitInfo(unitInfos2[0]) 
            {{ 
                Error = new ErrorInfo(ErrorTypes.InvalidOperation); 
            }};
        }

        //PerformManagedOperationValues is used to make sure that the resulting numeric information is stored
        //in Value (if possible).
        UnitInfo big2 = PerformManagedOperationValues
        (
            RaiseToIntegerExponent(10.0, gapExponent), unitInfos2[bigSmallI[0]].Value, 
            Operations.Multiplication                
        );

        boolean isWrong = 
        (
            big2.Error.Type != ErrorTypes.None || big2.BaseTenExponent != 0 ?
            
            //The value of the bigger input times 10^(gap between BaseTenExponent of inputs) is too big. 
            isWrong = true :
            
            //Overflow-check very unlikely to trigger an error. In fact, with properly normalised variables,
            //triggering an error would be plainly impossible.               
            AreAdditionFinalValuesWrong
            (
                unitInfos2[0].Value, unitInfos2[1].Value, operation
            )
        );

        if (isWrong)
        {
        	//This error is just an easy way to let the calling function know about the fact that no
            //calculation has been performed (too big gap). This isn't a properly-speaking error and
            //that's why it will not be notified to the user.
        	return new UnitInfo(unitInfos2[0])
            {{
            	Error = new ErrorInfo(ErrorTypes.InvalidOperation);
                 }};
        }
        else
        {
            //Returning the new big value. For example: with 5*10^4 & 3*10^2, 500 would be returned.
            return new UnitInfo(unitInfos2[bigSmallI[0]])
            {{
                Value = big2.Value;
            }};
        }

        
        return
        (
            isWrong ?
            //This error is just an easy way to let the calling function know about the fact that no
            //calculation has been performed (too big gap). This isn't a properly-speaking error and
            //that's why it will not be notified to the user.
            new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }} :
            //Returning the new big value. For example: with 5*10^4 & 3*10^2, 500 would be returned.
            new UnitInfo(unitInfos2[bigSmallI[0]])
            {{
                Value = big2.Value;
            }}
        );
    }

    static boolean AreAdditionFinalValuesWrong(double val1, double val2, Operations operation)
    {
        boolean isWrong = false;

        try
        {
            val1 = val1 + val2 *
            (
                operation == Operations.Addition ? 1 : -1
            );
        }
        catch { isWrong = true; }

        return isWrong;
    }

    static UnitInfo PerformManagedOperationMultiplication(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationNormalisedValues
        (
            firstInfo, new UnitInfo[] 
            { 
                NormaliseUnitInfo(firstInfo),
                NormaliseUnitInfo(secondInfo) 
            },
            operation
        );
    }

    public static UnitInfo RaiseToIntegerExponent(double baseValue, int exponent)
    {
        return RaiseToIntegerExponent(new UnitInfo(baseValue), exponent);
    }

    static UnitInfo RaiseToIntegerExponent(UnitInfo baseInfo, int exponent)
    {
        if (exponent <= 1 && exponent >= 0)
        {
            baseInfo.Value = (exponent == 0 ? 1.0 : baseInfo.Value);
            return baseInfo;
        }

        UnitInfo outInfo = new UnitInfo(baseInfo);

        for (int i = 1; i < Math.Abs(exponent); i++)
        {
            outInfo = PerformManagedOperationValues
            (
                outInfo, baseInfo, Operations.Multiplication
            );
            if (outInfo.Error.Type != ErrorTypes.None) return outInfo;
        }

        return
        (
            exponent < 0 ?
            PerformManagedOperationValues(new UnitInfo(1.0), outInfo, Operations.Division) :
            outInfo
        );
    }

    static UnitInfo PerformManagedOperationNormalisedValues(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        outInfo =
        (
            normalisedInfos.Length == 1 ?
            //There is just one operand when the difference between both of them is too big.
            outInfo = normalisedInfos[0] :
            PerformManagedOperationTwoOperands(outInfo, normalisedInfos, operation)
        );

        return outInfo;
    }

    static UnitInfo PerformManagedOperationTwoOperands(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        UnitInfo outInfoNormalised = PerformManagedOperationValues
        (
            normalisedInfos[0], normalisedInfos[1], operation
        );

        if (outInfo.Error.Type != ErrorTypes.None)
        {
            return new UnitInfo(outInfo)
            {
                Error = new ErrorInfo(ErrorTypes.NumericError)
            };
        }

        outInfo.BaseTenExponent = outInfoNormalised.BaseTenExponent;
        outInfo.Value = outInfoNormalised.Value;
        //Normalised means no prefixes.
        outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage); 

        return outInfo;
    }

    static UnitInfo PerformManagedOperationValues(double firstValue, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            new UnitInfo(firstValue), new UnitInfo(secondValue), operation
        );
    }

    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            firstInfo, new UnitInfo(secondValue), operation
        );
    }

    //This method might be used to perform full operations (not just being the last calculation step) instead
    //of the default one (PerformManagedOperationUnits) for simple cases. That is: ones not dealing with the
    //complex numeric reality (Value, Prefix and BaseTenExponent) which makes a pre-analysis required.
    //Note that, unlikely what happens with PerformMangedOperationUnits, the outputs of this method aren't
    //normalised (= primarily stored under Value), what is useful in certain contexts.
    //NOTE: this function assumes that both inputs are normalised, what means that no prefix information is expected.
    //It might also be used with non-normalised inputs, but their prefix information would be plainly ignored.
    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        if (firstInfo.Value == 0.0 || secondInfo.Value == 0.0)
        {
            if (operation == Operations.Multiplication || operation == Operations.Division)
            {
                //Dividing by zero scenarios are taken into account somewhere else.
                return new UnitInfo(firstInfo) { Value = 0.0 };
            }
        }

        UnitInfo outInfo = new UnitInfo(firstInfo);
        UnitInfo firstInfo0 = new UnitInfo(firstInfo);
        UnitInfo secondInfo0 = new UnitInfo(secondInfo);

        boolean isWrong = false;
        try
        {
            if (operation == Operations.Addition)
            {
                outInfo.Value += secondInfo0.Value;
            }
            else if (operation == Operations.Subtraction)
            {
                outInfo.Value -= secondInfo.Value;
            }
            else
            {
                //The reason for checking whether BaseTenExponent is inside/outside the int range before performing 
                //the operation (rather than going ahead and eventually catching the resulting exception) isn't just
                //being quicker, but also the only option in many situations. Note that an addition/subtraction between
                //two int variables whose result is outside the int range might not trigger an exception (+ random 
                //negative value as output).
                if (VaryBaseTenExponent(outInfo, secondInfo0.BaseTenExponent, operation == Operations.Division).Error.Type != ErrorTypes.None)
                {
                    return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
                }

                if (operation == Operations.Multiplication)
                {
                    outInfo.Value *= secondInfo.Value;
                    outInfo.BaseTenExponent += secondInfo.BaseTenExponent;
                }
                else if (operation == Operations.Division)
                {
                    if (secondInfo.Value == 0.0)
                    {
                        return
                        (
                            new UnitInfo(outInfo) 
                            { 
                                Error = new ErrorInfo(ErrorTypes.NumericError) 
                            }
                        );
                    }
                    outInfo.Value /= secondInfo.Value;
                    outInfo.BaseTenExponent -= secondInfo.BaseTenExponent;
                }
            }
        }
        catch { isWrong = true; }

        return
        (
            //An error might not be triggered despite of dealing with numbers outside double precision.
            //For example: 0.00000000000000000001m * 0.0000000000000000000001m can output 0.0 without triggering an error. 
            isWrong || ((operation == Operations.Multiplication || operation == Operations.Division) && outInfo.Value == 0.0.0) ?
            OperationValuesManageError(firstInfo0, secondInfo0, operation) : outInfo
        );
    }

    static UnitInfo OperationValuesManageError(UnitInfo outInfo, UnitInfo secondInfo, Operations operation)
    {
        if (operation != Operations.Multiplication && operation != Operations.Division)
        {
            //This condition should never be true on account of the fact that the pre-modifications performed before
            //adding/subtracting should avoid erroneous situations.
            return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
        }

        UnitInfo secondInfo2 = ConvertValueToBaseTen(secondInfo.Value);
        outInfo = VaryBaseTenExponent(outInfo, secondInfo2.BaseTenExponent, operation == Operations.Division);
        if (Math.Abs(secondInfo2.Value) == 1.0 || outInfo.Error.Type != ErrorTypes.None) return outInfo;
        
        try
        {
            outInfo = PerformManagedOperationUnits
            (
                outInfo, secondInfo2.Value, operation
            );
        }
        catch
        {
            //Very unlikely scenario on account of the fact that Math.Abs(secondInfo2.Value)
            //lies within the 0.1-10.0 range.
            outInfo = OperationValuesManageError
            (
                new UnitInfo(outInfo)
                {
                    Value = secondInfo2.Value,
                    BaseTenExponent = 0
                },
                new UnitInfo()
                {
                    Value = outInfo.Value,
                    BaseTenExponent = outInfo.BaseTenExponent
                },
                operation
            );
        }

        return outInfo;
    }

    static UnitInfo ConvertValueToBaseTen(double value)
    {
        value = Math.Abs(value);
        return FromValueToBaseTenExponent
        (
             new UnitInfo(value), Math.Abs(value), false
        );
    }

    static UnitInfo ConvertBaseTenToValue(UnitInfo unitInfo)
    {
        if (unitInfo.BaseTenExponent == 0) return unitInfo;

        UnitInfo outInfo = new UnitInfo(unitInfo);
        boolean decrease = unitInfo.BaseTenExponent > 0;
        int sign = Math.Sign(outInfo.Value);
        double absValue = Math.Abs(outInfo.Value);

        while (outInfo.BaseTenExponent != 0.0)
        {
            if (decrease)
            {
                if (absValue >= MaxValueDec / 10.0) break;
                absValue *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }
            else
            {
                if (absValue <= MinValueDec * 10.0) break;
                absValue /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
        }

        outInfo.Value = sign * absValue;

        return outInfo;
    }

    static UnitInfo NormaliseUnitInfo(UnitInfo unitInfo)
    {
        if (unitInfo.Value == 0 && unitInfo.Prefix.Factor == 1.0)
        {
            return unitInfo;
        }
        UnitInfo outInfo = new UnitInfo(unitInfo);

        if (outInfo.Prefix.Factor != 1)
        {
            outInfo = FromValueToBaseTenExponent
            (
                outInfo, outInfo.Prefix.Factor, true
            );
            outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage);
        }
        if (outInfo.Value == 0.0) return outInfo;

        outInfo = FromValueToBaseTenExponent
        (
            outInfo, outInfo.Value, false
        );

        return outInfo;
    }

    static UnitInfo FromValueToBaseTenExponent(UnitInfo outInfo, double value, boolean isPrefix)
    {
        if (value == 0.0) return outInfo;

        double valueAbs = Math.Abs(value);
        boolean decrease = (valueAbs > 1.0);
        if (!isPrefix)
        {
            outInfo.Value = outInfo.Value / valueAbs;
        }

        while (valueAbs != 1.0)
        {
            if ((valueAbs < 10.0 && valueAbs > 1.0) || (valueAbs > 0.1.0 && valueAbs < 1.0))
            {
                if (!isPrefix) outInfo.Value = value;
                else
                {
                    outInfo = PerformManagedOperationValues
                    (
                        outInfo, value, Operations.Multiplication
                    );
                }

                return outInfo;
            }

            if (decrease)
            {
                value /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
            else
            {
                value *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }

            valueAbs = Math.Abs(value);
        }

        return outInfo;
    }

    //Method used to vary BaseTenExponent without provoking unhandled exceptions (i.e., bigger than Integer.MAX_VALUE).
    static UnitInfo VaryBaseTenExponent(UnitInfo info, int baseTenIncrease, boolean isDivision = false)
    {
        long val1 = info.BaseTenExponent;
        long val2 = baseTenIncrease;

        if (isDivision)
        {
            //Converting a negative value into positive might provoke an overflow error for the int type
            //(e.g., Math.Abs(Integer.MAIN_VALUE)). Converting both variables to long is a quick and effective
            //way to avoid this problem.
            val2 *= -1;
        }

        return
        (
             ((val2 > 0 && val1 > Integer.MAX_VALUE - val2) || (val2 < 0 && val1 < Integer.MAIN_VALUE - val2)) ?
            new UnitInfo(info, ErrorTypes.NumericError) : new UnitInfo(info){{ BaseTenExponent = (int)(val1 + val2); }}
        );
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 2 2017-05-27 19:58:34.140
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 0 2017-05-27 19:58:34.140
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.core 4 4 2017-05-27 19:58:36.125
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
public class OperationsManaged
{
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, double second, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            firstInfo, new UnitInfo(second), operation
        );
    }

    public static UnitInfo PerformManagedOperationUnits(double first, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            new UnitInfo(first), secondInfo, operation
        );
    }

    //This method should always be used when dealing with random UnitInfo variables because it accounts for all the
    //possible scenarios. On the other hand, with simple operations (e.g., random UnitInfo & numeric type) it might
    //be better to use PerformManagedOperationValues. 
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        ErrorTypes errorType = InternalMethods.GetOperationError
        (
            firstInfo, secondInfo, operation
        );
        if (errorType != ErrorTypes.None)
        {
            return new UnitInfo(firstInfo) 
            {{
                Error = new ErrorInfo(errorType); 
            }};
        }

        return
        (
            operation == Operations.Addition || operation == Operations.Subtraction ?
            PerformManagedOperationAddition(firstInfo, secondInfo, operation) :
            PerformManagedOperationMultiplication(firstInfo, secondInfo, operation)
        );
    }

    static UnitInfo PerformManagedOperationAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {   
        //After being normalised, the operands might require further modifications.
        UnitInfo[] normalised = GetOperandsAddition(firstInfo, secondInfo, operation);

        return PerformManagedOperationNormalisedValues
        (
            firstInfo, normalised, operation
        );
    }

    static UnitInfo[] GetOperandsAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        UnitInfo[] operands2 = new UnitInfo[] 
        {
            new UnitInfo(firstInfo), new UnitInfo(secondInfo)
        };

        if (operands2[0].BaseTenExponent != operands2[1].BaseTenExponent || operands2[0].Prefix.Factor != operands2[1].Prefix.Factor)
        {
            //The addition/subtraction might not be performed right away even with normalised values.
            //For example: 5 and 6 from 5*10^2 and 6*10^7 cannot be added right away.
            operands2 = AdaptNormalisedValuesForAddition
            (
                new UnitInfo[] 
                { 
                    NormaliseUnitInfo(operands2[0]), 
                    NormaliseUnitInfo(operands2[1])
                },
                operation
            );
        }

        return operands2;
    }
    
    static UnitInfo[] AdaptNormalisedValuesForAddition(UnitInfo[] unitInfos2, Operations operation)
    {
        if (unitInfos2[0].BaseTenExponent == unitInfos2[1].BaseTenExponent)
        {
            //Having the same BaseTenExponent values means that the given operation can be performed right away.
            return unitInfos2;
        }

        int[] bigSmallI = 
        (
            unitInfos2[0].BaseTenExponent > unitInfos2[1].BaseTenExponent ?
            new int[] { 0, 1 } : new int[] { 1, 0 }
        );

        //Only the variable with the bigger value is modified. For example: 5*10^5 & 3*10^3 is converted
        //into 500*10^3 & 3*10^3 in order to allow the addition 500 + 3. 
        UnitInfo big2 = AdaptBiggerAdditionOperand(unitInfos2, bigSmallI, operation);
        if (big2.Error.Type != ErrorTypes.None)
        {
            return TooBigGapAddition(unitInfos2, bigSmallI, operation);
        }

        unitInfos2[bigSmallI[0]].Value = big2.Value;
        unitInfos2[bigSmallI[0]].BaseTenExponent = unitInfos2[bigSmallI[1]].BaseTenExponent;

        return unitInfos2;
    }

    //When adding/subtracting two numbers whose gap is bigger than the maximum double range, there
    //is no need to perform any operation (i.e., no change will be observed because of being outside
    //the maximum supported precision). This method takes care of these cases and returns the expected
    //output (i.e., biggest value).
    static UnitInfo[] TooBigGapAddition(UnitInfo[] unitInfos2, int[] bigSmallI, Operations operation)
    {
        UnitInfo[] outInfos = new UnitInfo[] 
        {
            //First operand (i.e., one whose information defines the operation) together with the
            //numeric information (i.e., just Value and BaseTenExponent because both are normalised)
            //which is associated with the biggest one.
            new UnitInfo(unitInfos2[0])
            {{
                Value = unitInfos2[bigSmallI[0]].Value;
                BaseTenExponent = unitInfos2[bigSmallI[0]].BaseTenExponent;
            }}
        };

        if (operation == Operations.Subtraction && bigSmallI[0] == 1)
        {
            outInfos[0].Value = -1.0 * outInfos[0].Value;
        }

        if (outInfos[0].Unit == Units.Unitless)
        {
            outInfos[0].Unit = unitInfos2[bigSmallI[1]].Unit;
        }

        return outInfos;
    }

    static UnitInfo AdaptBiggerAdditionOperand(UnitInfo[] unitInfos2, int[] bigSmallI, Operations operation)
    {
        int gapExponent = unitInfos2[bigSmallI[0]].BaseTenExponent - unitInfos2[bigSmallI[1]].BaseTenExponent;
        if (gapExponent >= 27)
        {
            //The difference between both inputs is bigger than (or, at least, very close to) the maximum double value/precision;
            //what makes this situation calculation unworthy and the first operand to be returned as the result.
            //Note that the error below these lines is just an easy way to tell the calling function about this eventuality.
            return new UnitInfo(unitInfos2[0]) 
            {{ 
                Error = new ErrorInfo(ErrorTypes.InvalidOperation); 
            }};
        }

        //PerformManagedOperationValues is used to make sure that the resulting numeric information is stored
        //in Value (if possible).
        UnitInfo big2 = PerformManagedOperationValues
        (
            RaiseToIntegerExponent(10.0, gapExponent), unitInfos2[bigSmallI[0]].Value, 
            Operations.Multiplication                
        );

        boolean isWrong = 
        (
            big2.Error.Type != ErrorTypes.None || big2.BaseTenExponent != 0 ?
            
            //The value of the bigger input times 10^(gap between BaseTenExponent of inputs) is too big. 
            isWrong = true :
            
            //Overflow-check very unlikely to trigger an error. In fact, with properly normalised variables,
            //triggering an error would be plainly impossible.               
            AreAdditionFinalValuesWrong
            (
                unitInfos2[0].Value, unitInfos2[1].Value, operation
            )
        );

        if (isWrong)
        {
        	//This error is just an easy way to let the calling function know about the fact that no
            //calculation has been performed (too big gap). This isn't a properly-speaking error and
            //that's why it will not be notified to the user.
        	return new UnitInfo(unitInfos2[0])
            {{
            	Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }};
        }
        else
        {
            //Returning the new big value. For example: with 5*10^4 & 3*10^2, 500 would be returned.
            return new UnitInfo(unitInfos2[bigSmallI[0]])
            {{
                Value = big2.Value;
            }};
        }

        
        return
        (
            isWrong ?
            //This error is just an easy way to let the calling function know about the fact that no
            //calculation has been performed (too big gap). This isn't a properly-speaking error and
            //that's why it will not be notified to the user.
            new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }} :
            //Returning the new big value. For example: with 5*10^4 & 3*10^2, 500 would be returned.
            new UnitInfo(unitInfos2[bigSmallI[0]])
            {{
                Value = big2.Value;
            }}
        );
    }

    static boolean AreAdditionFinalValuesWrong(double val1, double val2, Operations operation)
    {
        boolean isWrong = false;

        try
        {
            val1 = val1 + val2 *
            (
                operation == Operations.Addition ? 1 : -1
            );
        }
        catch { isWrong = true; }

        return isWrong;
    }

    static UnitInfo PerformManagedOperationMultiplication(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationNormalisedValues
        (
            firstInfo, new UnitInfo[] 
            { 
                NormaliseUnitInfo(firstInfo),
                NormaliseUnitInfo(secondInfo) 
            },
            operation
        );
    }

    public static UnitInfo RaiseToIntegerExponent(double baseValue, int exponent)
    {
        return RaiseToIntegerExponent(new UnitInfo(baseValue), exponent);
    }

    static UnitInfo RaiseToIntegerExponent(UnitInfo baseInfo, int exponent)
    {
        if (exponent <= 1 && exponent >= 0)
        {
            baseInfo.Value = (exponent == 0 ? 1.0 : baseInfo.Value);
            return baseInfo;
        }

        UnitInfo outInfo = new UnitInfo(baseInfo);

        for (int i = 1; i < Math.Abs(exponent); i++)
        {
            outInfo = PerformManagedOperationValues
            (
                outInfo, baseInfo, Operations.Multiplication
            );
            if (outInfo.Error.Type != ErrorTypes.None) return outInfo;
        }

        return
        (
            exponent < 0 ?
            PerformManagedOperationValues(new UnitInfo(1.0), outInfo, Operations.Division) :
            outInfo
        );
    }

    static UnitInfo PerformManagedOperationNormalisedValues(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        outInfo =
        (
            normalisedInfos.Length == 1 ?
            //There is just one operand when the difference between both of them is too big.
            outInfo = normalisedInfos[0] :
            PerformManagedOperationTwoOperands(outInfo, normalisedInfos, operation)
        );

        return outInfo;
    }

    static UnitInfo PerformManagedOperationTwoOperands(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        UnitInfo outInfoNormalised = PerformManagedOperationValues
        (
            normalisedInfos[0], normalisedInfos[1], operation
        );

        if (outInfo.Error.Type != ErrorTypes.None)
        {
            return new UnitInfo(outInfo)
            {
                Error = new ErrorInfo(ErrorTypes.NumericError)
            };
        }

        outInfo.BaseTenExponent = outInfoNormalised.BaseTenExponent;
        outInfo.Value = outInfoNormalised.Value;
        //Normalised means no prefixes.
        outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage); 

        return outInfo;
    }

    static UnitInfo PerformManagedOperationValues(double firstValue, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            new UnitInfo(firstValue), new UnitInfo(secondValue), operation
        );
    }

    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            firstInfo, new UnitInfo(secondValue), operation
        );
    }

    //This method might be used to perform full operations (not just being the last calculation step) instead
    //of the default one (PerformManagedOperationUnits) for simple cases. That is: ones not dealing with the
    //complex numeric reality (Value, Prefix and BaseTenExponent) which makes a pre-analysis required.
    //Note that, unlikely what happens with PerformMangedOperationUnits, the outputs of this method aren't
    //normalised (= primarily stored under Value), what is useful in certain contexts.
    //NOTE: this function assumes that both inputs are normalised, what means that no prefix information is expected.
    //It might also be used with non-normalised inputs, but their prefix information would be plainly ignored.
    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        if (firstInfo.Value == 0.0 || secondInfo.Value == 0.0)
        {
            if (operation == Operations.Multiplication || operation == Operations.Division)
            {
                //Dividing by zero scenarios are taken into account somewhere else.
                return new UnitInfo(firstInfo) { Value = 0.0 };
            }
        }

        UnitInfo outInfo = new UnitInfo(firstInfo);
        UnitInfo firstInfo0 = new UnitInfo(firstInfo);
        UnitInfo secondInfo0 = new UnitInfo(secondInfo);

        boolean isWrong = false;
        try
        {
            if (operation == Operations.Addition)
            {
                outInfo.Value += secondInfo0.Value;
            }
            else if (operation == Operations.Subtraction)
            {
                outInfo.Value -= secondInfo.Value;
            }
            else
            {
                //The reason for checking whether BaseTenExponent is inside/outside the int range before performing 
                //the operation (rather than going ahead and eventually catching the resulting exception) isn't just
                //being quicker, but also the only option in many situations. Note that an addition/subtraction between
                //two int variables whose result is outside the int range might not trigger an exception (+ random 
                //negative value as output).
                if (VaryBaseTenExponent(outInfo, secondInfo0.BaseTenExponent, operation == Operations.Division).Error.Type != ErrorTypes.None)
                {
                    return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
                }

                if (operation == Operations.Multiplication)
                {
                    outInfo.Value *= secondInfo.Value;
                    outInfo.BaseTenExponent += secondInfo.BaseTenExponent;
                }
                else if (operation == Operations.Division)
                {
                    if (secondInfo.Value == 0.0)
                    {
                        return
                        (
                            new UnitInfo(outInfo) 
                            { 
                                Error = new ErrorInfo(ErrorTypes.NumericError) 
                            }
                        );
                    }
                    outInfo.Value /= secondInfo.Value;
                    outInfo.BaseTenExponent -= secondInfo.BaseTenExponent;
                }
            }
        }
        catch { isWrong = true; }

        return
        (
            //An error might not be triggered despite of dealing with numbers outside double precision.
            //For example: 0.00000000000000000001m * 0.0000000000000000000001m can output 0.0 without triggering an error. 
            isWrong || ((operation == Operations.Multiplication || operation == Operations.Division) && outInfo.Value == 0.0.0) ?
            OperationValuesManageError(firstInfo0, secondInfo0, operation) : outInfo
        );
    }

    static UnitInfo OperationValuesManageError(UnitInfo outInfo, UnitInfo secondInfo, Operations operation)
    {
        if (operation != Operations.Multiplication && operation != Operations.Division)
        {
            //This condition should never be true on account of the fact that the pre-modifications performed before
            //adding/subtracting should avoid erroneous situations.
            return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
        }

        UnitInfo secondInfo2 = ConvertValueToBaseTen(secondInfo.Value);
        outInfo = VaryBaseTenExponent(outInfo, secondInfo2.BaseTenExponent, operation == Operations.Division);
        if (Math.Abs(secondInfo2.Value) == 1.0 || outInfo.Error.Type != ErrorTypes.None) return outInfo;
        
        try
        {
            outInfo = PerformManagedOperationUnits
            (
                outInfo, secondInfo2.Value, operation
            );
        }
        catch
        {
            //Very unlikely scenario on account of the fact that Math.Abs(secondInfo2.Value)
            //lies within the 0.1-10.0 range.
            outInfo = OperationValuesManageError
            (
                new UnitInfo(outInfo)
                {
                    Value = secondInfo2.Value,
                    BaseTenExponent = 0
                },
                new UnitInfo()
                {
                    Value = outInfo.Value,
                    BaseTenExponent = outInfo.BaseTenExponent
                },
                operation
            );
        }

        return outInfo;
    }

    static UnitInfo ConvertValueToBaseTen(double value)
    {
        value = Math.Abs(value);
        return FromValueToBaseTenExponent
        (
             new UnitInfo(value), Math.Abs(value), false
        );
    }

    static UnitInfo ConvertBaseTenToValue(UnitInfo unitInfo)
    {
        if (unitInfo.BaseTenExponent == 0) return unitInfo;

        UnitInfo outInfo = new UnitInfo(unitInfo);
        boolean decrease = unitInfo.BaseTenExponent > 0;
        int sign = Math.Sign(outInfo.Value);
        double absValue = Math.Abs(outInfo.Value);

        while (outInfo.BaseTenExponent != 0.0)
        {
            if (decrease)
            {
                if (absValue >= MaxValueDec / 10.0) break;
                absValue *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }
            else
            {
                if (absValue <= MinValueDec * 10.0) break;
                absValue /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
        }

        outInfo.Value = sign * absValue;

        return outInfo;
    }

    static UnitInfo NormaliseUnitInfo(UnitInfo unitInfo)
    {
        if (unitInfo.Value == 0 && unitInfo.Prefix.Factor == 1.0)
        {
            return unitInfo;
        }
        UnitInfo outInfo = new UnitInfo(unitInfo);

        if (outInfo.Prefix.Factor != 1)
        {
            outInfo = FromValueToBaseTenExponent
            (
                outInfo, outInfo.Prefix.Factor, true
            );
            outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage);
        }
        if (outInfo.Value == 0.0) return outInfo;

        outInfo = FromValueToBaseTenExponent
        (
            outInfo, outInfo.Value, false
        );

        return outInfo;
    }

    static UnitInfo FromValueToBaseTenExponent(UnitInfo outInfo, double value, boolean isPrefix)
    {
        if (value == 0.0) return outInfo;

        double valueAbs = Math.Abs(value);
        boolean decrease = (valueAbs > 1.0);
        if (!isPrefix)
        {
            outInfo.Value = outInfo.Value / valueAbs;
        }

        while (valueAbs != 1.0)
        {
            if ((valueAbs < 10.0 && valueAbs > 1.0) || (valueAbs > 0.1.0 && valueAbs < 1.0))
            {
                if (!isPrefix) outInfo.Value = value;
                else
                {
                    outInfo = PerformManagedOperationValues
                    (
                        outInfo, value, Operations.Multiplication
                    );
                }

                return outInfo;
            }

            if (decrease)
            {
                value /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
            else
            {
                value *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }

            valueAbs = Math.Abs(value);
        }

        return outInfo;
    }

    //Method used to vary BaseTenExponent without provoking unhandled exceptions (i.e., bigger than Integer.MAX_VALUE).
    static UnitInfo VaryBaseTenExponent(UnitInfo info, int baseTenIncrease, boolean isDivision = false)
    {
        long val1 = info.BaseTenExponent;
        long val2 = baseTenIncrease;

        if (isDivision)
        {
            //Converting a negative value into positive might provoke an overflow error for the int type
            //(e.g., Math.Abs(Integer.MAIN_VALUE)). Converting both variables to long is a quick and effective
            //way to avoid this problem.
            val2 *= -1;
        }

        return
        (
             ((val2 > 0 && val1 > Integer.MAX_VALUE - val2) || (val2 < 0 && val1 < Integer.MAIN_VALUE - val2)) ?
            new UnitInfo(info, ErrorTypes.NumericError) : new UnitInfo(info){{ BaseTenExponent = (int)(val1 + val2); }}
        );
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2017-05-27 19:58:36.126
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2017-05-27 19:58:36.127
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2017-05-27 19:58:36.156
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
public class OperationsManaged
{
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, double second, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            firstInfo, new UnitInfo(second), operation
        );
    }

    public static UnitInfo PerformManagedOperationUnits(double first, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            new UnitInfo(first), secondInfo, operation
        );
    }

    //This method should always be used when dealing with random UnitInfo variables because it accounts for all the
    //possible scenarios. On the other hand, with simple operations (e.g., random UnitInfo & numeric type) it might
    //be better to use PerformManagedOperationValues. 
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        ErrorTypes errorType = InternalMethods.GetOperationError
        (
            firstInfo, secondInfo, operation
        );
        if (errorType != ErrorTypes.None)
        {
            return new UnitInfo(firstInfo) 
            {{
                Error = new ErrorInfo(errorType); 
            }};
        }

        return
        (
            operation == Operations.Addition || operation == Operations.Subtraction ?
            PerformManagedOperationAddition(firstInfo, secondInfo, operation) :
            PerformManagedOperationMultiplication(firstInfo, secondInfo, operation)
        );
    }

    static UnitInfo PerformManagedOperationAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {   
        //After being normalised, the operands might require further modifications.
        UnitInfo[] normalised = GetOperandsAddition(firstInfo, secondInfo, operation);

        return PerformManagedOperationNormalisedValues
        (
            firstInfo, normalised, operation
        );
    }

    static UnitInfo[] GetOperandsAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        UnitInfo[] operands2 = new UnitInfo[] 
        {
            new UnitInfo(firstInfo), new UnitInfo(secondInfo)
        };

        if (operands2[0].BaseTenExponent != operands2[1].BaseTenExponent || operands2[0].Prefix.Factor != operands2[1].Prefix.Factor)
        {
            //The addition/subtraction might not be performed right away even with normalised values.
            //For example: 5 and 6 from 5*10^2 and 6*10^7 cannot be added right away.
            operands2 = AdaptNormalisedValuesForAddition
            (
                new UnitInfo[] 
                { 
                    NormaliseUnitInfo(operands2[0]), 
                    NormaliseUnitInfo(operands2[1])
                },
                operation
            );
        }

        return operands2;
    }
    
    static UnitInfo[] AdaptNormalisedValuesForAddition(UnitInfo[] unitInfos2, Operations operation)
    {
        if (unitInfos2[0].BaseTenExponent == unitInfos2[1].BaseTenExponent)
        {
            //Having the same BaseTenExponent values means that the given operation can be performed right away.
            return unitInfos2;
        }

        int[] bigSmallI = 
        (
            unitInfos2[0].BaseTenExponent > unitInfos2[1].BaseTenExponent ?
            new int[] { 0, 1 } : new int[] { 1, 0 }
        );

        //Only the variable with the bigger value is modified. For example: 5*10^5 & 3*10^3 is converted
        //into 500*10^3 & 3*10^3 in order to allow the addition 500 + 3. 
        UnitInfo big2 = AdaptBiggerAdditionOperand(unitInfos2, bigSmallI, operation);
        if (big2.Error.Type != ErrorTypes.None)
        {
            return TooBigGapAddition(unitInfos2, bigSmallI, operation);
        }

        unitInfos2[bigSmallI[0]].Value = big2.Value;
        unitInfos2[bigSmallI[0]].BaseTenExponent = unitInfos2[bigSmallI[1]].BaseTenExponent;

        return unitInfos2;
    }

    //When adding/subtracting two numbers whose gap is bigger than the maximum double range, there
    //is no need to perform any operation (i.e., no change will be observed because of being outside
    //the maximum supported precision). This method takes care of these cases and returns the expected
    //output (i.e., biggest value).
    static UnitInfo[] TooBigGapAddition(UnitInfo[] unitInfos2, int[] bigSmallI, Operations operation)
    {
        UnitInfo[] outInfos = new UnitInfo[] 
        {
            //First operand (i.e., one whose information defines the operation) together with the
            //numeric information (i.e., just Value and BaseTenExponent because both are normalised)
            //which is associated with the biggest one.
            new UnitInfo(unitInfos2[0])
            {{
                Value = unitInfos2[bigSmallI[0]].Value;
                BaseTenExponent = unitInfos2[bigSmallI[0]].BaseTenExponent;
            }}
        };

        if (operation == Operations.Subtraction && bigSmallI[0] == 1)
        {
            outInfos[0].Value = -1.0 * outInfos[0].Value;
        }

        if (outInfos[0].Unit == Units.Unitless)
        {
            outInfos[0].Unit = unitInfos2[bigSmallI[1]].Unit;
        }

        return outInfos;
    }

    static UnitInfo AdaptBiggerAdditionOperand(UnitInfo[] unitInfos2, int[] bigSmallI, Operations operation)
    {
        int gapExponent = unitInfos2[bigSmallI[0]].BaseTenExponent - unitInfos2[bigSmallI[1]].BaseTenExponent;
        if (gapExponent >= 27)
        {
            //The difference between both inputs is bigger than (or, at least, very close to) the maximum double value/precision;
            //what makes this situation calculation unworthy and the first operand to be returned as the result.
            //Note that the error below these lines is just an easy way to tell the calling function about this eventuality.
            return new UnitInfo(unitInfos2[0]) 
            {{ 
                Error = new ErrorInfo(ErrorTypes.InvalidOperation); 
            }};
        }

        //PerformManagedOperationValues is used to make sure that the resulting numeric information is stored
        //in Value (if possible).
        UnitInfo big2 = PerformManagedOperationValues
        (
            RaiseToIntegerExponent(10.0, gapExponent), unitInfos2[bigSmallI[0]].Value, 
            Operations.Multiplication                
        );

        boolean isWrong = 
        (
            big2.Error.Type != ErrorTypes.None || big2.BaseTenExponent != 0 ?
            
            //The value of the bigger input times 10^(gap between BaseTenExponent of inputs) is too big. 
            isWrong = true :
            
            //Overflow-check very unlikely to trigger an error. In fact, with properly normalised variables,
            //triggering an error would be plainly impossible.               
            AreAdditionFinalValuesWrong
            (
                unitInfos2[0].Value, unitInfos2[1].Value, operation
            )
        );

        if (isWrong)
        {
        	//This error is just an easy way to let the calling function know about the fact that no
            //calculation has been performed (too big gap). This isn't a properly-speaking error and
            //that's why it will not be notified to the user.
        	return new UnitInfo(unitInfos2[0])
            {{
            	Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }};
        }
        else
        {
            //Returning the new big value. For example: with 5*10^4 & 3*10^2, 500 would be returned.
            return new UnitInfo(unitInfos2[bigSmallI[0]])
            {{
                Value = big2.Value;
            }};
        }

        
        return
        (
            isWrong ?
            //This error is just an easy way to let the calling function know about the fact that no
            //calculation has been performed (too big gap). This isn't a properly-speaking error and
            //that's why it will not be notified to the user.
            new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }} :
            //Returning the new big value. For example: with 5*10^4 & 3*10^2, 500 would be returned.
            new UnitInfo(unitInfos2[bigSmallI[0]])
            {{
                Value = big2.Value;
            }}
        );
    }

    static boolean AreAdditionFinalValuesWrong(double val1, double val2, Operations operation)
    {
        boolean isWrong = false;

        try
        {
            val1 = val1 + val2 *
            (
                operation == Operations.Addition ? 1 : -1
            );
        }
        catch { isWrong = true; }

        return isWrong;
    }

    static UnitInfo PerformManagedOperationMultiplication(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationNormalisedValues
        (
            firstInfo, new UnitInfo[] 
            { 
                NormaliseUnitInfo(firstInfo),
                NormaliseUnitInfo(secondInfo) 
            },
            operation
        );
    }

    public static UnitInfo RaiseToIntegerExponent(double baseValue, int exponent)
    {
        return RaiseToIntegerExponent(new UnitInfo(baseValue), exponent);
    }

    static UnitInfo RaiseToIntegerExponent(UnitInfo baseInfo, int exponent)
    {
        if (exponent <= 1 && exponent >= 0)
        {
            baseInfo.Value = (exponent == 0 ? 1.0 : baseInfo.Value);
            return baseInfo;
        }

        UnitInfo outInfo = new UnitInfo(baseInfo);

        for (int i = 1; i < Math.Abs(exponent); i++)
        {
            outInfo = PerformManagedOperationValues
            (
                outInfo, baseInfo, Operations.Multiplication
            );
            if (outInfo.Error.Type != ErrorTypes.None) return outInfo;
        }

        return
        (
            exponent < 0 ?
            PerformManagedOperationValues(new UnitInfo(1.0), outInfo, Operations.Division) :
            outInfo
        );
    }

    static UnitInfo PerformManagedOperationNormalisedValues(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        outInfo =
        (
            normalisedInfos.Length == 1 ?
            //There is just one operand when the difference between both of them is too big.
            outInfo = normalisedInfos[0] :
            PerformManagedOperationTwoOperands(outInfo, normalisedInfos, operation)
        );

        return outInfo;
    }

    static UnitInfo PerformManagedOperationTwoOperands(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        UnitInfo outInfoNormalised = PerformManagedOperationValues
        (
            normalisedInfos[0], normalisedInfos[1], operation
        );

        if (outInfo.Error.Type != ErrorTypes.None)
        {
            return new UnitInfo(outInfo)
            {
                Error = new ErrorInfo(ErrorTypes.NumericError)
            };
        }

        outInfo.BaseTenExponent = outInfoNormalised.BaseTenExponent;
        outInfo.Value = outInfoNormalised.Value;
        //Normalised means no prefixes.
        outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage); 

        return outInfo;
    }

    static UnitInfo PerformManagedOperationValues(double firstValue, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            new UnitInfo(firstValue), new UnitInfo(secondValue), operation
        );
    }

    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            firstInfo, new UnitInfo(secondValue), operation
        );
    }

    //This method might be used to perform full operations (not just being the last calculation step) instead
    //of the default one (PerformManagedOperationUnits) for simple cases. That is: ones not dealing with the
    //complex numeric reality (Value, Prefix and BaseTenExponent) which makes a pre-analysis required.
    //Note that, unlikely what happens with PerformMangedOperationUnits, the outputs of this method aren't
    //normalised (= primarily stored under Value), what is useful in certain contexts.
    //NOTE: this function assumes that both inputs are normalised, what means that no prefix information is expected.
    //It might also be used with non-normalised inputs, but their prefix information would be plainly ignored.
    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        if (firstInfo.Value == 0.0 || secondInfo.Value == 0.0)
        {
            if (operation == Operations.Multiplication || operation == Operations.Division)
            {
                //Dividing by zero scenarios are taken into account somewhere else.
                return new UnitInfo(firstInfo) { Value = 0.0 };
            }
        }

        UnitInfo outInfo = new UnitInfo(firstInfo);
        UnitInfo firstInfo0 = new UnitInfo(firstInfo);
        UnitInfo secondInfo0 = new UnitInfo(secondInfo);

        boolean isWrong = false;
        try
        {
            if (operation == Operations.Addition)
            {
                outInfo.Value += secondInfo0.Value;
            }
            else if (operation == Operations.Subtraction)
            {
                outInfo.Value -= secondInfo.Value;
            }
            else
            {
                //The reason for checking whether BaseTenExponent is inside/outside the int range before performing 
                //the operation (rather than going ahead and eventually catching the resulting exception) isn't just
                //being quicker, but also the only option in many situations. Note that an addition/subtraction between
                //two int variables whose result is outside the int range might not trigger an exception (+ random 
                //negative value as output).
                if (VaryBaseTenExponent(outInfo, secondInfo0.BaseTenExponent, operation == Operations.Division).Error.Type != ErrorTypes.None)
                {
                    return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
                }

                if (operation == Operations.Multiplication)
                {
                    outInfo.Value *= secondInfo.Value;
                    outInfo.BaseTenExponent += secondInfo.BaseTenExponent;
                }
                else if (operation == Operations.Division)
                {
                    if (secondInfo.Value == 0.0)
                    {
                        return
                        (
                            new UnitInfo(outInfo) 
                            { 
                                Error = new ErrorInfo(ErrorTypes.NumericError) 
                            }
                        );
                    }
                    outInfo.Value /= secondInfo.Value;
                    outInfo.BaseTenExponent -= secondInfo.BaseTenExponent;
                }
            }
        }
        catch { isWrong = true; }

        return
        (
            //An error might not be triggered despite of dealing with numbers outside double precision.
            //For example: 0.00000000000000000001m * 0.0000000000000000000001m can output 0.0 without triggering an error. 
            isWrong || ((operation == Operations.Multiplication || operation == Operations.Division) && outInfo.Value == 0.0.0) ?
            OperationValuesManageError(firstInfo0, secondInfo0, operation) : outInfo
        );
    }

    static UnitInfo OperationValuesManageError(UnitInfo outInfo, UnitInfo secondInfo, Operations operation)
    {
        if (operation != Operations.Multiplication && operation != Operations.Division)
        {
            //This condition should never be true on account of the fact that the pre-modifications performed before
            //adding/subtracting should avoid erroneous situations.
            return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
        }

        UnitInfo secondInfo2 = ConvertValueToBaseTen(secondInfo.Value);
        outInfo = VaryBaseTenExponent(outInfo, secondInfo2.BaseTenExponent, operation == Operations.Division);
        if (Math.Abs(secondInfo2.Value) == 1.0 || outInfo.Error.Type != ErrorTypes.None) return outInfo;
        
        try
        {
            outInfo = PerformManagedOperationUnits
            (
                outInfo, secondInfo2.Value, operation
            );
        }
        catch
        {
            //Very unlikely scenario on account of the fact that Math.Abs(secondInfo2.Value)
            //lies within the 0.1-10.0 range.
            outInfo = OperationValuesManageError
            (
                new UnitInfo(outInfo)
                {
                    Value = secondInfo2.Value,
                    BaseTenExponent = 0
                },
                new UnitInfo()
                {
                    Value = outInfo.Value,
                    BaseTenExponent = outInfo.BaseTenExponent
                },
                operation
            );
        }

        return outInfo;
    }

    static UnitInfo ConvertValueToBaseTen(double value)
    {
        value = Math.Abs(value);
        return FromValueToBaseTenExponent
        (
             new UnitInfo(value), Math.Abs(value), false
        );
    }

    static UnitInfo ConvertBaseTenToValue(UnitInfo unitInfo)
    {
        if (unitInfo.BaseTenExponent == 0) return unitInfo;

        UnitInfo outInfo = new UnitInfo(unitInfo);
        boolean decrease = unitInfo.BaseTenExponent > 0;
        int sign = Math.Sign(outInfo.Value);
        double absValue = Math.Abs(outInfo.Value);

        while (outInfo.BaseTenExponent != 0.0)
        {
            if (decrease)
            {
                if (absValue >= MaxValueDec / 10.0) break;
                absValue *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }
            else
            {
                if (absValue <= MinValueDec * 10.0) break;
                absValue /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
        }

        outInfo.Value = sign * absValue;

        return outInfo;
    }

    static UnitInfo NormaliseUnitInfo(UnitInfo unitInfo)
    {
        if (unitInfo.Value == 0 && unitInfo.Prefix.Factor == 1.0)
        {
            return unitInfo;
        }
        UnitInfo outInfo = new UnitInfo(unitInfo);

        if (outInfo.Prefix.Factor != 1)
        {
            outInfo = FromValueToBaseTenExponent
            (
                outInfo, outInfo.Prefix.Factor, true
            );
            outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage);
        }
        if (outInfo.Value == 0.0) return outInfo;

        outInfo = FromValueToBaseTenExponent
        (
            outInfo, outInfo.Value, false
        );

        return outInfo;
    }

    static UnitInfo FromValueToBaseTenExponent(UnitInfo outInfo, double value, boolean isPrefix)
    {
        if (value == 0.0) return outInfo;

        double valueAbs = Math.Abs(value);
        boolean decrease = (valueAbs > 1.0);
        if (!isPrefix)
        {
            outInfo.Value = outInfo.Value / valueAbs;
        }

        while (valueAbs != 1.0)
        {
            if ((valueAbs < 10.0 && valueAbs > 1.0) || (valueAbs > 0.1.0 && valueAbs < 1.0))
            {
                if (!isPrefix) outInfo.Value = value;
                else
                {
                    outInfo = PerformManagedOperationValues
                    (
                        outInfo, value, Operations.Multiplication
                    );
                }

                return outInfo;
            }

            if (decrease)
            {
                value /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
            else
            {
                value *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }

            valueAbs = Math.Abs(value);
        }

        return outInfo;
    }

    //Method used to vary BaseTenExponent without provoking unhandled exceptions (i.e., bigger than Integer.MAX_VALUE).
    static UnitInfo VaryBaseTenExponent(UnitInfo info, int baseTenIncrease, boolean isDivision = false)
    {
        long val1 = info.BaseTenExponent;
        long val2 = baseTenIncrease;

        if (isDivision)
        {
            //Converting a negative value into positive might provoke an overflow error for the int type
            //(e.g., Math.Abs(Integer.MAIN_VALUE)). Converting both variables to long is a quick and effective
            //way to avoid this problem.
            val2 *= -1;
        }

        return
        (
             ((val2 > 0 && val1 > Integer.MAX_VALUE - val2) || (val2 < 0 && val1 < Integer.MAIN_VALUE - val2)) ?
            new UnitInfo(info, ErrorTypes.NumericError) : new UnitInfo(info){{ BaseTenExponent = (int)(val1 + val2); }}
        );
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:476)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 2 2017-05-27 19:58:36.163
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:476)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 0 2017-05-27 19:58:36.165
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:476)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.core 4 4 2017-05-27 19:58:39.165
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
public class OperationsManaged
{
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, double second, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            firstInfo, new UnitInfo(second), operation
        );
    }

    public static UnitInfo PerformManagedOperationUnits(double first, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            new UnitInfo(first), secondInfo, operation
        );
    }

    //This method should always be used when dealing with random UnitInfo variables because it accounts for all the
    //possible scenarios. On the other hand, with simple operations (e.g., random UnitInfo & numeric type) it might
    //be better to use PerformManagedOperationValues. 
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        ErrorTypes errorType = InternalMethods.GetOperationError
        (
            firstInfo, secondInfo, operation
        );
        if (errorType != ErrorTypes.None)
        {
            return new UnitInfo(firstInfo) 
            {{
                Error = new ErrorInfo(errorType); 
            }};
        }

        return
        (
            operation == Operations.Addition || operation == Operations.Subtraction ?
            PerformManagedOperationAddition(firstInfo, secondInfo, operation) :
            PerformManagedOperationMultiplication(firstInfo, secondInfo, operation)
        );
    }

    static UnitInfo PerformManagedOperationAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {   
        //After being normalised, the operands might require further modifications.
        UnitInfo[] normalised = GetOperandsAddition(firstInfo, secondInfo, operation);

        return PerformManagedOperationNormalisedValues
        (
            firstInfo, normalised, operation
        );
    }

    static UnitInfo[] GetOperandsAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        UnitInfo[] operands2 = new UnitInfo[] 
        {
            new UnitInfo(firstInfo), new UnitInfo(secondInfo)
        };

        if (operands2[0].BaseTenExponent != operands2[1].BaseTenExponent || operands2[0].Prefix.Factor != operands2[1].Prefix.Factor)
        {
            //The addition/subtraction might not be performed right away even with normalised values.
            //For example: 5 and 6 from 5*10^2 and 6*10^7 cannot be added right away.
            operands2 = AdaptNormalisedValuesForAddition
            (
                new UnitInfo[] 
                { 
                    NormaliseUnitInfo(operands2[0]), 
                    NormaliseUnitInfo(operands2[1])
                },
                operation
            );
        }

        return operands2;
    }
    
    static UnitInfo[] AdaptNormalisedValuesForAddition(UnitInfo[] unitInfos2, Operations operation)
    {
        if (unitInfos2[0].BaseTenExponent == unitInfos2[1].BaseTenExponent)
        {
            //Having the same BaseTenExponent values means that the given operation can be performed right away.
            return unitInfos2;
        }

        int[] bigSmallI = 
        (
            unitInfos2[0].BaseTenExponent > unitInfos2[1].BaseTenExponent ?
            new int[] { 0, 1 } : new int[] { 1, 0 }
        );

        //Only the variable with the bigger value is modified. For example: 5*10^5 & 3*10^3 is converted
        //into 500*10^3 & 3*10^3 in order to allow the addition 500 + 3. 
        UnitInfo big2 = AdaptBiggerAdditionOperand(unitInfos2, bigSmallI, operation);
        if (big2.Error.Type != ErrorTypes.None)
        {
            return TooBigGapAddition(unitInfos2, bigSmallI, operation);
        }

        unitInfos2[bigSmallI[0]].Value = big2.Value;
        unitInfos2[bigSmallI[0]].BaseTenExponent = unitInfos2[bigSmallI[1]].BaseTenExponent;

        return unitInfos2;
    }

    //When adding/subtracting two numbers whose gap is bigger than the maximum double range, there
    //is no need to perform any operation (i.e., no change will be observed because of being outside
    //the maximum supported precision). This method takes care of these cases and returns the expected
    //output (i.e., biggest value).
    static UnitInfo[] TooBigGapAddition(UnitInfo[] unitInfos2, int[] bigSmallI, Operations operation)
    {
        UnitInfo[] outInfos = new UnitInfo[] 
        {
            //First operand (i.e., one whose information defines the operation) together with the
            //numeric information (i.e., just Value and BaseTenExponent because both are normalised)
            //which is associated with the biggest one.
            new UnitInfo(unitInfos2[0])
            {{
                Value = unitInfos2[bigSmallI[0]].Value;
                BaseTenExponent = unitInfos2[bigSmallI[0]].BaseTenExponent;
            }}
        };

        if (operation == Operations.Subtraction && bigSmallI[0] == 1)
        {
            outInfos[0].Value = -1.0 * outInfos[0].Value;
        }

        if (outInfos[0].Unit == Units.Unitless)
        {
            outInfos[0].Unit = unitInfos2[bigSmallI[1]].Unit;
        }

        return outInfos;
    }

    static UnitInfo AdaptBiggerAdditionOperand(UnitInfo[] unitInfos2, int[] bigSmallI, Operations operation)
    {
        int gapExponent = unitInfos2[bigSmallI[0]].BaseTenExponent - unitInfos2[bigSmallI[1]].BaseTenExponent;
        if (gapExponent >= 27)
        {
            //The difference between both inputs is bigger than (or, at least, very close to) the maximum double value/precision;
            //what makes this situation calculation unworthy and the first operand to be returned as the result.
            //Note that the error below these lines is just an easy way to tell the calling function about this eventuality.
            return new UnitInfo(unitInfos2[0]) 
            {{ 
                Error = new ErrorInfo(ErrorTypes.InvalidOperation); 
            }};
        }

        //PerformManagedOperationValues is used to make sure that the resulting numeric information is stored
        //in Value (if possible).
        UnitInfo big2 = PerformManagedOperationValues
        (
            RaiseToIntegerExponent(10.0, gapExponent), unitInfos2[bigSmallI[0]].Value, 
            Operations.Multiplication                
        );

        boolean isWrong = 
        (
            big2.Error.Type != ErrorTypes.None || big2.BaseTenExponent != 0 ?
            
            //The value of the bigger input times 10^(gap between BaseTenExponent of inputs) is too big. 
            isWrong = true :
            
            //Overflow-check very unlikely to trigger an error. In fact, with properly normalised variables,
            //triggering an error would be plainly impossible.               
            AreAdditionFinalValuesWrong
            (
                unitInfos2[0].Value, unitInfos2[1].Value, operation
            )
        );

        if (isWrong)
        {
        	//This error is just an easy way to let the calling function know about the fact that no
            //calculation has been performed (too big gap). This isn't a properly-speaking error and
            //that's why it will not be notified to the user.
        	return new UnitInfo(unitInfos2[0])
            {{
            	Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }};
        }
        else
        {
            //Returning the new big value. For example: with 5*10^4 & 3*10^2, 500 would be returned.
            return new UnitInfo(unitInfos2[bigSmallI[0]])
            {{
                Value = big2.Value;
            }};
        }

        
        return
        (
            isWrong ?
            //This error is just an easy way to let the calling function know about the fact that no
            //calculation has been performed (too big gap). This isn't a properly-speaking error and
            //that's why it will not be notified to the user.
            new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }} :
            //Returning the new big value. For example: with 5*10^4 & 3*10^2, 500 would be returned.
            new UnitInfo(unitInfos2[bigSmallI[0]])
            {{
                Value = big2.Value;
            }}
        );
    }

    static boolean AreAdditionFinalValuesWrong(double val1, double val2, Operations operation)
    {
        boolean isWrong = false;

        try
        {
            val1 = val1 + val2 *
            (
                operation == Operations.Addition ? 1 : -1
            );
        }
        catch { isWrong = true; }

        return isWrong;
    }

    static UnitInfo PerformManagedOperationMultiplication(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationNormalisedValues
        (
            firstInfo, new UnitInfo[] 
            { 
                NormaliseUnitInfo(firstInfo),
                NormaliseUnitInfo(secondInfo) 
            },
            operation
        );
    }

    public static UnitInfo RaiseToIntegerExponent(double baseValue, int exponent)
    {
        return RaiseToIntegerExponent(new UnitInfo(baseValue), exponent);
    }

    static UnitInfo RaiseToIntegerExponent(UnitInfo baseInfo, int exponent)
    {
        if (exponent <= 1 && exponent >= 0)
        {
            baseInfo.Value = (exponent == 0 ? 1.0 : baseInfo.Value);
            return baseInfo;
        }

        UnitInfo outInfo = new UnitInfo(baseInfo);

        for (int i = 1; i < Math.Abs(exponent); i++)
        {
            outInfo = PerformManagedOperationValues
            (
                outInfo, baseInfo, Operations.Multiplication
            );
            if (outInfo.Error.Type != ErrorTypes.None) return outInfo;
        }

        return
        (
            exponent < 0 ?
            PerformManagedOperationValues(new UnitInfo(1.0), outInfo, Operations.Division) :
            outInfo
        );
    }

    static UnitInfo PerformManagedOperationNormalisedValues(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        outInfo =
        (
            normalisedInfos.Length == 1 ?
            //There is just one operand when the difference between both of them is too big.
            outInfo = normalisedInfos[0] :
            PerformManagedOperationTwoOperands(outInfo, normalisedInfos, operation)
        );

        return outInfo;
    }

    static UnitInfo PerformManagedOperationTwoOperands(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        UnitInfo outInfoNormalised = PerformManagedOperationValues
        (
            normalisedInfos[0], normalisedInfos[1], operation
        );

        if (outInfo.Error.Type != ErrorTypes.None)
        {
            return new UnitInfo(outInfo)
            {
                Error = new ErrorInfo(ErrorTypes.NumericError)
            };
        }

        outInfo.BaseTenExponent = outInfoNormalised.BaseTenExponent;
        outInfo.Value = outInfoNormalised.Value;
        //Normalised means no prefixes.
        outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage); 

        return outInfo;
    }

    static UnitInfo PerformManagedOperationValues(double firstValue, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            new UnitInfo(firstValue), new UnitInfo(secondValue), operation
        );
    }

    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            firstInfo, new UnitInfo(secondValue), operation
        );
    }

    //This method might be used to perform full operations (not just being the last calculation step) instead
    //of the default one (PerformManagedOperationUnits) for simple cases. That is: ones not dealing with the
    //complex numeric reality (Value, Prefix and BaseTenExponent) which makes a pre-analysis required.
    //Note that, unlikely what happens with PerformMangedOperationUnits, the outputs of this method aren't
    //normalised (= primarily stored under Value), what is useful in certain contexts.
    //NOTE: this function assumes that both inputs are normalised, what means that no prefix information is expected.
    //It might also be used with non-normalised inputs, but their prefix information would be plainly ignored.
    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        if (firstInfo.Value == 0.0 || secondInfo.Value == 0.0)
        {
            if (operation == Operations.Multiplication || operation == Operations.Division)
            {
                //Dividing by zero scenarios are taken into account somewhere else.
                return new UnitInfo(firstInfo) { Value = 0.0 };
            }
        }

        UnitInfo outInfo = new UnitInfo(firstInfo);
        UnitInfo firstInfo0 = new UnitInfo(firstInfo);
        UnitInfo secondInfo0 = new UnitInfo(secondInfo);

        boolean isWrong = false;
        try
        {
            if (operation == Operations.Addition)
            {
                outInfo.Value += secondInfo0.Value;
            }
            else if (operation == Operations.Subtraction)
            {
                outInfo.Value -= secondInfo.Value;
            }
            else
            {
                //The reason for checking whether BaseTenExponent is inside/outside the int range before performing 
                //the operation (rather than going ahead and eventually catching the resulting exception) isn't just
                //being quicker, but also the only option in many situations. Note that an addition/subtraction between
                //two int variables whose result is outside the int range might not trigger an exception (+ random 
                //negative value as output).
                if (VaryBaseTenExponent(outInfo, secondInfo0.BaseTenExponent, operation == Operations.Division).Error.Type != ErrorTypes.None)
                {
                    return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
                }

                if (operation == Operations.Multiplication)
                {
                    outInfo.Value *= secondInfo.Value;
                    outInfo.BaseTenExponent += secondInfo.BaseTenExponent;
                }
                else if (operation == Operations.Division)
                {
                    if (secondInfo.Value == 0.0)
                    {
                        return
                        (
                            new UnitInfo(outInfo) 
                            { 
                                Error = new ErrorInfo(ErrorTypes.NumericError) 
                            }
                        );
                    }
                    outInfo.Value /= secondInfo.Value;
                    outInfo.BaseTenExponent -= secondInfo.BaseTenExponent;
                }
            }
        }
        catch { isWrong = true; }

        return
        (
            //An error might not be triggered despite of dealing with numbers outside double precision.
            //For example: 0.00000000000000000001m * 0.0000000000000000000001m can output 0.0 without triggering an error. 
            isWrong || ((operation == Operations.Multiplication || operation == Operations.Division) && outInfo.Value == 0.0.0) ?
            OperationValuesManageError(firstInfo0, secondInfo0, operation) : outInfo
        );
    }

    static UnitInfo OperationValuesManageError(UnitInfo outInfo, UnitInfo secondInfo, Operations operation)
    {
        if (operation != Operations.Multiplication && operation != Operations.Division)
        {
            //This condition should never be true on account of the fact that the pre-modifications performed before
            //adding/subtracting should avoid erroneous situations.
            return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
        }

        UnitInfo secondInfo2 = ConvertValueToBaseTen(secondInfo.Value);
        outInfo = VaryBaseTenExponent(outInfo, secondInfo2.BaseTenExponent, operation == Operations.Division);
        if (Math.Abs(secondInfo2.Value) == 1.0 || outInfo.Error.Type != ErrorTypes.None) return outInfo;
        
        try
        {
            outInfo = PerformManagedOperationUnits
            (
                outInfo, secondInfo2.Value, operation
            );
        }
        catch
        {
            //Very unlikely scenario on account of the fact that Math.Abs(secondInfo2.Value)
            //lies within the 0.1-10.0 range.
            outInfo = OperationValuesManageError
            (
                new UnitInfo(outInfo)
                {
                    Value = secondInfo2.Value,
                    BaseTenExponent = 0
                },
                new UnitInfo()
                {
                    Value = outInfo.Value,
                    BaseTenExponent = outInfo.BaseTenExponent
                },
                operation
            );
        }

        return outInfo;
    }

    static UnitInfo ConvertValueToBaseTen(double value)
    {
        value = Math.Abs(value);
        return FromValueToBaseTenExponent
        (
             new UnitInfo(value), Math.Abs(value), false
        );
    }

    static UnitInfo ConvertBaseTenToValue(UnitInfo unitInfo)
    {
        if (unitInfo.BaseTenExponent == 0) return unitInfo;

        UnitInfo outInfo = new UnitInfo(unitInfo);
        boolean decrease = unitInfo.BaseTenExponent > 0;
        int sign = Math.Sign(outInfo.Value);
        double absValue = Math.Abs(outInfo.Value);

        while (outInfo.BaseTenExponent != 0.0)
        {
            if (decrease)
            {
                if (absValue >= MaxValueDec / 10.0) break;
                absValue *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }
            else
            {
                if (absValue <= MinValueDec * 10.0) break;
                absValue /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
        }

        outInfo.Value = sign * absValue;

        return outInfo;
    }

    static UnitInfo NormaliseUnitInfo(UnitInfo unitInfo)
    {
        if (unitInfo.Value == 0 && unitInfo.Prefix.Factor == 1.0)
        {
            return unitInfo;
        }
        UnitInfo outInfo = new UnitInfo(unitInfo);

        if (outInfo.Prefix.Factor != 1)
        {
            outInfo = FromValueToBaseTenExponent
            (
                outInfo, outInfo.Prefix.Factor, true
            );
            outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage);
        }
        if (outInfo.Value == 0.0) return outInfo;

        outInfo = FromValueToBaseTenExponent
        (
            outInfo, outInfo.Value, false
        );

        return outInfo;
    }

    static UnitInfo FromValueToBaseTenExponent(UnitInfo outInfo, double value, boolean isPrefix)
    {
        if (value == 0.0) return outInfo;

        double valueAbs = Math.Abs(value);
        boolean decrease = (valueAbs > 1.0);
        if (!isPrefix)
        {
            outInfo.Value = outInfo.Value / valueAbs;
        }

        while (valueAbs != 1.0)
        {
            if ((valueAbs < 10.0 && valueAbs > 1.0) || (valueAbs > 0.1.0 && valueAbs < 1.0))
            {
                if (!isPrefix) outInfo.Value = value;
                else
                {
                    outInfo = PerformManagedOperationValues
                    (
                        outInfo, value, Operations.Multiplication
                    );
                }

                return outInfo;
            }

            if (decrease)
            {
                value /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
            else
            {
                value *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }

            valueAbs = Math.Abs(value);
        }

        return outInfo;
    }

    //Method used to vary BaseTenExponent without provoking unhandled exceptions (i.e., bigger than Integer.MAX_VALUE).
    static UnitInfo VaryBaseTenExponent(UnitInfo info, int baseTenIncrease, boolean isDivision = false)
    {
        long val1 = info.BaseTenExponent;
        long val2 = baseTenIncrease;

        if (isDivision)
        {
            //Converting a negative value into positive might provoke an overflow error for the int type
            //(e.g., Math.Abs(Integer.MAIN_VALUE)). Converting both variables to long is a quick and effective
            //way to avoid this problem.
            val2 *= -1;
        }

        return
        (
             ((val2 > 0 && val1 > Integer.MAX_VALUE - val2) || (val2 < 0 && val1 < Integer.MAIN_VALUE - val2)) ?
            new UnitInfo(info, ErrorTypes.NumericError) : new UnitInfo(info){{ BaseTenExponent = (int)(val1 + val2); }}
        );
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:207)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2017-05-27 19:58:39.166
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:207)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2017-05-27 19:58:39.166
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:207)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2017-05-27 19:58:39.188
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
public class OperationsManaged
{
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, double second, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            firstInfo, new UnitInfo(second), operation
        );
    }

    public static UnitInfo PerformManagedOperationUnits(double first, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            new UnitInfo(first), secondInfo, operation
        );
    }

    //This method should always be used when dealing with random UnitInfo variables because it accounts for all the
    //possible scenarios. On the other hand, with simple operations (e.g., random UnitInfo & numeric type) it might
    //be better to use PerformManagedOperationValues. 
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        ErrorTypes errorType = InternalMethods.GetOperationError
        (
            firstInfo, secondInfo, operation
        );
        if (errorType != ErrorTypes.None)
        {
            return new UnitInfo(firstInfo) 
            {{
                Error = new ErrorInfo(errorType); 
            }};
        }

        return
        (
            operation == Operations.Addition || operation == Operations.Subtraction ?
            PerformManagedOperationAddition(firstInfo, secondInfo, operation) :
            PerformManagedOperationMultiplication(firstInfo, secondInfo, operation)
        );
    }

    static UnitInfo PerformManagedOperationAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {   
        //After being normalised, the operands might require further modifications.
        UnitInfo[] normalised = GetOperandsAddition(firstInfo, secondInfo, operation);

        return PerformManagedOperationNormalisedValues
        (
            firstInfo, normalised, operation
        );
    }

    static UnitInfo[] GetOperandsAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        UnitInfo[] operands2 = new UnitInfo[] 
        {
            new UnitInfo(firstInfo), new UnitInfo(secondInfo)
        };

        if (operands2[0].BaseTenExponent != operands2[1].BaseTenExponent || operands2[0].Prefix.Factor != operands2[1].Prefix.Factor)
        {
            //The addition/subtraction might not be performed right away even with normalised values.
            //For example: 5 and 6 from 5*10^2 and 6*10^7 cannot be added right away.
            operands2 = AdaptNormalisedValuesForAddition
            (
                new UnitInfo[] 
                { 
                    NormaliseUnitInfo(operands2[0]), 
                    NormaliseUnitInfo(operands2[1])
                },
                operation
            );
        }

        return operands2;
    }
    
    static UnitInfo[] AdaptNormalisedValuesForAddition(UnitInfo[] unitInfos2, Operations operation)
    {
        if (unitInfos2[0].BaseTenExponent == unitInfos2[1].BaseTenExponent)
        {
            //Having the same BaseTenExponent values means that the given operation can be performed right away.
            return unitInfos2;
        }

        int[] bigSmallI = 
        (
            unitInfos2[0].BaseTenExponent > unitInfos2[1].BaseTenExponent ?
            new int[] { 0, 1 } : new int[] { 1, 0 }
        );

        //Only the variable with the bigger value is modified. For example: 5*10^5 & 3*10^3 is converted
        //into 500*10^3 & 3*10^3 in order to allow the addition 500 + 3. 
        UnitInfo big2 = AdaptBiggerAdditionOperand(unitInfos2, bigSmallI, operation);
        if (big2.Error.Type != ErrorTypes.None)
        {
            return TooBigGapAddition(unitInfos2, bigSmallI, operation);
        }

        unitInfos2[bigSmallI[0]].Value = big2.Value;
        unitInfos2[bigSmallI[0]].BaseTenExponent = unitInfos2[bigSmallI[1]].BaseTenExponent;

        return unitInfos2;
    }

    //When adding/subtracting two numbers whose gap is bigger than the maximum double range, there
    //is no need to perform any operation (i.e., no change will be observed because of being outside
    //the maximum supported precision). This method takes care of these cases and returns the expected
    //output (i.e., biggest value).
    static UnitInfo[] TooBigGapAddition(UnitInfo[] unitInfos2, int[] bigSmallI, Operations operation)
    {
        UnitInfo[] outInfos = new UnitInfo[] 
        {
            //First operand (i.e., one whose information defines the operation) together with the
            //numeric information (i.e., just Value and BaseTenExponent because both are normalised)
            //which is associated with the biggest one.
            new UnitInfo(unitInfos2[0])
            {{
                Value = unitInfos2[bigSmallI[0]].Value;
                BaseTenExponent = unitInfos2[bigSmallI[0]].BaseTenExponent;
            }}
        };

        if (operation == Operations.Subtraction && bigSmallI[0] == 1)
        {
            outInfos[0].Value = -1.0 * outInfos[0].Value;
        }

        if (outInfos[0].Unit == Units.Unitless)
        {
            outInfos[0].Unit = unitInfos2[bigSmallI[1]].Unit;
        }

        return outInfos;
    }

    static UnitInfo AdaptBiggerAdditionOperand(UnitInfo[] unitInfos2, int[] bigSmallI, Operations operation)
    {
        int gapExponent = unitInfos2[bigSmallI[0]].BaseTenExponent - unitInfos2[bigSmallI[1]].BaseTenExponent;
        if (gapExponent >= 27)
        {
            //The difference between both inputs is bigger than (or, at least, very close to) the maximum double value/precision;
            //what makes this situation calculation unworthy and the first operand to be returned as the result.
            //Note that the error below these lines is just an easy way to tell the calling function about this eventuality.
            return new UnitInfo(unitInfos2[0]) 
            {{ 
                Error = new ErrorInfo(ErrorTypes.InvalidOperation); 
            }};
        }

        //PerformManagedOperationValues is used to make sure that the resulting numeric information is stored
        //in Value (if possible).
        UnitInfo big2 = PerformManagedOperationValues
        (
            RaiseToIntegerExponent(10.0, gapExponent), unitInfos2[bigSmallI[0]].Value, 
            Operations.Multiplication                
        );

        boolean isWrong = 
        (
            big2.Error.Type != ErrorTypes.None || big2.BaseTenExponent != 0 ?
            
            //The value of the bigger input times 10^(gap between BaseTenExponent of inputs) is too big. 
            isWrong = true :
            
            //Overflow-check very unlikely to trigger an error. In fact, with properly normalised variables,
            //triggering an error would be plainly impossible.               
            AreAdditionFinalValuesWrong
            (
                unitInfos2[0].Value, unitInfos2[1].Value, operation
            )
        );

        if (isWrong)
        {
        	//This error is just an easy way to let the calling function know about the fact that no
            //calculation has been performed (too big gap). This isn't a properly-speaking error and
            //that's why it will not be notified to the user.
        	return new UnitInfo(unitInfos2[0])
            {{
            	Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }};
        }
        else
        {
            //Returning the new big value. For example: with 5*10^4 & 3*10^2, 500 would be returned.
            return new UnitInfo(unitInfos2[bigSmallI[0]])
            {{
                Value = big2.Value;
            }};
        }

        
        return
        (
            isWrong ?
            //This error is just an easy way to let the calling function know about the fact that no
            //calculation has been performed (too big gap). This isn't a properly-speaking error and
            //that's why it will not be notified to the user.
            new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }} :
            //Returning the new big value. For example: with 5*10^4 & 3*10^2, 500 would be returned.
            new UnitInfo(unitInfos2[bigSmallI[0]])
            {{
                Value = big2.Value;
            }}
        );
    }

    static boolean AreAdditionFinalValuesWrong(double val1, double val2, Operations operation)
    {
        boolean isWrong = false;

        try
        {
            val1 = val1 + val2 *
            (
                operation == Operations.Addition ? 1 : -1
            );
        }
        catch { isWrong = true; }

        return isWrong;
    }

    static UnitInfo PerformManagedOperationMultiplication(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationNormalisedValues
        (
            firstInfo, new UnitInfo[] 
            { 
                NormaliseUnitInfo(firstInfo),
                NormaliseUnitInfo(secondInfo) 
            },
            operation
        );
    }

    public static UnitInfo RaiseToIntegerExponent(double baseValue, int exponent)
    {
        return RaiseToIntegerExponent(new UnitInfo(baseValue), exponent);
    }

    static UnitInfo RaiseToIntegerExponent(UnitInfo baseInfo, int exponent)
    {
        if (exponent <= 1 && exponent >= 0)
        {
            baseInfo.Value = (exponent == 0 ? 1.0 : baseInfo.Value);
            return baseInfo;
        }

        UnitInfo outInfo = new UnitInfo(baseInfo);

        for (int i = 1; i < Math.Abs(exponent); i++)
        {
            outInfo = PerformManagedOperationValues
            (
                outInfo, baseInfo, Operations.Multiplication
            );
            if (outInfo.Error.Type != ErrorTypes.None) return outInfo;
        }

        return
        (
            exponent < 0 ?
            PerformManagedOperationValues(new UnitInfo(1.0), outInfo, Operations.Division) :
            outInfo
        );
    }

    static UnitInfo PerformManagedOperationNormalisedValues(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        outInfo =
        (
            normalisedInfos.Length == 1 ?
            //There is just one operand when the difference between both of them is too big.
            outInfo = normalisedInfos[0] :
            PerformManagedOperationTwoOperands(outInfo, normalisedInfos, operation)
        );

        return outInfo;
    }

    static UnitInfo PerformManagedOperationTwoOperands(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        UnitInfo outInfoNormalised = PerformManagedOperationValues
        (
            normalisedInfos[0], normalisedInfos[1], operation
        );

        if (outInfo.Error.Type != ErrorTypes.None)
        {
            return new UnitInfo(outInfo)
            {
                Error = new ErrorInfo(ErrorTypes.NumericError)
            };
        }

        outInfo.BaseTenExponent = outInfoNormalised.BaseTenExponent;
        outInfo.Value = outInfoNormalised.Value;
        //Normalised means no prefixes.
        outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage); 

        return outInfo;
    }

    static UnitInfo PerformManagedOperationValues(double firstValue, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            new UnitInfo(firstValue), new UnitInfo(secondValue), operation
        );
    }

    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            firstInfo, new UnitInfo(secondValue), operation
        );
    }

    //This method might be used to perform full operations (not just being the last calculation step) instead
    //of the default one (PerformManagedOperationUnits) for simple cases. That is: ones not dealing with the
    //complex numeric reality (Value, Prefix and BaseTenExponent) which makes a pre-analysis required.
    //Note that, unlikely what happens with PerformMangedOperationUnits, the outputs of this method aren't
    //normalised (= primarily stored under Value), what is useful in certain contexts.
    //NOTE: this function assumes that both inputs are normalised, what means that no prefix information is expected.
    //It might also be used with non-normalised inputs, but their prefix information would be plainly ignored.
    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        if (firstInfo.Value == 0.0 || secondInfo.Value == 0.0)
        {
            if (operation == Operations.Multiplication || operation == Operations.Division)
            {
                //Dividing by zero scenarios are taken into account somewhere else.
                return new UnitInfo(firstInfo) { Value = 0.0 };
            }
        }

        UnitInfo outInfo = new UnitInfo(firstInfo);
        UnitInfo firstInfo0 = new UnitInfo(firstInfo);
        UnitInfo secondInfo0 = new UnitInfo(secondInfo);

        boolean isWrong = false;
        try
        {
            if (operation == Operations.Addition)
            {
                outInfo.Value += secondInfo0.Value;
            }
            else if (operation == Operations.Subtraction)
            {
                outInfo.Value -= secondInfo.Value;
            }
            else
            {
                //The reason for checking whether BaseTenExponent is inside/outside the int range before performing 
                //the operation (rather than going ahead and eventually catching the resulting exception) isn't just
                //being quicker, but also the only option in many situations. Note that an addition/subtraction between
                //two int variables whose result is outside the int range might not trigger an exception (+ random 
                //negative value as output).
                if (VaryBaseTenExponent(outInfo, secondInfo0.BaseTenExponent, operation == Operations.Division).Error.Type != ErrorTypes.None)
                {
                    return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
                }

                if (operation == Operations.Multiplication)
                {
                    outInfo.Value *= secondInfo.Value;
                    outInfo.BaseTenExponent += secondInfo.BaseTenExponent;
                }
                else if (operation == Operations.Division)
                {
                    if (secondInfo.Value == 0.0)
                    {
                        return
                        (
                            new UnitInfo(outInfo) 
                            { 
                                Error = new ErrorInfo(ErrorTypes.NumericError) 
                            }
                        );
                    }
                    outInfo.Value /= secondInfo.Value;
                    outInfo.BaseTenExponent -= secondInfo.BaseTenExponent;
                }
            }
        }
        catch { isWrong = true; }

        return
        (
            //An error might not be triggered despite of dealing with numbers outside double precision.
            //For example: 0.00000000000000000001m * 0.0000000000000000000001m can output 0.0 without triggering an error. 
            isWrong || ((operation == Operations.Multiplication || operation == Operations.Division) && outInfo.Value == 0.0.0) ?
            OperationValuesManageError(firstInfo0, secondInfo0, operation) : outInfo
        );
    }

    static UnitInfo OperationValuesManageError(UnitInfo outInfo, UnitInfo secondInfo, Operations operation)
    {
        if (operation != Operations.Multiplication && operation != Operations.Division)
        {
            //This condition should never be true on account of the fact that the pre-modifications performed before
            //adding/subtracting should avoid erroneous situations.
            return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
        }

        UnitInfo secondInfo2 = ConvertValueToBaseTen(secondInfo.Value);
        outInfo = VaryBaseTenExponent(outInfo, secondInfo2.BaseTenExponent, operation == Operations.Division);
        if (Math.Abs(secondInfo2.Value) == 1.0 || outInfo.Error.Type != ErrorTypes.None) return outInfo;
        
        try
        {
            outInfo = PerformManagedOperationUnits
            (
                outInfo, secondInfo2.Value, operation
            );
        }
        catch
        {
            //Very unlikely scenario on account of the fact that Math.Abs(secondInfo2.Value)
            //lies within the 0.1-10.0 range.
            outInfo = OperationValuesManageError
            (
                new UnitInfo(outInfo)
                {
                    Value = secondInfo2.Value,
                    BaseTenExponent = 0
                },
                new UnitInfo()
                {
                    Value = outInfo.Value,
                    BaseTenExponent = outInfo.BaseTenExponent
                },
                operation
            );
        }

        return outInfo;
    }

    static UnitInfo ConvertValueToBaseTen(double value)
    {
        value = Math.Abs(value);
        return FromValueToBaseTenExponent
        (
             new UnitInfo(value), Math.Abs(value), false
        );
    }

    static UnitInfo ConvertBaseTenToValue(UnitInfo unitInfo)
    {
        if (unitInfo.BaseTenExponent == 0) return unitInfo;

        UnitInfo outInfo = new UnitInfo(unitInfo);
        boolean decrease = unitInfo.BaseTenExponent > 0;
        int sign = Math.Sign(outInfo.Value);
        double absValue = Math.Abs(outInfo.Value);

        while (outInfo.BaseTenExponent != 0.0)
        {
            if (decrease)
            {
                if (absValue >= MaxValueDec / 10.0) break;
                absValue *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }
            else
            {
                if (absValue <= MinValueDec * 10.0) break;
                absValue /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
        }

        outInfo.Value = sign * absValue;

        return outInfo;
    }

    static UnitInfo NormaliseUnitInfo(UnitInfo unitInfo)
    {
        if (unitInfo.Value == 0 && unitInfo.Prefix.Factor == 1.0)
        {
            return unitInfo;
        }
        UnitInfo outInfo = new UnitInfo(unitInfo);

        if (outInfo.Prefix.Factor != 1)
        {
            outInfo = FromValueToBaseTenExponent
            (
                outInfo, outInfo.Prefix.Factor, true
            );
            outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage);
        }
        if (outInfo.Value == 0.0) return outInfo;

        outInfo = FromValueToBaseTenExponent
        (
            outInfo, outInfo.Value, false
        );

        return outInfo;
    }

    static UnitInfo FromValueToBaseTenExponent(UnitInfo outInfo, double value, boolean isPrefix)
    {
        if (value == 0.0) return outInfo;

        double valueAbs = Math.Abs(value);
        boolean decrease = (valueAbs > 1.0);
        if (!isPrefix)
        {
            outInfo.Value = outInfo.Value / valueAbs;
        }

        while (valueAbs != 1.0)
        {
            if ((valueAbs < 10.0 && valueAbs > 1.0) || (valueAbs > 0.1.0 && valueAbs < 1.0))
            {
                if (!isPrefix) outInfo.Value = value;
                else
                {
                    outInfo = PerformManagedOperationValues
                    (
                        outInfo, value, Operations.Multiplication
                    );
                }

                return outInfo;
            }

            if (decrease)
            {
                value /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
            else
            {
                value *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }

            valueAbs = Math.Abs(value);
        }

        return outInfo;
    }

    //Method used to vary BaseTenExponent without provoking unhandled exceptions (i.e., bigger than Integer.MAX_VALUE).
    static UnitInfo VaryBaseTenExponent(UnitInfo info, int baseTenIncrease, boolean isDivision = false)
    {
        long val1 = info.BaseTenExponent;
        long val2 = baseTenIncrease;

        if (isDivision)
        {
            //Converting a negative value into positive might provoke an overflow error for the int type
            //(e.g., Math.Abs(Integer.MAIN_VALUE)). Converting both variables to long is a quick and effective
            //way to avoid this problem.
            val2 *= -1;
        }

        return
        (
             ((val2 > 0 && val1 > Integer.MAX_VALUE - val2) || (val2 < 0 && val1 < Integer.MAIN_VALUE - val2)) ?
            new UnitInfo(info, ErrorTypes.NumericError) : new UnitInfo(info){{ BaseTenExponent = (int)(val1 + val2); }}
        );
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:476)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:157)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:132)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:260)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:260)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:100)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:383)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:367)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:327)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 2 2017-05-27 19:58:39.189
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:476)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:157)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:132)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:260)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:260)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:100)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:383)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:367)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:327)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 0 2017-05-27 19:58:39.190
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:476)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:157)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:132)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:260)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:260)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:100)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:383)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:367)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:327)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.core 4 4 2017-05-27 19:58:53.222
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
public class OperationsManaged
{
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, double second, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            firstInfo, new UnitInfo(second), operation
        );
    }

    public static UnitInfo PerformManagedOperationUnits(double first, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            new UnitInfo(first), secondInfo, operation
        );
    }

    //This method should always be used when dealing with random UnitInfo variables because it accounts for all the
    //possible scenarios. On the other hand, with simple operations (e.g., random UnitInfo & numeric type) it might
    //be better to use PerformManagedOperationValues. 
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        ErrorTypes errorType = InternalMethods.GetOperationError
        (
            firstInfo, secondInfo, operation
        );
        if (errorType != ErrorTypes.None)
        {
            return new UnitInfo(firstInfo) 
            {{
                Error = new ErrorInfo(errorType); 
            }};
        }

        return
        (
            operation == Operations.Addition || operation == Operations.Subtraction ?
            PerformManagedOperationAddition(firstInfo, secondInfo, operation) :
            PerformManagedOperationMultiplication(firstInfo, secondInfo, operation)
        );
    }

    static UnitInfo PerformManagedOperationAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {   
        //After being normalised, the operands might require further modifications.
        UnitInfo[] normalised = GetOperandsAddition(firstInfo, secondInfo, operation);

        return PerformManagedOperationNormalisedValues
        (
            firstInfo, normalised, operation
        );
    }

    static UnitInfo[] GetOperandsAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        UnitInfo[] operands2 = new UnitInfo[] 
        {
            new UnitInfo(firstInfo), new UnitInfo(secondInfo)
        };

        if (operands2[0].BaseTenExponent != operands2[1].BaseTenExponent || operands2[0].Prefix.Factor != operands2[1].Prefix.Factor)
        {
            //The addition/subtraction might not be performed right away even with normalised values.
            //For example: 5 and 6 from 5*10^2 and 6*10^7 cannot be added right away.
            operands2 = AdaptNormalisedValuesForAddition
            (
                new UnitInfo[] 
                { 
                    NormaliseUnitInfo(operands2[0]), 
                    NormaliseUnitInfo(operands2[1])
                },
                operation
            );
        }

        return operands2;
    }
    
    static UnitInfo[] AdaptNormalisedValuesForAddition(UnitInfo[] unitInfos2, Operations operation)
    {
        if (unitInfos2[0].BaseTenExponent == unitInfos2[1].BaseTenExponent)
        {
            //Having the same BaseTenExponent values means that the given operation can be performed right away.
            return unitInfos2;
        }

        int[] bigSmallI = 
        (
            unitInfos2[0].BaseTenExponent > unitInfos2[1].BaseTenExponent ?
            new int[] { 0, 1 } : new int[] { 1, 0 }
        );

        //Only the variable with the bigger value is modified. For example: 5*10^5 & 3*10^3 is converted
        //into 500*10^3 & 3*10^3 in order to allow the addition 500 + 3. 
        UnitInfo big2 = AdaptBiggerAdditionOperand(unitInfos2, bigSmallI, operation);
        if (big2.Error.Type != ErrorTypes.None)
        {
            return TooBigGapAddition(unitInfos2, bigSmallI, operation);
        }

        unitInfos2[bigSmallI[0]].Value = big2.Value;
        unitInfos2[bigSmallI[0]].BaseTenExponent = unitInfos2[bigSmallI[1]].BaseTenExponent;

        return unitInfos2;
    }

    //When adding/subtracting two numbers whose gap is bigger than the maximum double range, there
    //is no need to perform any operation (i.e., no change will be observed because of being outside
    //the maximum supported precision). This method takes care of these cases and returns the expected
    //output (i.e., biggest value).
    static UnitInfo[] TooBigGapAddition(UnitInfo[] unitInfos2, int[] bigSmallI, Operations operation)
    {
        UnitInfo[] outInfos = new UnitInfo[] 
        {
            //First operand (i.e., one whose information defines the operation) together with the
            //numeric information (i.e., just Value and BaseTenExponent because both are normalised)
            //which is associated with the biggest one.
            new UnitInfo(unitInfos2[0])
            {{
                Value = unitInfos2[bigSmallI[0]].Value;
                BaseTenExponent = unitInfos2[bigSmallI[0]].BaseTenExponent;
            }}
        };

        if (operation == Operations.Subtraction && bigSmallI[0] == 1)
        {
            outInfos[0].Value = -1.0 * outInfos[0].Value;
        }

        if (outInfos[0].Unit == Units.Unitless)
        {
            outInfos[0].Unit = unitInfos2[bigSmallI[1]].Unit;
        }

        return outInfos;
    }

    static UnitInfo AdaptBiggerAdditionOperand(UnitInfo[] unitInfos2, int[] bigSmallI, Operations operation)
    {
        int gapExponent = unitInfos2[bigSmallI[0]].BaseTenExponent - unitInfos2[bigSmallI[1]].BaseTenExponent;
        if (gapExponent >= 27)
        {
            //The difference between both inputs is bigger than (or, at least, very close to) the maximum double value/precision;
            //what makes this situation calculation unworthy and the first operand to be returned as the result.
            //Note that the error below these lines is just an easy way to tell the calling function about this eventuality.
            return new UnitInfo(unitInfos2[0]) 
            {{ 
                Error = new ErrorInfo(ErrorTypes.InvalidOperation); 
            }};
        }

        //PerformManagedOperationValues is used to make sure that the resulting numeric information is stored
        //in Value (if possible).
        UnitInfo big2 = PerformManagedOperationValues
        (
            RaiseToIntegerExponent(10.0, gapExponent), unitInfos2[bigSmallI[0]].Value, 
            Operations.Multiplication                
        );

        boolean isWrong = 
        (
            big2.Error.Type != ErrorTypes.None || big2.BaseTenExponent != 0 ?
            
            //The value of the bigger input times 10^(gap between BaseTenExponent of inputs) is too big. 
            isWrong = true :
            
            //Overflow-check very unlikely to trigger an error. In fact, with properly normalised variables,
            //triggering an error would be plainly impossible.               
            AreAdditionFinalValuesWrong
            (
                unitInfos2[0].Value, unitInfos2[1].Value, operation
            )
        );

        if (isWrong)
        {
        	//This error is just an easy way to let the calling function know about the fact that no
            //calculation has been performed (too big gap). This isn't a properly-speaking error and
            //that's why it will not be notified to the user.
        	return new UnitInfo(unitInfos2[0])
            {{
            	Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }};
        }
        else
        {
            //Returning the new big value. For example: with 5*10^4 & 3*10^2, 500 would be returned.
            return new UnitInfo(unitInfos2[bigSmallI[0]])
            {{
                Value = big2.Value;
            }};
        }

        
        return
        (
            isWrong ?
            //This error is just an easy way to let the calling function know about the fact that no
            //calculation has been performed (too big gap). This isn't a properly-speaking error and
            //that's why it will not be notified to the user.
            new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }} :
            //Returning the new big value. For example: with 5*10^4 & 3*10^2, 500 would be returned.
            new UnitInfo(unitInfos2[bigSmallI[0]])
            {{
                Value = big2.Value;
            }}
        );
    }

    static boolean AreAdditionFinalValuesWrong(double val1, double val2, Operations operation)
    {
        boolean isWrong = false;

        try
        {
            val1 = val1 + val2 *
            (
                operation == Operations.Addition ? 1 : -1
            );
        }
        catch { isWrong = true; }

        return isWrong;
    }

    static UnitInfo PerformManagedOperationMultiplication(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationNormalisedValues
        (
            firstInfo, new UnitInfo[] 
            { 
                NormaliseUnitInfo(firstInfo),
                NormaliseUnitInfo(secondInfo) 
            },
            operation
        );
    }

    public static UnitInfo RaiseToIntegerExponent(double baseValue, int exponent)
    {
        return RaiseToIntegerExponent(new UnitInfo(baseValue), exponent);
    }

    static UnitInfo RaiseToIntegerExponent(UnitInfo baseInfo, int exponent)
    {
        if (exponent <= 1 && exponent >= 0)
        {
            baseInfo.Value = (exponent == 0 ? 1.0 : baseInfo.Value);
            return baseInfo;
        }

        UnitInfo outInfo = new UnitInfo(baseInfo);

        for (int i = 1; i < Math.Abs(exponent); i++)
        {
            outInfo = PerformManagedOperationValues
            (
                outInfo, baseInfo, Operations.Multiplication
            );
            if (outInfo.Error.Type != ErrorTypes.None) return outInfo;
        }

        return
        (
            exponent < 0 ?
            PerformManagedOperationValues(new UnitInfo(1.0), outInfo, Operations.Division) :
            outInfo
        );
    }

    static UnitInfo PerformManagedOperationNormalisedValues(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        outInfo =
        (
            normalisedInfos.Length == 1 ?
            //There is just one operand when the difference between both of them is too big.
            outInfo = normalisedInfos[0] :
            PerformManagedOperationTwoOperands(outInfo, normalisedInfos, operation)
        );

        return outInfo;
    }

    static UnitInfo PerformManagedOperationTwoOperands(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        UnitInfo outInfoNormalised = PerformManagedOperationValues
        (
            normalisedInfos[0], normalisedInfos[1], operation
        );

        if (outInfo.Error.Type != ErrorTypes.None)
        {
            return new UnitInfo(outInfo)
            {
                Error = new ErrorInfo(ErrorTypes.NumericError)
            };
        }

        outInfo.BaseTenExponent = outInfoNormalised.BaseTenExponent;
        outInfo.Value = outInfoNormalised.Value;
        //Normalised means no prefixes.
        outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage); 

        return outInfo;
    }

    static UnitInfo PerformManagedOperationValues(double firstValue, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            new UnitInfo(firstValue), new UnitInfo(secondValue), operation
        );
    }

    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            firstInfo, new UnitInfo(secondValue), operation
        );
    }

    //This method might be used to perform full operations (not just being the last calculation step) instead
    //of the default one (PerformManagedOperationUnits) for simple cases. That is: ones not dealing with the
    //complex numeric reality (Value, Prefix and BaseTenExponent) which makes a pre-analysis required.
    //Note that, unlikely what happens with PerformMangedOperationUnits, the outputs of this method aren't
    //normalised (= primarily stored under Value), what is useful in certain contexts.
    //NOTE: this function assumes that both inputs are normalised, what means that no prefix information is expected.
    //It might also be used with non-normalised inputs, but their prefix information would be plainly ignored.
    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        if (firstInfo.Value == 0.0 || secondInfo.Value == 0.0)
        {
            if (operation == Operations.Multiplication || operation == Operations.Division)
            {
                //Dividing by zero scenarios are taken into account somewhere else.
                return new UnitInfo(firstInfo) { Value = 0.0 };
            }
        }

        UnitInfo outInfo = new UnitInfo(firstInfo);
        UnitInfo firstInfo0 = new UnitInfo(firstInfo);
        UnitInfo secondInfo0 = new UnitInfo(secondInfo);

        boolean isWrong = false;
        try
        {
            if (operation == Operations.Addition)
            {
                outInfo.Value += secondInfo0.Value;
            }
            else if (operation == Operations.Subtraction)
            {
                outInfo.Value -= secondInfo.Value;
            }
            else
            {
                //The reason for checking whether BaseTenExponent is inside/outside the int range before performing 
                //the operation (rather than going ahead and eventually catching the resulting exception) isn't just
                //being quicker, but also the only option in many situations. Note that an addition/subtraction between
                //two int variables whose result is outside the int range might not trigger an exception (+ random 
                //negative value as output).
                if (VaryBaseTenExponent(outInfo, secondInfo0.BaseTenExponent, operation == Operations.Division).Error.Type != ErrorTypes.None)
                {
                    return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
                }

                if (operation == Operations.Multiplication)
                {
                    outInfo.Value *= secondInfo.Value;
                    outInfo.BaseTenExponent += secondInfo.BaseTenExponent;
                }
                else if (operation == Operations.Division)
                {
                    if (secondInfo.Value == 0.0)
                    {
                        return
                        (
                            new UnitInfo(outInfo) 
                            { 
                                Error = new ErrorInfo(ErrorTypes.NumericError) 
                            }
                        );
                    }
                    outInfo.Value /= secondInfo.Value;
                    outInfo.BaseTenExponent -= secondInfo.BaseTenExponent;
                }
            }
        }
        catch { isWrong = true; }

        return
        (
            //An error might not be triggered despite of dealing with numbers outside double precision.
            //For example: 0.00000000000000000001m * 0.0000000000000000000001m can output 0.0 without triggering an error. 
            isWrong || ((operation == Operations.Multiplication || operation == Operations.Division) && outInfo.Value == 0.0.0) ?
            OperationValuesManageError(firstInfo0, secondInfo0, operation) : outInfo
        );
    }

    static UnitInfo OperationValuesManageError(UnitInfo outInfo, UnitInfo secondInfo, Operations operation)
    {
        if (operation != Operations.Multiplication && operation != Operations.Division)
        {
            //This condition should never be true on account of the fact that the pre-modifications performed before
            //adding/subtracting should avoid erroneous situations.
            return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
        }

        UnitInfo secondInfo2 = ConvertValueToBaseTen(secondInfo.Value);
        outInfo = VaryBaseTenExponent(outInfo, secondInfo2.BaseTenExponent, operation == Operations.Division);
        if (Math.Abs(secondInfo2.Value) == 1.0 || outInfo.Error.Type != ErrorTypes.None) return outInfo;
        
        try
        {
            outInfo = PerformManagedOperationUnits
            (
                outInfo, secondInfo2.Value, operation
            );
        }
        catch
        {
            //Very unlikely scenario on account of the fact that Math.Abs(secondInfo2.Value)
            //lies within the 0.1-10.0 range.
            outInfo = OperationValuesManageError
            (
                new UnitInfo(outInfo)
                {
                    Value = secondInfo2.Value,
                    BaseTenExponent = 0
                },
                new UnitInfo()
                {
                    Value = outInfo.Value,
                    BaseTenExponent = outInfo.BaseTenExponent
                },
                operation
            );
        }

        return outInfo;
    }

    static UnitInfo ConvertValueToBaseTen(double value)
    {
        value = Math.Abs(value);
        return FromValueToBaseTenExponent
        (
             new UnitInfo(value), Math.Abs(value), false
        );
    }

    static UnitInfo ConvertBaseTenToValue(UnitInfo unitInfo)
    {
        if (unitInfo.BaseTenExponent == 0) return unitInfo;

        UnitInfo outInfo = new UnitInfo(unitInfo);
        boolean decrease = unitInfo.BaseTenExponent > 0;
        int sign = Math.Sign(outInfo.Value);
        double absValue = Math.Abs(outInfo.Value);

        while (outInfo.BaseTenExponent != 0.0)
        {
            if (decrease)
            {
                if (absValue >= MaxValueDec / 10.0) break;
                absValue *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }
            else
            {
                if (absValue <= MinValueDec * 10.0) break;
                absValue /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
        }

        outInfo.Value = sign * absValue;

        return outInfo;
    }

    static UnitInfo NormaliseUnitInfo(UnitInfo unitInfo)
    {
        if (unitInfo.Value == 0 && unitInfo.Prefix.Factor == 1.0)
        {
            return unitInfo;
        }
        UnitInfo outInfo = new UnitInfo(unitInfo);

        if (outInfo.Prefix.Factor != 1)
        {
            outInfo = FromValueToBaseTenExponent
            (
                outInfo, outInfo.Prefix.Factor, true
            );
            outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage);
        }
        if (outInfo.Value == 0.0) return outInfo;

        outInfo = FromValueToBaseTenExponent
        (
            outInfo, outInfo.Value, false
        );

        return outInfo;
    }

    static UnitInfo FromValueToBaseTenExponent(UnitInfo outInfo, double value, boolean isPrefix)
    {
        if (value == 0.0) return outInfo;

        double valueAbs = Math.Abs(value);
        boolean decrease = (valueAbs > 1.0);
        if (!isPrefix)
        {
            outInfo.Value = outInfo.Value / valueAbs;
        }

        while (valueAbs != 1.0)
        {
            if ((valueAbs < 10.0 && valueAbs > 1.0) || (valueAbs > 0.1.0 && valueAbs < 1.0))
            {
                if (!isPrefix) outInfo.Value = value;
                else
                {
                    outInfo = PerformManagedOperationValues
                    (
                        outInfo, value, Operations.Multiplication
                    );
                }

                return outInfo;
            }

            if (decrease)
            {
                value /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
            else
            {
                value *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }

            valueAbs = Math.Abs(value);
        }

        return outInfo;
    }

    //Method used to vary BaseTenExponent without provoking unhandled exceptions (i.e., bigger than Integer.MAX_VALUE).
    static UnitInfo VaryBaseTenExponent(UnitInfo info, int baseTenIncrease, boolean isDivision = false)
    {
        long val1 = info.BaseTenExponent;
        long val2 = baseTenIncrease;

        if (isDivision)
        {
            //Converting a negative value into positive might provoke an overflow error for the int type
            //(e.g., Math.Abs(Integer.MAIN_VALUE)). Converting both variables to long is a quick and effective
            //way to avoid this problem.
            val2 *= -1;
        }

        return
        (
             ((val2 > 0 && val1 > Integer.MAX_VALUE - val2) || (val2 < 0 && val1 < Integer.MAIN_VALUE - val2)) ?
            new UnitInfo(info, ErrorTypes.NumericError) : new UnitInfo(info){{ BaseTenExponent = (int)(val1 + val2); }}
        );
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 2 2017-05-27 19:58:53.223
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 0 2017-05-27 19:58:53.224
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.core 4 4 2017-05-27 19:58:53.523
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
public class OperationsManaged
{
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, double second, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            firstInfo, new UnitInfo(second), operation
        );
    }

    public static UnitInfo PerformManagedOperationUnits(double first, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            new UnitInfo(first), secondInfo, operation
        );
    }

    //This method should always be used when dealing with random UnitInfo variables because it accounts for all the
    //possible scenarios. On the other hand, with simple operations (e.g., random UnitInfo & numeric type) it might
    //be better to use PerformManagedOperationValues. 
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        ErrorTypes errorType = InternalMethods.GetOperationError
        (
            firstInfo, secondInfo, operation
        );
        if (errorType != ErrorTypes.None)
        {
            return new UnitInfo(firstInfo) 
            {{
                Error = new ErrorInfo(errorType); 
            }};
        }

        return
        (
            operation == Operations.Addition || operation == Operations.Subtraction ?
            PerformManagedOperationAddition(firstInfo, secondInfo, operation) :
            PerformManagedOperationMultiplication(firstInfo, secondInfo, operation)
        );
    }

    static UnitInfo PerformManagedOperationAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {   
        //After being normalised, the operands might require further modifications.
        UnitInfo[] normalised = GetOperandsAddition(firstInfo, secondInfo, operation);

        return PerformManagedOperationNormalisedValues
        (
            firstInfo, normalised, operation
        );
    }

    static UnitInfo[] GetOperandsAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        UnitInfo[] operands2 = new UnitInfo[] 
        {
            new UnitInfo(firstInfo), new UnitInfo(secondInfo)
        };

        if (operands2[0].BaseTenExponent != operands2[1].BaseTenExponent || operands2[0].Prefix.Factor != operands2[1].Prefix.Factor)
        {
            //The addition/subtraction might not be performed right away even with normalised values.
            //For example: 5 and 6 from 5*10^2 and 6*10^7 cannot be added right away.
            operands2 = AdaptNormalisedValuesForAddition
            (
                new UnitInfo[] 
                { 
                    NormaliseUnitInfo(operands2[0]), 
                    NormaliseUnitInfo(operands2[1])
                },
                operation
            );
        }

        return operands2;
    }
    
    static UnitInfo[] AdaptNormalisedValuesForAddition(UnitInfo[] unitInfos2, Operations operation)
    {
        if (unitInfos2[0].BaseTenExponent == unitInfos2[1].BaseTenExponent)
        {
            //Having the same BaseTenExponent values means that the given operation can be performed right away.
            return unitInfos2;
        }

        int[] bigSmallI = 
        (
            unitInfos2[0].BaseTenExponent > unitInfos2[1].BaseTenExponent ?
            new int[] { 0, 1 } : new int[] { 1, 0 }
        );

        //Only the variable with the bigger value is modified. For example: 5*10^5 & 3*10^3 is converted
        //into 500*10^3 & 3*10^3 in order to allow the addition 500 + 3. 
        UnitInfo big2 = AdaptBiggerAdditionOperand(unitInfos2, bigSmallI, operation);
        if (big2.Error.Type != ErrorTypes.None)
        {
            return TooBigGapAddition(unitInfos2, bigSmallI, operation);
        }

        unitInfos2[bigSmallI[0]].Value = big2.Value;
        unitInfos2[bigSmallI[0]].BaseTenExponent = unitInfos2[bigSmallI[1]].BaseTenExponent;

        return unitInfos2;
    }

    //When adding/subtracting two numbers whose gap is bigger than the maximum double range, there
    //is no need to perform any operation (i.e., no change will be observed because of being outside
    //the maximum supported precision). This method takes care of these cases and returns the expected
    //output (i.e., biggest value).
    static UnitInfo[] TooBigGapAddition(UnitInfo[] unitInfos2, int[] bigSmallI, Operations operation)
    {
        UnitInfo[] outInfos = new UnitInfo[] 
        {
            //First operand (i.e., one whose information defines the operation) together with the
            //numeric information (i.e., just Value and BaseTenExponent because both are normalised)
            //which is associated with the biggest one.
            new UnitInfo(unitInfos2[0])
            {{
                Value = unitInfos2[bigSmallI[0]].Value;
                BaseTenExponent = unitInfos2[bigSmallI[0]].BaseTenExponent;
            }}
        };

        if (operation == Operations.Subtraction && bigSmallI[0] == 1)
        {
            outInfos[0].Value = -1.0 * outInfos[0].Value;
        }

        if (outInfos[0].Unit == Units.Unitless)
        {
            outInfos[0].Unit = unitInfos2[bigSmallI[1]].Unit;
        }

        return outInfos;
    }

    static UnitInfo AdaptBiggerAdditionOperand(UnitInfo[] unitInfos2, int[] bigSmallI, Operations operation)
    {
        int gapExponent = unitInfos2[bigSmallI[0]].BaseTenExponent - unitInfos2[bigSmallI[1]].BaseTenExponent;
        if (gapExponent >= 27)
        {
            //The difference between both inputs is bigger than (or, at least, very close to) the maximum double value/precision;
            //what makes this situation calculation unworthy and the first operand to be returned as the result.
            //Note that the error below these lines is just an easy way to tell the calling function about this eventuality.
            return new UnitInfo(unitInfos2[0]) 
            {{ 
                Error = new ErrorInfo(ErrorTypes.InvalidOperation); 
            }};
        }

        //PerformManagedOperationValues is used to make sure that the resulting numeric information is stored
        //in Value (if possible).
        UnitInfo big2 = PerformManagedOperationValues
        (
            RaiseToIntegerExponent(10.0, gapExponent), unitInfos2[bigSmallI[0]].Value, 
            Operations.Multiplication                
        );

        boolean isWrong = 
        (
            big2.Error.Type != ErrorTypes.None || big2.BaseTenExponent != 0 ?
            
            //The value of the bigger input times 10^(gap between BaseTenExponent of inputs) is too big. 
            isWrong = true :
            
            //Overflow-check very unlikely to trigger an error. In fact, with properly normalised variables,
            //triggering an error would be plainly impossible.               
            AreAdditionFinalValuesWrong
            (
                unitInfos2[0].Value, unitInfos2[1].Value, operation
            )
        );

        if (isWrong)
        {
        	//This error is just an easy way to let the calling function know about the fact that no
            //calculation has been performed (too big gap). This isn't a properly-speaking error and
            //that's why it will not be notified to the user.
        	return new UnitInfo(unitInfos2[0])
            {{
            	Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }};
        }
        else
        {
            //Returning the new big value. For example: with 5*10^4 & 3*10^2, 500 would be returned.
            return new UnitInfo(unitInfos2[bigSmallI[0]])
            {{
                Value = big2.Value;
            }};
        }

        
        return
        (
            isWrong ?
            //This error is just an easy way to let the calling function know about the fact that no
            //calculation has been performed (too big gap). This isn't a properly-speaking error and
            //that's why it will not be notified to the user.
            new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }} :
            //Returning the new big value. For example: with 5*10^4 & 3*10^2, 500 would be returned.
            new UnitInfo(unitInfos2[bigSmallI[0]])
            {{
                Value = big2.Value;
            }}
        );
    }

    static boolean AreAdditionFinalValuesWrong(double val1, double val2, Operations operation)
    {
        boolean isWrong = false;

        try
        {
            val1 = val1 + val2 *
            (
                operation == Operations.Addition ? 1 : -1
            );
        }
        catch { isWrong = true; }

        return isWrong;
    }

    static UnitInfo PerformManagedOperationMultiplication(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationNormalisedValues
        (
            firstInfo, new UnitInfo[] 
            { 
                NormaliseUnitInfo(firstInfo),
                NormaliseUnitInfo(secondInfo) 
            },
            operation
        );
    }

    public static UnitInfo RaiseToIntegerExponent(double baseValue, int exponent)
    {
        return RaiseToIntegerExponent(new UnitInfo(baseValue), exponent);
    }

    static UnitInfo RaiseToIntegerExponent(UnitInfo baseInfo, int exponent)
    {
        if (exponent <= 1 && exponent >= 0)
        {
            baseInfo.Value = (exponent == 0 ? 1.0 : baseInfo.Value);
            return baseInfo;
        }

        UnitInfo outInfo = new UnitInfo(baseInfo);

        for (int i = 1; i < Math.Abs(exponent); i++)
        {
            outInfo = PerformManagedOperationValues
            (
                outInfo, baseInfo, Operations.Multiplication
            );
            if (outInfo.Error.Type != ErrorTypes.None) return outInfo;
        }

        return
        (
            exponent < 0 ?
            PerformManagedOperationValues(new UnitInfo(1.0), outInfo, Operations.Division) :
            outInfo
        );
    }

    static UnitInfo PerformManagedOperationNormalisedValues(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        outInfo =
        (
            normalisedInfos.Length == 1 ?
            //There is just one operand when the difference between both of them is too big.
            outInfo = normalisedInfos[0] :
            PerformManagedOperationTwoOperands(outInfo, normalisedInfos, operation)
        );

        return outInfo;
    }

    static UnitInfo PerformManagedOperationTwoOperands(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        UnitInfo outInfoNormalised = PerformManagedOperationValues
        (
            normalisedInfos[0], normalisedInfos[1], operation
        );

        if (outInfo.Error.Type != ErrorTypes.None)
        {
            return new UnitInfo(outInfo)
            {
                Error = new ErrorInfo(ErrorTypes.NumericError)
            };
        }

        outInfo.BaseTenExponent = outInfoNormalised.BaseTenExponent;
        outInfo.Value = outInfoNormalised.Value;
        //Normalised means no prefixes.
        outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage); 

        return outInfo;
    }

    static UnitInfo PerformManagedOperationValues(double firstValue, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            new UnitInfo(firstValue), new UnitInfo(secondValue), operation
        );
    }

    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            firstInfo, new UnitInfo(secondValue), operation
        );
    }

    //This method might be used to perform full operations (not just being the last calculation step) instead
    //of the default one (PerformManagedOperationUnits) for simple cases. That is: ones not dealing with the
    //complex numeric reality (Value, Prefix and BaseTenExponent) which makes a pre-analysis required.
    //Note that, unlikely what happens with PerformMangedOperationUnits, the outputs of this method aren't
    //normalised (= primarily stored under Value), what is useful in certain contexts.
    //NOTE: this function assumes that both inputs are normalised, what means that no prefix information is expected.
    //It might also be used with non-normalised inputs, but their prefix information would be plainly ignored.
    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        if (firstInfo.Value == 0.0 || secondInfo.Value == 0.0)
        {
            if (operation == Operations.Multiplication || operation == Operations.Division)
            {
                //Dividing by zero scenarios are taken into account somewhere else.
                return new UnitInfo(firstInfo) { Value = 0.0 };
            }
        }

        UnitInfo outInfo = new UnitInfo(firstInfo);
        UnitInfo firstInfo0 = new UnitInfo(firstInfo);
        UnitInfo secondInfo0 = new UnitInfo(secondInfo);

        boolean isWrong = false;
        try
        {
            if (operation == Operations.Addition)
            {
                outInfo.Value += secondInfo0.Value;
            }
            else if (operation == Operations.Subtraction)
            {
                outInfo.Value -= secondInfo.Value;
            }
            else
            {
                //The reason for checking whether BaseTenExponent is inside/outside the int range before performing 
                //the operation (rather than going ahead and eventually catching the resulting exception) isn't just
                //being quicker, but also the only option in many situations. Note that an addition/subtraction between
                //two int variables whose result is outside the int range might not trigger an exception (+ random 
                //negative value as output).
                if (VaryBaseTenExponent(outInfo, secondInfo0.BaseTenExponent, operation == Operations.Division).Error.Type != ErrorTypes.None)
                {
                    return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
                }

                if (operation == Operations.Multiplication)
                {
                    outInfo.Value *= secondInfo.Value;
                    outInfo.BaseTenExponent += secondInfo.BaseTenExponent;
                }
                else if (operation == Operations.Division)
                {
                    if (secondInfo.Value == 0.0)
                    {
                        return
                        (
                            new UnitInfo(outInfo) 
                            { 
                                Error = new ErrorInfo(ErrorTypes.NumericError) 
                            }
                        );
                    }
                    outInfo.Value /= secondInfo.Value;
                    outInfo.BaseTenExponent -= secondInfo.BaseTenExponent;
                }
            }
        }
        catch { isWrong = true; }

        return
        (
            //An error might not be triggered despite of dealing with numbers outside double precision.
            //For example: 0.00000000000000000001m * 0.0000000000000000000001m can output 0.0 without triggering an error. 
            isWrong || ((operation == Operations.Multiplication || operation == Operations.Division) && outInfo.Value == 0.0.0) ?
            OperationValuesManageError(firstInfo0, secondInfo0, operation) : outInfo
        );
    }

    static UnitInfo OperationValuesManageError(UnitInfo outInfo, UnitInfo secondInfo, Operations operation)
    {
        if (operation != Operations.Multiplication && operation != Operations.Division)
        {
            //This condition should never be true on account of the fact that the pre-modifications performed before
            //adding/subtracting should avoid erroneous situations.
            return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
        }

        UnitInfo secondInfo2 = ConvertValueToBaseTen(secondInfo.Value);
        outInfo = VaryBaseTenExponent(outInfo, secondInfo2.BaseTenExponent, operation == Operations.Division);
        if (Math.Abs(secondInfo2.Value) == 1.0 || outInfo.Error.Type != ErrorTypes.None) return outInfo;
        
        try
        {
            outInfo = PerformManagedOperationUnits
            (
                outInfo, secondInfo2.Value, operation
            );
        }
        catch
        {
            //Very unlikely scenario on account of the fact that Math.Abs(secondInfo2.Value)
            //lies within the 0.1-10.0 range.
            outInfo = OperationValuesManageError
            (
                new UnitInfo(outInfo)
                {
                    Value = secondInfo2.Value,
                    BaseTenExponent = 0
                },
                new UnitInfo()
                {
                    Value = outInfo.Value,
                    BaseTenExponent = outInfo.BaseTenExponent
                },
                operation
            );
        }

        return outInfo;
    }

    static UnitInfo ConvertValueToBaseTen(double value)
    {
        value = Math.Abs(value);
        return FromValueToBaseTenExponent
        (
             new UnitInfo(value), Math.Abs(value), false
        );
    }

    static UnitInfo ConvertBaseTenToValue(UnitInfo unitInfo)
    {
        if (unitInfo.BaseTenExponent == 0) return unitInfo;

        UnitInfo outInfo = new UnitInfo(unitInfo);
        boolean decrease = unitInfo.BaseTenExponent > 0;
        int sign = Math.Sign(outInfo.Value);
        double absValue = Math.Abs(outInfo.Value);

        while (outInfo.BaseTenExponent != 0.0)
        {
            if (decrease)
            {
                if (absValue >= MaxValueDec / 10.0) break;
                absValue *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }
            else
            {
                if (absValue <= MinValueDec * 10.0) break;
                absValue /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
        }

        outInfo.Value = sign * absValue;

        return outInfo;
    }

    static UnitInfo NormaliseUnitInfo(UnitInfo unitInfo)
    {
        if (unitInfo.Value == 0 && unitInfo.Prefix.Factor == 1.0)
        {
            return unitInfo;
        }
        UnitInfo outInfo = new UnitInfo(unitInfo);

        if (outInfo.Prefix.Factor != 1)
        {
            outInfo = FromValueToBaseTenExponent
            (
                outInfo, outInfo.Prefix.Factor, true
            );
            outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage);
        }
        if (outInfo.Value == 0.0) return outInfo;

        outInfo = FromValueToBaseTenExponent
        (
            outInfo, outInfo.Value, false
        );

        return outInfo;
    }

    static UnitInfo FromValueToBaseTenExponent(UnitInfo outInfo, double value, boolean isPrefix)
    {
        if (value == 0.0) return outInfo;

        double valueAbs = Math.Abs(value);
        boolean decrease = (valueAbs > 1.0);
        if (!isPrefix)
        {
            outInfo.Value = outInfo.Value / valueAbs;
        }

        while (valueAbs != 1.0)
        {
            if ((valueAbs < 10.0 && valueAbs > 1.0) || (valueAbs > 0.1.0 && valueAbs < 1.0))
            {
                if (!isPrefix) outInfo.Value = value;
                else
                {
                    outInfo = PerformManagedOperationValues
                    (
                        outInfo, value, Operations.Multiplication
                    );
                }

                return outInfo;
            }

            if (decrease)
            {
                value /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
            else
            {
                value *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }

            valueAbs = Math.Abs(value);
        }

        return outInfo;
    }

    //Method used to vary BaseTenExponent without provoking unhandled exceptions (i.e., bigger than Integer.MAX_VALUE).
    static UnitInfo VaryBaseTenExponent(UnitInfo info, int baseTenIncrease, boolean isDivision = false)
    {
        long val1 = info.BaseTenExponent;
        long val2 = baseTenIncrease;

        if (isDivision)
        {
            //Converting a negative value into positive might provoke an overflow error for the int type
            //(e.g., Math.Abs(Integer.MAIN_VALUE)). Converting both variables to long is a quick and effective
            //way to avoid this problem.
            val2 *= -1;
        }

        return
        (
             ((val2 > 0 && val1 > Integer.MAX_VALUE - val2) || (val2 < 0 && val1 < Integer.MAIN_VALUE - val2)) ?
            new UnitInfo(info, ErrorTypes.NumericError) : new UnitInfo(info){{ BaseTenExponent = (int)(val1 + val2); }}
        );
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:137)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:116)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:164)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:86)
	at org.eclipse.jface.text.TextViewerHoverManager$4.run(TextViewerHoverManager.java:165)

!ENTRY org.eclipse.jdt.ui 4 2 2017-05-27 19:58:53.524
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:137)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:116)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:164)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:86)
	at org.eclipse.jface.text.TextViewerHoverManager$4.run(TextViewerHoverManager.java:165)

!ENTRY org.eclipse.jdt.ui 4 0 2017-05-27 19:58:53.525
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:137)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:116)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:164)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:86)
	at org.eclipse.jface.text.TextViewerHoverManager$4.run(TextViewerHoverManager.java:165)

!ENTRY org.eclipse.jdt.core 4 4 2017-05-27 20:02:58.166
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
public class OperationsManaged
{
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, double second, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            firstInfo, new UnitInfo(second), operation
        );
    }

    public static UnitInfo PerformManagedOperationUnits(double first, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            new UnitInfo(first), secondInfo, operation
        );
    }

    //This method should always be used when dealing with random UnitInfo variables because it accounts for all the
    //possible scenarios. On the other hand, with simple operations (e.g., random UnitInfo & numeric type) it might
    //be better to use PerformManagedOperationValues. 
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        ErrorTypes errorType = InternalMethods.GetOperationError
        (
            firstInfo, secondInfo, operation
        );
        if (errorType != ErrorTypes.None)
        {
            return new UnitInfo(firstInfo) 
            {{
                Error = new ErrorInfo(errorType); 
            }};
        }

        return
        (
            operation == Operations.Addition || operation == Operations.Subtraction ?
            PerformManagedOperationAddition(firstInfo, secondInfo, operation) :
            PerformManagedOperationMultiplication(firstInfo, secondInfo, operation)
        );
    }

    static UnitInfo PerformManagedOperationAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {   
        //After being normalised, the operands might require further modifications.
        UnitInfo[] normalised = GetOperandsAddition(firstInfo, secondInfo, operation);

        return PerformManagedOperationNormalisedValues
        (
            firstInfo, normalised, operation
        );
    }

    static UnitInfo[] GetOperandsAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        UnitInfo[] operands2 = new UnitInfo[] 
        {
            new UnitInfo(firstInfo), new UnitInfo(secondInfo)
        };

        if (operands2[0].BaseTenExponent != operands2[1].BaseTenExponent || operands2[0].Prefix.Factor != operands2[1].Prefix.Factor)
        {
            //The addition/subtraction might not be performed right away even with normalised values.
            //For example: 5 and 6 from 5*10^2 and 6*10^7 cannot be added right away.
            operands2 = AdaptNormalisedValuesForAddition
            (
                new UnitInfo[] 
                { 
                    NormaliseUnitInfo(operands2[0]), 
                    NormaliseUnitInfo(operands2[1])
                },
                operation
            );
        }

        return operands2;
    }
    
    static UnitInfo[] AdaptNormalisedValuesForAddition(UnitInfo[] unitInfos2, Operations operation)
    {
        if (unitInfos2[0].BaseTenExponent == unitInfos2[1].BaseTenExponent)
        {
            //Having the same BaseTenExponent values means that the given operation can be performed right away.
            return unitInfos2;
        }

        int[] bigSmallI = 
        (
            unitInfos2[0].BaseTenExponent > unitInfos2[1].BaseTenExponent ?
            new int[] { 0, 1 } : new int[] { 1, 0 }
        );

        //Only the variable with the bigger value is modified. For example: 5*10^5 & 3*10^3 is converted
        //into 500*10^3 & 3*10^3 in order to allow the addition 500 + 3. 
        UnitInfo big2 = AdaptBiggerAdditionOperand(unitInfos2, bigSmallI, operation);
        if (big2.Error.Type != ErrorTypes.None)
        {
            return TooBigGapAddition(unitInfos2, bigSmallI, operation);
        }

        unitInfos2[bigSmallI[0]].Value = big2.Value;
        unitInfos2[bigSmallI[0]].BaseTenExponent = unitInfos2[bigSmallI[1]].BaseTenExponent;

        return unitInfos2;
    }

    //When adding/subtracting two numbers whose gap is bigger than the maximum double range, there
    //is no need to perform any operation (i.e., no change will be observed because of being outside
    //the maximum supported precision). This method takes care of these cases and returns the expected
    //output (i.e., biggest value).
    static UnitInfo[] TooBigGapAddition(UnitInfo[] unitInfos2, int[] bigSmallI, Operations operation)
    {
        UnitInfo[] outInfos = new UnitInfo[] 
        {
            //First operand (i.e., one whose information defines the operation) together with the
            //numeric information (i.e., just Value and BaseTenExponent because both are normalised)
            //which is associated with the biggest one.
            new UnitInfo(unitInfos2[0])
            {{
                Value = unitInfos2[bigSmallI[0]].Value;
                BaseTenExponent = unitInfos2[bigSmallI[0]].BaseTenExponent;
            }}
        };

        if (operation == Operations.Subtraction && bigSmallI[0] == 1)
        {
            outInfos[0].Value = -1.0 * outInfos[0].Value;
        }

        if (outInfos[0].Unit == Units.Unitless)
        {
            outInfos[0].Unit = unitInfos2[bigSmallI[1]].Unit;
        }

        return outInfos;
    }

    static UnitInfo AdaptBiggerAdditionOperand(UnitInfo[] unitInfos2, Integer[] bigSmallI, Operations operation)
    {
        int gapExponent = unitInfos2[bigSmallI[0]].BaseTenExponent - unitInfos2[bigSmallI[1]].BaseTenExponent;
        if (gapExponent >= 27)
        {
            //The difference between both inputs is bigger than (or, at least, very close to) the maximum double value/precision;
            //what makes this situation calculation unworthy and the first operand to be returned as the result.
            //Note that the error below these lines is just an easy way to tell the calling function about this eventuality.
            return new UnitInfo(unitInfos2[0]) 
            {{ 
                Error = new ErrorInfo(ErrorTypes.InvalidOperation); 
            }};
        }

        //PerformManagedOperationValues is used to make sure that the resulting numeric information is stored
        //in Value (if possible).
        UnitInfo big2 = PerformManagedOperationValues
        (
            RaiseToIntegerExponent(10.0, gapExponent), unitInfos2[bigSmallI[0]].Value, 
            Operations.Multiplication                
        );

        boolean isWrong = 
        (
            big2.Error.Type != ErrorTypes.None || big2.BaseTenExponent != 0 ?
            
            //The value of the bigger input times 10^(gap between BaseTenExponent of inputs) is too big. 
            isWrong = true :
            
            //Overflow-check very unlikely to trigger an error. In fact, with properly normalised variables,
            //triggering an error would be plainly impossible.               
            AreAdditionFinalValuesWrong
            (
                unitInfos2[0].Value, unitInfos2[1].Value, operation
            )
        );

        return
        (
            isWrong ?
            //This error is just an easy way to let the calling function know about the fact that no
            //calculation has been performed (too big gap). This isn't a properly-speaking error and
            //that's why it will not be notified to the user.
            new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }} :
            //Returning the new big value. For example: with 5*10^4 & 3*10^2, 500 would be returned.
            new UnitInfo(unitInfos2[bigSmallI[0]])
            {{
                Value = big2.Value;
            }};
        );
    }

    static boolean AreAdditionFinalValuesWrong(double val1, double val2, Operations operation)
    {
        boolean isWrong = false;

        try
        {
            val1 = val1 + val2 *
            (
                operation == Operations.Addition ? 1 : -1
            );
        }
        catch { isWrong = true; }

        return isWrong;
    }

    static UnitInfo PerformManagedOperationMultiplication(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationNormalisedValues
        (
            firstInfo, new UnitInfo[] 
            { 
                NormaliseUnitInfo(firstInfo),
                NormaliseUnitInfo(secondInfo) 
            },
            operation
        );
    }

    public static UnitInfo RaiseToIntegerExponent(double baseValue, int exponent)
    {
        return RaiseToIntegerExponent(new UnitInfo(baseValue), exponent);
    }

    static UnitInfo RaiseToIntegerExponent(UnitInfo baseInfo, int exponent)
    {
        if (exponent <= 1 && exponent >= 0)
        {
            baseInfo.Value = (exponent == 0 ? 1.0 : baseInfo.Value);
            return baseInfo;
        }

        UnitInfo outInfo = new UnitInfo(baseInfo);

        for (int i = 1; i < Math.Abs(exponent); i++)
        {
            outInfo = PerformManagedOperationValues
            (
                outInfo, baseInfo, Operations.Multiplication
            );
            if (outInfo.Error.Type != ErrorTypes.None) return outInfo;
        }

        return
        (
            exponent < 0 ?
            PerformManagedOperationValues(new UnitInfo(1.0), outInfo, Operations.Division) :
            outInfo
        );
    }

    static UnitInfo PerformManagedOperationNormalisedValues(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        outInfo =
        (
            normalisedInfos.Length == 1 ?
            //There is just one operand when the difference between both of them is too big.
            outInfo = normalisedInfos[0] :
            PerformManagedOperationTwoOperands(outInfo, normalisedInfos, operation)
        );

        return outInfo;
    }

    static UnitInfo PerformManagedOperationTwoOperands(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        UnitInfo outInfoNormalised = PerformManagedOperationValues
        (
            normalisedInfos[0], normalisedInfos[1], operation
        );

        if (outInfo.Error.Type != ErrorTypes.None)
        {
            return new UnitInfo(outInfo)
            {
                Error = new ErrorInfo(ErrorTypes.NumericError)
            };
        }

        outInfo.BaseTenExponent = outInfoNormalised.BaseTenExponent;
        outInfo.Value = outInfoNormalised.Value;
        //Normalised means no prefixes.
        outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage); 

        return outInfo;
    }

    static UnitInfo PerformManagedOperationValues(double firstValue, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            new UnitInfo(firstValue), new UnitInfo(secondValue), operation
        );
    }

    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            firstInfo, new UnitInfo(secondValue), operation
        );
    }

    //This method might be used to perform full operations (not just being the last calculation step) instead
    //of the default one (PerformManagedOperationUnits) for simple cases. That is: ones not dealing with the
    //complex numeric reality (Value, Prefix and BaseTenExponent) which makes a pre-analysis required.
    //Note that, unlikely what happens with PerformMangedOperationUnits, the outputs of this method aren't
    //normalised (= primarily stored under Value), what is useful in certain contexts.
    //NOTE: this function assumes that both inputs are normalised, what means that no prefix information is expected.
    //It might also be used with non-normalised inputs, but their prefix information would be plainly ignored.
    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        if (firstInfo.Value == 0.0 || secondInfo.Value == 0.0)
        {
            if (operation == Operations.Multiplication || operation == Operations.Division)
            {
                //Dividing by zero scenarios are taken into account somewhere else.
                return new UnitInfo(firstInfo) { Value = 0.0 };
            }
        }

        UnitInfo outInfo = new UnitInfo(firstInfo);
        UnitInfo firstInfo0 = new UnitInfo(firstInfo);
        UnitInfo secondInfo0 = new UnitInfo(secondInfo);

        boolean isWrong = false;
        try
        {
            if (operation == Operations.Addition)
            {
                outInfo.Value += secondInfo0.Value;
            }
            else if (operation == Operations.Subtraction)
            {
                outInfo.Value -= secondInfo.Value;
            }
            else
            {
                //The reason for checking whether BaseTenExponent is inside/outside the int range before performing 
                //the operation (rather than going ahead and eventually catching the resulting exception) isn't just
                //being quicker, but also the only option in many situations. Note that an addition/subtraction between
                //two int variables whose result is outside the int range might not trigger an exception (+ random 
                //negative value as output).
                if (VaryBaseTenExponent(outInfo, secondInfo0.BaseTenExponent, operation == Operations.Division).Error.Type != ErrorTypes.None)
                {
                    return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
                }

                if (operation == Operations.Multiplication)
                {
                    outInfo.Value *= secondInfo.Value;
                    outInfo.BaseTenExponent += secondInfo.BaseTenExponent;
                }
                else if (operation == Operations.Division)
                {
                    if (secondInfo.Value == 0.0)
                    {
                        return
                        (
                            new UnitInfo(outInfo) 
                            { 
                                Error = new ErrorInfo(ErrorTypes.NumericError) 
                            }
                        );
                    }
                    outInfo.Value /= secondInfo.Value;
                    outInfo.BaseTenExponent -= secondInfo.BaseTenExponent;
                }
            }
        }
        catch { isWrong = true; }

        return
        (
            //An error might not be triggered despite of dealing with numbers outside double precision.
            //For example: 0.00000000000000000001m * 0.0000000000000000000001m can output 0.0 without triggering an error. 
            isWrong || ((operation == Operations.Multiplication || operation == Operations.Division) && outInfo.Value == 0.0.0) ?
            OperationValuesManageError(firstInfo0, secondInfo0, operation) : outInfo
        );
    }

    static UnitInfo OperationValuesManageError(UnitInfo outInfo, UnitInfo secondInfo, Operations operation)
    {
        if (operation != Operations.Multiplication && operation != Operations.Division)
        {
            //This condition should never be true on account of the fact that the pre-modifications performed before
            //adding/subtracting should avoid erroneous situations.
            return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
        }

        UnitInfo secondInfo2 = ConvertValueToBaseTen(secondInfo.Value);
        outInfo = VaryBaseTenExponent(outInfo, secondInfo2.BaseTenExponent, operation == Operations.Division);
        if (Math.Abs(secondInfo2.Value) == 1.0 || outInfo.Error.Type != ErrorTypes.None) return outInfo;
        
        try
        {
            outInfo = PerformManagedOperationUnits
            (
                outInfo, secondInfo2.Value, operation
            );
        }
        catch
        {
            //Very unlikely scenario on account of the fact that Math.Abs(secondInfo2.Value)
            //lies within the 0.1-10.0 range.
            outInfo = OperationValuesManageError
            (
                new UnitInfo(outInfo)
                {
                    Value = secondInfo2.Value,
                    BaseTenExponent = 0
                },
                new UnitInfo()
                {
                    Value = outInfo.Value,
                    BaseTenExponent = outInfo.BaseTenExponent
                },
                operation
            );
        }

        return outInfo;
    }

    static UnitInfo ConvertValueToBaseTen(double value)
    {
        value = Math.Abs(value);
        return FromValueToBaseTenExponent
        (
             new UnitInfo(value), Math.Abs(value), false
        );
    }

    static UnitInfo ConvertBaseTenToValue(UnitInfo unitInfo)
    {
        if (unitInfo.BaseTenExponent == 0) return unitInfo;

        UnitInfo outInfo = new UnitInfo(unitInfo);
        boolean decrease = unitInfo.BaseTenExponent > 0;
        int sign = Math.Sign(outInfo.Value);
        double absValue = Math.Abs(outInfo.Value);

        while (outInfo.BaseTenExponent != 0.0)
        {
            if (decrease)
            {
                if (absValue >= MaxValueDec / 10.0) break;
                absValue *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }
            else
            {
                if (absValue <= MinValueDec * 10.0) break;
                absValue /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
        }

        outInfo.Value = sign * absValue;

        return outInfo;
    }

    static UnitInfo NormaliseUnitInfo(UnitInfo unitInfo)
    {
        if (unitInfo.Value == 0 && unitInfo.Prefix.Factor == 1.0)
        {
            return unitInfo;
        }
        UnitInfo outInfo = new UnitInfo(unitInfo);

        if (outInfo.Prefix.Factor != 1)
        {
            outInfo = FromValueToBaseTenExponent
            (
                outInfo, outInfo.Prefix.Factor, true
            );
            outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage);
        }
        if (outInfo.Value == 0.0) return outInfo;

        outInfo = FromValueToBaseTenExponent
        (
            outInfo, outInfo.Value, false
        );

        return outInfo;
    }

    static UnitInfo FromValueToBaseTenExponent(UnitInfo outInfo, double value, boolean isPrefix)
    {
        if (value == 0.0) return outInfo;

        double valueAbs = Math.Abs(value);
        boolean decrease = (valueAbs > 1.0);
        if (!isPrefix)
        {
            outInfo.Value = outInfo.Value / valueAbs;
        }

        while (valueAbs != 1.0)
        {
            if ((valueAbs < 10.0 && valueAbs > 1.0) || (valueAbs > 0.1.0 && valueAbs < 1.0))
            {
                if (!isPrefix) outInfo.Value = value;
                else
                {
                    outInfo = PerformManagedOperationValues
                    (
                        outInfo, value, Operations.Multiplication
                    );
                }

                return outInfo;
            }

            if (decrease)
            {
                value /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
            else
            {
                value *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }

            valueAbs = Math.Abs(value);
        }

        return outInfo;
    }

    //Method used to vary BaseTenExponent without provoking unhandled exceptions (i.e., bigger than Integer.MAX_VALUE).
    static UnitInfo VaryBaseTenExponent(UnitInfo info, int baseTenIncrease, boolean isDivision = false)
    {
        long val1 = info.BaseTenExponent;
        long val2 = baseTenIncrease;

        if (isDivision)
        {
            //Converting a negative value into positive might provoke an overflow error for the int type
            //(e.g., Math.Abs(Integer.MAIN_VALUE)). Converting both variables to long is a quick and effective
            //way to avoid this problem.
            val2 *= -1;
        }

        return
        (
             ((val2 > 0 && val1 > Integer.MAX_VALUE - val2) || (val2 < 0 && val1 < Integer.MAIN_VALUE - val2)) ?
            new UnitInfo(info, ErrorTypes.NumericError) : new UnitInfo(info){{ BaseTenExponent = (int)(val1 + val2); }}
        );
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2017-05-27 20:02:58.168
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2017-05-27 20:02:58.169
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2017-05-27 20:02:58.197
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
public class OperationsManaged
{
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, double second, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            firstInfo, new UnitInfo(second), operation
        );
    }

    public static UnitInfo PerformManagedOperationUnits(double first, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            new UnitInfo(first), secondInfo, operation
        );
    }

    //This method should always be used when dealing with random UnitInfo variables because it accounts for all the
    //possible scenarios. On the other hand, with simple operations (e.g., random UnitInfo & numeric type) it might
    //be better to use PerformManagedOperationValues. 
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        ErrorTypes errorType = InternalMethods.GetOperationError
        (
            firstInfo, secondInfo, operation
        );
        if (errorType != ErrorTypes.None)
        {
            return new UnitInfo(firstInfo) 
            {{
                Error = new ErrorInfo(errorType); 
            }};
        }

        return
        (
            operation == Operations.Addition || operation == Operations.Subtraction ?
            PerformManagedOperationAddition(firstInfo, secondInfo, operation) :
            PerformManagedOperationMultiplication(firstInfo, secondInfo, operation)
        );
    }

    static UnitInfo PerformManagedOperationAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {   
        //After being normalised, the operands might require further modifications.
        UnitInfo[] normalised = GetOperandsAddition(firstInfo, secondInfo, operation);

        return PerformManagedOperationNormalisedValues
        (
            firstInfo, normalised, operation
        );
    }

    static UnitInfo[] GetOperandsAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        UnitInfo[] operands2 = new UnitInfo[] 
        {
            new UnitInfo(firstInfo), new UnitInfo(secondInfo)
        };

        if (operands2[0].BaseTenExponent != operands2[1].BaseTenExponent || operands2[0].Prefix.Factor != operands2[1].Prefix.Factor)
        {
            //The addition/subtraction might not be performed right away even with normalised values.
            //For example: 5 and 6 from 5*10^2 and 6*10^7 cannot be added right away.
            operands2 = AdaptNormalisedValuesForAddition
            (
                new UnitInfo[] 
                { 
                    NormaliseUnitInfo(operands2[0]), 
                    NormaliseUnitInfo(operands2[1])
                },
                operation
            );
        }

        return operands2;
    }
    
    static UnitInfo[] AdaptNormalisedValuesForAddition(UnitInfo[] unitInfos2, Operations operation)
    {
        if (unitInfos2[0].BaseTenExponent == unitInfos2[1].BaseTenExponent)
        {
            //Having the same BaseTenExponent values means that the given operation can be performed right away.
            return unitInfos2;
        }

        int[] bigSmallI = 
        (
            unitInfos2[0].BaseTenExponent > unitInfos2[1].BaseTenExponent ?
            new int[] { 0, 1 } : new int[] { 1, 0 }
        );

        //Only the variable with the bigger value is modified. For example: 5*10^5 & 3*10^3 is converted
        //into 500*10^3 & 3*10^3 in order to allow the addition 500 + 3. 
        UnitInfo big2 = AdaptBiggerAdditionOperand(unitInfos2, bigSmallI, operation);
        if (big2.Error.Type != ErrorTypes.None)
        {
            return TooBigGapAddition(unitInfos2, bigSmallI, operation);
        }

        unitInfos2[bigSmallI[0]].Value = big2.Value;
        unitInfos2[bigSmallI[0]].BaseTenExponent = unitInfos2[bigSmallI[1]].BaseTenExponent;

        return unitInfos2;
    }

    //When adding/subtracting two numbers whose gap is bigger than the maximum double range, there
    //is no need to perform any operation (i.e., no change will be observed because of being outside
    //the maximum supported precision). This method takes care of these cases and returns the expected
    //output (i.e., biggest value).
    static UnitInfo[] TooBigGapAddition(UnitInfo[] unitInfos2, int[] bigSmallI, Operations operation)
    {
        UnitInfo[] outInfos = new UnitInfo[] 
        {
            //First operand (i.e., one whose information defines the operation) together with the
            //numeric information (i.e., just Value and BaseTenExponent because both are normalised)
            //which is associated with the biggest one.
            new UnitInfo(unitInfos2[0])
            {{
                Value = unitInfos2[bigSmallI[0]].Value;
                BaseTenExponent = unitInfos2[bigSmallI[0]].BaseTenExponent;
            }}
        };

        if (operation == Operations.Subtraction && bigSmallI[0] == 1)
        {
            outInfos[0].Value = -1.0 * outInfos[0].Value;
        }

        if (outInfos[0].Unit == Units.Unitless)
        {
            outInfos[0].Unit = unitInfos2[bigSmallI[1]].Unit;
        }

        return outInfos;
    }

    static UnitInfo AdaptBiggerAdditionOperand(UnitInfo[] unitInfos2, Integer[] bigSmallI, Operations operation)
    {
        int gapExponent = unitInfos2[bigSmallI[0]].BaseTenExponent - unitInfos2[bigSmallI[1]].BaseTenExponent;
        if (gapExponent >= 27)
        {
            //The difference between both inputs is bigger than (or, at least, very close to) the maximum double value/precision;
            //what makes this situation calculation unworthy and the first operand to be returned as the result.
            //Note that the error below these lines is just an easy way to tell the calling function about this eventuality.
            return new UnitInfo(unitInfos2[0]) 
            {{ 
                Error = new ErrorInfo(ErrorTypes.InvalidOperation); 
            }};
        }

        //PerformManagedOperationValues is used to make sure that the resulting numeric information is stored
        //in Value (if possible).
        UnitInfo big2 = PerformManagedOperationValues
        (
            RaiseToIntegerExponent(10.0, gapExponent), unitInfos2[bigSmallI[0]].Value, 
            Operations.Multiplication                
        );

        boolean isWrong = 
        (
            big2.Error.Type != ErrorTypes.None || big2.BaseTenExponent != 0 ?
            
            //The value of the bigger input times 10^(gap between BaseTenExponent of inputs) is too big. 
            isWrong = true :
            
            //Overflow-check very unlikely to trigger an error. In fact, with properly normalised variables,
            //triggering an error would be plainly impossible.               
            AreAdditionFinalValuesWrong
            (
                unitInfos2[0].Value, unitInfos2[1].Value, operation
            )
        );

        return
        (
            isWrong ?
            //This error is just an easy way to let the calling function know about the fact that no
            //calculation has been performed (too big gap). This isn't a properly-speaking error and
            //that's why it will not be notified to the user.
            new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }} :
            //Returning the new big value. For example: with 5*10^4 & 3*10^2, 500 would be returned.
            new UnitInfo(unitInfos2[bigSmallI[0]])
            {{
                Value = big2.Value;
            }};
        );
    }

    static boolean AreAdditionFinalValuesWrong(double val1, double val2, Operations operation)
    {
        boolean isWrong = false;

        try
        {
            val1 = val1 + val2 *
            (
                operation == Operations.Addition ? 1 : -1
            );
        }
        catch { isWrong = true; }

        return isWrong;
    }

    static UnitInfo PerformManagedOperationMultiplication(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationNormalisedValues
        (
            firstInfo, new UnitInfo[] 
            { 
                NormaliseUnitInfo(firstInfo),
                NormaliseUnitInfo(secondInfo) 
            },
            operation
        );
    }

    public static UnitInfo RaiseToIntegerExponent(double baseValue, int exponent)
    {
        return RaiseToIntegerExponent(new UnitInfo(baseValue), exponent);
    }

    static UnitInfo RaiseToIntegerExponent(UnitInfo baseInfo, int exponent)
    {
        if (exponent <= 1 && exponent >= 0)
        {
            baseInfo.Value = (exponent == 0 ? 1.0 : baseInfo.Value);
            return baseInfo;
        }

        UnitInfo outInfo = new UnitInfo(baseInfo);

        for (int i = 1; i < Math.Abs(exponent); i++)
        {
            outInfo = PerformManagedOperationValues
            (
                outInfo, baseInfo, Operations.Multiplication
            );
            if (outInfo.Error.Type != ErrorTypes.None) return outInfo;
        }

        return
        (
            exponent < 0 ?
            PerformManagedOperationValues(new UnitInfo(1.0), outInfo, Operations.Division) :
            outInfo
        );
    }

    static UnitInfo PerformManagedOperationNormalisedValues(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        outInfo =
        (
            normalisedInfos.Length == 1 ?
            //There is just one operand when the difference between both of them is too big.
            outInfo = normalisedInfos[0] :
            PerformManagedOperationTwoOperands(outInfo, normalisedInfos, operation)
        );

        return outInfo;
    }

    static UnitInfo PerformManagedOperationTwoOperands(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        UnitInfo outInfoNormalised = PerformManagedOperationValues
        (
            normalisedInfos[0], normalisedInfos[1], operation
        );

        if (outInfo.Error.Type != ErrorTypes.None)
        {
            return new UnitInfo(outInfo)
            {
                Error = new ErrorInfo(ErrorTypes.NumericError)
            };
        }

        outInfo.BaseTenExponent = outInfoNormalised.BaseTenExponent;
        outInfo.Value = outInfoNormalised.Value;
        //Normalised means no prefixes.
        outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage); 

        return outInfo;
    }

    static UnitInfo PerformManagedOperationValues(double firstValue, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            new UnitInfo(firstValue), new UnitInfo(secondValue), operation
        );
    }

    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            firstInfo, new UnitInfo(secondValue), operation
        );
    }

    //This method might be used to perform full operations (not just being the last calculation step) instead
    //of the default one (PerformManagedOperationUnits) for simple cases. That is: ones not dealing with the
    //complex numeric reality (Value, Prefix and BaseTenExponent) which makes a pre-analysis required.
    //Note that, unlikely what happens with PerformMangedOperationUnits, the outputs of this method aren't
    //normalised (= primarily stored under Value), what is useful in certain contexts.
    //NOTE: this function assumes that both inputs are normalised, what means that no prefix information is expected.
    //It might also be used with non-normalised inputs, but their prefix information would be plainly ignored.
    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        if (firstInfo.Value == 0.0 || secondInfo.Value == 0.0)
        {
            if (operation == Operations.Multiplication || operation == Operations.Division)
            {
                //Dividing by zero scenarios are taken into account somewhere else.
                return new UnitInfo(firstInfo) { Value = 0.0 };
            }
        }

        UnitInfo outInfo = new UnitInfo(firstInfo);
        UnitInfo firstInfo0 = new UnitInfo(firstInfo);
        UnitInfo secondInfo0 = new UnitInfo(secondInfo);

        boolean isWrong = false;
        try
        {
            if (operation == Operations.Addition)
            {
                outInfo.Value += secondInfo0.Value;
            }
            else if (operation == Operations.Subtraction)
            {
                outInfo.Value -= secondInfo.Value;
            }
            else
            {
                //The reason for checking whether BaseTenExponent is inside/outside the int range before performing 
                //the operation (rather than going ahead and eventually catching the resulting exception) isn't just
                //being quicker, but also the only option in many situations. Note that an addition/subtraction between
                //two int variables whose result is outside the int range might not trigger an exception (+ random 
                //negative value as output).
                if (VaryBaseTenExponent(outInfo, secondInfo0.BaseTenExponent, operation == Operations.Division).Error.Type != ErrorTypes.None)
                {
                    return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
                }

                if (operation == Operations.Multiplication)
                {
                    outInfo.Value *= secondInfo.Value;
                    outInfo.BaseTenExponent += secondInfo.BaseTenExponent;
                }
                else if (operation == Operations.Division)
                {
                    if (secondInfo.Value == 0.0)
                    {
                        return
                        (
                            new UnitInfo(outInfo) 
                            { 
                                Error = new ErrorInfo(ErrorTypes.NumericError) 
                            }
                        );
                    }
                    outInfo.Value /= secondInfo.Value;
                    outInfo.BaseTenExponent -= secondInfo.BaseTenExponent;
                }
            }
        }
        catch { isWrong = true; }

        return
        (
            //An error might not be triggered despite of dealing with numbers outside double precision.
            //For example: 0.00000000000000000001m * 0.0000000000000000000001m can output 0.0 without triggering an error. 
            isWrong || ((operation == Operations.Multiplication || operation == Operations.Division) && outInfo.Value == 0.0.0) ?
            OperationValuesManageError(firstInfo0, secondInfo0, operation) : outInfo
        );
    }

    static UnitInfo OperationValuesManageError(UnitInfo outInfo, UnitInfo secondInfo, Operations operation)
    {
        if (operation != Operations.Multiplication && operation != Operations.Division)
        {
            //This condition should never be true on account of the fact that the pre-modifications performed before
            //adding/subtracting should avoid erroneous situations.
            return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
        }

        UnitInfo secondInfo2 = ConvertValueToBaseTen(secondInfo.Value);
        outInfo = VaryBaseTenExponent(outInfo, secondInfo2.BaseTenExponent, operation == Operations.Division);
        if (Math.Abs(secondInfo2.Value) == 1.0 || outInfo.Error.Type != ErrorTypes.None) return outInfo;
        
        try
        {
            outInfo = PerformManagedOperationUnits
            (
                outInfo, secondInfo2.Value, operation
            );
        }
        catch
        {
            //Very unlikely scenario on account of the fact that Math.Abs(secondInfo2.Value)
            //lies within the 0.1-10.0 range.
            outInfo = OperationValuesManageError
            (
                new UnitInfo(outInfo)
                {
                    Value = secondInfo2.Value,
                    BaseTenExponent = 0
                },
                new UnitInfo()
                {
                    Value = outInfo.Value,
                    BaseTenExponent = outInfo.BaseTenExponent
                },
                operation
            );
        }

        return outInfo;
    }

    static UnitInfo ConvertValueToBaseTen(double value)
    {
        value = Math.Abs(value);
        return FromValueToBaseTenExponent
        (
             new UnitInfo(value), Math.Abs(value), false
        );
    }

    static UnitInfo ConvertBaseTenToValue(UnitInfo unitInfo)
    {
        if (unitInfo.BaseTenExponent == 0) return unitInfo;

        UnitInfo outInfo = new UnitInfo(unitInfo);
        boolean decrease = unitInfo.BaseTenExponent > 0;
        int sign = Math.Sign(outInfo.Value);
        double absValue = Math.Abs(outInfo.Value);

        while (outInfo.BaseTenExponent != 0.0)
        {
            if (decrease)
            {
                if (absValue >= MaxValueDec / 10.0) break;
                absValue *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }
            else
            {
                if (absValue <= MinValueDec * 10.0) break;
                absValue /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
        }

        outInfo.Value = sign * absValue;

        return outInfo;
    }

    static UnitInfo NormaliseUnitInfo(UnitInfo unitInfo)
    {
        if (unitInfo.Value == 0 && unitInfo.Prefix.Factor == 1.0)
        {
            return unitInfo;
        }
        UnitInfo outInfo = new UnitInfo(unitInfo);

        if (outInfo.Prefix.Factor != 1)
        {
            outInfo = FromValueToBaseTenExponent
            (
                outInfo, outInfo.Prefix.Factor, true
            );
            outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage);
        }
        if (outInfo.Value == 0.0) return outInfo;

        outInfo = FromValueToBaseTenExponent
        (
            outInfo, outInfo.Value, false
        );

        return outInfo;
    }

    static UnitInfo FromValueToBaseTenExponent(UnitInfo outInfo, double value, boolean isPrefix)
    {
        if (value == 0.0) return outInfo;

        double valueAbs = Math.Abs(value);
        boolean decrease = (valueAbs > 1.0);
        if (!isPrefix)
        {
            outInfo.Value = outInfo.Value / valueAbs;
        }

        while (valueAbs != 1.0)
        {
            if ((valueAbs < 10.0 && valueAbs > 1.0) || (valueAbs > 0.1.0 && valueAbs < 1.0))
            {
                if (!isPrefix) outInfo.Value = value;
                else
                {
                    outInfo = PerformManagedOperationValues
                    (
                        outInfo, value, Operations.Multiplication
                    );
                }

                return outInfo;
            }

            if (decrease)
            {
                value /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
            else
            {
                value *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }

            valueAbs = Math.Abs(value);
        }

        return outInfo;
    }

    //Method used to vary BaseTenExponent without provoking unhandled exceptions (i.e., bigger than Integer.MAX_VALUE).
    static UnitInfo VaryBaseTenExponent(UnitInfo info, int baseTenIncrease, boolean isDivision = false)
    {
        long val1 = info.BaseTenExponent;
        long val2 = baseTenIncrease;

        if (isDivision)
        {
            //Converting a negative value into positive might provoke an overflow error for the int type
            //(e.g., Math.Abs(Integer.MAIN_VALUE)). Converting both variables to long is a quick and effective
            //way to avoid this problem.
            val2 *= -1;
        }

        return
        (
             ((val2 > 0 && val1 > Integer.MAX_VALUE - val2) || (val2 < 0 && val1 < Integer.MAIN_VALUE - val2)) ?
            new UnitInfo(info, ErrorTypes.NumericError) : new UnitInfo(info){{ BaseTenExponent = (int)(val1 + val2); }}
        );
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:476)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 2 2017-05-27 20:02:58.198
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:476)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 0 2017-05-27 20:02:58.198
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:476)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.core 4 4 2017-05-27 20:02:59.206
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
public class OperationsManaged
{
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, double second, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            firstInfo, new UnitInfo(second), operation
        );
    }

    public static UnitInfo PerformManagedOperationUnits(double first, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            new UnitInfo(first), secondInfo, operation
        );
    }

    //This method should always be used when dealing with random UnitInfo variables because it accounts for all the
    //possible scenarios. On the other hand, with simple operations (e.g., random UnitInfo & numeric type) it might
    //be better to use PerformManagedOperationValues. 
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        ErrorTypes errorType = InternalMethods.GetOperationError
        (
            firstInfo, secondInfo, operation
        );
        if (errorType != ErrorTypes.None)
        {
            return new UnitInfo(firstInfo) 
            {{
                Error = new ErrorInfo(errorType); 
            }};
        }

        return
        (
            operation == Operations.Addition || operation == Operations.Subtraction ?
            PerformManagedOperationAddition(firstInfo, secondInfo, operation) :
            PerformManagedOperationMultiplication(firstInfo, secondInfo, operation)
        );
    }

    static UnitInfo PerformManagedOperationAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {   
        //After being normalised, the operands might require further modifications.
        UnitInfo[] normalised = GetOperandsAddition(firstInfo, secondInfo, operation);

        return PerformManagedOperationNormalisedValues
        (
            firstInfo, normalised, operation
        );
    }

    static UnitInfo[] GetOperandsAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        UnitInfo[] operands2 = new UnitInfo[] 
        {
            new UnitInfo(firstInfo), new UnitInfo(secondInfo)
        };

        if (operands2[0].BaseTenExponent != operands2[1].BaseTenExponent || operands2[0].Prefix.Factor != operands2[1].Prefix.Factor)
        {
            //The addition/subtraction might not be performed right away even with normalised values.
            //For example: 5 and 6 from 5*10^2 and 6*10^7 cannot be added right away.
            operands2 = AdaptNormalisedValuesForAddition
            (
                new UnitInfo[] 
                { 
                    NormaliseUnitInfo(operands2[0]), 
                    NormaliseUnitInfo(operands2[1])
                },
                operation
            );
        }

        return operands2;
    }
    
    static UnitInfo[] AdaptNormalisedValuesForAddition(UnitInfo[] unitInfos2, Operations operation)
    {
        if (unitInfos2[0].BaseTenExponent == unitInfos2[1].BaseTenExponent)
        {
            //Having the same BaseTenExponent values means that the given operation can be performed right away.
            return unitInfos2;
        }

        int[] bigSmallI = 
        (
            unitInfos2[0].BaseTenExponent > unitInfos2[1].BaseTenExponent ?
            new int[] { 0, 1 } : new int[] { 1, 0 }
        );

        //Only the variable with the bigger value is modified. For example: 5*10^5 & 3*10^3 is converted
        //into 500*10^3 & 3*10^3 in order to allow the addition 500 + 3. 
        UnitInfo big2 = AdaptBiggerAdditionOperand(unitInfos2, bigSmallI, operation);
        if (big2.Error.Type != ErrorTypes.None)
        {
            return TooBigGapAddition(unitInfos2, bigSmallI, operation);
        }

        unitInfos2[bigSmallI[0]].Value = big2.Value;
        unitInfos2[bigSmallI[0]].BaseTenExponent = unitInfos2[bigSmallI[1]].BaseTenExponent;

        return unitInfos2;
    }

    //When adding/subtracting two numbers whose gap is bigger than the maximum double range, there
    //is no need to perform any operation (i.e., no change will be observed because of being outside
    //the maximum supported precision). This method takes care of these cases and returns the expected
    //output (i.e., biggest value).
    static UnitInfo[] TooBigGapAddition(UnitInfo[] unitInfos2, int[] bigSmallI, Operations operation)
    {
        UnitInfo[] outInfos = new UnitInfo[] 
        {
            //First operand (i.e., one whose information defines the operation) together with the
            //numeric information (i.e., just Value and BaseTenExponent because both are normalised)
            //which is associated with the biggest one.
            new UnitInfo(unitInfos2[0])
            {{
                Value = unitInfos2[bigSmallI[0]].Value;
                BaseTenExponent = unitInfos2[bigSmallI[0]].BaseTenExponent;
            }}
        };

        if (operation == Operations.Subtraction && bigSmallI[0] == 1)
        {
            outInfos[0].Value = -1.0 * outInfos[0].Value;
        }

        if (outInfos[0].Unit == Units.Unitless)
        {
            outInfos[0].Unit = unitInfos2[bigSmallI[1]].Unit;
        }

        return outInfos;
    }

    static UnitInfo AdaptBiggerAdditionOperand(UnitInfo[] unitInfos2, Integer[] bigSmallI, Operations operation)
    {
        int gapExponent = unitInfos2[bigSmallI[0]].BaseTenExponent - unitInfos2[bigSmallI[1]].BaseTenExponent;
        if (gapExponent >= 27)
        {
            //The difference between both inputs is bigger than (or, at least, very close to) the maximum double value/precision;
            //what makes this situation calculation unworthy and the first operand to be returned as the result.
            //Note that the error below these lines is just an easy way to tell the calling function about this eventuality.
            return new UnitInfo(unitInfos2[0]) 
            {{ 
                Error = new ErrorInfo(ErrorTypes.InvalidOperation); 
            }};
        }

        //PerformManagedOperationValues is used to make sure that the resulting numeric information is stored
        //in Value (if possible).
        UnitInfo big2 = PerformManagedOperationValues
        (
            RaiseToIntegerExponent(10.0, gapExponent), unitInfos2[bigSmallI[0]].Value, 
            Operations.Multiplication                
        );

        boolean isWrong = 
        (
            big2.Error.Type != ErrorTypes.None || big2.BaseTenExponent != 0 ?
            
            //The value of the bigger input times 10^(gap between BaseTenExponent of inputs) is too big. 
            isWrong = true :
            
            //Overflow-check very unlikely to trigger an error. In fact, with properly normalised variables,
            //triggering an error would be plainly impossible.               
            AreAdditionFinalValuesWrong
            (
                unitInfos2[0].Value, unitInfos2[1].Value, operation
            )
        );

        return
        (
            isWrong ?
            //This error is just an easy way to let the calling function know about the fact that no
            //calculation has been performed (too big gap). This isn't a properly-speaking error and
            //that's why it will not be notified to the user.
            new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }} :
            //Returning the new big value. For example: with 5*10^4 & 3*10^2, 500 would be returned.
            new UnitInfo(unitInfos2[bigSmallI[0]])
            {{
                Value = big2.Value;
            }}
        );
    }

    static boolean AreAdditionFinalValuesWrong(double val1, double val2, Operations operation)
    {
        boolean isWrong = false;

        try
        {
            val1 = val1 + val2 *
            (
                operation == Operations.Addition ? 1 : -1
            );
        }
        catch { isWrong = true; }

        return isWrong;
    }

    static UnitInfo PerformManagedOperationMultiplication(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationNormalisedValues
        (
            firstInfo, new UnitInfo[] 
            { 
                NormaliseUnitInfo(firstInfo),
                NormaliseUnitInfo(secondInfo) 
            },
            operation
        );
    }

    public static UnitInfo RaiseToIntegerExponent(double baseValue, int exponent)
    {
        return RaiseToIntegerExponent(new UnitInfo(baseValue), exponent);
    }

    static UnitInfo RaiseToIntegerExponent(UnitInfo baseInfo, int exponent)
    {
        if (exponent <= 1 && exponent >= 0)
        {
            baseInfo.Value = (exponent == 0 ? 1.0 : baseInfo.Value);
            return baseInfo;
        }

        UnitInfo outInfo = new UnitInfo(baseInfo);

        for (int i = 1; i < Math.Abs(exponent); i++)
        {
            outInfo = PerformManagedOperationValues
            (
                outInfo, baseInfo, Operations.Multiplication
            );
            if (outInfo.Error.Type != ErrorTypes.None) return outInfo;
        }

        return
        (
            exponent < 0 ?
            PerformManagedOperationValues(new UnitInfo(1.0), outInfo, Operations.Division) :
            outInfo
        );
    }

    static UnitInfo PerformManagedOperationNormalisedValues(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        outInfo =
        (
            normalisedInfos.Length == 1 ?
            //There is just one operand when the difference between both of them is too big.
            outInfo = normalisedInfos[0] :
            PerformManagedOperationTwoOperands(outInfo, normalisedInfos, operation)
        );

        return outInfo;
    }

    static UnitInfo PerformManagedOperationTwoOperands(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        UnitInfo outInfoNormalised = PerformManagedOperationValues
        (
            normalisedInfos[0], normalisedInfos[1], operation
        );

        if (outInfo.Error.Type != ErrorTypes.None)
        {
            return new UnitInfo(outInfo)
            {
                Error = new ErrorInfo(ErrorTypes.NumericError)
            };
        }

        outInfo.BaseTenExponent = outInfoNormalised.BaseTenExponent;
        outInfo.Value = outInfoNormalised.Value;
        //Normalised means no prefixes.
        outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage); 

        return outInfo;
    }

    static UnitInfo PerformManagedOperationValues(double firstValue, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            new UnitInfo(firstValue), new UnitInfo(secondValue), operation
        );
    }

    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            firstInfo, new UnitInfo(secondValue), operation
        );
    }

    //This method might be used to perform full operations (not just being the last calculation step) instead
    //of the default one (PerformManagedOperationUnits) for simple cases. That is: ones not dealing with the
    //complex numeric reality (Value, Prefix and BaseTenExponent) which makes a pre-analysis required.
    //Note that, unlikely what happens with PerformMangedOperationUnits, the outputs of this method aren't
    //normalised (= primarily stored under Value), what is useful in certain contexts.
    //NOTE: this function assumes that both inputs are normalised, what means that no prefix information is expected.
    //It might also be used with non-normalised inputs, but their prefix information would be plainly ignored.
    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        if (firstInfo.Value == 0.0 || secondInfo.Value == 0.0)
        {
            if (operation == Operations.Multiplication || operation == Operations.Division)
            {
                //Dividing by zero scenarios are taken into account somewhere else.
                return new UnitInfo(firstInfo) { Value = 0.0 };
            }
        }

        UnitInfo outInfo = new UnitInfo(firstInfo);
        UnitInfo firstInfo0 = new UnitInfo(firstInfo);
        UnitInfo secondInfo0 = new UnitInfo(secondInfo);

        boolean isWrong = false;
        try
        {
            if (operation == Operations.Addition)
            {
                outInfo.Value += secondInfo0.Value;
            }
            else if (operation == Operations.Subtraction)
            {
                outInfo.Value -= secondInfo.Value;
            }
            else
            {
                //The reason for checking whether BaseTenExponent is inside/outside the int range before performing 
                //the operation (rather than going ahead and eventually catching the resulting exception) isn't just
                //being quicker, but also the only option in many situations. Note that an addition/subtraction between
                //two int variables whose result is outside the int range might not trigger an exception (+ random 
                //negative value as output).
                if (VaryBaseTenExponent(outInfo, secondInfo0.BaseTenExponent, operation == Operations.Division).Error.Type != ErrorTypes.None)
                {
                    return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
                }

                if (operation == Operations.Multiplication)
                {
                    outInfo.Value *= secondInfo.Value;
                    outInfo.BaseTenExponent += secondInfo.BaseTenExponent;
                }
                else if (operation == Operations.Division)
                {
                    if (secondInfo.Value == 0.0)
                    {
                        return
                        (
                            new UnitInfo(outInfo) 
                            { 
                                Error = new ErrorInfo(ErrorTypes.NumericError) 
                            }
                        );
                    }
                    outInfo.Value /= secondInfo.Value;
                    outInfo.BaseTenExponent -= secondInfo.BaseTenExponent;
                }
            }
        }
        catch { isWrong = true; }

        return
        (
            //An error might not be triggered despite of dealing with numbers outside double precision.
            //For example: 0.00000000000000000001m * 0.0000000000000000000001m can output 0.0 without triggering an error. 
            isWrong || ((operation == Operations.Multiplication || operation == Operations.Division) && outInfo.Value == 0.0.0) ?
            OperationValuesManageError(firstInfo0, secondInfo0, operation) : outInfo
        );
    }

    static UnitInfo OperationValuesManageError(UnitInfo outInfo, UnitInfo secondInfo, Operations operation)
    {
        if (operation != Operations.Multiplication && operation != Operations.Division)
        {
            //This condition should never be true on account of the fact that the pre-modifications performed before
            //adding/subtracting should avoid erroneous situations.
            return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
        }

        UnitInfo secondInfo2 = ConvertValueToBaseTen(secondInfo.Value);
        outInfo = VaryBaseTenExponent(outInfo, secondInfo2.BaseTenExponent, operation == Operations.Division);
        if (Math.Abs(secondInfo2.Value) == 1.0 || outInfo.Error.Type != ErrorTypes.None) return outInfo;
        
        try
        {
            outInfo = PerformManagedOperationUnits
            (
                outInfo, secondInfo2.Value, operation
            );
        }
        catch
        {
            //Very unlikely scenario on account of the fact that Math.Abs(secondInfo2.Value)
            //lies within the 0.1-10.0 range.
            outInfo = OperationValuesManageError
            (
                new UnitInfo(outInfo)
                {
                    Value = secondInfo2.Value,
                    BaseTenExponent = 0
                },
                new UnitInfo()
                {
                    Value = outInfo.Value,
                    BaseTenExponent = outInfo.BaseTenExponent
                },
                operation
            );
        }

        return outInfo;
    }

    static UnitInfo ConvertValueToBaseTen(double value)
    {
        value = Math.Abs(value);
        return FromValueToBaseTenExponent
        (
             new UnitInfo(value), Math.Abs(value), false
        );
    }

    static UnitInfo ConvertBaseTenToValue(UnitInfo unitInfo)
    {
        if (unitInfo.BaseTenExponent == 0) return unitInfo;

        UnitInfo outInfo = new UnitInfo(unitInfo);
        boolean decrease = unitInfo.BaseTenExponent > 0;
        int sign = Math.Sign(outInfo.Value);
        double absValue = Math.Abs(outInfo.Value);

        while (outInfo.BaseTenExponent != 0.0)
        {
            if (decrease)
            {
                if (absValue >= MaxValueDec / 10.0) break;
                absValue *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }
            else
            {
                if (absValue <= MinValueDec * 10.0) break;
                absValue /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
        }

        outInfo.Value = sign * absValue;

        return outInfo;
    }

    static UnitInfo NormaliseUnitInfo(UnitInfo unitInfo)
    {
        if (unitInfo.Value == 0 && unitInfo.Prefix.Factor == 1.0)
        {
            return unitInfo;
        }
        UnitInfo outInfo = new UnitInfo(unitInfo);

        if (outInfo.Prefix.Factor != 1)
        {
            outInfo = FromValueToBaseTenExponent
            (
                outInfo, outInfo.Prefix.Factor, true
            );
            outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage);
        }
        if (outInfo.Value == 0.0) return outInfo;

        outInfo = FromValueToBaseTenExponent
        (
            outInfo, outInfo.Value, false
        );

        return outInfo;
    }

    static UnitInfo FromValueToBaseTenExponent(UnitInfo outInfo, double value, boolean isPrefix)
    {
        if (value == 0.0) return outInfo;

        double valueAbs = Math.Abs(value);
        boolean decrease = (valueAbs > 1.0);
        if (!isPrefix)
        {
            outInfo.Value = outInfo.Value / valueAbs;
        }

        while (valueAbs != 1.0)
        {
            if ((valueAbs < 10.0 && valueAbs > 1.0) || (valueAbs > 0.1.0 && valueAbs < 1.0))
            {
                if (!isPrefix) outInfo.Value = value;
                else
                {
                    outInfo = PerformManagedOperationValues
                    (
                        outInfo, value, Operations.Multiplication
                    );
                }

                return outInfo;
            }

            if (decrease)
            {
                value /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
            else
            {
                value *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }

            valueAbs = Math.Abs(value);
        }

        return outInfo;
    }

    //Method used to vary BaseTenExponent without provoking unhandled exceptions (i.e., bigger than Integer.MAX_VALUE).
    static UnitInfo VaryBaseTenExponent(UnitInfo info, int baseTenIncrease, boolean isDivision = false)
    {
        long val1 = info.BaseTenExponent;
        long val2 = baseTenIncrease;

        if (isDivision)
        {
            //Converting a negative value into positive might provoke an overflow error for the int type
            //(e.g., Math.Abs(Integer.MAIN_VALUE)). Converting both variables to long is a quick and effective
            //way to avoid this problem.
            val2 *= -1;
        }

        return
        (
             ((val2 > 0 && val1 > Integer.MAX_VALUE - val2) || (val2 < 0 && val1 < Integer.MAIN_VALUE - val2)) ?
            new UnitInfo(info, ErrorTypes.NumericError) : new UnitInfo(info){{ BaseTenExponent = (int)(val1 + val2); }}
        );
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2017-05-27 20:02:59.207
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2017-05-27 20:02:59.207
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2017-05-27 20:02:59.225
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
public class OperationsManaged
{
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, double second, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            firstInfo, new UnitInfo(second), operation
        );
    }

    public static UnitInfo PerformManagedOperationUnits(double first, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            new UnitInfo(first), secondInfo, operation
        );
    }

    //This method should always be used when dealing with random UnitInfo variables because it accounts for all the
    //possible scenarios. On the other hand, with simple operations (e.g., random UnitInfo & numeric type) it might
    //be better to use PerformManagedOperationValues. 
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        ErrorTypes errorType = InternalMethods.GetOperationError
        (
            firstInfo, secondInfo, operation
        );
        if (errorType != ErrorTypes.None)
        {
            return new UnitInfo(firstInfo) 
            {{
                Error = new ErrorInfo(errorType); 
            }};
        }

        return
        (
            operation == Operations.Addition || operation == Operations.Subtraction ?
            PerformManagedOperationAddition(firstInfo, secondInfo, operation) :
            PerformManagedOperationMultiplication(firstInfo, secondInfo, operation)
        );
    }

    static UnitInfo PerformManagedOperationAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {   
        //After being normalised, the operands might require further modifications.
        UnitInfo[] normalised = GetOperandsAddition(firstInfo, secondInfo, operation);

        return PerformManagedOperationNormalisedValues
        (
            firstInfo, normalised, operation
        );
    }

    static UnitInfo[] GetOperandsAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        UnitInfo[] operands2 = new UnitInfo[] 
        {
            new UnitInfo(firstInfo), new UnitInfo(secondInfo)
        };

        if (operands2[0].BaseTenExponent != operands2[1].BaseTenExponent || operands2[0].Prefix.Factor != operands2[1].Prefix.Factor)
        {
            //The addition/subtraction might not be performed right away even with normalised values.
            //For example: 5 and 6 from 5*10^2 and 6*10^7 cannot be added right away.
            operands2 = AdaptNormalisedValuesForAddition
            (
                new UnitInfo[] 
                { 
                    NormaliseUnitInfo(operands2[0]), 
                    NormaliseUnitInfo(operands2[1])
                },
                operation
            );
        }

        return operands2;
    }
    
    static UnitInfo[] AdaptNormalisedValuesForAddition(UnitInfo[] unitInfos2, Operations operation)
    {
        if (unitInfos2[0].BaseTenExponent == unitInfos2[1].BaseTenExponent)
        {
            //Having the same BaseTenExponent values means that the given operation can be performed right away.
            return unitInfos2;
        }

        int[] bigSmallI = 
        (
            unitInfos2[0].BaseTenExponent > unitInfos2[1].BaseTenExponent ?
            new int[] { 0, 1 } : new int[] { 1, 0 }
        );

        //Only the variable with the bigger value is modified. For example: 5*10^5 & 3*10^3 is converted
        //into 500*10^3 & 3*10^3 in order to allow the addition 500 + 3. 
        UnitInfo big2 = AdaptBiggerAdditionOperand(unitInfos2, bigSmallI, operation);
        if (big2.Error.Type != ErrorTypes.None)
        {
            return TooBigGapAddition(unitInfos2, bigSmallI, operation);
        }

        unitInfos2[bigSmallI[0]].Value = big2.Value;
        unitInfos2[bigSmallI[0]].BaseTenExponent = unitInfos2[bigSmallI[1]].BaseTenExponent;

        return unitInfos2;
    }

    //When adding/subtracting two numbers whose gap is bigger than the maximum double range, there
    //is no need to perform any operation (i.e., no change will be observed because of being outside
    //the maximum supported precision). This method takes care of these cases and returns the expected
    //output (i.e., biggest value).
    static UnitInfo[] TooBigGapAddition(UnitInfo[] unitInfos2, int[] bigSmallI, Operations operation)
    {
        UnitInfo[] outInfos = new UnitInfo[] 
        {
            //First operand (i.e., one whose information defines the operation) together with the
            //numeric information (i.e., just Value and BaseTenExponent because both are normalised)
            //which is associated with the biggest one.
            new UnitInfo(unitInfos2[0])
            {{
                Value = unitInfos2[bigSmallI[0]].Value;
                BaseTenExponent = unitInfos2[bigSmallI[0]].BaseTenExponent;
            }}
        };

        if (operation == Operations.Subtraction && bigSmallI[0] == 1)
        {
            outInfos[0].Value = -1.0 * outInfos[0].Value;
        }

        if (outInfos[0].Unit == Units.Unitless)
        {
            outInfos[0].Unit = unitInfos2[bigSmallI[1]].Unit;
        }

        return outInfos;
    }

    static UnitInfo AdaptBiggerAdditionOperand(UnitInfo[] unitInfos2, Integer[] bigSmallI, Operations operation)
    {
        int gapExponent = unitInfos2[bigSmallI[0]].BaseTenExponent - unitInfos2[bigSmallI[1]].BaseTenExponent;
        if (gapExponent >= 27)
        {
            //The difference between both inputs is bigger than (or, at least, very close to) the maximum double value/precision;
            //what makes this situation calculation unworthy and the first operand to be returned as the result.
            //Note that the error below these lines is just an easy way to tell the calling function about this eventuality.
            return new UnitInfo(unitInfos2[0]) 
            {{ 
                Error = new ErrorInfo(ErrorTypes.InvalidOperation); 
            }};
        }

        //PerformManagedOperationValues is used to make sure that the resulting numeric information is stored
        //in Value (if possible).
        UnitInfo big2 = PerformManagedOperationValues
        (
            RaiseToIntegerExponent(10.0, gapExponent), unitInfos2[bigSmallI[0]].Value, 
            Operations.Multiplication                
        );

        boolean isWrong = 
        (
            big2.Error.Type != ErrorTypes.None || big2.BaseTenExponent != 0 ?
            
            //The value of the bigger input times 10^(gap between BaseTenExponent of inputs) is too big. 
            isWrong = true :
            
            //Overflow-check very unlikely to trigger an error. In fact, with properly normalised variables,
            //triggering an error would be plainly impossible.               
            AreAdditionFinalValuesWrong
            (
                unitInfos2[0].Value, unitInfos2[1].Value, operation
            )
        );

        return
        (
            isWrong ?
            //This error is just an easy way to let the calling function know about the fact that no
            //calculation has been performed (too big gap). This isn't a properly-speaking error and
            //that's why it will not be notified to the user.
            new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }} :
            //Returning the new big value. For example: with 5*10^4 & 3*10^2, 500 would be returned.
            new UnitInfo(unitInfos2[bigSmallI[0]])
            {{
                Value = big2.Value;
            }}
        );
    }

    static boolean AreAdditionFinalValuesWrong(double val1, double val2, Operations operation)
    {
        boolean isWrong = false;

        try
        {
            val1 = val1 + val2 *
            (
                operation == Operations.Addition ? 1 : -1
            );
        }
        catch { isWrong = true; }

        return isWrong;
    }

    static UnitInfo PerformManagedOperationMultiplication(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationNormalisedValues
        (
            firstInfo, new UnitInfo[] 
            { 
                NormaliseUnitInfo(firstInfo),
                NormaliseUnitInfo(secondInfo) 
            },
            operation
        );
    }

    public static UnitInfo RaiseToIntegerExponent(double baseValue, int exponent)
    {
        return RaiseToIntegerExponent(new UnitInfo(baseValue), exponent);
    }

    static UnitInfo RaiseToIntegerExponent(UnitInfo baseInfo, int exponent)
    {
        if (exponent <= 1 && exponent >= 0)
        {
            baseInfo.Value = (exponent == 0 ? 1.0 : baseInfo.Value);
            return baseInfo;
        }

        UnitInfo outInfo = new UnitInfo(baseInfo);

        for (int i = 1; i < Math.Abs(exponent); i++)
        {
            outInfo = PerformManagedOperationValues
            (
                outInfo, baseInfo, Operations.Multiplication
            );
            if (outInfo.Error.Type != ErrorTypes.None) return outInfo;
        }

        return
        (
            exponent < 0 ?
            PerformManagedOperationValues(new UnitInfo(1.0), outInfo, Operations.Division) :
            outInfo
        );
    }

    static UnitInfo PerformManagedOperationNormalisedValues(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        outInfo =
        (
            normalisedInfos.Length == 1 ?
            //There is just one operand when the difference between both of them is too big.
            outInfo = normalisedInfos[0] :
            PerformManagedOperationTwoOperands(outInfo, normalisedInfos, operation)
        );

        return outInfo;
    }

    static UnitInfo PerformManagedOperationTwoOperands(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        UnitInfo outInfoNormalised = PerformManagedOperationValues
        (
            normalisedInfos[0], normalisedInfos[1], operation
        );

        if (outInfo.Error.Type != ErrorTypes.None)
        {
            return new UnitInfo(outInfo)
            {
                Error = new ErrorInfo(ErrorTypes.NumericError)
            };
        }

        outInfo.BaseTenExponent = outInfoNormalised.BaseTenExponent;
        outInfo.Value = outInfoNormalised.Value;
        //Normalised means no prefixes.
        outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage); 

        return outInfo;
    }

    static UnitInfo PerformManagedOperationValues(double firstValue, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            new UnitInfo(firstValue), new UnitInfo(secondValue), operation
        );
    }

    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            firstInfo, new UnitInfo(secondValue), operation
        );
    }

    //This method might be used to perform full operations (not just being the last calculation step) instead
    //of the default one (PerformManagedOperationUnits) for simple cases. That is: ones not dealing with the
    //complex numeric reality (Value, Prefix and BaseTenExponent) which makes a pre-analysis required.
    //Note that, unlikely what happens with PerformMangedOperationUnits, the outputs of this method aren't
    //normalised (= primarily stored under Value), what is useful in certain contexts.
    //NOTE: this function assumes that both inputs are normalised, what means that no prefix information is expected.
    //It might also be used with non-normalised inputs, but their prefix information would be plainly ignored.
    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        if (firstInfo.Value == 0.0 || secondInfo.Value == 0.0)
        {
            if (operation == Operations.Multiplication || operation == Operations.Division)
            {
                //Dividing by zero scenarios are taken into account somewhere else.
                return new UnitInfo(firstInfo) { Value = 0.0 };
            }
        }

        UnitInfo outInfo = new UnitInfo(firstInfo);
        UnitInfo firstInfo0 = new UnitInfo(firstInfo);
        UnitInfo secondInfo0 = new UnitInfo(secondInfo);

        boolean isWrong = false;
        try
        {
            if (operation == Operations.Addition)
            {
                outInfo.Value += secondInfo0.Value;
            }
            else if (operation == Operations.Subtraction)
            {
                outInfo.Value -= secondInfo.Value;
            }
            else
            {
                //The reason for checking whether BaseTenExponent is inside/outside the int range before performing 
                //the operation (rather than going ahead and eventually catching the resulting exception) isn't just
                //being quicker, but also the only option in many situations. Note that an addition/subtraction between
                //two int variables whose result is outside the int range might not trigger an exception (+ random 
                //negative value as output).
                if (VaryBaseTenExponent(outInfo, secondInfo0.BaseTenExponent, operation == Operations.Division).Error.Type != ErrorTypes.None)
                {
                    return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
                }

                if (operation == Operations.Multiplication)
                {
                    outInfo.Value *= secondInfo.Value;
                    outInfo.BaseTenExponent += secondInfo.BaseTenExponent;
                }
                else if (operation == Operations.Division)
                {
                    if (secondInfo.Value == 0.0)
                    {
                        return
                        (
                            new UnitInfo(outInfo) 
                            { 
                                Error = new ErrorInfo(ErrorTypes.NumericError) 
                            }
                        );
                    }
                    outInfo.Value /= secondInfo.Value;
                    outInfo.BaseTenExponent -= secondInfo.BaseTenExponent;
                }
            }
        }
        catch { isWrong = true; }

        return
        (
            //An error might not be triggered despite of dealing with numbers outside double precision.
            //For example: 0.00000000000000000001m * 0.0000000000000000000001m can output 0.0 without triggering an error. 
            isWrong || ((operation == Operations.Multiplication || operation == Operations.Division) && outInfo.Value == 0.0.0) ?
            OperationValuesManageError(firstInfo0, secondInfo0, operation) : outInfo
        );
    }

    static UnitInfo OperationValuesManageError(UnitInfo outInfo, UnitInfo secondInfo, Operations operation)
    {
        if (operation != Operations.Multiplication && operation != Operations.Division)
        {
            //This condition should never be true on account of the fact that the pre-modifications performed before
            //adding/subtracting should avoid erroneous situations.
            return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
        }

        UnitInfo secondInfo2 = ConvertValueToBaseTen(secondInfo.Value);
        outInfo = VaryBaseTenExponent(outInfo, secondInfo2.BaseTenExponent, operation == Operations.Division);
        if (Math.Abs(secondInfo2.Value) == 1.0 || outInfo.Error.Type != ErrorTypes.None) return outInfo;
        
        try
        {
            outInfo = PerformManagedOperationUnits
            (
                outInfo, secondInfo2.Value, operation
            );
        }
        catch
        {
            //Very unlikely scenario on account of the fact that Math.Abs(secondInfo2.Value)
            //lies within the 0.1-10.0 range.
            outInfo = OperationValuesManageError
            (
                new UnitInfo(outInfo)
                {
                    Value = secondInfo2.Value,
                    BaseTenExponent = 0
                },
                new UnitInfo()
                {
                    Value = outInfo.Value,
                    BaseTenExponent = outInfo.BaseTenExponent
                },
                operation
            );
        }

        return outInfo;
    }

    static UnitInfo ConvertValueToBaseTen(double value)
    {
        value = Math.Abs(value);
        return FromValueToBaseTenExponent
        (
             new UnitInfo(value), Math.Abs(value), false
        );
    }

    static UnitInfo ConvertBaseTenToValue(UnitInfo unitInfo)
    {
        if (unitInfo.BaseTenExponent == 0) return unitInfo;

        UnitInfo outInfo = new UnitInfo(unitInfo);
        boolean decrease = unitInfo.BaseTenExponent > 0;
        int sign = Math.Sign(outInfo.Value);
        double absValue = Math.Abs(outInfo.Value);

        while (outInfo.BaseTenExponent != 0.0)
        {
            if (decrease)
            {
                if (absValue >= MaxValueDec / 10.0) break;
                absValue *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }
            else
            {
                if (absValue <= MinValueDec * 10.0) break;
                absValue /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
        }

        outInfo.Value = sign * absValue;

        return outInfo;
    }

    static UnitInfo NormaliseUnitInfo(UnitInfo unitInfo)
    {
        if (unitInfo.Value == 0 && unitInfo.Prefix.Factor == 1.0)
        {
            return unitInfo;
        }
        UnitInfo outInfo = new UnitInfo(unitInfo);

        if (outInfo.Prefix.Factor != 1)
        {
            outInfo = FromValueToBaseTenExponent
            (
                outInfo, outInfo.Prefix.Factor, true
            );
            outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage);
        }
        if (outInfo.Value == 0.0) return outInfo;

        outInfo = FromValueToBaseTenExponent
        (
            outInfo, outInfo.Value, false
        );

        return outInfo;
    }

    static UnitInfo FromValueToBaseTenExponent(UnitInfo outInfo, double value, boolean isPrefix)
    {
        if (value == 0.0) return outInfo;

        double valueAbs = Math.Abs(value);
        boolean decrease = (valueAbs > 1.0);
        if (!isPrefix)
        {
            outInfo.Value = outInfo.Value / valueAbs;
        }

        while (valueAbs != 1.0)
        {
            if ((valueAbs < 10.0 && valueAbs > 1.0) || (valueAbs > 0.1.0 && valueAbs < 1.0))
            {
                if (!isPrefix) outInfo.Value = value;
                else
                {
                    outInfo = PerformManagedOperationValues
                    (
                        outInfo, value, Operations.Multiplication
                    );
                }

                return outInfo;
            }

            if (decrease)
            {
                value /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
            else
            {
                value *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }

            valueAbs = Math.Abs(value);
        }

        return outInfo;
    }

    //Method used to vary BaseTenExponent without provoking unhandled exceptions (i.e., bigger than Integer.MAX_VALUE).
    static UnitInfo VaryBaseTenExponent(UnitInfo info, int baseTenIncrease, boolean isDivision = false)
    {
        long val1 = info.BaseTenExponent;
        long val2 = baseTenIncrease;

        if (isDivision)
        {
            //Converting a negative value into positive might provoke an overflow error for the int type
            //(e.g., Math.Abs(Integer.MAIN_VALUE)). Converting both variables to long is a quick and effective
            //way to avoid this problem.
            val2 *= -1;
        }

        return
        (
             ((val2 > 0 && val1 > Integer.MAX_VALUE - val2) || (val2 < 0 && val1 < Integer.MAIN_VALUE - val2)) ?
            new UnitInfo(info, ErrorTypes.NumericError) : new UnitInfo(info){{ BaseTenExponent = (int)(val1 + val2); }}
        );
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:476)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 2 2017-05-27 20:02:59.226
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:476)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 0 2017-05-27 20:02:59.227
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:476)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.core 4 4 2017-05-27 20:02:59.776
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
public class OperationsManaged
{
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, double second, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            firstInfo, new UnitInfo(second), operation
        );
    }

    public static UnitInfo PerformManagedOperationUnits(double first, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            new UnitInfo(first), secondInfo, operation
        );
    }

    //This method should always be used when dealing with random UnitInfo variables because it accounts for all the
    //possible scenarios. On the other hand, with simple operations (e.g., random UnitInfo & numeric type) it might
    //be better to use PerformManagedOperationValues. 
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        ErrorTypes errorType = InternalMethods.GetOperationError
        (
            firstInfo, secondInfo, operation
        );
        if (errorType != ErrorTypes.None)
        {
            return new UnitInfo(firstInfo) 
            {{
                Error = new ErrorInfo(errorType); 
            }};
        }

        return
        (
            operation == Operations.Addition || operation == Operations.Subtraction ?
            PerformManagedOperationAddition(firstInfo, secondInfo, operation) :
            PerformManagedOperationMultiplication(firstInfo, secondInfo, operation)
        );
    }

    static UnitInfo PerformManagedOperationAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {   
        //After being normalised, the operands might require further modifications.
        UnitInfo[] normalised = GetOperandsAddition(firstInfo, secondInfo, operation);

        return PerformManagedOperationNormalisedValues
        (
            firstInfo, normalised, operation
        );
    }

    static UnitInfo[] GetOperandsAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        UnitInfo[] operands2 = new UnitInfo[] 
        {
            new UnitInfo(firstInfo), new UnitInfo(secondInfo)
        };

        if (operands2[0].BaseTenExponent != operands2[1].BaseTenExponent || operands2[0].Prefix.Factor != operands2[1].Prefix.Factor)
        {
            //The addition/subtraction might not be performed right away even with normalised values.
            //For example: 5 and 6 from 5*10^2 and 6*10^7 cannot be added right away.
            operands2 = AdaptNormalisedValuesForAddition
            (
                new UnitInfo[] 
                { 
                    NormaliseUnitInfo(operands2[0]), 
                    NormaliseUnitInfo(operands2[1])
                },
                operation
            );
        }

        return operands2;
    }
    
    static UnitInfo[] AdaptNormalisedValuesForAddition(UnitInfo[] unitInfos2, Operations operation)
    {
        if (unitInfos2[0].BaseTenExponent == unitInfos2[1].BaseTenExponent)
        {
            //Having the same BaseTenExponent values means that the given operation can be performed right away.
            return unitInfos2;
        }

        int[] bigSmallI = 
        (
            unitInfos2[0].BaseTenExponent > unitInfos2[1].BaseTenExponent ?
            new int[] { 0, 1 } : new int[] { 1, 0 }
        );

        //Only the variable with the bigger value is modified. For example: 5*10^5 & 3*10^3 is converted
        //into 500*10^3 & 3*10^3 in order to allow the addition 500 + 3. 
        UnitInfo big2 = AdaptBiggerAdditionOperand(unitInfos2, bigSmallI, operation);
        if (big2.Error.Type != ErrorTypes.None)
        {
            return TooBigGapAddition(unitInfos2, bigSmallI, operation);
        }

        unitInfos2[bigSmallI[0]].Value = big2.Value;
        unitInfos2[bigSmallI[0]].BaseTenExponent = unitInfos2[bigSmallI[1]].BaseTenExponent;

        return unitInfos2;
    }

    //When adding/subtracting two numbers whose gap is bigger than the maximum double range, there
    //is no need to perform any operation (i.e., no change will be observed because of being outside
    //the maximum supported precision). This method takes care of these cases and returns the expected
    //output (i.e., biggest value).
    static UnitInfo[] TooBigGapAddition(UnitInfo[] unitInfos2, int[] bigSmallI, Operations operation)
    {
        UnitInfo[] outInfos = new UnitInfo[] 
        {
            //First operand (i.e., one whose information defines the operation) together with the
            //numeric information (i.e., just Value and BaseTenExponent because both are normalised)
            //which is associated with the biggest one.
            new UnitInfo(unitInfos2[0])
            {{
                Value = unitInfos2[bigSmallI[0]].Value;
                BaseTenExponent = unitInfos2[bigSmallI[0]].BaseTenExponent;
            }}
        };

        if (operation == Operations.Subtraction && bigSmallI[0] == 1)
        {
            outInfos[0].Value = -1.0 * outInfos[0].Value;
        }

        if (outInfos[0].Unit == Units.Unitless)
        {
            outInfos[0].Unit = unitInfos2[bigSmallI[1]].Unit;
        }

        return outInfos;
    }

    static UnitInfo AdaptBiggerAdditionOperand(UnitInfo[] unitInfos2, Integer[] bigSmallI, Operations operation)
    {
        int gapExponent = unitInfos2[bigSmallI[0]].BaseTenExponent - unitInfos2[bigSmallI[1]].BaseTenExponent;
        if (gapExponent >= 27)
        {
            //The difference between both inputs is bigger than (or, at least, very close to) the maximum double value/precision;
            //what makes this situation calculation unworthy and the first operand to be returned as the result.
            //Note that the error below these lines is just an easy way to tell the calling function about this eventuality.
            return new UnitInfo(unitInfos2[0]) 
            {{ 
                Error = new ErrorInfo(ErrorTypes.InvalidOperation); 
            }};
        }

        //PerformManagedOperationValues is used to make sure that the resulting numeric information is stored
        //in Value (if possible).
        UnitInfo big2 = PerformManagedOperationValues
        (
            RaiseToIntegerExponent(10.0, gapExponent), unitInfos2[bigSmallI[0]].Value, 
            Operations.Multiplication                
        );

        boolean isWrong = 
        (
            big2.Error.Type != ErrorTypes.None || big2.BaseTenExponent != 0 ?
            
            //The value of the bigger input times 10^(gap between BaseTenExponent of inputs) is too big. 
            isWrong = true :
            
            //Overflow-check very unlikely to trigger an error. In fact, with properly normalised variables,
            //triggering an error would be plainly impossible.               
            AreAdditionFinalValuesWrong
            (
                unitInfos2[0].Value, unitInfos2[1].Value, operation
            )
        );

        return
        (
            isWrong ?
            //This error is just an easy way to let the calling function know about the fact that no
            //calculation has been performed (too big gap). This isn't a properly-speaking error and
            //that's why it will not be notified to the user.
            new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }} :
            //Returning the new big value. For example: with 5*10^4 & 3*10^2, 500 would be returned.
            new UnitInfo(unitInfos2[bigSmallI[0]])
            {{
                Value = big2.Value;
            }}
        );
    }

    static boolean AreAdditionFinalValuesWrong(double val1, double val2, Operations operation)
    {
        boolean isWrong = false;

        try
        {
            val1 = val1 + val2 *
            (
                operation == Operations.Addition ? 1 : -1
            );
        }
        catch { isWrong = true; }

        return isWrong;
    }

    static UnitInfo PerformManagedOperationMultiplication(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationNormalisedValues
        (
            firstInfo, new UnitInfo[] 
            { 
                NormaliseUnitInfo(firstInfo),
                NormaliseUnitInfo(secondInfo) 
            },
            operation
        );
    }

    public static UnitInfo RaiseToIntegerExponent(double baseValue, int exponent)
    {
        return RaiseToIntegerExponent(new UnitInfo(baseValue), exponent);
    }

    static UnitInfo RaiseToIntegerExponent(UnitInfo baseInfo, int exponent)
    {
        if (exponent <= 1 && exponent >= 0)
        {
            baseInfo.Value = (exponent == 0 ? 1.0 : baseInfo.Value);
            return baseInfo;
        }

        UnitInfo outInfo = new UnitInfo(baseInfo);

        for (int i = 1; i < Math.Abs(exponent); i++)
        {
            outInfo = PerformManagedOperationValues
            (
                outInfo, baseInfo, Operations.Multiplication
            );
            if (outInfo.Error.Type != ErrorTypes.None) return outInfo;
        }

        return
        (
            exponent < 0 ?
            PerformManagedOperationValues(new UnitInfo(1.0), outInfo, Operations.Division) :
            outInfo
        );
    }

    static UnitInfo PerformManagedOperationNormalisedValues(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        outInfo =
        (
            normalisedInfos.Length == 1 ?
            //There is just one operand when the difference between both of them is too big.
            outInfo = normalisedInfos[0] :
            PerformManagedOperationTwoOperands(outInfo, normalisedInfos, operation)
        );

        return outInfo;
    }

    static UnitInfo PerformManagedOperationTwoOperands(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        UnitInfo outInfoNormalised = PerformManagedOperationValues
        (
            normalisedInfos[0], normalisedInfos[1], operation
        );

        if (outInfo.Error.Type != ErrorTypes.None)
        {
            return new UnitInfo(outInfo)
            {
                Error = new ErrorInfo(ErrorTypes.NumericError)
            };
        }

        outInfo.BaseTenExponent = outInfoNormalised.BaseTenExponent;
        outInfo.Value = outInfoNormalised.Value;
        //Normalised means no prefixes.
        outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage); 

        return outInfo;
    }

    static UnitInfo PerformManagedOperationValues(double firstValue, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            new UnitInfo(firstValue), new UnitInfo(secondValue), operation
        );
    }

    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            firstInfo, new UnitInfo(secondValue), operation
        );
    }

    //This method might be used to perform full operations (not just being the last calculation step) instead
    //of the default one (PerformManagedOperationUnits) for simple cases. That is: ones not dealing with the
    //complex numeric reality (Value, Prefix and BaseTenExponent) which makes a pre-analysis required.
    //Note that, unlikely what happens with PerformMangedOperationUnits, the outputs of this method aren't
    //normalised (= primarily stored under Value), what is useful in certain contexts.
    //NOTE: this function assumes that both inputs are normalised, what means that no prefix information is expected.
    //It might also be used with non-normalised inputs, but their prefix information would be plainly ignored.
    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        if (firstInfo.Value == 0.0 || secondInfo.Value == 0.0)
        {
            if (operation == Operations.Multiplication || operation == Operations.Division)
            {
                //Dividing by zero scenarios are taken into account somewhere else.
                return new UnitInfo(firstInfo) { Value = 0.0 };
            }
        }

        UnitInfo outInfo = new UnitInfo(firstInfo);
        UnitInfo firstInfo0 = new UnitInfo(firstInfo);
        UnitInfo secondInfo0 = new UnitInfo(secondInfo);

        boolean isWrong = false;
        try
        {
            if (operation == Operations.Addition)
            {
                outInfo.Value += secondInfo0.Value;
            }
            else if (operation == Operations.Subtraction)
            {
                outInfo.Value -= secondInfo.Value;
            }
            else
            {
                //The reason for checking whether BaseTenExponent is inside/outside the int range before performing 
                //the operation (rather than going ahead and eventually catching the resulting exception) isn't just
                //being quicker, but also the only option in many situations. Note that an addition/subtraction between
                //two int variables whose result is outside the int range might not trigger an exception (+ random 
                //negative value as output).
                if (VaryBaseTenExponent(outInfo, secondInfo0.BaseTenExponent, operation == Operations.Division).Error.Type != ErrorTypes.None)
                {
                    return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
                }

                if (operation == Operations.Multiplication)
                {
                    outInfo.Value *= secondInfo.Value;
                    outInfo.BaseTenExponent += secondInfo.BaseTenExponent;
                }
                else if (operation == Operations.Division)
                {
                    if (secondInfo.Value == 0.0)
                    {
                        return
                        (
                            new UnitInfo(outInfo) 
                            { 
                                Error = new ErrorInfo(ErrorTypes.NumericError) 
                            }
                        );
                    }
                    outInfo.Value /= secondInfo.Value;
                    outInfo.BaseTenExponent -= secondInfo.BaseTenExponent;
                }
            }
        }
        catch { isWrong = true; }

        return
        (
            //An error might not be triggered despite of dealing with numbers outside double precision.
            //For example: 0.00000000000000000001m * 0.0000000000000000000001m can output 0.0 without triggering an error. 
            isWrong || ((operation == Operations.Multiplication || operation == Operations.Division) && outInfo.Value == 0.0.0) ?
            OperationValuesManageError(firstInfo0, secondInfo0, operation) : outInfo
        );
    }

    static UnitInfo OperationValuesManageError(UnitInfo outInfo, UnitInfo secondInfo, Operations operation)
    {
        if (operation != Operations.Multiplication && operation != Operations.Division)
        {
            //This condition should never be true on account of the fact that the pre-modifications performed before
            //adding/subtracting should avoid erroneous situations.
            return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
        }

        UnitInfo secondInfo2 = ConvertValueToBaseTen(secondInfo.Value);
        outInfo = VaryBaseTenExponent(outInfo, secondInfo2.BaseTenExponent, operation == Operations.Division);
        if (Math.Abs(secondInfo2.Value) == 1.0 || outInfo.Error.Type != ErrorTypes.None) return outInfo;
        
        try
        {
            outInfo = PerformManagedOperationUnits
            (
                outInfo, secondInfo2.Value, operation
            );
        }
        catch
        {
            //Very unlikely scenario on account of the fact that Math.Abs(secondInfo2.Value)
            //lies within the 0.1-10.0 range.
            outInfo = OperationValuesManageError
            (
                new UnitInfo(outInfo)
                {
                    Value = secondInfo2.Value,
                    BaseTenExponent = 0
                },
                new UnitInfo()
                {
                    Value = outInfo.Value,
                    BaseTenExponent = outInfo.BaseTenExponent
                },
                operation
            );
        }

        return outInfo;
    }

    static UnitInfo ConvertValueToBaseTen(double value)
    {
        value = Math.Abs(value);
        return FromValueToBaseTenExponent
        (
             new UnitInfo(value), Math.Abs(value), false
        );
    }

    static UnitInfo ConvertBaseTenToValue(UnitInfo unitInfo)
    {
        if (unitInfo.BaseTenExponent == 0) return unitInfo;

        UnitInfo outInfo = new UnitInfo(unitInfo);
        boolean decrease = unitInfo.BaseTenExponent > 0;
        int sign = Math.Sign(outInfo.Value);
        double absValue = Math.Abs(outInfo.Value);

        while (outInfo.BaseTenExponent != 0.0)
        {
            if (decrease)
            {
                if (absValue >= MaxValueDec / 10.0) break;
                absValue *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }
            else
            {
                if (absValue <= MinValueDec * 10.0) break;
                absValue /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
        }

        outInfo.Value = sign * absValue;

        return outInfo;
    }

    static UnitInfo NormaliseUnitInfo(UnitInfo unitInfo)
    {
        if (unitInfo.Value == 0 && unitInfo.Prefix.Factor == 1.0)
        {
            return unitInfo;
        }
        UnitInfo outInfo = new UnitInfo(unitInfo);

        if (outInfo.Prefix.Factor != 1)
        {
            outInfo = FromValueToBaseTenExponent
            (
                outInfo, outInfo.Prefix.Factor, true
            );
            outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage);
        }
        if (outInfo.Value == 0.0) return outInfo;

        outInfo = FromValueToBaseTenExponent
        (
            outInfo, outInfo.Value, false
        );

        return outInfo;
    }

    static UnitInfo FromValueToBaseTenExponent(UnitInfo outInfo, double value, boolean isPrefix)
    {
        if (value == 0.0) return outInfo;

        double valueAbs = Math.Abs(value);
        boolean decrease = (valueAbs > 1.0);
        if (!isPrefix)
        {
            outInfo.Value = outInfo.Value / valueAbs;
        }

        while (valueAbs != 1.0)
        {
            if ((valueAbs < 10.0 && valueAbs > 1.0) || (valueAbs > 0.1.0 && valueAbs < 1.0))
            {
                if (!isPrefix) outInfo.Value = value;
                else
                {
                    outInfo = PerformManagedOperationValues
                    (
                        outInfo, value, Operations.Multiplication
                    );
                }

                return outInfo;
            }

            if (decrease)
            {
                value /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
            else
            {
                value *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }

            valueAbs = Math.Abs(value);
        }

        return outInfo;
    }

    //Method used to vary BaseTenExponent without provoking unhandled exceptions (i.e., bigger than Integer.MAX_VALUE).
    static UnitInfo VaryBaseTenExponent(UnitInfo info, int baseTenIncrease, boolean isDivision = false)
    {
        long val1 = info.BaseTenExponent;
        long val2 = baseTenIncrease;

        if (isDivision)
        {
            //Converting a negative value into positive might provoke an overflow error for the int type
            //(e.g., Math.Abs(Integer.MAIN_VALUE)). Converting both variables to long is a quick and effective
            //way to avoid this problem.
            val2 *= -1;
        }

        return
        (
             ((val2 > 0 && val1 > Integer.MAX_VALUE - val2) || (val2 < 0 && val1 < Integer.MAIN_VALUE - val2)) ?
            new UnitInfo(info, ErrorTypes.NumericError) : new UnitInfo(info){{ BaseTenExponent = (int)(val1 + val2); }}
        );
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 2 2017-05-27 20:02:59.777
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 0 2017-05-27 20:02:59.777
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.core 4 4 2017-05-27 20:03:01.081
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
public class OperationsManaged
{
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, double second, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            firstInfo, new UnitInfo(second), operation
        );
    }

    public static UnitInfo PerformManagedOperationUnits(double first, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            new UnitInfo(first), secondInfo, operation
        );
    }

    //This method should always be used when dealing with random UnitInfo variables because it accounts for all the
    //possible scenarios. On the other hand, with simple operations (e.g., random UnitInfo & numeric type) it might
    //be better to use PerformManagedOperationValues. 
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        ErrorTypes errorType = InternalMethods.GetOperationError
        (
            firstInfo, secondInfo, operation
        );
        if (errorType != ErrorTypes.None)
        {
            return new UnitInfo(firstInfo) 
            {{
                Error = new ErrorInfo(errorType); 
            }};
        }

        return
        (
            operation == Operations.Addition || operation == Operations.Subtraction ?
            PerformManagedOperationAddition(firstInfo, secondInfo, operation) :
            PerformManagedOperationMultiplication(firstInfo, secondInfo, operation)
        );
    }

    static UnitInfo PerformManagedOperationAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {   
        //After being normalised, the operands might require further modifications.
        UnitInfo[] normalised = GetOperandsAddition(firstInfo, secondInfo, operation);

        return PerformManagedOperationNormalisedValues
        (
            firstInfo, normalised, operation
        );
    }

    static UnitInfo[] GetOperandsAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        UnitInfo[] operands2 = new UnitInfo[] 
        {
            new UnitInfo(firstInfo), new UnitInfo(secondInfo)
        };

        if (operands2[0].BaseTenExponent != operands2[1].BaseTenExponent || operands2[0].Prefix.Factor != operands2[1].Prefix.Factor)
        {
            //The addition/subtraction might not be performed right away even with normalised values.
            //For example: 5 and 6 from 5*10^2 and 6*10^7 cannot be added right away.
            operands2 = AdaptNormalisedValuesForAddition
            (
                new UnitInfo[] 
                { 
                    NormaliseUnitInfo(operands2[0]), 
                    NormaliseUnitInfo(operands2[1])
                },
                operation
            );
        }

        return operands2;
    }
    
    static UnitInfo[] AdaptNormalisedValuesForAddition(UnitInfo[] unitInfos2, Operations operation)
    {
        if (unitInfos2[0].BaseTenExponent == unitInfos2[1].BaseTenExponent)
        {
            //Having the same BaseTenExponent values means that the given operation can be performed right away.
            return unitInfos2;
        }

        int[] bigSmallI = 
        (
            unitInfos2[0].BaseTenExponent > unitInfos2[1].BaseTenExponent ?
            new int[] { 0, 1 } : new int[] { 1, 0 }
        );

        //Only the variable with the bigger value is modified. For example: 5*10^5 & 3*10^3 is converted
        //into 500*10^3 & 3*10^3 in order to allow the addition 500 + 3. 
        UnitInfo big2 = AdaptBiggerAdditionOperand(unitInfos2, bigSmallI, operation);
        if (big2.Error.Type != ErrorTypes.None)
        {
            return TooBigGapAddition(unitInfos2, bigSmallI, operation);
        }

        unitInfos2[bigSmallI[0]].Value = big2.Value;
        unitInfos2[bigSmallI[0]].BaseTenExponent = unitInfos2[bigSmallI[1]].BaseTenExponent;

        return unitInfos2;
    }

    //When adding/subtracting two numbers whose gap is bigger than the maximum double range, there
    //is no need to perform any operation (i.e., no change will be observed because of being outside
    //the maximum supported precision). This method takes care of these cases and returns the expected
    //output (i.e., biggest value).
    static UnitInfo[] TooBigGapAddition(UnitInfo[] unitInfos2, int[] bigSmallI, Operations operation)
    {
        UnitInfo[] outInfos = new UnitInfo[] 
        {
            //First operand (i.e., one whose information defines the operation) together with the
            //numeric information (i.e., just Value and BaseTenExponent because both are normalised)
            //which is associated with the biggest one.
            new UnitInfo(unitInfos2[0])
            {{
                Value = unitInfos2[bigSmallI[0]].Value;
                BaseTenExponent = unitInfos2[bigSmallI[0]].BaseTenExponent;
            }}
        };

        if (operation == Operations.Subtraction && bigSmallI[0] == 1)
        {
            outInfos[0].Value = -1.0 * outInfos[0].Value;
        }

        if (outInfos[0].Unit == Units.Unitless)
        {
            outInfos[0].Unit = unitInfos2[bigSmallI[1]].Unit;
        }

        return outInfos;
    }

    static UnitInfo AdaptBiggerAdditionOperand(UnitInfo[] unitInfos2, Integer[] bigSmallI, Operations operation)
    {
        int gapExponent = unitInfos2[bigSmallI[0]].BaseTenExponent - unitInfos2[bigSmallI[1]].BaseTenExponent;
        if (gapExponent >= 27)
        {
            //The difference between both inputs is bigger than (or, at least, very close to) the maximum double value/precision;
            //what makes this situation calculation unworthy and the first operand to be returned as the result.
            //Note that the error below these lines is just an easy way to tell the calling function about this eventuality.
            return new UnitInfo(unitInfos2[0]) 
            {{ 
                Error = new ErrorInfo(ErrorTypes.InvalidOperation); 
            }};
        }

        //PerformManagedOperationValues is used to make sure that the resulting numeric information is stored
        //in Value (if possible).
        UnitInfo big2 = PerformManagedOperationValues
        (
            RaiseToIntegerExponent(10.0, gapExponent), unitInfos2[bigSmallI[0]].Value, 
            Operations.Multiplication                
        );

        boolean isWrong = 
        (
            big2.Error.Type != ErrorTypes.None || big2.BaseTenExponent != 0 ?
            
            //The value of the bigger input times 10^(gap between BaseTenExponent of inputs) is too big. 
            isWrong = true :
            
            //Overflow-check very unlikely to trigger an error. In fact, with properly normalised variables,
            //triggering an error would be plainly impossible.               
            AreAdditionFinalValuesWrong
            (
                unitInfos2[0].Value, unitInfos2[1].Value, operation
            )
        );

        return
        (
            isWrong ?
            //This error is just an easy way to let the calling function know about the fact that no
            //calculation has been performed (too big gap). This isn't a properly-speaking error and
            //that's why it will not be notified to the user.
            new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }} :
            //Returning the new big value. For example: with 5*10^4 & 3*10^2, 500 would be returned.
            new UnitInfo(unitInfos2[bigSmallI[0]])
            {{
                Value = big2.Value;
            }}
        );
    }

    static boolean AreAdditionFinalValuesWrong(double val1, double val2, Operations operation)
    {
        boolean isWrong = false;

        try
        {
            val1 = val1 + val2 *
            (
                operation == Operations.Addition ? 1 : -1
            );
        }
        catch { isWrong = true; }

        return isWrong;
    }

    static UnitInfo PerformManagedOperationMultiplication(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationNormalisedValues
        (
            firstInfo, new UnitInfo[] 
            { 
                NormaliseUnitInfo(firstInfo),
                NormaliseUnitInfo(secondInfo) 
            },
            operation
        );
    }

    public static UnitInfo RaiseToIntegerExponent(double baseValue, int exponent)
    {
        return RaiseToIntegerExponent(new UnitInfo(baseValue), exponent);
    }

    static UnitInfo RaiseToIntegerExponent(UnitInfo baseInfo, int exponent)
    {
        if (exponent <= 1 && exponent >= 0)
        {
            baseInfo.Value = (exponent == 0 ? 1.0 : baseInfo.Value);
            return baseInfo;
        }

        UnitInfo outInfo = new UnitInfo(baseInfo);

        for (int i = 1; i < Math.Abs(exponent); i++)
        {
            outInfo = PerformManagedOperationValues
            (
                outInfo, baseInfo, Operations.Multiplication
            );
            if (outInfo.Error.Type != ErrorTypes.None) return outInfo;
        }

        return
        (
            exponent < 0 ?
            PerformManagedOperationValues(new UnitInfo(1.0), outInfo, Operations.Division) :
            outInfo
        );
    }

    static UnitInfo PerformManagedOperationNormalisedValues(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        outInfo =
        (
            normalisedInfos.Length == 1 ?
            //There is just one operand when the difference between both of them is too big.
            outInfo = normalisedInfos[0] :
            PerformManagedOperationTwoOperands(outInfo, normalisedInfos, operation)
        );

        return outInfo;
    }

    static UnitInfo PerformManagedOperationTwoOperands(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        UnitInfo outInfoNormalised = PerformManagedOperationValues
        (
            normalisedInfos[0], normalisedInfos[1], operation
        );

        if (outInfo.Error.Type != ErrorTypes.None)
        {
            return new UnitInfo(outInfo)
            {
                Error = new ErrorInfo(ErrorTypes.NumericError)
            };
        }

        outInfo.BaseTenExponent = outInfoNormalised.BaseTenExponent;
        outInfo.Value = outInfoNormalised.Value;
        //Normalised means no prefixes.
        outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage); 

        return outInfo;
    }

    static UnitInfo PerformManagedOperationValues(double firstValue, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            new UnitInfo(firstValue), new UnitInfo(secondValue), operation
        );
    }

    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            firstInfo, new UnitInfo(secondValue), operation
        );
    }

    //This method might be used to perform full operations (not just being the last calculation step) instead
    //of the default one (PerformManagedOperationUnits) for simple cases. That is: ones not dealing with the
    //complex numeric reality (Value, Prefix and BaseTenExponent) which makes a pre-analysis required.
    //Note that, unlikely what happens with PerformMangedOperationUnits, the outputs of this method aren't
    //normalised (= primarily stored under Value), what is useful in certain contexts.
    //NOTE: this function assumes that both inputs are normalised, what means that no prefix information is expected.
    //It might also be used with non-normalised inputs, but their prefix information would be plainly ignored.
    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        if (firstInfo.Value == 0.0 || secondInfo.Value == 0.0)
        {
            if (operation == Operations.Multiplication || operation == Operations.Division)
            {
                //Dividing by zero scenarios are taken into account somewhere else.
                return new UnitInfo(firstInfo) { Value = 0.0 };
            }
        }

        UnitInfo outInfo = new UnitInfo(firstInfo);
        UnitInfo firstInfo0 = new UnitInfo(firstInfo);
        UnitInfo secondInfo0 = new UnitInfo(secondInfo);

        boolean isWrong = false;
        try
        {
            if (operation == Operations.Addition)
            {
                outInfo.Value += secondInfo0.Value;
            }
            else if (operation == Operations.Subtraction)
            {
                outInfo.Value -= secondInfo.Value;
            }
            else
            {
                //The reason for checking whether BaseTenExponent is inside/outside the int range before performing 
                //the operation (rather than going ahead and eventually catching the resulting exception) isn't just
                //being quicker, but also the only option in many situations. Note that an addition/subtraction between
                //two int variables whose result is outside the int range might not trigger an exception (+ random 
                //negative value as output).
                if (VaryBaseTenExponent(outInfo, secondInfo0.BaseTenExponent, operation == Operations.Division).Error.Type != ErrorTypes.None)
                {
                    return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
                }

                if (operation == Operations.Multiplication)
                {
                    outInfo.Value *= secondInfo.Value;
                    outInfo.BaseTenExponent += secondInfo.BaseTenExponent;
                }
                else if (operation == Operations.Division)
                {
                    if (secondInfo.Value == 0.0)
                    {
                        return
                        (
                            new UnitInfo(outInfo) 
                            { 
                                Error = new ErrorInfo(ErrorTypes.NumericError) 
                            }
                        );
                    }
                    outInfo.Value /= secondInfo.Value;
                    outInfo.BaseTenExponent -= secondInfo.BaseTenExponent;
                }
            }
        }
        catch { isWrong = true; }

        return
        (
            //An error might not be triggered despite of dealing with numbers outside double precision.
            //For example: 0.00000000000000000001m * 0.0000000000000000000001m can output 0.0 without triggering an error. 
            isWrong || ((operation == Operations.Multiplication || operation == Operations.Division) && outInfo.Value == 0.0.0) ?
            OperationValuesManageError(firstInfo0, secondInfo0, operation) : outInfo
        );
    }

    static UnitInfo OperationValuesManageError(UnitInfo outInfo, UnitInfo secondInfo, Operations operation)
    {
        if (operation != Operations.Multiplication && operation != Operations.Division)
        {
            //This condition should never be true on account of the fact that the pre-modifications performed before
            //adding/subtracting should avoid erroneous situations.
            return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
        }

        UnitInfo secondInfo2 = ConvertValueToBaseTen(secondInfo.Value);
        outInfo = VaryBaseTenExponent(outInfo, secondInfo2.BaseTenExponent, operation == Operations.Division);
        if (Math.Abs(secondInfo2.Value) == 1.0 || outInfo.Error.Type != ErrorTypes.None) return outInfo;
        
        try
        {
            outInfo = PerformManagedOperationUnits
            (
                outInfo, secondInfo2.Value, operation
            );
        }
        catch
        {
            //Very unlikely scenario on account of the fact that Math.Abs(secondInfo2.Value)
            //lies within the 0.1-10.0 range.
            outInfo = OperationValuesManageError
            (
                new UnitInfo(outInfo)
                {
                    Value = secondInfo2.Value,
                    BaseTenExponent = 0
                },
                new UnitInfo()
                {
                    Value = outInfo.Value,
                    BaseTenExponent = outInfo.BaseTenExponent
                },
                operation
            );
        }

        return outInfo;
    }

    static UnitInfo ConvertValueToBaseTen(double value)
    {
        value = Math.Abs(value);
        return FromValueToBaseTenExponent
        (
             new UnitInfo(value), Math.Abs(value), false
        );
    }

    static UnitInfo ConvertBaseTenToValue(UnitInfo unitInfo)
    {
        if (unitInfo.BaseTenExponent == 0) return unitInfo;

        UnitInfo outInfo = new UnitInfo(unitInfo);
        boolean decrease = unitInfo.BaseTenExponent > 0;
        int sign = Math.Sign(outInfo.Value);
        double absValue = Math.Abs(outInfo.Value);

        while (outInfo.BaseTenExponent != 0.0)
        {
            if (decrease)
            {
                if (absValue >= MaxValueDec / 10.0) break;
                absValue *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }
            else
            {
                if (absValue <= MinValueDec * 10.0) break;
                absValue /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
        }

        outInfo.Value = sign * absValue;

        return outInfo;
    }

    static UnitInfo NormaliseUnitInfo(UnitInfo unitInfo)
    {
        if (unitInfo.Value == 0 && unitInfo.Prefix.Factor == 1.0)
        {
            return unitInfo;
        }
        UnitInfo outInfo = new UnitInfo(unitInfo);

        if (outInfo.Prefix.Factor != 1)
        {
            outInfo = FromValueToBaseTenExponent
            (
                outInfo, outInfo.Prefix.Factor, true
            );
            outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage);
        }
        if (outInfo.Value == 0.0) return outInfo;

        outInfo = FromValueToBaseTenExponent
        (
            outInfo, outInfo.Value, false
        );

        return outInfo;
    }

    static UnitInfo FromValueToBaseTenExponent(UnitInfo outInfo, double value, boolean isPrefix)
    {
        if (value == 0.0) return outInfo;

        double valueAbs = Math.Abs(value);
        boolean decrease = (valueAbs > 1.0);
        if (!isPrefix)
        {
            outInfo.Value = outInfo.Value / valueAbs;
        }

        while (valueAbs != 1.0)
        {
            if ((valueAbs < 10.0 && valueAbs > 1.0) || (valueAbs > 0.1.0 && valueAbs < 1.0))
            {
                if (!isPrefix) outInfo.Value = value;
                else
                {
                    outInfo = PerformManagedOperationValues
                    (
                        outInfo, value, Operations.Multiplication
                    );
                }

                return outInfo;
            }

            if (decrease)
            {
                value /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
            else
            {
                value *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }

            valueAbs = Math.Abs(value);
        }

        return outInfo;
    }

    //Method used to vary BaseTenExponent without provoking unhandled exceptions (i.e., bigger than Integer.MAX_VALUE).
    static UnitInfo VaryBaseTenExponent(UnitInfo info, int baseTenIncrease, boolean isDivision = false)
    {
        long val1 = info.BaseTenExponent;
        long val2 = baseTenIncrease;

        if (isDivision)
        {
            //Converting a negative value into positive might provoke an overflow error for the int type
            //(e.g., Math.Abs(Integer.MAIN_VALUE)). Converting both variables to long is a quick and effective
            //way to avoid this problem.
            val2 *= -1;
        }

        return
        (
             ((val2 > 0 && val1 > Integer.MAX_VALUE - val2) || (val2 < 0 && val1 < Integer.MAIN_VALUE - val2)) ?
            new UnitInfo(info, ErrorTypes.NumericError) : new UnitInfo(info){{ BaseTenExponent = (int)(val1 + val2); }}
        );
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:137)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:116)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:164)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:86)
	at org.eclipse.jface.text.TextViewerHoverManager$4.run(TextViewerHoverManager.java:165)

!ENTRY org.eclipse.jdt.ui 4 2 2017-05-27 20:03:01.086
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:137)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:116)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:164)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:86)
	at org.eclipse.jface.text.TextViewerHoverManager$4.run(TextViewerHoverManager.java:165)

!ENTRY org.eclipse.jdt.ui 4 0 2017-05-27 20:03:01.086
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:137)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:116)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:164)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:86)
	at org.eclipse.jface.text.TextViewerHoverManager$4.run(TextViewerHoverManager.java:165)

!ENTRY org.eclipse.jdt.core 4 4 2017-05-27 20:03:01.145
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
public class OperationsManaged
{
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, double second, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            firstInfo, new UnitInfo(second), operation
        );
    }

    public static UnitInfo PerformManagedOperationUnits(double first, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            new UnitInfo(first), secondInfo, operation
        );
    }

    //This method should always be used when dealing with random UnitInfo variables because it accounts for all the
    //possible scenarios. On the other hand, with simple operations (e.g., random UnitInfo & numeric type) it might
    //be better to use PerformManagedOperationValues. 
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        ErrorTypes errorType = InternalMethods.GetOperationError
        (
            firstInfo, secondInfo, operation
        );
        if (errorType != ErrorTypes.None)
        {
            return new UnitInfo(firstInfo) 
            {{
                Error = new ErrorInfo(errorType); 
            }};
        }

        return
        (
            operation == Operations.Addition || operation == Operations.Subtraction ?
            PerformManagedOperationAddition(firstInfo, secondInfo, operation) :
            PerformManagedOperationMultiplication(firstInfo, secondInfo, operation)
        );
    }

    static UnitInfo PerformManagedOperationAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {   
        //After being normalised, the operands might require further modifications.
        UnitInfo[] normalised = GetOperandsAddition(firstInfo, secondInfo, operation);

        return PerformManagedOperationNormalisedValues
        (
            firstInfo, normalised, operation
        );
    }

    static UnitInfo[] GetOperandsAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        UnitInfo[] operands2 = new UnitInfo[] 
        {
            new UnitInfo(firstInfo), new UnitInfo(secondInfo)
        };

        if (operands2[0].BaseTenExponent != operands2[1].BaseTenExponent || operands2[0].Prefix.Factor != operands2[1].Prefix.Factor)
        {
            //The addition/subtraction might not be performed right away even with normalised values.
            //For example: 5 and 6 from 5*10^2 and 6*10^7 cannot be added right away.
            operands2 = AdaptNormalisedValuesForAddition
            (
                new UnitInfo[] 
                { 
                    NormaliseUnitInfo(operands2[0]), 
                    NormaliseUnitInfo(operands2[1])
                },
                operation
            );
        }

        return operands2;
    }
    
    static UnitInfo[] AdaptNormalisedValuesForAddition(UnitInfo[] unitInfos2, Operations operation)
    {
        if (unitInfos2[0].BaseTenExponent == unitInfos2[1].BaseTenExponent)
        {
            //Having the same BaseTenExponent values means that the given operation can be performed right away.
            return unitInfos2;
        }

        int[] bigSmallI = 
        (
            unitInfos2[0].BaseTenExponent > unitInfos2[1].BaseTenExponent ?
            new int[] { 0, 1 } : new int[] { 1, 0 }
        );

        //Only the variable with the bigger value is modified. For example: 5*10^5 & 3*10^3 is converted
        //into 500*10^3 & 3*10^3 in order to allow the addition 500 + 3. 
        UnitInfo big2 = AdaptBiggerAdditionOperand(unitInfos2, bigSmallI, operation);
        if (big2.Error.Type != ErrorTypes.None)
        {
            return TooBigGapAddition(unitInfos2, bigSmallI, operation);
        }

        unitInfos2[bigSmallI[0]].Value = big2.Value;
        unitInfos2[bigSmallI[0]].BaseTenExponent = unitInfos2[bigSmallI[1]].BaseTenExponent;

        return unitInfos2;
    }

    //When adding/subtracting two numbers whose gap is bigger than the maximum double range, there
    //is no need to perform any operation (i.e., no change will be observed because of being outside
    //the maximum supported precision). This method takes care of these cases and returns the expected
    //output (i.e., biggest value).
    static UnitInfo[] TooBigGapAddition(UnitInfo[] unitInfos2, int[] bigSmallI, Operations operation)
    {
        UnitInfo[] outInfos = new UnitInfo[] 
        {
            //First operand (i.e., one whose information defines the operation) together with the
            //numeric information (i.e., just Value and BaseTenExponent because both are normalised)
            //which is associated with the biggest one.
            new UnitInfo(unitInfos2[0])
            {{
                Value = unitInfos2[bigSmallI[0]].Value;
                BaseTenExponent = unitInfos2[bigSmallI[0]].BaseTenExponent;
            }}
        };

        if (operation == Operations.Subtraction && bigSmallI[0] == 1)
        {
            outInfos[0].Value = -1.0 * outInfos[0].Value;
        }

        if (outInfos[0].Unit == Units.Unitless)
        {
            outInfos[0].Unit = unitInfos2[bigSmallI[1]].Unit;
        }

        return outInfos;
    }

    static UnitInfo AdaptBiggerAdditionOperand(UnitInfo[] unitInfos2, Integer[] bigSmallI, Operations operation)
    {
        int gapExponent = unitInfos2[bigSmallI[0]].BaseTenExponent - unitInfos2[bigSmallI[1]].BaseTenExponent;
        if (gapExponent >= 27)
        {
            //The difference between both inputs is bigger than (or, at least, very close to) the maximum double value/precision;
            //what makes this situation calculation unworthy and the first operand to be returned as the result.
            //Note that the error below these lines is just an easy way to tell the calling function about this eventuality.
            return new UnitInfo(unitInfos2[0]) 
            {{ 
                Error = new ErrorInfo(ErrorTypes.InvalidOperation); 
            }};
        }

        //PerformManagedOperationValues is used to make sure that the resulting numeric information is stored
        //in Value (if possible).
        UnitInfo big2 = PerformManagedOperationValues
        (
            RaiseToIntegerExponent(10.0, gapExponent), unitInfos2[bigSmallI[0]].Value, 
            Operations.Multiplication                
        );

        boolean isWrong = 
        (
            big2.Error.Type != ErrorTypes.None || big2.BaseTenExponent != 0 ?
            
            //The value of the bigger input times 10^(gap between BaseTenExponent of inputs) is too big. 
            isWrong = true :
            
            //Overflow-check very unlikely to trigger an error. In fact, with properly normalised variables,
            //triggering an error would be plainly impossible.               
            AreAdditionFinalValuesWrong
            (
                unitInfos2[0].Value, unitInfos2[1].Value, operation
            )
        );

        return
        (
            isWrong ?
            //This error is just an easy way to let the calling function know about the fact that no
            //calculation has been performed (too big gap). This isn't a properly-speaking error and
            //that's why it will not be notified to the user.
            new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }} :
            //Returning the new big value. For example: with 5*10^4 & 3*10^2, 500 would be returned.
            new UnitInfo(unitInfos2[bigSmallI[0]])
            {{
                Value = big2.Value;
            }}
        );
    }

    static boolean AreAdditionFinalValuesWrong(double val1, double val2, Operations operation)
    {
        boolean isWrong = false;

        try
        {
            val1 = val1 + val2 *
            (
                operation == Operations.Addition ? 1 : -1
            );
        }
        catch { isWrong = true; }

        return isWrong;
    }

    static UnitInfo PerformManagedOperationMultiplication(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationNormalisedValues
        (
            firstInfo, new UnitInfo[] 
            { 
                NormaliseUnitInfo(firstInfo),
                NormaliseUnitInfo(secondInfo) 
            },
            operation
        );
    }

    public static UnitInfo RaiseToIntegerExponent(double baseValue, int exponent)
    {
        return RaiseToIntegerExponent(new UnitInfo(baseValue), exponent);
    }

    static UnitInfo RaiseToIntegerExponent(UnitInfo baseInfo, int exponent)
    {
        if (exponent <= 1 && exponent >= 0)
        {
            baseInfo.Value = (exponent == 0 ? 1.0 : baseInfo.Value);
            return baseInfo;
        }

        UnitInfo outInfo = new UnitInfo(baseInfo);

        for (int i = 1; i < Math.Abs(exponent); i++)
        {
            outInfo = PerformManagedOperationValues
            (
                outInfo, baseInfo, Operations.Multiplication
            );
            if (outInfo.Error.Type != ErrorTypes.None) return outInfo;
        }

        return
        (
            exponent < 0 ?
            PerformManagedOperationValues(new UnitInfo(1.0), outInfo, Operations.Division) :
            outInfo
        );
    }

    static UnitInfo PerformManagedOperationNormalisedValues(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        outInfo =
        (
            normalisedInfos.Length == 1 ?
            //There is just one operand when the difference between both of them is too big.
            outInfo = normalisedInfos[0] :
            PerformManagedOperationTwoOperands(outInfo, normalisedInfos, operation)
        );

        return outInfo;
    }

    static UnitInfo PerformManagedOperationTwoOperands(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        UnitInfo outInfoNormalised = PerformManagedOperationValues
        (
            normalisedInfos[0], normalisedInfos[1], operation
        );

        if (outInfo.Error.Type != ErrorTypes.None)
        {
            return new UnitInfo(outInfo)
            {
                Error = new ErrorInfo(ErrorTypes.NumericError)
            };
        }

        outInfo.BaseTenExponent = outInfoNormalised.BaseTenExponent;
        outInfo.Value = outInfoNormalised.Value;
        //Normalised means no prefixes.
        outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage); 

        return outInfo;
    }

    static UnitInfo PerformManagedOperationValues(double firstValue, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            new UnitInfo(firstValue), new UnitInfo(secondValue), operation
        );
    }

    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            firstInfo, new UnitInfo(secondValue), operation
        );
    }

    //This method might be used to perform full operations (not just being the last calculation step) instead
    //of the default one (PerformManagedOperationUnits) for simple cases. That is: ones not dealing with the
    //complex numeric reality (Value, Prefix and BaseTenExponent) which makes a pre-analysis required.
    //Note that, unlikely what happens with PerformMangedOperationUnits, the outputs of this method aren't
    //normalised (= primarily stored under Value), what is useful in certain contexts.
    //NOTE: this function assumes that both inputs are normalised, what means that no prefix information is expected.
    //It might also be used with non-normalised inputs, but their prefix information would be plainly ignored.
    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        if (firstInfo.Value == 0.0 || secondInfo.Value == 0.0)
        {
            if (operation == Operations.Multiplication || operation == Operations.Division)
            {
                //Dividing by zero scenarios are taken into account somewhere else.
                return new UnitInfo(firstInfo) { Value = 0.0 };
            }
        }

        UnitInfo outInfo = new UnitInfo(firstInfo);
        UnitInfo firstInfo0 = new UnitInfo(firstInfo);
        UnitInfo secondInfo0 = new UnitInfo(secondInfo);

        boolean isWrong = false;
        try
        {
            if (operation == Operations.Addition)
            {
                outInfo.Value += secondInfo0.Value;
            }
            else if (operation == Operations.Subtraction)
            {
                outInfo.Value -= secondInfo.Value;
            }
            else
            {
                //The reason for checking whether BaseTenExponent is inside/outside the int range before performing 
                //the operation (rather than going ahead and eventually catching the resulting exception) isn't just
                //being quicker, but also the only option in many situations. Note that an addition/subtraction between
                //two int variables whose result is outside the int range might not trigger an exception (+ random 
                //negative value as output).
                if (VaryBaseTenExponent(outInfo, secondInfo0.BaseTenExponent, operation == Operations.Division).Error.Type != ErrorTypes.None)
                {
                    return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
                }

                if (operation == Operations.Multiplication)
                {
                    outInfo.Value *= secondInfo.Value;
                    outInfo.BaseTenExponent += secondInfo.BaseTenExponent;
                }
                else if (operation == Operations.Division)
                {
                    if (secondInfo.Value == 0.0)
                    {
                        return
                        (
                            new UnitInfo(outInfo) 
                            { 
                                Error = new ErrorInfo(ErrorTypes.NumericError) 
                            }
                        );
                    }
                    outInfo.Value /= secondInfo.Value;
                    outInfo.BaseTenExponent -= secondInfo.BaseTenExponent;
                }
            }
        }
        catch { isWrong = true; }

        return
        (
            //An error might not be triggered despite of dealing with numbers outside double precision.
            //For example: 0.00000000000000000001m * 0.0000000000000000000001m can output 0.0 without triggering an error. 
            isWrong || ((operation == Operations.Multiplication || operation == Operations.Division) && outInfo.Value == 0.0.0) ?
            OperationValuesManageError(firstInfo0, secondInfo0, operation) : outInfo
        );
    }

    static UnitInfo OperationValuesManageError(UnitInfo outInfo, UnitInfo secondInfo, Operations operation)
    {
        if (operation != Operations.Multiplication && operation != Operations.Division)
        {
            //This condition should never be true on account of the fact that the pre-modifications performed before
            //adding/subtracting should avoid erroneous situations.
            return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
        }

        UnitInfo secondInfo2 = ConvertValueToBaseTen(secondInfo.Value);
        outInfo = VaryBaseTenExponent(outInfo, secondInfo2.BaseTenExponent, operation == Operations.Division);
        if (Math.Abs(secondInfo2.Value) == 1.0 || outInfo.Error.Type != ErrorTypes.None) return outInfo;
        
        try
        {
            outInfo = PerformManagedOperationUnits
            (
                outInfo, secondInfo2.Value, operation
            );
        }
        catch
        {
            //Very unlikely scenario on account of the fact that Math.Abs(secondInfo2.Value)
            //lies within the 0.1-10.0 range.
            outInfo = OperationValuesManageError
            (
                new UnitInfo(outInfo)
                {
                    Value = secondInfo2.Value,
                    BaseTenExponent = 0
                },
                new UnitInfo()
                {
                    Value = outInfo.Value,
                    BaseTenExponent = outInfo.BaseTenExponent
                },
                operation
            );
        }

        return outInfo;
    }

    static UnitInfo ConvertValueToBaseTen(double value)
    {
        value = Math.Abs(value);
        return FromValueToBaseTenExponent
        (
             new UnitInfo(value), Math.Abs(value), false
        );
    }

    static UnitInfo ConvertBaseTenToValue(UnitInfo unitInfo)
    {
        if (unitInfo.BaseTenExponent == 0) return unitInfo;

        UnitInfo outInfo = new UnitInfo(unitInfo);
        boolean decrease = unitInfo.BaseTenExponent > 0;
        int sign = Math.Sign(outInfo.Value);
        double absValue = Math.Abs(outInfo.Value);

        while (outInfo.BaseTenExponent != 0.0)
        {
            if (decrease)
            {
                if (absValue >= MaxValueDec / 10.0) break;
                absValue *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }
            else
            {
                if (absValue <= MinValueDec * 10.0) break;
                absValue /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
        }

        outInfo.Value = sign * absValue;

        return outInfo;
    }

    static UnitInfo NormaliseUnitInfo(UnitInfo unitInfo)
    {
        if (unitInfo.Value == 0 && unitInfo.Prefix.Factor == 1.0)
        {
            return unitInfo;
        }
        UnitInfo outInfo = new UnitInfo(unitInfo);

        if (outInfo.Prefix.Factor != 1)
        {
            outInfo = FromValueToBaseTenExponent
            (
                outInfo, outInfo.Prefix.Factor, true
            );
            outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage);
        }
        if (outInfo.Value == 0.0) return outInfo;

        outInfo = FromValueToBaseTenExponent
        (
            outInfo, outInfo.Value, false
        );

        return outInfo;
    }

    static UnitInfo FromValueToBaseTenExponent(UnitInfo outInfo, double value, boolean isPrefix)
    {
        if (value == 0.0) return outInfo;

        double valueAbs = Math.Abs(value);
        boolean decrease = (valueAbs > 1.0);
        if (!isPrefix)
        {
            outInfo.Value = outInfo.Value / valueAbs;
        }

        while (valueAbs != 1.0)
        {
            if ((valueAbs < 10.0 && valueAbs > 1.0) || (valueAbs > 0.1.0 && valueAbs < 1.0))
            {
                if (!isPrefix) outInfo.Value = value;
                else
                {
                    outInfo = PerformManagedOperationValues
                    (
                        outInfo, value, Operations.Multiplication
                    );
                }

                return outInfo;
            }

            if (decrease)
            {
                value /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
            else
            {
                value *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }

            valueAbs = Math.Abs(value);
        }

        return outInfo;
    }

    //Method used to vary BaseTenExponent without provoking unhandled exceptions (i.e., bigger than Integer.MAX_VALUE).
    static UnitInfo VaryBaseTenExponent(UnitInfo info, int baseTenIncrease, boolean isDivision = false)
    {
        long val1 = info.BaseTenExponent;
        long val2 = baseTenIncrease;

        if (isDivision)
        {
            //Converting a negative value into positive might provoke an overflow error for the int type
            //(e.g., Math.Abs(Integer.MAIN_VALUE)). Converting both variables to long is a quick and effective
            //way to avoid this problem.
            val2 *= -1;
        }

        return
        (
             ((val2 > 0 && val1 > Integer.MAX_VALUE - val2) || (val2 < 0 && val1 < Integer.MAIN_VALUE - val2)) ?
            new UnitInfo(info, ErrorTypes.NumericError) : new UnitInfo(info){{ BaseTenExponent = (int)(val1 + val2); }}
        );
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:897)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:763)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:712)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:635)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:627)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:164)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:86)
	at org.eclipse.jface.text.TextViewerHoverManager$4.run(TextViewerHoverManager.java:165)

!ENTRY org.eclipse.jdt.ui 4 2 2017-05-27 20:03:01.146
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:897)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:763)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:712)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:635)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:627)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:164)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:86)
	at org.eclipse.jface.text.TextViewerHoverManager$4.run(TextViewerHoverManager.java:165)

!ENTRY org.eclipse.jdt.ui 4 0 2017-05-27 20:03:01.146
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:897)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:763)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:712)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:635)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:627)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:164)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:86)
	at org.eclipse.jface.text.TextViewerHoverManager$4.run(TextViewerHoverManager.java:165)

!ENTRY org.eclipse.jdt.core 4 4 2017-05-27 20:03:03.233
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
public class OperationsManaged
{
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, double second, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            firstInfo, new UnitInfo(second), operation
        );
    }

    public static UnitInfo PerformManagedOperationUnits(double first, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationUnits
        (
            new UnitInfo(first), secondInfo, operation
        );
    }

    //This method should always be used when dealing with random UnitInfo variables because it accounts for all the
    //possible scenarios. On the other hand, with simple operations (e.g., random UnitInfo & numeric type) it might
    //be better to use PerformManagedOperationValues. 
    public static UnitInfo PerformManagedOperationUnits(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        ErrorTypes errorType = InternalMethods.GetOperationError
        (
            firstInfo, secondInfo, operation
        );
        if (errorType != ErrorTypes.None)
        {
            return new UnitInfo(firstInfo) 
            {{
                Error = new ErrorInfo(errorType); 
            }};
        }

        return
        (
            operation == Operations.Addition || operation == Operations.Subtraction ?
            PerformManagedOperationAddition(firstInfo, secondInfo, operation) :
            PerformManagedOperationMultiplication(firstInfo, secondInfo, operation)
        );
    }

    static UnitInfo PerformManagedOperationAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {   
        //After being normalised, the operands might require further modifications.
        UnitInfo[] normalised = GetOperandsAddition(firstInfo, secondInfo, operation);

        return PerformManagedOperationNormalisedValues
        (
            firstInfo, normalised, operation
        );
    }

    static UnitInfo[] GetOperandsAddition(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        UnitInfo[] operands2 = new UnitInfo[] 
        {
            new UnitInfo(firstInfo), new UnitInfo(secondInfo)
        };

        if (operands2[0].BaseTenExponent != operands2[1].BaseTenExponent || operands2[0].Prefix.Factor != operands2[1].Prefix.Factor)
        {
            //The addition/subtraction might not be performed right away even with normalised values.
            //For example: 5 and 6 from 5*10^2 and 6*10^7 cannot be added right away.
            operands2 = AdaptNormalisedValuesForAddition
            (
                new UnitInfo[] 
                { 
                    NormaliseUnitInfo(operands2[0]), 
                    NormaliseUnitInfo(operands2[1])
                },
                operation
            );
        }

        return operands2;
    }
    
    static UnitInfo[] AdaptNormalisedValuesForAddition(UnitInfo[] unitInfos2, Operations operation)
    {
        if (unitInfos2[0].BaseTenExponent == unitInfos2[1].BaseTenExponent)
        {
            //Having the same BaseTenExponent values means that the given operation can be performed right away.
            return unitInfos2;
        }

        int[] bigSmallI = 
        (
            unitInfos2[0].BaseTenExponent > unitInfos2[1].BaseTenExponent ?
            new int[] { 0, 1 } : new int[] { 1, 0 }
        );

        //Only the variable with the bigger value is modified. For example: 5*10^5 & 3*10^3 is converted
        //into 500*10^3 & 3*10^3 in order to allow the addition 500 + 3. 
        UnitInfo big2 = AdaptBiggerAdditionOperand(unitInfos2, bigSmallI, operation);
        if (big2.Error.Type != ErrorTypes.None)
        {
            return TooBigGapAddition(unitInfos2, bigSmallI, operation);
        }

        unitInfos2[bigSmallI[0]].Value = big2.Value;
        unitInfos2[bigSmallI[0]].BaseTenExponent = unitInfos2[bigSmallI[1]].BaseTenExponent;

        return unitInfos2;
    }

    //When adding/subtracting two numbers whose gap is bigger than the maximum double range, there
    //is no need to perform any operation (i.e., no change will be observed because of being outside
    //the maximum supported precision). This method takes care of these cases and returns the expected
    //output (i.e., biggest value).
    static UnitInfo[] TooBigGapAddition(UnitInfo[] unitInfos2, int[] bigSmallI, Operations operation)
    {
        UnitInfo[] outInfos = new UnitInfo[] 
        {
            //First operand (i.e., one whose information defines the operation) together with the
            //numeric information (i.e., just Value and BaseTenExponent because both are normalised)
            //which is associated with the biggest one.
            new UnitInfo(unitInfos2[0])
            {{
                Value = unitInfos2[bigSmallI[0]].Value;
                BaseTenExponent = unitInfos2[bigSmallI[0]].BaseTenExponent;
            }}
        };

        if (operation == Operations.Subtraction && bigSmallI[0] == 1)
        {
            outInfos[0].Value = -1.0 * outInfos[0].Value;
        }

        if (outInfos[0].Unit == Units.Unitless)
        {
            outInfos[0].Unit = unitInfos2[bigSmallI[1]].Unit;
        }

        return outInfos;
    }

    static UnitInfo AdaptBiggerAdditionOperand(UnitInfo[] unitInfos2, Integer[] bigSmallI, Operations operation)
    {
        int gapExponent = unitInfos2[bigSmallI[0]].BaseTenExponent - unitInfos2[bigSmallI[1]].BaseTenExponent;
        if (gapExponent >= 27)
        {
            //The difference between both inputs is bigger than (or, at least, very close to) the maximum double value/precision;
            //what makes this situation calculation unworthy and the first operand to be returned as the result.
            //Note that the error below these lines is just an easy way to tell the calling function about this eventuality.
            return new UnitInfo(unitInfos2[0]) 
            {{ 
                Error = new ErrorInfo(ErrorTypes.InvalidOperation); 
            }};
        }

        //PerformManagedOperationValues is used to make sure that the resulting numeric information is stored
        //in Value (if possible).
        UnitInfo big2 = PerformManagedOperationValues
        (
            RaiseToIntegerExponent(10.0, gapExponent), unitInfos2[bigSmallI[0]].Value, 
            Operations.Multiplication                
        );

        boolean isWrong = 
        (
            big2.Error.Type != ErrorTypes.None || big2.BaseTenExponent != 0 ?
            
            //The value of the bigger input times 10^(gap between BaseTenExponent of inputs) is too big. 
            isWrong = true :
            
            //Overflow-check very unlikely to trigger an error. In fact, with properly normalised variables,
            //triggering an error would be plainly impossible.               
            AreAdditionFinalValuesWrong
            (
                unitInfos2[0].Value, unitInfos2[1].Value, operation
            )
        );

        return
        (
            isWrong ?
            //This error is just an easy way to let the calling function know about the fact that no
            //calculation has been performed (too big gap). This isn't a properly-speaking error and
            //that's why it will not be notified to the user.
            new UnitInfo(unitInfos2[0])
            {{
                Error = new ErrorInfo(ErrorTypes.InvalidOperation);
            }} :
            //Returning the new big value. For example: with 5*10^4 & 3*10^2, 500 would be returned.
            new UnitInfo(unitInfos2[bigSmallI[0]])
            {{
                Value = big2.Value;
            }}
        );
    }

    static boolean AreAdditionFinalValuesWrong(double val1, double val2, Operations operation)
    {
        boolean isWrong = false;

        try
        {
            val1 = val1 + val2 *
            (
                operation == Operations.Addition ? 1 : -1
            );
        }
        catch { isWrong = true; }

        return isWrong;
    }

    static UnitInfo PerformManagedOperationMultiplication(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        return PerformManagedOperationNormalisedValues
        (
            firstInfo, new UnitInfo[] 
            { 
                NormaliseUnitInfo(firstInfo),
                NormaliseUnitInfo(secondInfo) 
            },
            operation
        );
    }

    public static UnitInfo RaiseToIntegerExponent(double baseValue, int exponent)
    {
        return RaiseToIntegerExponent(new UnitInfo(baseValue), exponent);
    }

    static UnitInfo RaiseToIntegerExponent(UnitInfo baseInfo, int exponent)
    {
        if (exponent <= 1 && exponent >= 0)
        {
            baseInfo.Value = (exponent == 0 ? 1.0 : baseInfo.Value);
            return baseInfo;
        }

        UnitInfo outInfo = new UnitInfo(baseInfo);

        for (int i = 1; i < Math.Abs(exponent); i++)
        {
            outInfo = PerformManagedOperationValues
            (
                outInfo, baseInfo, Operations.Multiplication
            );
            if (outInfo.Error.Type != ErrorTypes.None) return outInfo;
        }

        return
        (
            exponent < 0 ?
            PerformManagedOperationValues(new UnitInfo(1.0), outInfo, Operations.Division) :
            outInfo
        );
    }

    static UnitInfo PerformManagedOperationNormalisedValues(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        outInfo =
        (
            normalisedInfos.Length == 1 ?
            //There is just one operand when the difference between both of them is too big.
            outInfo = normalisedInfos[0] :
            PerformManagedOperationTwoOperands(outInfo, normalisedInfos, operation)
        );

        return outInfo;
    }

    static UnitInfo PerformManagedOperationTwoOperands(UnitInfo outInfo, UnitInfo[] normalisedInfos, Operations operation)
    {
        UnitInfo outInfoNormalised = PerformManagedOperationValues
        (
            normalisedInfos[0], normalisedInfos[1], operation
        );

        if (outInfo.Error.Type != ErrorTypes.None)
        {
            return new UnitInfo(outInfo)
            {
                Error = new ErrorInfo(ErrorTypes.NumericError)
            };
        }

        outInfo.BaseTenExponent = outInfoNormalised.BaseTenExponent;
        outInfo.Value = outInfoNormalised.Value;
        //Normalised means no prefixes.
        outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage); 

        return outInfo;
    }

    static UnitInfo PerformManagedOperationValues(double firstValue, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            new UnitInfo(firstValue), new UnitInfo(secondValue), operation
        );
    }

    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, double secondValue, Operations operation)
    {
        return PerformManagedOperationValues
        (
            firstInfo, new UnitInfo(secondValue), operation
        );
    }

    //This method might be used to perform full operations (not just being the last calculation step) instead
    //of the default one (PerformManagedOperationUnits) for simple cases. That is: ones not dealing with the
    //complex numeric reality (Value, Prefix and BaseTenExponent) which makes a pre-analysis required.
    //Note that, unlikely what happens with PerformMangedOperationUnits, the outputs of this method aren't
    //normalised (= primarily stored under Value), what is useful in certain contexts.
    //NOTE: this function assumes that both inputs are normalised, what means that no prefix information is expected.
    //It might also be used with non-normalised inputs, but their prefix information would be plainly ignored.
    static UnitInfo PerformManagedOperationValues(UnitInfo firstInfo, UnitInfo secondInfo, Operations operation)
    {
        if (firstInfo.Value == 0.0 || secondInfo.Value == 0.0)
        {
            if (operation == Operations.Multiplication || operation == Operations.Division)
            {
                //Dividing by zero scenarios are taken into account somewhere else.
                return new UnitInfo(firstInfo) { Value = 0.0 };
            }
        }

        UnitInfo outInfo = new UnitInfo(firstInfo);
        UnitInfo firstInfo0 = new UnitInfo(firstInfo);
        UnitInfo secondInfo0 = new UnitInfo(secondInfo);

        boolean isWrong = false;
        try
        {
            if (operation == Operations.Addition)
            {
                outInfo.Value += secondInfo0.Value;
            }
            else if (operation == Operations.Subtraction)
            {
                outInfo.Value -= secondInfo.Value;
            }
            else
            {
                //The reason for checking whether BaseTenExponent is inside/outside the int range before performing 
                //the operation (rather than going ahead and eventually catching the resulting exception) isn't just
                //being quicker, but also the only option in many situations. Note that an addition/subtraction between
                //two int variables whose result is outside the int range might not trigger an exception (+ random 
                //negative value as output).
                if (VaryBaseTenExponent(outInfo, secondInfo0.BaseTenExponent, operation == Operations.Division).Error.Type != ErrorTypes.None)
                {
                    return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
                }

                if (operation == Operations.Multiplication)
                {
                    outInfo.Value *= secondInfo.Value;
                    outInfo.BaseTenExponent += secondInfo.BaseTenExponent;
                }
                else if (operation == Operations.Division)
                {
                    if (secondInfo.Value == 0.0)
                    {
                        return
                        (
                            new UnitInfo(outInfo) 
                            { 
                                Error = new ErrorInfo(ErrorTypes.NumericError) 
                            }
                        );
                    }
                    outInfo.Value /= secondInfo.Value;
                    outInfo.BaseTenExponent -= secondInfo.BaseTenExponent;
                }
            }
        }
        catch { isWrong = true; }

        return
        (
            //An error might not be triggered despite of dealing with numbers outside double precision.
            //For example: 0.00000000000000000001m * 0.0000000000000000000001m can output 0.0 without triggering an error. 
            isWrong || ((operation == Operations.Multiplication || operation == Operations.Division) && outInfo.Value == 0.0.0) ?
            OperationValuesManageError(firstInfo0, secondInfo0, operation) : outInfo
        );
    }

    static UnitInfo OperationValuesManageError(UnitInfo outInfo, UnitInfo secondInfo, Operations operation)
    {
        if (operation != Operations.Multiplication && operation != Operations.Division)
        {
            //This condition should never be true on account of the fact that the pre-modifications performed before
            //adding/subtracting should avoid erroneous situations.
            return new UnitInfo(outInfo, ErrorTypes.InvalidOperation);
        }

        UnitInfo secondInfo2 = ConvertValueToBaseTen(secondInfo.Value);
        outInfo = VaryBaseTenExponent(outInfo, secondInfo2.BaseTenExponent, operation == Operations.Division);
        if (Math.Abs(secondInfo2.Value) == 1.0 || outInfo.Error.Type != ErrorTypes.None) return outInfo;
        
        try
        {
            outInfo = PerformManagedOperationUnits
            (
                outInfo, secondInfo2.Value, operation
            );
        }
        catch
        {
            //Very unlikely scenario on account of the fact that Math.Abs(secondInfo2.Value)
            //lies within the 0.1-10.0 range.
            outInfo = OperationValuesManageError
            (
                new UnitInfo(outInfo)
                {
                    Value = secondInfo2.Value,
                    BaseTenExponent = 0
                },
                new UnitInfo()
                {
                    Value = outInfo.Value,
                    BaseTenExponent = outInfo.BaseTenExponent
                },
                operation
            );
        }

        return outInfo;
    }

    static UnitInfo ConvertValueToBaseTen(double value)
    {
        value = Math.Abs(value);
        return FromValueToBaseTenExponent
        (
             new UnitInfo(value), Math.Abs(value), false
        );
    }

    static UnitInfo ConvertBaseTenToValue(UnitInfo unitInfo)
    {
        if (unitInfo.BaseTenExponent == 0) return unitInfo;

        UnitInfo outInfo = new UnitInfo(unitInfo);
        boolean decrease = unitInfo.BaseTenExponent > 0;
        int sign = Math.Sign(outInfo.Value);
        double absValue = Math.Abs(outInfo.Value);

        while (outInfo.BaseTenExponent != 0.0)
        {
            if (decrease)
            {
                if (absValue >= MaxValueDec / 10.0) break;
                absValue *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }
            else
            {
                if (absValue <= MinValueDec * 10.0) break;
                absValue /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
        }

        outInfo.Value = sign * absValue;

        return outInfo;
    }

    static UnitInfo NormaliseUnitInfo(UnitInfo unitInfo)
    {
        if (unitInfo.Value == 0 && unitInfo.Prefix.Factor == 1.0)
        {
            return unitInfo;
        }
        UnitInfo outInfo = new UnitInfo(unitInfo);

        if (outInfo.Prefix.Factor != 1)
        {
            outInfo = FromValueToBaseTenExponent
            (
                outInfo, outInfo.Prefix.Factor, true
            );
            outInfo.Prefix = new Prefix(outInfo.Prefix.PrefixUsage);
        }
        if (outInfo.Value == 0.0) return outInfo;

        outInfo = FromValueToBaseTenExponent
        (
            outInfo, outInfo.Value, false
        );

        return outInfo;
    }

    static UnitInfo FromValueToBaseTenExponent(UnitInfo outInfo, double value, boolean isPrefix)
    {
        if (value == 0.0) return outInfo;

        double valueAbs = Math.Abs(value);
        boolean decrease = (valueAbs > 1.0);
        if (!isPrefix)
        {
            outInfo.Value = outInfo.Value / valueAbs;
        }

        while (valueAbs != 1.0)
        {
            if ((valueAbs < 10.0 && valueAbs > 1.0) || (valueAbs > 0.1.0 && valueAbs < 1.0))
            {
                if (!isPrefix) outInfo.Value = value;
                else
                {
                    outInfo = PerformManagedOperationValues
                    (
                        outInfo, value, Operations.Multiplication
                    );
                }

                return outInfo;
            }

            if (decrease)
            {
                value /= 10.0;
                outInfo.BaseTenExponent += 1;
            }
            else
            {
                value *= 10.0;
                outInfo.BaseTenExponent -= 1;
            }

            valueAbs = Math.Abs(value);
        }

        return outInfo;
    }

    //Method used to vary BaseTenExponent without provoking unhandled exceptions (i.e., bigger than Integer.MAX_VALUE).
    static UnitInfo VaryBaseTenExponent(UnitInfo info, int baseTenIncrease, boolean isDivision = false)
    {
        long val1 = info.BaseTenExponent;
        long val2 = baseTenIncrease;

        if (isDivision)
        {
            //Converting a negative value into positive might provoke an overflow error for the int type
            //(e.g., Math.Abs(Integer.MAIN_VALUE)). Converting both variables to long is a quick and effective
            //way to avoid this problem.
            val2 *= -1;
        }

        return
        (
             ((val2 > 0 && val1 > Integer.MAX_VALUE - val2) || (val2 < 0 && val1 < Integer.MAIN_VALUE - val2)) ?
            new UnitInfo(info, ErrorTypes.NumericError) : new UnitInfo(info){{ BaseTenExponent = (int)(val1 + val2); }}
        );
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:207)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2017-05-27 20:03:03.234
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:425)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:327)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2518)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1697)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2758)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:639)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:207)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)
