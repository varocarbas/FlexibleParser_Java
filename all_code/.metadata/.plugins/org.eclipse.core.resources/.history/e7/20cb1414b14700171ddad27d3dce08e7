package InternalUnitParser.Classes;

import java.util.ArrayList;

import InternalUnitParser.Parse.ParseInfo;
import UnitParser.ErrorInfo;
import UnitParser.Prefix;
import UnitParser.UnitP;
import UnitParser.UnitPart;
import UnitParser.UnitSystems;
import UnitParser.UnitTypes;
import UnitParser.Units;

public class UnitPInternal
{
    /**Member of the Units enum which best suits the current conditions.**/
    public final Units Unit;
    /**Member of the UnitTypes enum which best suits the current conditions.**/
    public final UnitTypes UnitType;
    /**Member of the UnitSystems enum which best suits the current conditions.**/
    public final UnitSystems UnitSystem;        
    /**Prefix information affecting all the unit parts.**/
    public final Prefix UnitPrefix;
    /**List containing the basic unit parts which define the current unit.**/
    public final ArrayList<UnitPart> UnitParts;
    /**String variable including the unit information which was input at variable instantiation.**/
    public final String OriginalUnitString;
    /**String variable containing the symbol(s) best describing the current unit.**/
    public final String UnitString;
    /**String variable including both numeric and unit information associated with the current conditions.**/
    public final String ValueAndUnitString;
    /**Base-ten exponent used when dealing with too small/big numeric values.**/
    public final Integer BaseTenExponent;
    /**ErrorInfo variable containing all the error- and exception-related information.**/
    public final ErrorInfo Error;
    /**Decimal variable storing the primary numeric information under the current conditions.**/
    public Double Value;
    
    private UnitPInternal(UnitP unitP, Double value, int baseTenExponent)
    {
        Value = value;
        BaseTenExponent = baseTenExponent;
        Unit = unitP.Unit;
        UnitType = unitP.UnitType;
        UnitSystem = unitP.UnitSystem;
        UnitPrefix = new Prefix(unitP.UnitPrefix);
        UnitParts = new ArrayList<UnitPart>(unitP.UnitParts);
        UnitString = unitP.UnitString;
        OriginalUnitString = unitP.Value.toString() +
        (
            unitP.BaseTenExponent != 0 ?
            "*10^" + unitP.BaseTenExponent.toString() : ""
        );
        ValueAndUnitString = Value.toString() +
        (
            BaseTenExponent != 0 ?
            "*10^" + BaseTenExponent.toString() : ""
        ) + " " + UnitString;
        Error = new ErrorInfo(unitP.Error);
    }

    public UnitPInternal
    (
        ParseInfo parseInfo, String originalUnitString = "", UnitSystems system = UnitSystems.None,
        ExceptionHandlingTypes exceptionHandling = ExceptionHandlingTypes.NeverTriggerException,
        PrefixUsageTypes prefixUsage = PrefixUsageTypes.DefaultUsage, bool noPrefixImprovement = false,
        bool improveFinalValue = true
    )
    {
        UnitPConstructor unitP2 = new UnitPConstructor
        (
            originalUnitString, parseInfo.UnitInfo, parseInfo.UnitInfo.Type, parseInfo.UnitInfo.System,
            ErrorTypes.None, exceptionHandling, noPrefixImprovement, improveFinalValue
        );

        OriginalUnitString = unitP2.OriginalUnitString;
        Value = unitP2.Value;
        BaseTenExponent = unitP2.UnitInfo.BaseTenExponent;
        Unit = unitP2.UnitInfo.Unit;
        UnitType = unitP2.UnitType;
        UnitSystem =
        (
            system != UnitSystems.None ?
            system : unitP2.UnitSystem
        );
        UnitPrefix = new Prefix(unitP2.UnitInfo.Prefix);
        UnitParts = unitP2.UnitInfo.Parts.AsReadOnly();
        UnitString = unitP2.UnitString;
        ValueAndUnitString = unitP2.ValueAndUnitString;
        //If applicable, this instantiation would trigger an exception right away.
        Error = new ErrorInfo(unitP2.ErrorType, unitP2.ExceptionHandling);
    }

    private UnitP
    (
        UnitP unitP, ErrorTypes errorType,
        ExceptionHandlingTypes exceptionHandling = ExceptionHandlingTypes.NeverTriggerException
    )
    {
        if (unitP == null) unitP = new UnitP();

        UnitPConstructor unitP2 = new UnitPConstructor
        (
            unitP.OriginalUnitString, new UnitInfo(unitP),
            UnitTypes.None, UnitSystems.None, errorType,
            (
                exceptionHandling != ExceptionHandlingTypes.NeverTriggerException ?
                exceptionHandling : unitP.Error.ExceptionHandling
            )
        );

        if (unitP2.ErrorType != ErrorTypes.None)
        {
            Value = 0m;
            BaseTenExponent = 0;
            UnitPrefix = new Prefix(unitP2.UnitInfo.Prefix.PrefixUsage);
            UnitParts = new List<UnitPart>().AsReadOnly();
        }
        else
        {
            OriginalUnitString = unitP2.OriginalUnitString;
            Value = unitP2.Value;
            BaseTenExponent = unitP2.UnitInfo.BaseTenExponent;
            Unit = unitP2.UnitInfo.Unit;
            UnitType = unitP2.UnitType;
            UnitSystem = unitP2.UnitSystem;
            UnitPrefix = new Prefix(unitP2.UnitInfo.Prefix);
            UnitParts = unitP2.UnitInfo.Parts.AsReadOnly();
            UnitString = unitP2.UnitString;
            ValueAndUnitString = unitP2.ValueAndUnitString;
        }

        //If applicable, this instantiation would trigger an exception right away.
        Error = new ErrorInfo(unitP2.ErrorType, unitP2.ExceptionHandling);
    }

    private UnitP(UnitInfo unitInfo, UnitP unitP, bool noPrefixImprovement) : this
    (
        new ParseInfo(unitInfo), unitP.OriginalUnitString, unitP.UnitSystem,
        unitP.Error.ExceptionHandling, unitP.UnitPrefix.PrefixUsage,
        noPrefixImprovement
    )
    { }

    private UnitP
    (
        UnitInfo unitInfo, UnitP unitP, String originalUnitString = "",
        bool improveFinalValue = true
    )
    : this
    (
        new ParseInfo(unitInfo), originalUnitString, UnitSystems.None,
        unitP.Error.ExceptionHandling, unitInfo.Prefix.PrefixUsage, 
        false, improveFinalValue
    )
    { }
}
