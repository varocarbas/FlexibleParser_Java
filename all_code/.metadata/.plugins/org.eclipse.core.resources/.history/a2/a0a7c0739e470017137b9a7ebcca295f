package InternalUnitParser.Classes;

import UnitParser.*;


//Class helping to deal with the relevant number of constructors including quite a few readonly variables.
public class UnitPConstructor
{
    public Double Value;
    public String OriginalUnitString, UnitString, ValueAndUnitString;
    public UnitTypes UnitType;
    public UnitSystems UnitSystem;
    public UnitInfo UnitInfo;
    public ErrorTypes ErrorType;
    public ExceptionHandlingTypes ExceptionHandling;

    public UnitPConstructor(String originalUnitString, UnitInfo unitInfo) : this
    (
        originalUnitString, unitInfo, UnitTypes.None, 
        UnitSystems.None, unitInfo.Error.Type 
    )
    { }
    
    public UnitPConstructor
    (
        String originalUnitString, UnitInfo unitInfo, UnitTypes unitType, 
        UnitSystems unitSystem = UnitSystems.None, ErrorTypes errorType = ErrorTypes.None,
        ExceptionHandlingTypes exceptionHandling = ExceptionHandlingTypes.NeverTriggerException
    )
    {
    	this
        (
            String originalUnitString, UnitInfo unitInfo, UnitTypes unitType, 
            UnitSystems unitSystem = UnitSystems.None, ErrorTypes errorType = ErrorTypes.None,
            ExceptionHandlingTypes exceptionHandling = ExceptionHandlingTypes.NeverTriggerException,
            false
        );
    }
    
    public UnitPConstructor
    (
        String originalUnitString, UnitInfo unitInfo, UnitTypes unitType, 
        UnitSystems unitSystem = UnitSystems.None, ErrorTypes errorType = ErrorTypes.None,
        ExceptionHandlingTypes exceptionHandling = ExceptionHandlingTypes.NeverTriggerException
    )
    {
    	this
        (
            String originalUnitString, UnitInfo unitInfo, UnitTypes unitType, 
            UnitSystems unitSystem = UnitSystems.None, ErrorTypes errorType = ErrorTypes.None,
            ExceptionHandlingTypes exceptionHandling = ExceptionHandlingTypes.NeverTriggerException,
            false
        );
    }
    
    public UnitPConstructor
    (
        String originalUnitString, UnitInfo unitInfo, UnitTypes unitType, 
        UnitSystems unitSystem = UnitSystems.None, ErrorTypes errorType = ErrorTypes.None,
        ExceptionHandlingTypes exceptionHandling = ExceptionHandlingTypes.NeverTriggerException,
        boolean noPrefixImprovement = false
    )
    {
    	this
        (
            String originalUnitString, UnitInfo unitInfo, UnitTypes unitType, 
            UnitSystems unitSystem = UnitSystems.None, ErrorTypes errorType = ErrorTypes.None,
            ExceptionHandlingTypes exceptionHandling = ExceptionHandlingTypes.NeverTriggerException,
            boolean noPrefixImprovement = false, true
        );
    }
    
    public UnitPConstructor
    (
        String originalUnitString, UnitInfo unitInfo, UnitTypes unitType, 
        UnitSystems unitSystem = UnitSystems.None, ErrorTypes errorType = ErrorTypes.None,
        ExceptionHandlingTypes exceptionHandling = ExceptionHandlingTypes.NeverTriggerException,
        boolean noPrefixImprovement = false, boolean improveFinalValue = true
    )
    {
        OriginalUnitString =
        (
            originalUnitString == null ? "" :
            originalUnitString.Trim()
        );
        ErrorType = errorType;
        ExceptionHandling = exceptionHandling;

        if (ErrorType != ErrorTypes.None)
        {
            UnitInfo = new UnitInfo();
        }
        else
        {
            UnitInfo = ImproveUnitInfo(unitInfo, noPrefixImprovement);
            UnitType =
            (
                UnitInfo.Type != UnitTypes.None ? UnitInfo.Type :
                GetTypeFromUnitInfo(UnitInfo)
            );
            UnitSystem =
            (
                UnitInfo.System != UnitSystems.None && UnitInfo.System != UnitSystems.Imperial ?
                UnitInfo.System : GetSystemFromUnit(UnitInfo.Unit, false, true)
            );
            if (UnitSystem == UnitSystems.Imperial && UnitInfo.Unit == Units.ValidImperialUSCSUnit)
            {
                UnitInfo.Unit = Units.ValidImperialUnit;
            }
            UnitString = GetUnitString(UnitInfo);

            Value =
            (
                improveFinalValue ?
                //Values like 1.999999 are assumed to be a not-that-good version of 2.0 + some precision loss.
                //This assumption doesn't hold every time (e.g., input value which wasn't part of any operation).
                ImproveFinalValue(UnitInfo.Value) :
                UnitInfo.Value
            );

            ValueAndUnitString = Value.ToString() +
            (
                UnitInfo.BaseTenExponent != 0 ?
                "*10^" + UnitInfo.BaseTenExponent.ToString() : ""
            )
            + " " + UnitString;
        }
    }
}
