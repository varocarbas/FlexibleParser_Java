package InternalUnitParser.CSharpAdaptation;

import InternalUnitParser.Classes.*;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.Map;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.stream.Collectors;

/**Class including Java custom versions for all the System.Linq methods used in the original C# code.**/
@SuppressWarnings({ "serial", "rawtypes", "unchecked" })
public class Linq 
{
	public static <X> ArrayList<X> Distinct(ArrayList<X> input)
	{
		return (ArrayList<X>) input.stream().distinct().collect
		(
			Collectors.toList()
		);
	}
	
	public static <X> ArrayList<X> Select(ArrayList<X> input, Function<X, X> filter)
	{
		return (ArrayList<X>)input.stream().map(filter).collect(Collectors.toList());
	}

	public static <X, Y, Z> ArrayList<Z> SelectDict(HashMap<X, Y> input, Function<Map.Entry<X, Y>, Z> filter)
	{
		return (ArrayList<Z>) input.entrySet().stream().map(filter).collect(Collectors.toList());
	}
	
	public static <X> ArrayList<X> TakeWhile(ArrayList<X> input, Predicate<X> filter)
	{
		ArrayList<X> output = new ArrayList<X>();
		ArrayList<X> input2 = Where(input, filter);
		
		for (X item: input)
		{
			if (!input2.contains(item)) return output;
			
			output.add(item);
		}
		
		return output;
	}
	
	public static <X, Y> Map.Entry<X, Y> Max(HashMap<X, Y> input, Comparator<Map.Entry<X, Y>> comparator)
	{
		if (input == null || input.size() < 2)
		{
			return FirstOrDefaultDict(input, null);
		}
		
		return FirstOrDefault
		(
			OrderByDescending(new ArrayList(input.entrySet()), comparator), null
		);
	}
	
	public static <X> ArrayList<X> GroupByJustCountAndOrderByDescending(ArrayList<X> input, Comparator<X> comparator)
	{
		return (ArrayList<X>)OrderByDescending
    	(
    		(ArrayList<XAndIntegerClass>)GroupByJustCount(input, comparator), new Comparator<XAndIntegerClass>()
			{
				public int compare(XAndIntegerClass first, XAndIntegerClass second)
				{
					return first.Count.compareTo(second.Count);
				}        				
			}
    	)
    	.stream().map(x -> x.Input).collect(Collectors.toList());
	}
	
	static <X> ArrayList<XAndIntegerClass> GroupByJustCount(ArrayList<X> input, Comparator<X> comparator)
	{
		ArrayList<XAndIntegerClass> output = new ArrayList<XAndIntegerClass>()
		{{ 
			new XAndIntegerClass(input.get(0), 1); 
		}};
		if (input == null || input.size() < 2) return output;  

		ArrayList<X> sorted = OrderBy(input, comparator);
		
		X last = sorted.get(0);
		Integer count = 1;
		
		for (int i = 1; i < sorted.size(); i++) 
		{
			X current = sorted.get(i);
			
		    if (current == last) count++;
		    else 
		    {
		    	output.add(new XAndIntegerClass(current, count));
		    	count = 1;
		    	last = current;
		    }
		}
		
		if (count > 1) 
		{
			output.add(new XAndIntegerClass(last, count));
		}
		
		return output;
	}
	
	public static <X> ArrayList<X> OrderBy(ArrayList<X> input, Comparator<X> comparator)
	{
		return PerformSorting(input, comparator, false);
	}
	
	public static <X> ArrayList<X> OrderByDescending(ArrayList<X> input, Comparator<X> comparator)
	{
		return PerformSorting(input, comparator, true);
	}

	static <X> ArrayList<X> PerformSorting(ArrayList<X> input, Comparator<X> comparator, boolean ascending)
	{
		if (!(input instanceof Comparable<?>) || input == null || comparator == null)
		{
			return input;
		}
			
		ArrayList<X> output = new ArrayList<X>(input);
		if (output.size() < 2) return output;
		
		if (!ascending) Collections.reverse(output);
		
		return output;
	}
	
	public static <X> X FirstOrDefault(ArrayList<X> input, X defaultVal)
	{
		return FirstOrDefault(input, null, defaultVal);
	}
	
	public static <X> X FirstOrDefault(ArrayList<X> input, Predicate<X> filter, X defaultVal)
	{
		ArrayList<X> input2 = new ArrayList<X>
		(
			filter == null ? input : Where(input, filter)
		);
		
		X output = null;
        try
        {
        	output = GetFirst
        	(
        		input2, filter, defaultVal, ExceptionTypes.None
        	);       	
        }
        catch(Exception e)
        {
        	//This part will never be hit as far as FirstOrDefaultDict takes care of all the possible scenarios.
        	//The only motivation for this try...catch is complying with the Java compiler requirements.
        }

		return output;
	}
	
	public static <X> ArrayList<X> Where(ArrayList<X> input, Predicate<X> filter)
	{
		return (ArrayList<X>)input.stream().filter(filter).collect
		(
				Collectors.toList()
		);
	}
	
	private static <X> X GetFirst(ArrayList<X> input, Predicate<X> filter, X defaultVal, ExceptionTypes type) throws Exception
	{
		if (!(input instanceof Iterable<?>) || input == null) 
		{
			return GetDefaultOrException(defaultVal, type);
		}
		
		try
		{
			for (X item : (Iterable<X>)input) 
			{
				return item;
			}			
		}
		catch (Exception e) { }
		
		return GetDefaultOrException(defaultVal, type);
	}
	
	private static <X> X GetDefaultOrException(X defaultVal, ExceptionTypes type) throws Exception
	{
		if (type != ExceptionTypes.None)
		{
			ThrowException(type);
		}
		
		return defaultVal;
	}
	
	public static <X, Y> Map.Entry<X, Y> FirstDict(HashMap<X, Y> input) throws Exception
	{
		return FirstDict(input, null);
	}
	
	public static <X, Y> Map.Entry<X, Y> FirstDict(HashMap<X, Y> input, Predicate<Map.Entry<X, Y>> filter) throws Exception
	{
		if (filter != null) input = WhereDict(input, filter);
		
		return GetFirstDict
		(
				input, filter, null, ExceptionTypes.FirstDict
		);
	}
	
	public static <X, Y> Map.Entry<X, Y> FirstOrDefaultDict(HashMap<X, Y> input, Map.Entry<X, Y> defaultVal)
	{
		return FirstOrDefaultDict(input, null);
	}
	
	public static <X, Y> Map.Entry<X, Y> FirstOrDefaultDict(HashMap<X, Y> input, Predicate<Map.Entry<X, Y>> filter, Map.Entry<X, Y> defaultVal)
	{
		HashMap<X, Y> input2 = new HashMap<X, Y>
		(
			filter == null ? input : WhereDict(input, filter)
		);
		
		Map.Entry<X, Y> output = null;
		
        try
        {
        	output = GetFirstDict
        	(
        		input2, filter, defaultVal, ExceptionTypes.None
        	);       	
        }
        catch(Exception e)
        {
        	//This part will never be hit as far as FirstOrDefaultDict takes care of all the possible scenarios.
        	//The only motivation for this try...catch is complying with the Java compiler requirements.
        }
        
		return output;
	}
	
	public static <X, Y> HashMap<X, Y> WhereDict(HashMap<X, Y> input, Predicate<Map.Entry<X, Y>> filter)
	{
		return (HashMap<X, Y>)input.entrySet().stream().filter(filter).collect
		(
			Collectors.toMap(x -> x.getKey(), x -> x.getValue())
		);
	}
	
	private static <X, Y> Map.Entry<X, Y> GetFirstDict
	(
		HashMap<X, Y> input, Predicate<Map.Entry<X, Y>> filter, Map.Entry<X, Y> defaultVal, ExceptionTypes type
	) 
	throws Exception
	{
		if (!(input instanceof Iterable<?>) || input == null) 
		{
			return GetDefaultOrExceptionDict(defaultVal, type);
		}
		
		try
		{
			for (Map.Entry<X, Y> entry : input.entrySet()) 
			{
				return entry;
			}		
		}
		catch (Exception e) { }
		
		return GetDefaultOrExceptionDict(defaultVal, type);
	}
	
	private static <X, Y> Map.Entry<X, Y> GetDefaultOrExceptionDict(Map.Entry<X, Y> defaultVal, ExceptionTypes type) throws Exception
	{
		if (type != ExceptionTypes.None)
		{
			ThrowException(type);
		}
		
		return defaultVal;
	}
	
	private static void ThrowException(ExceptionTypes type) throws Exception
	{
		String method = "First";
		if (type == ExceptionTypes.FirstDict)
		{
			method = " (1-D collections)";
		}
		else if (type == ExceptionTypes.First)
		{
			method = " (dictionaries)";
		}
		
		throw new Exception("Exception provoked by an error in the custom version of the " + method + " LINQ method.");
	}
	
	enum ExceptionTypes { None, First, FirstDict }
}
